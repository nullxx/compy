<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:23:44 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GITCORE&minus;TUTORIAL</title>

</head>
<body>

<h1 align="center">GITCORE&minus;TUTORIAL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CREATING A GIT REPOSITORY">CREATING A GIT REPOSITORY</a><br>
<a href="#POPULATING A GIT REPOSITORY">POPULATING A GIT REPOSITORY</a><br>
<a href="#COMMITTING GIT STATE">COMMITTING GIT STATE</a><br>
<a href="#MAKING A CHANGE">MAKING A CHANGE</a><br>
<a href="#INSPECTING CHANGES">INSPECTING CHANGES</a><br>
<a href="#TAGGING A VERSION">TAGGING A VERSION</a><br>
<a href="#COPYING REPOSITORIES">COPYING REPOSITORIES</a><br>
<a href="#CREATING A NEW BRANCH">CREATING A NEW BRANCH</a><br>
<a href="#MERGING TWO BRANCHES">MERGING TWO BRANCHES</a><br>
<a href="#MERGING EXTERNAL WORK">MERGING EXTERNAL WORK</a><br>
<a href="#HOW DOES THE MERGE WORK?">HOW DOES THE MERGE WORK?</a><br>
<a href="#PUBLISHING YOUR WORK">PUBLISHING YOUR WORK</a><br>
<a href="#PACKING YOUR REPOSITORY">PACKING YOUR REPOSITORY</a><br>
<a href="#WORKING WITH OTHERS">WORKING WITH OTHERS</a><br>
<a href="#WORKING WITH OTHERS, SHARED REPOSITORY STYLE">WORKING WITH OTHERS, SHARED REPOSITORY STYLE</a><br>
<a href="#BUNDLING YOUR WORK TOGETHER">BUNDLING YOUR WORK TOGETHER</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">gitcore-tutorial
&minus; A Git core tutorial for developers</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git *</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This tutorial
explains how to use the &quot;core&quot; Git commands to set
up and work with a Git repository.</p>

<p style="margin-left:11%; margin-top: 1em">If you just
need to use Git as a revision control system you may prefer
to start with &quot;A Tutorial Introduction to Git&quot;
(<b>gittutorial</b>(7)) or <b><font color="#0000FF">the Git
User Manual</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">However,
an understanding of these low&minus;level tools can be
helpful if you want to understand Git&rsquo;s
internals.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
core Git is often called &quot;plumbing&quot;, with the
prettier user interfaces on top of it called
&quot;porcelain&quot;. You may not want to use the plumbing
directly very often, but it can be good to know what the
plumbing does for when the porcelain isn&rsquo;t
flushing.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Back
when this document was originally written, many porcelain
commands were shell scripts. For simplicity, it still uses
them as examples to illustrate how plumbing is fit together
to form the porcelain commands. The source tree includes
some of these scripts in contrib/examples/ for reference.
Although these are not implemented as shell scripts anymore,
the description of what the plumbing layer commands do is
still valid.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
Deeper technical details are often marked as Notes, which
you can skip on your first reading.</font></p>

<h2>CREATING A GIT REPOSITORY
<a name="CREATING A GIT REPOSITORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Creating
a new Git repository couldn&rsquo;t be easier: all Git
repositories start out empty, and the only thing you need to
do is find yourself a subdirectory that you want to use as a
working tree &minus; either an empty one for a totally new
project, or an existing working tree that you want to import
into Git.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>For
our first example, we&rsquo;re going to start a totally new
repository from scratch, with no pre&minus;existing files,
and we&rsquo;ll call it <i>git&minus;tutorial</i>. To start
up, create a subdirectory for it, change into that
subdirectory, and initialize the Git infrastructure with
<i>git init</i>:</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>$
mkdir git&minus;tutorial <br>
$ cd git&minus;tutorial <br>
$ git init</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>to
which Git will reply</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Initialized
empty Git repository in .git/</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>which
is just Git&rsquo;s way of saying that you haven&rsquo;t
been doing anything strange, and that it will have created a
local .git directory setup for your new project. You will
now have a .git directory, and you can inspect that with
<i>ls</i>. For your new empty project, it should show you
three entries, among other things:</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
a file called HEAD, that has ref: refs/heads/master in it.
This is similar to a symbolic link and points at
refs/heads/master relative to the HEAD
file.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>Don&rsquo;t
worry about the fact that the file that the HEAD link points
to doesn&rsquo;t even exist yet &mdash; you haven&rsquo;t
created the commit that will start your HEAD development
branch yet.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
a subdirectory called objects, which will contain all the
objects of your project. You should never have any real
reason to look at the objects directly, but you might want
to know that these objects are what contains all the real
<i>data</i> in your repository.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>&bull;
a subdirectory called refs, which contains references to
objects.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>In
particular, the refs subdirectory will contain two other
subdirectories, named heads and tags respectively. They do
exactly what their names imply: they contain references to
any number of different <i>heads</i> of development (aka
<i>branches</i>), and to any <i>tags</i> that you have
created to name specific versions in your
repository.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>One
note: the special master head is the default branch, which
is why the .git/HEAD file was created points to it even if
it doesn&rsquo;t yet exist. Basically, the HEAD link is
supposed to always point to the branch you are working on
right now, and you always start out expecting to work on the
master branch.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>However,
this is only a convention, and you can name your branches
anything you want, and don&rsquo;t have to ever even
<i>have</i> a master branch. A number of the Git tools will
assume that .git/HEAD is valid, though.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b>
<br>
An <i>object</i> is identified by its 160&minus;bit
SHA&minus;1 hash, aka <i>object name</i>, and a reference to
an object is always the 40&minus;byte hex representation of
that SHA&minus;1 name. The files in the refs subdirectory
are expected to contain these hex references (usually with a
final \n at the end), and you should thus expect to see a
number of 41&minus;byte files containing these references in
these refs subdirectories when you actually start populating
your tree.</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b>
<br>
An advanced user may want to take a look at
<b>gitrepository-layout</b>(5) after finishing this
tutorial.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>You
have now created your first Git repository. Of course, since
it&rsquo;s empty, that&rsquo;s not very useful, so
let&rsquo;s start populating it with data.</big></font></p>

<h2>POPULATING A GIT REPOSITORY
<a name="POPULATING A GIT REPOSITORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>We&rsquo;ll
keep this simple and stupid, so we&rsquo;ll start off with
populating a few trivial files just to get a feel for
it.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Start
off with just creating any random files that you want to
maintain in your Git repository. We&rsquo;ll start off with
a few bad examples, just to get a feel for how this
works:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
echo &quot;Hello World&quot; &gt;hello <br>
$ echo &quot;Silly example&quot;
&gt;example</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>you
have now created two files in your working tree (aka
<i>working directory</i>), but to actually check in your
hard work, you will have to go through two
steps:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
fill in the <i>index</i> file (aka <i>cache</i>) with the
information about your working tree
state.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>&bull;
commit that index file as an object.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>The
first step is trivial: when you want to tell Git about any
changes to your working tree, you use the <i>git
update&minus;index</i> program. That program normally just
takes a list of filenames you want to update, but to avoid
trivial mistakes, it refuses to add new entries to the index
(or remove existing ones) unless you explicitly tell it that
you&rsquo;re adding a new entry with the &minus;&minus;add
flag (or removing an entry with the &minus;&minus;remove)
flag.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>So
to populate the index with the two files you just created,
you can do</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git update&minus;index &minus;&minus;add hello
example</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>and
you have now told Git to track those two
files.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
fact, as you did that, if you now look into your object
directory, you&rsquo;ll notice that Git will have added two
new objects to the object database. If you did exactly the
steps above, you should now be able to
do</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
ls .git/objects/??/*</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>and
see two files:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>.git/objects/55/7db03de997c86a4a028e1ebd3a1ceb225be238
<br>

.git/objects/f2/4c74a2e500f5ee1332c86b94199f52b1d1d962</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>which
correspond with the objects with names of 557db... and
f24c7... respectively.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>If
you want to, you can use <i>git cat&minus;file</i> to look
at those objects, but you&rsquo;ll have to use the object
name, not the filename of the object:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git cat&minus;file &minus;t
557db03de997c86a4a028e1ebd3a1ceb225be238</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>where
the &minus;t tells <i>git cat&minus;file</i> to tell you
what the &quot;type&quot; of the object is. Git will tell
you that you have a &quot;blob&quot; object (i.e., just a
regular file), and you can see the contents
with</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git cat&minus;file blob 557db03</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>which
will print out &quot;Hello World&quot;. The object 557db03
is nothing more than the contents of your file
hello.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><b><big>Note</big></b>
<br>
Don&rsquo;t confuse that object with the file hello itself.
The object is literally just those specific <b>contents</b>
of the file, and however much you later change the contents
in file hello, the object we just looked at will never
change. Objects are immutable.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><b><big>Note</big></b>
<br>
The second example demonstrates that you can abbreviate the
object name to only the first several hexadecimal digits in
most places.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Anyway,
as we mentioned previously, you normally never actually take
a look at the objects themselves, and typing long
40&minus;character hex names is not something you&rsquo;d
normally want to do. The above digression was just to show
that <i>git update&minus;index</i> did something magical,
and actually saved away the contents of your files into the
Git object database.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Updating
the index did something else too: it created a .git/index
file. This is the index that describes your current working
tree, and something you should be very aware of. Again, you
normally never worry about the index file itself, but you
should be aware of the fact that you have not actually
really &quot;checked in&quot; your files into Git so far,
you&rsquo;ve only <b>told</b> Git about
them.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>However,
since Git knows about them, you can now start using some of
the most basic Git commands to manipulate the files or look
at their status.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
particular, let&rsquo;s not even check in the two files into
Git yet, we&rsquo;ll start off by adding another line to
hello first:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
echo &quot;It's a new day for git&quot;
&gt;&gt;hello</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>and
you can now, since you told Git about the previous state of
hello, ask Git what has changed in the tree compared to your
old index, using the <i>git diff&minus;files</i>
command:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git diff&minus;files</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>Oops.
That wasn&rsquo;t very readable. It just spit out its own
internal version of a <i>diff</i>, but that internal version
really just tells you that it has noticed that
&quot;hello&quot; has been modified, and that the old object
contents it had have been replaced with something
else.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>To
make it readable, we can tell <i>git diff&minus;files</i> to
output the differences as a patch, using the &minus;p
flag:</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git diff&minus;files &minus;p <br>
diff &minus;&minus;git a/hello b/hello <br>
index 557db03..263414f 100644 <br>
&minus;&minus;&minus; a/hello <br>
+++ b/hello <br>
@@ &minus;1 +1,2 @@ <br>
Hello World <br>
+It's a new day for git</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>i.e.
the diff of the change we caused by adding another line to
hello.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>In
other words, <i>git diff&minus;files</i> always shows us the
difference between what is recorded in the index, and what
is currently in the working tree. That&rsquo;s very
useful.</big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big>A
common shorthand for git diff&minus;files &minus;p is to
just write git diff, which will do the same
thing.</big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big>$
git diff <br>
diff &minus;&minus;git a/hello b/hello <br>
index 557db03..263414f 100644 <br>
&minus;&minus;&minus; a/hello <br>
+++ b/hello <br>
@@ &minus;1 +1,2 @@ <br>
Hello World <br>
+It's a new day for git</big></big></font></p>

<h2>COMMITTING GIT STATE
<a name="COMMITTING GIT STATE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Now,
we want to go to the next stage in Git, which is to take the
files that Git knows about in the index, and commit them as
a real tree. We do that in two phases: creating a
<i>tree</i> object, and committing that <i>tree</i> object
as a <i>commit</i> object together with an explanation of
what the tree was all about, along with information of how
we came to that state.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Creating
a tree object is trivial, and is done with <i>git
write&minus;tree</i>. There are no options or other input:
git write&minus;tree will take the current index state, and
write an object that describes that whole index. In other
words, we&rsquo;re now tying together all the different
filenames with their contents (and their permissions), and
we&rsquo;re creating the equivalent of a Git
&quot;directory&quot; object:</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
git write&minus;tree</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>and
this will just output the name of the resulting tree, in
this case (if you have done exactly as I&rsquo;ve described)
it should be</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>8988da15d077d4829fc51d8544c097def6644dbb</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>which
is another incomprehensible object name. Again, if you want
to, you can use git cat&minus;file &minus;t 8988d... to see
that this time the object is not a &quot;blob&quot; object,
but a &quot;tree&quot; object (you can also use git
cat&minus;file to actually output the raw object contents,
but you&rsquo;ll see mainly a binary mess, so that&rsquo;s
less interesting).</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>However
&mdash; normally you&rsquo;d never use <i>git
write&minus;tree</i> on its own, because normally you always
commit a tree into a commit object using the <i>git
commit&minus;tree</i> command. In fact, it&rsquo;s easier to
not actually use <i>git write&minus;tree</i> on its own at
all, but to just pass its result in as an argument to <i>git
commit&minus;tree</i>.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><i>git
commit&minus;tree</i> normally takes several arguments
&mdash; it wants to know what the <i>parent</i> of a commit
was, but since this is the first commit ever in this new
repository, and it has no parents, we only need to pass in
the object name of the tree. However, <i>git
commit&minus;tree</i> also wants to get a commit message on
its standard input, and it will write out the resulting
object name for the commit to its standard
output.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>And
this is where we create the .git/refs/heads/master file
which is pointed at by HEAD. This file is supposed to
contain the reference to the top&minus;of&minus;tree of the
master branch, and since that&rsquo;s exactly what <i>git
commit&minus;tree</i> spits out, we can do this all with a
sequence of simple shell
commands:</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
tree=$(git write&minus;tree) <br>
$ commit=$(echo 'Initial commit' | git commit&minus;tree
$tree) <br>
$ git update&minus;ref HEAD
$commit</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>In
this case this creates a totally new commit that is not
related to anything else. Normally you do this only
<b>once</b> for a project ever, and all later commits will
be parented on top of an earlier
commit.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Again,
normally you&rsquo;d never actually do this by hand. There
is a helpful script called git commit that will do all of
this for you. So you could have just written git commit
instead, and it would have done the above magic scripting
for you.</big></big></big></font></p>

<h2>MAKING A CHANGE
<a name="MAKING A CHANGE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Remember
how we did the <i>git update&minus;index</i> on file hello
and then we changed hello afterward, and could compare the
new state of hello with the state we saved in the index
file?</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Further,
remember how I said that <i>git write&minus;tree</i> writes
the contents of the <b>index</b> file to the tree, and thus
what we just committed was in fact the <b>original</b>
contents of the file hello, not the new ones. We did that on
purpose, to show the difference between the index state, and
the state in the working tree, and how they don&rsquo;t have
to match, even when we commit
things.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>As
before, if we do git diff&minus;files &minus;p in our
git&minus;tutorial project, we&rsquo;ll still see the same
difference we saw last time: the index file hasn&rsquo;t
changed by the act of committing anything. However, now that
we have committed something, we can also learn to use a new
command: <i>git
diff&minus;index</i>.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Unlike
<i>git diff&minus;files</i>, which showed the difference
between the index file and the working tree, <i>git
diff&minus;index</i> shows the differences between a
committed <b>tree</b> and either the index file or the
working tree. In other words, <i>git diff&minus;index</i>
wants a tree to be diffed against, and before we did the
commit, we couldn&rsquo;t do that, because we didn&rsquo;t
have anything to diff against.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>But
now we can do</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
git diff&minus;index &minus;p
HEAD</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>(where
&minus;p has the same meaning as it did in <i>git
diff&minus;files</i>), and it will show us the same
difference, but for a totally different reason. Now
we&rsquo;re comparing the working tree not against the index
file, but against the tree we just wrote. It just so happens
that those two are obviously the same, so we get the same
result.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Again,
because this is a common operation, you can also just
shorthand it with</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
git diff HEAD</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>which
ends up doing the above for
you.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>In
other words, <i>git diff&minus;index</i> normally compares a
tree against the working tree, but when given the
&minus;&minus;cached flag, it is told to instead compare
against just the index cache contents, and ignore the
current working tree state entirely. Since we just wrote the
index file to HEAD, doing git diff&minus;index
&minus;&minus;cached &minus;p HEAD should thus return an
empty set of differences, and that&rsquo;s exactly what it
does.</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><b><big>Note</big></b>
<i><br>
git diff&minus;index</i> really always uses the index for
its comparisons, and saying that it compares a tree against
the working tree is thus not strictly accurate. In
particular, the list of files to compare (the
&quot;meta&minus;data&quot;) <b>always</b> comes from the
index file, regardless of whether the &minus;&minus;cached
flag is used or not. The &minus;&minus;cached flag really
only determines whether the file <b>contents</b> to be
compared come from the working tree or
not.</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>This
is not hard to understand, as soon as you realize that Git
simply never knows (or cares) about files that it is not
told about explicitly. Git will never go <b>looking</b> for
files to compare, it expects you to tell it what the files
are, and that&rsquo;s what the index is there
for.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>However,
our next step is to commit the <b>change</b> we did, and
again, to understand what&rsquo;s going on, keep in mind the
difference between &quot;working tree contents&quot;,
&quot;index file&quot; and &quot;committed tree&quot;. We
have changes in the working tree that we want to commit, and
we always have to work through the index file, so the first
thing we need to do is to update the index
cache:</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
git update&minus;index hello</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>(note
how we didn&rsquo;t need the &minus;&minus;add flag this
time, since Git knew about the file
already).</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Note
what happens to the different <i>git diff&minus;*</i>
versions here. After we&rsquo;ve updated hello in the index,
git diff&minus;files &minus;p now shows no differences, but
git diff&minus;index &minus;p HEAD still <b>does</b> show
that the current state is different from the state we
committed. In fact, now <i>git diff&minus;index</i> shows
the same difference whether we use the &minus;&minus;cached
flag or not, since now the index is coherent with the
working tree.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Now,
since we&rsquo;ve updated hello in the index, we can commit
the new version. We could do it by writing the tree by hand
again, and committing the tree (this time we&rsquo;d have to
use the &minus;p HEAD flag to tell commit that the HEAD was
the <b>parent</b> of the new commit, and that this
wasn&rsquo;t an initial commit any more), but you&rsquo;ve
done that once already, so let&rsquo;s just use the helpful
script this time:</big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big>$
git commit</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>which
starts an editor for you to write the commit message and
tells you a bit about what you have
done.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>Write
whatever message you want, and all the lines that start with
<i>#</i> will be pruned out, and the rest will be used as
the commit message for the change. If you decide you
don&rsquo;t want to commit anything after all at this point
(you can continue to edit things and update the index), you
can just leave an empty message. Otherwise git commit will
commit the change for you.</big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big>You&rsquo;ve
now made your first real Git commit. And if you&rsquo;re
interested in looking at what git commit really does, feel
free to investigate: it&rsquo;s a few very simple shell
scripts to generate the helpful (?) commit message headers,
and a few one&minus;liners that actually do the commit
itself (<i>git commit</i>).</big></big></big></font></p>

<h2>INSPECTING CHANGES
<a name="INSPECTING CHANGES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>While
creating changes is useful, it&rsquo;s even more useful if
you can tell later what changed. The most useful command for
this is another of the <i>diff</i> family, namely <i>git
diff&minus;tree</i>.</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><i>git
diff&minus;tree</i> can be given two arbitrary trees, and it
will tell you the differences between them. Perhaps even
more commonly, though, you can give it just a single commit
object, and it will figure out the parent of that commit
itself, and show the difference directly. Thus, to get the
same diff that we&rsquo;ve already seen several times, we
can now do</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big>$
git diff&minus;tree &minus;p
HEAD</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>(again,
&minus;p means to show the difference as a
human&minus;readable patch), and it will show what the last
commit (in HEAD) actually
changed.</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><b><big>Note</big></b>
<br>
Here is an ASCII art by Jon Loeliger that illustrates how
various <i>diff&minus;*</i> commands compare
things.</big></big></big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big><big><big>diff&minus;tree
<br>
+&minus;&minus;&minus;&minus;+ <br>
| | <br>
| | <br>
V V <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
<br>
| Object DB | <br>
| Backing | <br>
| Store | <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
<br>
^ ^ <br>
| | <br>
| | diff&minus;index &minus;&minus;cached <br>
| | <br>
diff&minus;index | V <br>
|
+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
<br>
| | Index | <br>
| | &quot;cache&quot; | <br>
|
+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
<br>
| ^ <br>
| | <br>
| | diff&minus;files <br>
| | <br>
V V <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
<br>
| Working | <br>
| Directory | <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>More
interestingly, you can also give <i>git diff&minus;tree</i>
the &minus;&minus;pretty flag, which tells it to also show
the commit message and author and date of the commit, and
you can tell it to show a whole series of diffs.
Alternatively, you can tell it to be &quot;silent&quot;, and
not show the diffs at all, but just show the actual commit
message.</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>In
fact, together with the <i>git rev&minus;list</i> program
(which generates a list of revisions), <i>git
diff&minus;tree</i> ends up being a veritable fount of
changes. A trivial (but very useful) script called <i>git
whatchanged</i> is included with Git which does exactly
this, and shows a log of recent
activities.</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>To
see the whole history of our pitiful little
git&minus;tutorial project, you can
do</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big>$
git log</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>which
shows just the log messages, or if we want to see the log
together with the associated patches use the more complex
(and much more powerful)</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big>$
git whatchanged &minus;p</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>and
you will see exactly what has changed in the repository over
its short history.</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><b><big>Note</big></b>
<br>
When using the above two commands, the initial commit will
be shown. If this is a problem because it is huge, you can
hide it by setting the log.showroot configuration variable
to false. Having this, you can still show it for each
command just adding the &minus;&minus;root option, which is
a flag for <i>git diff&minus;tree</i> accepted by both
commands.</big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big>With
that, you should now be having some inkling of what Git
does, and can explore on your
own.</big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><b><big>Note</big></b>
<br>
Most likely, you are not directly using the core Git
Plumbing commands, but using Porcelain such as <i>git
add</i>, &lsquo;git&minus;rm&rsquo; and
&lsquo;git&minus;commit&rsquo;.</big></big></big></big></font></p>

<h2>TAGGING A VERSION
<a name="TAGGING A VERSION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>In
Git, there are two kinds of tags, a &quot;light&quot; one,
and an &quot;annotated
tag&quot;.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>A
&quot;light&quot; tag is technically nothing more than a
branch, except we put it in the .git/refs/tags/ subdirectory
instead of calling it a head. So the simplest form of tag
involves nothing more
than</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git tag
my&minus;first&minus;tag</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>which
just writes the current HEAD into the
.git/refs/tags/my&minus;first&minus;tag file, after which
point you can then use this symbolic name for that
particular state. You can, for example,
do</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git diff
my&minus;first&minus;tag</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>to
diff your current state against that tag which at this point
will obviously be an empty diff, but if you continue to
develop and commit stuff, you can use your tag as an
&quot;anchor&minus;point&quot; to see what has changed since
you tagged it.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>An
&quot;annotated tag&quot; is actually a real Git object, and
contains not only a pointer to the state you want to tag,
but also a small tag name and message, along with optionally
a PGP signature that says that yes, you really did that tag.
You create these annotated tags with either the &minus;a or
&minus;s flag to <i>git
tag</i>:</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git tag &minus;s
&lt;tagname&gt;</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>which
will sign the current HEAD (but you can also give it another
argument that specifies the thing to tag, e.g., you could
have tagged the current mybranch point by using git tag
&lt;tagname&gt;
mybranch).</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>You
normally only do signed tags for major releases or things
like that, while the light&minus;weight tags are useful for
any marking you want to do &mdash; any time you decide that
you want to remember a certain point, just create a private
tag for it, and you have a nice symbolic name for the state
at that point.</big></big></big></big></big></font></p>

<h2>COPYING REPOSITORIES
<a name="COPYING REPOSITORIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>Git
repositories are normally totally self&minus;sufficient and
relocatable. Unlike CVS, for example, there is no separate
notion of &quot;repository&quot; and &quot;working
tree&quot;. A Git repository normally <b>is</b> the working
tree, with the local Git information hidden in the .git
subdirectory. There is nothing else. What you see is what
you got.</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><b><big>Note</big></b>
<br>
You can tell Git to split the Git internal information from
the directory that it tracks, but we&rsquo;ll ignore that
for now: it&rsquo;s not how normal projects work, and
it&rsquo;s really only meant for special uses. So the mental
model of &quot;the Git information is always tied directly
to the working tree that it describes&quot; may not be
technically 100% accurate, but it&rsquo;s a good model for
all normal use.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>This
has two
implications:</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>&bull;
if you grow bored with the tutorial repository you created
(or you&rsquo;ve made a mistake and want to start all over),
you can just do
simple</big></big></big></big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
rm &minus;rf
git&minus;tutorial</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>and
it will be gone. There&rsquo;s no external repository, and
there&rsquo;s no history outside the project you
created.</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>&bull;
if you want to move or duplicate a Git repository, you can
do so. There is <i>git clone</i> command, but if all you
want to do is just to create a copy of your repository (with
all the full history that went along with it), you can do so
with a regular cp &minus;a git&minus;tutorial
new&minus;git&minus;tutorial.</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>Note
that when you&rsquo;ve moved or copied a Git repository,
your Git index file (which caches various information,
notably some of the &quot;stat&quot; information for the
files involved) will likely need to be refreshed. So after
you do a cp &minus;a to create a new copy, you&rsquo;ll want
to do</big></big></big></big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git update&minus;index
&minus;&minus;refresh</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>in
the new repository to make sure that the index file is
up&minus;to&minus;date.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>Note
that the second point is true even across machines. You can
duplicate a remote Git repository with <b>any</b> regular
copy mechanism, be it <i>scp</i>, <i>rsync</i> or
<i>wget</i>.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>When
copying a remote repository, you&rsquo;ll want to at a
minimum update the index cache when you do this, and
especially with other peoples' repositories you often want
to make sure that the index cache is in some known state
(you don&rsquo;t know <b>what</b> they&rsquo;ve done and not
yet checked in), so usually you&rsquo;ll precede the <i>git
update&minus;index</i> with
a</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git read&minus;tree &minus;&minus;reset HEAD <br>
$ git update&minus;index
&minus;&minus;refresh</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>which
will force a total index re&minus;build from the tree
pointed to by HEAD. It resets the index contents to HEAD,
and then the <i>git update&minus;index</i> makes sure to
match up all index entries with the checked&minus;out files.
If the original repository had uncommitted changes in its
working tree, git update&minus;index &minus;&minus;refresh
notices them and tells you they need to be
updated.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>The
above can also be written as
simply</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git reset</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>and
in fact a lot of the common Git command combinations can be
scripted with the git xyz interfaces. You can learn things
by just looking at what the various git scripts do. For
example, git reset used to be the above two lines
implemented in <i>git reset</i>, but some things like <i>git
status</i> and <i>git commit</i> are slightly more complex
scripts around the basic Git
commands.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>Many
(most?) public remote repositories will not contain any of
the checked out files or even an index file, and will
<b>only</b> contain the actual core Git files. Such a
repository usually doesn&rsquo;t even have the .git
subdirectory, but has all the Git files directly in the
repository.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>To
create your own local live copy of such a &quot;raw&quot;
Git repository, you&rsquo;d first create your own
subdirectory for the project, and then copy the raw
repository contents into the .git directory. For example, to
create your own copy of the Git repository, you&rsquo;d do
the following</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
mkdir my&minus;git <br>
$ cd my&minus;git <br>
$ rsync &minus;rL
rsync://rsync.kernel.org/pub/scm/git/git.git/
.git</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>followed
by</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git read&minus;tree
HEAD</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>to
populate the index. However, now you have populated the
index, and you have all the Git internal files, but you will
notice that you don&rsquo;t actually have any of the working
tree files to work on. To get those, you&rsquo;d check them
out with</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git checkout&minus;index &minus;u
&minus;a</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>where
the &minus;u flag means that you want the checkout to keep
the index up&minus;to&minus;date (so that you don&rsquo;t
have to refresh it afterward), and the &minus;a flag means
&quot;check out all files&quot; (if you have a stale copy or
an older version of a checked out tree you may also need to
add the &minus;f flag first, to tell <i>git
checkout&minus;index</i> to <b>force</b> overwriting of any
old files).</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>Again,
this can all be simplified
with</big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>$
git clone rsync://rsync.kernel.org/pub/scm/git/git.git/
my&minus;git <br>
$ cd my&minus;git <br>
$ git checkout</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>which
will end up doing all of the above for
you.</big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big>You
have now successfully copied somebody else&rsquo;s (mine)
remote repository, and checked it
out.</big></big></big></big></big></font></p>

<h2>CREATING A NEW BRANCH
<a name="CREATING A NEW BRANCH"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>Branches
in Git are really nothing more than pointers into the Git
object database from within the .git/refs/ subdirectory, and
as we already discussed, the HEAD branch is nothing but a
symlink to one of these object
pointers.</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>You
can at any time create a new branch by just picking an
arbitrary point in the project history, and just writing the
SHA&minus;1 name of that object into a file under
.git/refs/heads/. You can use any filename you want (and
indeed, subdirectories), but the convention is that the
&quot;normal&quot; branch is called master. That&rsquo;s
just a convention, though, and nothing enforces
it.</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>To
show that as an example, let&rsquo;s go back to the
git&minus;tutorial repository we used earlier, and create a
branch in it. You do that by simply just saying that you
want to check out a new
branch:</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
git checkout &minus;b
mybranch</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>will
create a new branch based at the current HEAD position, and
switch to it.</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><b><big>Note</big></b>
<br>
If you make the decision to start your new branch at some
other point in the history than the current HEAD, you can do
so by just telling <i>git checkout</i> what the base of the
checkout would be. In other words, if you have an earlier
tag or branch, you&rsquo;d just
do</big></big></big></big></big></big></font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
git checkout &minus;b mybranch
earlier&minus;commit</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>and
it would create the new branch mybranch at the earlier
commit, and check out the state at that
time.</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>You
can always just jump back to your original master branch by
doing</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
git checkout
master</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>(or
any other branch&minus;name, for that matter) and if you
forget which branch you happen to be on, a
simple</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
cat .git/HEAD</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>will
tell you where it&rsquo;s pointing. To get the list of
branches you have, you can
say</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
git branch</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>which
used to be nothing more than a simple script around ls
.git/refs/heads. There will be an asterisk in front of the
branch you are currently
on.</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>Sometimes
you may wish to create a new branch <i>without</i> actually
checking it out and switching to it. If so, just use the
command</big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>$
git branch &lt;branchname&gt;
[startingpoint]</big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big>which
will simply <i>create</i> the branch, but will not do
anything further. You can then later &mdash; once you decide
that you want to actually develop on that branch &mdash;
switch to that branch with a regular <i>git checkout</i>
with the branchname as the
argument.</big></big></big></big></big></big></font></p>

<h2>MERGING TWO BRANCHES
<a name="MERGING TWO BRANCHES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>One
of the ideas of having a branch is that you do some
(possibly experimental) work in it, and eventually merge it
back to the main branch. So assuming you created the above
mybranch that started out being the same as the original
master branch, let&rsquo;s make sure we&rsquo;re in that
branch, and do some work
there.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git checkout mybranch <br>
$ echo &quot;Work, work, work&quot; &gt;&gt;hello <br>
$ git commit &minus;m &quot;Some work.&quot; &minus;i
hello</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Here,
we just added another line to hello, and we used a shorthand
for doing both git update&minus;index hello and git commit
by just giving the filename directly to git commit, with an
&minus;i flag (it tells Git to <i>include</i> that file in
addition to what you have done to the index file so far when
making the commit). The &minus;m flag is to give the commit
log message from the command
line.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Now,
to make it a bit more interesting, let&rsquo;s assume that
somebody else does some work in the original branch, and
simulate that by going back to the master branch, and
editing the same file differently
there:</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git checkout
master</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Here,
take a moment to look at the contents of hello, and notice
how they don&rsquo;t contain the work we just did in
mybranch &mdash; because that work hasn&rsquo;t happened in
the master branch at all. Then
do</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
echo &quot;Play, play, play&quot; &gt;&gt;hello <br>
$ echo &quot;Lots of fun&quot; &gt;&gt;example <br>
$ git commit &minus;m &quot;Some fun.&quot; &minus;i hello
example</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>since
the master branch is obviously in a much better
mood.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Now,
you&rsquo;ve got two branches, and you decide that you want
to merge the work done. Before we do that, let&rsquo;s
introduce a cool graphical tool that helps you view
what&rsquo;s going
on:</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
gitk
&minus;&minus;all</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>will
show you graphically both of your branches (that&rsquo;s
what the &minus;&minus;all means: normally it will just show
you your current HEAD) and their histories. You can also see
exactly how they came to be from a common
source.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Anyway,
let&rsquo;s exit <i>gitk</i> (^Q or the File menu), and
decide that we want to merge the work we did on the mybranch
branch into the master branch (which is currently our HEAD
too). To do that, there&rsquo;s a nice script called <i>git
merge</i>, which wants to know which branches you want to
resolve and what the merge is all
about:</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git merge &minus;m &quot;Merge work in mybranch&quot;
mybranch</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>where
the first argument is going to be used as the commit message
if the merge can be resolved
automatically.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Now,
in this case we&rsquo;ve intentionally created a situation
where the merge will need to be fixed up by hand, though, so
Git will do as much of it as it can automatically (which in
this case is just merge the example file, which had no
differences in the mybranch branch), and
say:</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Auto&minus;merging
hello <br>
CONFLICT (content): Merge conflict in hello <br>
Automatic merge failed; fix conflicts and then commit the
result.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>It
tells you that it did an &quot;Automatic merge&quot;, which
failed due to conflicts in
hello.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Not
to worry. It left the (trivial) conflict in hello in the
same form you should already be well used to if you&rsquo;ve
ever used CVS, so let&rsquo;s just open hello in our editor
(whatever that may be), and fix it up somehow. I&rsquo;d
suggest just making it so that hello contains all four
lines:</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Hello
World <br>
It's a new day for git <br>
Play, play, play <br>
Work, work,
work</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>and
once you&rsquo;re happy with your manual merge, just do
a</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git commit &minus;i
hello</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>which
will very loudly warn you that you&rsquo;re now committing a
merge (which is correct, so never mind), and you can write a
small merge message about your adventures in <i>git
merge</i>&minus;land.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>After
you&rsquo;re done, start up gitk &minus;&minus;all to see
graphically what the history looks like. Notice that
mybranch still exists, and you can switch to it, and
continue to work with it if you want to. The mybranch branch
will not contain the merge, but next time you merge it from
the master branch, Git will know how you merged it, so
you&rsquo;ll not have to do <i>that</i> merge
again.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Another
useful tool, especially if you do not always work in
X&minus;Window environment, is git
show&minus;branch.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git show&minus;branch &minus;&minus;topo&minus;order
&minus;&minus;more=1 master mybranch <br>
* [master] Merge work in mybranch <br>
! [mybranch] Some work. <br>
&minus;&minus; <br>
&minus; [master] Merge work in mybranch <br>
*+ [mybranch] Some work. <br>
* [master^] Some
fun.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>The
first two lines indicate that it is showing the two branches
with the titles of their top&minus;of&minus;the&minus;tree
commits, you are currently on master branch (notice the
asterisk * character), and the first column for the later
output lines is used to show commits contained in the master
branch, and the second column for the mybranch branch. Three
commits are shown along with their titles. All of them have
non blank characters in the first column (* shows an
ordinary commit on the current branch, &minus; is a merge
commit), which means they are now part of the master branch.
Only the &quot;Some work&quot; commit has the plus +
character in the second column, because mybranch has not
been merged to incorporate these commits from the master
branch. The string inside brackets before the commit log
message is a short name you can use to name the commit. In
the above example, <i>master</i> and <i>mybranch</i> are
branch heads. <i>master^</i> is the first parent of
<i>master</i> branch head. Please see <b>gitrevisions</b>(7)
if you want to see more complex
cases.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
Without the <i>&minus;&minus;more=1</i> option, <i>git
show&minus;branch</i> would not output the <i>[master^]</i>
commit, as <i>[mybranch]</i> commit is a common ancestor of
both <i>master</i> and <i>mybranch</i> tips. Please see
<b>git-show-branch</b>(1) for
details.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
If there were more commits on the <i>master</i> branch after
the merge, the merge commit itself would not be shown by
<i>git show&minus;branch</i> by default. You would need to
provide <i>&minus;&minus;sparse</i> option to make the merge
commit visible in this
case.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Now,
let&rsquo;s pretend you are the one who did all the work in
mybranch, and the fruit of your hard work has finally been
merged to the master branch. Let&rsquo;s go back to
mybranch, and run <i>git merge</i> to get the &quot;upstream
changes&quot; back to your
branch.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git checkout mybranch <br>
$ git merge &minus;m &quot;Merge upstream changes.&quot;
master</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>This
outputs something like this (the actual commit object names
would be
different)</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Updating
from ae3a2da... to a80b4aa.... <br>
Fast&minus;forward (no commit created; &minus;m option
ignored) <br>
example | 1 + <br>
hello | 1 + <br>
2 files changed, 2
insertions(+)</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>Because
your branch did not contain anything more than what had
already been merged into the master branch, the merge
operation did not actually do a merge. Instead, it just
updated the top of the tree of your branch to that of the
master branch. This is often called
<i>fast&minus;forward</i>
merge.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>You
can run gitk &minus;&minus;all again to see how the commit
ancestry looks like, or run <i>show&minus;branch</i>, which
tells you
this.</big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big>$
git show&minus;branch master mybranch <br>
! [master] Merge work in mybranch <br>
* [mybranch] Merge work in mybranch <br>
&minus;&minus; <br>
&minus;&minus; [master] Merge work in
mybranch</big></big></big></big></big></big></big></font></p>

<h2>MERGING EXTERNAL WORK
<a name="MERGING EXTERNAL WORK"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>It&rsquo;s
usually much more common that you merge with somebody else
than merging with your own branches, so it&rsquo;s worth
pointing out that Git makes that very easy too, and in fact,
it&rsquo;s not that different from doing a <i>git merge</i>.
In fact, a remote merge ends up being nothing more than
&quot;fetch the work from a remote repository into a
temporary tag&quot; followed by a <i>git
merge</i>.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Fetching
from a remote repository is done by, unsurprisingly, <i>git
fetch</i>:</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>$
git fetch
&lt;remote&minus;repository&gt;</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>One
of the following transports can be used to name the
repository to download
from:</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Rsync</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big><big><big><big><big><big><big>rsync://remote.machine/path/to/repo.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Rsync
transport is usable for both uploading and downloading, but
is completely unaware of what git does, and can produce
unexpected results when you download from the public
repository while the repository owner is uploading into it
via rsync transport. Most notably, it could update the files
under refs/ which holds the object name of the topmost
commits before uploading the files in objects/ &mdash; the
downloader would obtain head commit object name while that
object itself is still not available in the repository. For
this reason, it is considered
deprecated.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>SSH</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big><big><big><big><big><big><big>remote.machine:/path/to/repo.git/
or</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>ssh://remote.machine/path/to/repo.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>This
transport can be used for both uploading and downloading,
and requires you to have a log&minus;in privilege over ssh
to the remote machine. It finds out the set of objects the
other side lacks by exchanging the head commits both ends
have and transfers (close to) minimum set of objects. It is
by far the most efficient way to exchange Git objects
between
repositories.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Local
directory</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big><big><big><big><big><big><big>/path/to/repo.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>This
transport is the same as SSH transport but uses <i>sh</i> to
run both ends on the local machine instead of running other
end on the remote machine via
<i>ssh</i>.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Git
Native</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big><big><big><big><big><big><big>git://remote.machine/path/to/repo.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>This
transport was designed for anonymous downloading. Like SSH
transport, it finds out the set of objects the downstream
side lacks and transfers (close to) minimum set of
objects.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>HTTP(S)</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%;"><font color="#000000"><big><big><big><big><big><big><big><big>http://remote.machine/path/to/repo.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Downloader
from http and https URL first obtains the topmost commit
object name from the remote site by looking at the specified
refname under repo.git/refs/ directory, and then tries to
obtain the commit object by downloading from
repo.git/objects/xx/xxx... using the object name of that
commit object. Then it reads the commit object to find out
its parent commits and the associate tree object; it repeats
this process until it gets all the necessary objects.
Because of this behavior, they are sometimes also called
<i>commit
walkers</i>.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>The
<i>commit walkers</i> are sometimes also called <i>dumb
transports</i>, because they do not require any Git aware
smart server like Git Native transport does. Any stock HTTP
server that does not even support directory index would
suffice. But you must prepare your repository with <i>git
update&minus;server&minus;info</i> to help dumb transport
downloaders.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Once
you fetch from the remote repository, you merge that with
your current
branch.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>However
&mdash; it&rsquo;s such a common thing to fetch and then
immediately merge, that it&rsquo;s called git pull, and you
can simply
do</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>$
git pull
&lt;remote&minus;repository&gt;</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>and
optionally give a branch&minus;name for the remote end as a
second
argument.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
You could do without using any branches at all, by keeping
as many local repositories as you would like to have
branches, and merging between them with <i>git pull</i>,
just like you merge between branches. The advantage of this
approach is that it lets you keep a set of files for each
branch checked out and you may find it easier to switch back
and forth if you juggle multiple lines of development
simultaneously. Of course, you will pay the price of more
disk usage to hold multiple working trees, but disk space is
cheap these
days.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>It
is likely that you will be pulling from the same remote
repository from time to time. As a short hand, you can store
the remote repository URL in the local repository&rsquo;s
config file like
this:</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>$
git config remote.linus.url
http://www.kernel.org/pub/scm/git/git.git/</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>and
use the &quot;linus&quot; keyword with <i>git pull</i>
instead of the full
URL.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>Examples.</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>1.
git pull
linus</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>2.
git pull linus tag
v0.99.1</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>the
above are equivalent
to:</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>1.
git pull http://www.kernel.org/pub/scm/git/git.git/
HEAD</big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big>2.
git pull http://www.kernel.org/pub/scm/git/git.git/ tag
v0.99.1</big></big></big></big></big></big></big></big></font></p>

<h2>HOW DOES THE MERGE WORK?
<a name="HOW DOES THE MERGE WORK?"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>We
said this tutorial shows what plumbing does to help you cope
with the porcelain that isn&rsquo;t flushing, but we so far
did not talk about how the merge really works. If you are
following this tutorial the first time, I&rsquo;d suggest to
skip to &quot;Publishing your work&quot; section and come
back here
later.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>OK,
still with me? To give us an example to look at, let&rsquo;s
go back to the earlier repository with &quot;hello&quot; and
&quot;example&quot; file, and bring ourselves back to the
pre&minus;merge
state:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git show&minus;branch &minus;&minus;more=2 master mybranch
<br>
! [master] Merge work in mybranch <br>
* [mybranch] Merge work in mybranch <br>
&minus;&minus; <br>
&minus;&minus; [master] Merge work in mybranch <br>
+* [master^2] Some work. <br>
+* [master^] Some
fun.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Remember,
before running <i>git merge</i>, our master head was at
&quot;Some fun.&quot; commit, while our mybranch head was at
&quot;Some work.&quot;
commit.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git checkout mybranch <br>
$ git reset &minus;&minus;hard master^2 <br>
$ git checkout master <br>
$ git reset &minus;&minus;hard
master^</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>After
rewinding, the commit structure should look like
this:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git show&minus;branch <br>
* [master] Some fun. <br>
! [mybranch] Some work. <br>
&minus;&minus; <br>
* [master] Some fun. <br>
+ [mybranch] Some work. <br>
*+ [master^] Initial
commit</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Now
we are ready to experiment with the merge by
hand.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>git
merge command, when merging two branches, uses 3&minus;way
merge algorithm. First, it finds the common ancestor between
them. The command it uses is <i>git
merge&minus;base</i>:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
mb=$(git merge&minus;base HEAD
mybranch)</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>The
command writes the commit object name of the common ancestor
to the standard output, so we captured its output to a
variable, because we will be using it in the next step. By
the way, the common ancestor commit is the &quot;Initial
commit&quot; commit in this case. You can tell it
by:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git name&minus;rev &minus;&minus;name&minus;only
&minus;&minus;tags $mb <br>

my&minus;first&minus;tag</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>After
finding out a common ancestor commit, the second step is
this:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git read&minus;tree &minus;m &minus;u $mb HEAD
mybranch</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>This
is the same <i>git read&minus;tree</i> command we have
already seen, but it takes three trees, unlike previous
examples. This reads the contents of each tree into
different <i>stage</i> in the index file (the first tree
goes to stage 1, the second to stage 2, etc.). After reading
three trees into three stages, the paths that are the same
in all three stages are <i>collapsed</i> into stage 0. Also
paths that are the same in two of three stages are collapsed
into stage 0, taking the SHA&minus;1 from either stage 2 or
stage 3, whichever is different from stage 1 (i.e. only one
side changed from the common
ancestor).</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>After
<i>collapsing</i> operation, paths that are different in
three trees are left in non&minus;zero stages. At this
point, you can inspect the index file with this
command:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git ls&minus;files &minus;&minus;stage <br>
100644 7f8b141b65fdcee47321e399a2598a235a032422 0 example
<br>
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>
100644 cc44c73eb783565da5831b4d820c962954019b69 3
hello</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>In
our example of only two files, we did not have unchanged
files so only <i>example</i> resulted in collapsing. But in
real&minus;life large projects, when only a small number of
files change in one commit, this <i>collapsing</i> tends to
trivially merge most of the paths fairly quickly, leaving
only a handful of real changes in non&minus;zero
stages.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>To
look at only non&minus;zero stages, use
&minus;&minus;unmerged
flag:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git ls&minus;files &minus;&minus;unmerged <br>
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>
100644 cc44c73eb783565da5831b4d820c962954019b69 3
hello</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>The
next step of merging is to merge these three versions of the
file, using 3&minus;way merge. This is done by giving <i>git
merge&minus;one&minus;file</i> command as one of the
arguments to <i>git merge&minus;index</i>
command:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git merge&minus;index git&minus;merge&minus;one&minus;file
hello <br>
Auto&minus;merging hello <br>
ERROR: Merge conflict in hello <br>
fatal: merge program
failed</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><i>git
merge&minus;one&minus;file</i> script is called with
parameters to describe those three versions, and is
responsible to leave the merge results in the working tree.
It is a fairly straightforward shell script, and eventually
calls <i>merge</i> program from RCS suite to perform a
file&minus;level 3&minus;way merge. In this case,
<i>merge</i> detects conflicts, and the merge result with
conflict marks is left in the working tree.. This can be
seen if you run ls&minus;files &minus;&minus;stage again at
this
point:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git ls&minus;files &minus;&minus;stage <br>
100644 7f8b141b65fdcee47321e399a2598a235a032422 0 example
<br>
100644 557db03de997c86a4a028e1ebd3a1ceb225be238 1 hello <br>
100644 ba42a2a96e3027f3333e13ede4ccf4498c3ae942 2 hello <br>
100644 cc44c73eb783565da5831b4d820c962954019b69 3
hello</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>This
is the state of the index file and the working file after
<i>git merge</i> returns control back to you, leaving the
conflicting merge for you to resolve. Notice that the path
hello is still unmerged, and what you see with <i>git
diff</i> at this point is differences since stage 2 (i.e.
your
version).</big></big></big></big></big></big></big></big></big></font></p>

<h2>PUBLISHING YOUR WORK
<a name="PUBLISHING YOUR WORK"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>So,
we can use somebody else&rsquo;s work from a remote
repository, but how can <b>you</b> prepare a repository to
let other people pull from
it?</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>You
do your real work in your working tree that has your primary
repository hanging under it as its .git subdirectory. You
<b>could</b> make that repository accessible remotely and
ask people to pull from it, but in practice that is not the
way things are usually done. A recommended way is to have a
public repository, make it reachable by other people, and
when the changes you made in your primary working tree are
in good shape, update the public repository from it. This is
often called
<i>pushing</i>.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
This public repository could further be mirrored, and that
is how Git repositories at kernel.org are
managed.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Publishing
the changes from your local (private) repository to your
remote (public) repository requires a write privilege on the
remote machine. You need to have an SSH account there to run
a single command,
<i>git&minus;receive&minus;pack</i>.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>First,
you need to create an empty repository on the remote machine
that will house your public repository. This empty
repository will be populated and be kept
up&minus;to&minus;date by pushing into it later. Obviously,
this repository creation needs to be done only
once.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<i><br>
git push</i> uses a pair of commands, <i>git
send&minus;pack</i> on your local machine, and
<i>git&minus;receive&minus;pack</i> on the remote machine.
The communication between the two over the network
internally uses an SSH
connection.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Your
private repository&rsquo;s Git directory is usually .git,
but your public repository is often named after the project
name, i.e. &lt;project&gt;.git. Let&rsquo;s create such a
public repository for project my&minus;git. After logging
into the remote machine, create an empty
directory:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
mkdir
my&minus;git.git</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Then,
make that directory into a Git repository by running <i>git
init</i>, but this time, since its name is not the usual
.git, we do things slightly
differently:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
GIT_DIR=my&minus;git.git git
init</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Make
sure this directory is available for others you want your
changes to be pulled via the transport of your choice. Also
you need to make sure that you have the
<i>git&minus;receive&minus;pack</i> program on the
$PATH.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
Many installations of sshd do not invoke your shell as the
login shell when you directly run programs; what this means
is that if your login shell is <i>bash</i>, only .bashrc is
read and not .bash_profile. As a workaround, make sure
.bashrc sets up $PATH so that you can run
<i>git&minus;receive&minus;pack</i>
program.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
If you plan to publish this repository to be accessed over
http, you should do mv
my&minus;git.git/hooks/post&minus;update.sample
my&minus;git.git/hooks/post&minus;update at this point. This
makes sure that every time you push into this repository,
git update&minus;server&minus;info is
run.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>Your
&quot;public repository&quot; is now ready to accept your
changes. Come back to the machine you have your private
repository. From there, run this
command:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git push &lt;public&minus;host&gt;:/path/to/my&minus;git.git
master</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>This
synchronizes your public repository to match the named
branch head (i.e. master in this case) and objects reachable
from them in your current
repository.</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>As
a real example, this is how I update my public Git
repository. Kernel.org mirror network takes care of the
propagation to other publicly visible
machines:</big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big>$
git push
master.kernel.org:/pub/scm/git/git.git/</big></big></big></big></big></big></big></big></big></font></p>

<h2>PACKING YOUR REPOSITORY
<a name="PACKING YOUR REPOSITORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>Earlier,
we saw that one file under .git/objects/??/ directory is
stored for each Git object you create. This representation
is efficient to create atomically and safely, but not so
convenient to transport over the network. Since Git objects
are immutable once they are created, there is a way to
optimize the storage by &quot;packing them together&quot;.
The
command</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>$
git
repack</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>will
do it for you. If you followed the tutorial examples, you
would have accumulated about 17 objects in .git/objects/??/
directories by now. <i>git repack</i> tells you how many
objects it packed, and stores the packed file in
.git/objects/pack
directory.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
You will see two files, pack&minus;*.pack and
pack&minus;*.idx, in .git/objects/pack directory. They are
closely related to each other, and if you ever copy them by
hand to a different repository for whatever reason, you
should make sure you copy them together. The former holds
all the data from the objects in the pack, and the latter
holds the index for random
access.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>If
you are paranoid, running <i>git verify&minus;pack</i>
command would detect if you have a corrupt pack, but do not
worry too much. Our programs are always perfect
;&minus;).</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>Once
you have packed objects, you do not need to leave the
unpacked objects that are contained in the pack file
anymore.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>$
git
prune&minus;packed</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>would
remove them for
you.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>You
can try running find .git/objects &minus;type f before and
after you run git prune&minus;packed if you are curious.
Also git count&minus;objects would tell you how many
unpacked objects are in your repository and how much space
they are
consuming.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big><b><big>Note</big></b>
<br>
git pull is slightly cumbersome for HTTP transport, as a
packed repository may contain relatively few objects in a
relatively large pack. If you expect many HTTP pulls from
your public repository you might want to repack &amp; prune
often, or
never.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>If
you run git repack again at this point, it will say
&quot;Nothing new to pack.&quot;. Once you continue your
development and accumulate the changes, running git repack
again will create a new pack, that contains objects created
since you packed your repository the last time. We recommend
that you pack your project soon after the initial import
(unless you are starting your project from scratch), and
then run git repack every once in a while, depending on how
active your project
is.</big></big></big></big></big></big></big></big></big></big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big>When
a repository is synchronized via git push and git pull
objects packed in the source repository are usually stored
unpacked in the destination, unless rsync transport is used.
While this allows you to use different packing strategies on
both ends, it also means you may need to repack both
repositories every once in a
while.</big></big></big></big></big></big></big></big></big></big></font></p>

<h2>WORKING WITH OTHERS
<a name="WORKING WITH OTHERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big><big><big><big><big><big><big><big><big><big><big>Although
Git is a truly distributed system, it is often convenient to
organize your project with an informal hierarchy of
developers. Linux kernel development is run this way. There
is a nice illustration (page 17, &quot;Merges to
Mainline&quot;)
in</big></big></big></big></big></big></big></big></big></big></big></font>
<big><big><big><big><big><big><big><big><big><big><big><b><font color="#0000FF">Randy
Dunlap&rsquo;s presentation</font></b></big>
<font color="#000000">[2]
<big>.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>It
should be stressed that this hierarchy is purely
<b>informal</b>. There is nothing fundamental in Git that
enforces the &quot;chain of patch flow&quot; this hierarchy
implies. You do not have to pull from only one remote
repository.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>A
recommended workflow for a &quot;project lead&quot; goes
like
this:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>1.
Prepare your primary repository on your local machine. Your
work is done
there.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>2.
Prepare a public repository accessible to
others.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>If
other people are pulling from your repository over dumb
transport protocols (HTTP), you need to keep this repository
<i>dumb transport friendly</i>. After git init,
$GIT_DIR/hooks/post&minus;update.sample copied from the
standard templates would contain a call to <i>git
update&minus;server&minus;info</i> but you need to manually
enable the hook with mv post&minus;update.sample
post&minus;update. This makes sure <i>git
update&minus;server&minus;info</i> keeps the necessary files
up&minus;to&minus;date.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>3.
Push into the public repository from your primary
repository.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>4.
<i>git repack</i> the public repository. This establishes a
big pack that contains the initial set of objects as the
baseline, and possibly <i>git prune</i> if the transport
used for pulling from your repository supports packed
repositories.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>5.
Keep working in your primary repository. Your changes
include modifications of your own, patches you receive via
e&minus;mails, and merges resulting from pulling the
&quot;public&quot; repositories of your &quot;subsystem
maintainers&quot;.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>You
can repack this private repository whenever you feel
like.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>6.
Push your changes to the public repository, and announce it
to the
public.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>7.
Every once in a while, <i>git repack</i> the public
repository. Go back to step 5. and continue
working.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>A
recommended work cycle for a &quot;subsystem
maintainer&quot; who works on that project and has an own
&quot;public repository&quot; goes like
this:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>1.
Prepare your work repository, by <i>git clone</i> the public
repository of the &quot;project lead&quot;. The URL used for
the initial cloning is stored in the remote.origin.url
configuration
variable.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>2.
Prepare a public repository accessible to others, just like
the &quot;project lead&quot; person
does.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>3.
Copy over the packed files from &quot;project lead&quot;
public repository to your public repository, unless the
&quot;project lead&quot; repository lives on the same
machine as yours. In the latter case, you can use
objects/info/alternates file to point at the repository you
are borrowing
from.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>4.
Push into the public repository from your primary
repository. Run <i>git repack</i>, and possibly <i>git
prune</i> if the transport used for pulling from your
repository supports packed
repositories.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>5.
Keep working in your primary repository. Your changes
include modifications of your own, patches you receive via
e&minus;mails, and merges resulting from pulling the
&quot;public&quot; repositories of your &quot;project
lead&quot; and possibly your &quot;sub&minus;subsystem
maintainers&quot;.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>You
can repack this private repository whenever you feel
like.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>6.
Push your changes to your public repository, and ask your
&quot;project lead&quot; and possibly your
&quot;sub&minus;subsystem maintainers&quot; to pull from
it.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>7.
Every once in a while, <i>git repack</i> the public
repository. Go back to step 5. and continue
working.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>A
recommended work cycle for an &quot;individual
developer&quot; who does not have a &quot;public&quot;
repository is somewhat different. It goes like
this:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>1.
Prepare your work repository, by <i>git clone</i> the public
repository of the &quot;project lead&quot; (or a
&quot;subsystem maintainer&quot;, if you work on a
subsystem). The URL used for the initial cloning is stored
in the remote.origin.url configuration
variable.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>2.
Do your work in your repository on <i>master</i>
branch.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>3.
Run git fetch origin from the public repository of your
upstream every once in a while. This does only the first
half of git pull but does not merge. The head of the public
repository is stored in
.git/refs/remotes/origin/master.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>4.
Use git cherry origin to see which ones of your patches were
accepted, and/or use git rebase origin to port your unmerged
changes forward to the updated
upstream.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>5.
Use git format&minus;patch origin to prepare patches for
e&minus;mail submission to your upstream and send it out. Go
back to step 2. and
continue.</big></font></big></big></big></big></big></big></big></big></big></big></p>

<h2>WORKING WITH OTHERS, SHARED REPOSITORY STYLE
<a name="WORKING WITH OTHERS, SHARED REPOSITORY STYLE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>If
you are coming from CVS background, the style of cooperation
suggested in the previous section may be new to you. You do
not have to worry. Git supports &quot;shared public
repository&quot; style of cooperation you are probably more
familiar with as
well.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>See
<b>gitcvs-migration</b>(7) for the
details.</big></font></big></big></big></big></big></big></big></big></big></big></p>

<h2>BUNDLING YOUR WORK TOGETHER
<a name="BUNDLING YOUR WORK TOGETHER"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>It
is likely that you will be working on more than one thing at
a time. It is easy to manage those more&minus;or&minus;less
independent tasks using branches with
Git.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>We
have already seen how branches work previously, with
&quot;fun and work&quot; example using two branches. The
idea is the same if there are more than two branches.
Let&rsquo;s say you started out from &quot;master&quot;
head, and have some new code in the &quot;master&quot;
branch, and two independent fixes in the
&quot;commit&minus;fix&quot; and &quot;diff&minus;fix&quot;
branches:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>$
git show&minus;branch <br>
! [commit&minus;fix] Fix commit message normalization. <br>
! [diff&minus;fix] Fix rename detection. <br>
* [master] Release candidate #1 <br>
&minus;&minus;&minus; <br>
+ [diff&minus;fix] Fix rename detection. <br>
+ [diff&minus;fix~1] Better common substring algorithm. <br>
+ [commit&minus;fix] Fix commit message normalization. <br>
* [master] Release candidate #1 <br>
++* [diff&minus;fix~2] Pretty&minus;print
messages.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Both
fixes are tested well, and at this point, you want to merge
in both of them. You could merge in <i>diff&minus;fix</i>
first and then <i>commit&minus;fix</i> next, like
this:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>$
git merge &minus;m &quot;Merge fix in diff&minus;fix&quot;
diff&minus;fix <br>
$ git merge &minus;m &quot;Merge fix in
commit&minus;fix&quot;
commit&minus;fix</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Which
would result
in:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>$
git show&minus;branch <br>
! [commit&minus;fix] Fix commit message normalization. <br>
! [diff&minus;fix] Fix rename detection. <br>
* [master] Merge fix in commit&minus;fix <br>
&minus;&minus;&minus; <br>
&minus; [master] Merge fix in commit&minus;fix <br>
+ * [commit&minus;fix] Fix commit message normalization.
<br>
&minus; [master~1] Merge fix in diff&minus;fix <br>
+* [diff&minus;fix] Fix rename detection. <br>
+* [diff&minus;fix~1] Better common substring algorithm.
<br>
* [master~2] Release candidate #1 <br>
++* [master~3] Pretty&minus;print
messages.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>However,
there is no particular reason to merge in one branch first
and the other next, when what you have are a set of truly
independent changes (if the order mattered, then they are
not independent by definition). You could instead merge
those two branches into the current branch at once. First
let&rsquo;s undo what we just did and start over. We would
want to get the master branch before these two merges by
resetting it to
<i>master~2</i>:</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>$
git reset &minus;&minus;hard
master~2</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>You
can make sure git show&minus;branch matches the state before
those two <i>git merge</i> you just did. Then, instead of
running two <i>git merge</i> commands in a row, you would
merge these two branch heads (this is known as <i>making an
Octopus</i>):</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>$
git merge commit&minus;fix diff&minus;fix <br>
$ git show&minus;branch <br>
! [commit&minus;fix] Fix commit message normalization. <br>
! [diff&minus;fix] Fix rename detection. <br>
* [master] Octopus merge of branches 'diff&minus;fix' and
'commit&minus;fix' <br>
&minus;&minus;&minus; <br>
&minus; [master] Octopus merge of branches 'diff&minus;fix'
and 'commit&minus;fix' <br>
+ * [commit&minus;fix] Fix commit message normalization.
<br>
+* [diff&minus;fix] Fix rename detection. <br>
+* [diff&minus;fix~1] Better common substring algorithm.
<br>
* [master~1] Release candidate #1 <br>
++* [master~2] Pretty&minus;print
messages.</big></font></big></big></big></big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Note
that you should not do Octopus because you can. An octopus
is a valid thing to do and often makes it easier to view the
commit history if you are merging more than two independent
changes at the same time. However, if you have merge
conflicts with any of the branches you are merging in and
need to hand resolve, that is an indication that the
development happened in those branches were not independent
after all, and you should merge two at a time, documenting
how you resolved the conflicts, and the reason why you
preferred changes made in one side over the other. Otherwise
it would make the project history harder to follow, not
easier.</big></font></big></big></big></big></big></big></big></big></big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big><b>gittutorial</b>(7),
<b>gittutorial-2</b>(7), <b>gitcvs-migration</b>(7),
<b>git-help</b>(1),</big></font>
<big><b><font color="#0000FF">Everyday git</font></b></big>
<font color="#000000">[3] <big>,</big></font>
<big><b><font color="#0000FF">The Git User&rsquo;s
Manual</font></b></big>
<font color="#000000">[1]</font></big></big></big></big></big></big></big></big></big></big></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Part
of the <b>git</b>(1)
suite.</big></font></big></big></big></big></big></big></big></big></big></big></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>1.</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="2%"></td>
<td width="29%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>the
Git User
Manual</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="54%">
</td></tr>
</table>


<p style="margin-left:17%;"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>file:///usr/share/doc/git-1.8.3.1/user-manual.html</big></font></big></big></big></big></big></big></big></big></big></big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>2.</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="2%"></td>
<td width="41%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Randy
Dunlap&rsquo;s
presentation</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:17%;"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf</big></font></big></big></big></big></big></big></big></big></big></big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>3.</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="2%"></td>
<td width="18%">



<p style="margin-top: 1em"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>Everyday
git</big></font></big></big></big></big></big></big></big></big></big></big></p> </td>
<td width="65%">
</td></tr>
</table>


<p style="margin-left:17%;"><big><big><big><big><big><big><big><big><big><big><font color="#000000"><big>file:///usr/share/doc/git-1.8.3.1/everyday.html</big></font></big></big></big></big></big></big></big></big></big></big></p>
<hr>
</body>
</html>
