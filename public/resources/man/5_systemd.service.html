<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:23:29 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SYSTEMD.SERVICE</title>

</head>
<body>

<h1 align="center">SYSTEMD.SERVICE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#COMMAND LINES">COMMAND LINES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">systemd.service
&minus; Service unit configuration</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>service</i>.service</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A unit
configuration file whose name ends in .service encodes
information about a process controlled and supervised by
systemd.</p>

<p style="margin-left:11%; margin-top: 1em">This man page
lists the configuration options specific to this unit type.
See <b>systemd.unit</b>(5) for the common options of all
unit configuration files. The common configuration items are
configured in the generic &quot;[Unit]&quot; and
&quot;[Install]&quot; sections. The service specific
configuration options are configured in the
&quot;[Service]&quot; section.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
options are listed in <b>systemd.exec</b>(5), which define
the execution environment the commands are executed in, and
in <b>systemd.kill</b>(5), which define the way the
processes of the service are terminated, and in
<b>systemd.resource-control</b>(5), which configure resource
control settings for the processes of the service.</p>

<p style="margin-left:11%; margin-top: 1em">Unless
<i>DefaultDependencies=</i> is set to <b>false</b>, service
units will implicitly have dependencies of type
<i>Requires=</i> and <i>After=</i> on basic.target as well
as dependencies of type <i>Conflicts=</i> and <i>Before=</i>
on shutdown.target. These ensure that normal service units
pull in basic system initialization, and are terminated
cleanly prior to system shutdown. Only services involved
with early boot or late system shutdown should disable this
option.</p>

<p style="margin-left:11%; margin-top: 1em">If a service is
requested under a certain name but no unit configuration
file is found, systemd looks for a SysV init script by the
same name (with the .service suffix removed) and dynamically
creates a service unit from that script. This is useful for
compatibility with SysV. Note that this compatibility is
quite comprehensive but not 100%. For details about the
incompatibilities, see the
<b><font color="#0000FF">Incompatibilities with
SysV</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">document.</font></p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Service
files must include a &quot;[Service]&quot; section, which
carries information about the service and the process it
supervises. A number of options that may be used in this
section are shared with other unit types. These options are
documented in <b>systemd.exec</b>(5) and
<b>systemd.kill</b>(5). The options specific to the
&quot;[Service]&quot; section of service units are the
following:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the process start&minus;up type for this service unit. One
of <b>simple</b>, <b>forking</b>, <b>oneshot</b>,
<b>dbus</b>, <b>notify</b> or <b>idle</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
set to <b>simple</b> (the default if neither <i>Type=</i>
nor <i>BusName=</i>, but <i>ExecStart=</i> are specified),
it is expected that the process configured with
<i>ExecStart=</i> is the main process of the service. In
this mode, if the process offers functionality to other
processes on the system, its communication channels should
be installed before the daemon is started up (e.g. sockets
set up by systemd, via socket activation), as systemd will
immediately proceed starting follow&minus;up
units.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
set to <b>forking</b>, it is expected that the process
configured with <i>ExecStart=</i> will call <b>fork()</b> as
part of its start&minus;up. The parent process is expected
to exit when start&minus;up is complete and all
communication channels are set up. The child continues to
run as the main daemon process. This is the behavior of
traditional UNIX daemons. If this setting is used, it is
recommended to also use the <i>PIDFile=</i> option, so that
systemd can identify the main process of the daemon. systemd
will proceed with starting follow&minus;up units as soon as
the parent process exits.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Behavior
of <b>oneshot</b> is similar to <b>simple</b>; however, it
is expected that the process has to exit before systemd
starts follow&minus;up units. <i>RemainAfterExit=</i> is
particularly useful for this type of service. This is the
implied default if neither <i>Type=</i> or <i>ExecStart=</i>
are specified.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Behavior
of <b>dbus</b> is similar to <b>simple</b>; however, it is
expected that the daemon acquires a name on the D&minus;Bus
bus, as configured by <i>BusName=</i>. systemd will proceed
with starting follow&minus;up units after the D&minus;Bus
bus name has been acquired. Service units with this option
configured implicitly gain dependencies on the dbus.socket
unit. This type is the default if <i>BusName=</i> is
specified.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Behavior
of <b>notify</b> is similar to <b>simple</b>; however, it is
expected that the daemon sends a notification message via
<b>sd_notify</b>(3) or an equivalent call when it has
finished starting up. systemd will proceed with starting
follow&minus;up units after this notification message has
been sent. If this option is used, <i>NotifyAccess=</i> (see
below) should be set to open access to the notification
socket provided by systemd. If <i>NotifyAccess=</i> is not
set, it will be implicitly set to <b>main</b>. Note that
currently <i>Type=</i><b>notify</b> will not work if used in
combination with
<i>PrivateNetwork=</i><b>yes</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Behavior
of <b>idle</b> is very similar to <b>simple</b>; however,
actual execution of the service binary is delayed until all
jobs are dispatched. This may be used to avoid interleaving
of output of shell services with the status output on the
console.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RemainAfterExit=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean value that specifies whether the service shall be
considered active even when all its processes exited.
Defaults to <b>no</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>GuessMainPID=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean value that specifies whether systemd should try to
guess the main PID of a service if it cannot be determined
reliably. This option is ignored unless <b>Type=forking</b>
is set and <b>PIDFile=</b> is unset because for the other
types or with an explicitly configured PID file, the main
PID is always known. The guessing algorithm might come to
incorrect conclusions if a daemon consists of more than one
process. If the main PID cannot be determined, failure
detection and automatic restarting of a service will not
work reliably. Defaults to <b>yes</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PIDFile=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes an
absolute file name pointing to the PID file of this daemon.
Use of this option is recommended for services where
<i>Type=</i> is set to <b>forking</b>. systemd will read the
PID of the main process of the daemon after start&minus;up
of the service. systemd will not write to the file
configured here, although it will remove the file after the
service has shut down if it still exists.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>BusName=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
D&minus;Bus bus name that this service is reachable as. This
option is mandatory for services where <i>Type=</i> is set
to <b>dbus</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>BusPolicy=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">If
specified, a custom</font>
<b><font color="#0000FF">kdbus</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">endpoint will be created and installed
as the default bus node for the service. Such a custom
endpoint can hold an own set of policy rules that are
enforced on top of the bus&minus;wide ones. The custom
endpoint is named after the service it was created for, and
its node will be bind&minus;mounted over the default bus
node location, so the service can only access the bus
through its own endpoint. Note that custom bus endpoints
default to a 'deny all' policy. Hence, if at least one
<i>BusPolicy=</i> directive is given, you have to make sure
to add explicit rules for everything the service should be
able to do.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
value of this directive is comprised of two parts; the bus
name, and a verb to specify to granted access, which is one
of <b>see</b>, <b>talk</b>, or <b>own</b>. <b>talk</b>
implies <b>see</b>, and <b>own</b> implies both <b>talk</b>
and <b>see</b>. If multiple access levels are specified for
the same bus name, the most powerful one takes
effect.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Examples:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">BusPolicy=org.freedesktop.systemd1
talk</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">BusPolicy=org.foo.bar
see</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option is only available on kdbus enabled
systems.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStart=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
with their arguments that are executed when this service is
started. The value is split into zero or more command lines
is according to the rules described below (see section
&quot;Command Lines&quot; below).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<i>Type</i> is not <b>oneshot</b>, only one command may and
must be given. When <i>Type=oneshot</i> is used, zero or
more commands may be specified. This can be specified by
providing multiple command lines in the same directive, or
alternatively, this directive may be specified more than
once with the same effect. If the empty string is assigned
to this option, the list of commands to start is reset,
prior assignments of this option will have no effect. If no
<i>ExecStart=</i> is specified, then the service must have
<i>RemainAfterExit=yes</i> set.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">For
each of the specified commands, the first argument must be
an absolute path to an executable. Optionally, if this file
name is prefixed with &quot;@&quot;, the second token will
be passed as &quot;argv[0]&quot; to the executed process,
followed by the further arguments specified. If the absolute
filename is prefixed with &quot;&minus;&quot;, an exit code
of the command normally considered a failure (i.e.
non&minus;zero exit status or abnormal exit due to signal)
is ignored and considered success. If both
&quot;&minus;&quot; and &quot;@&quot; are used, they can
appear in either order.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
more than one command is specified, the commands are invoked
sequentially in the order they appear in the unit file. If
one of the commands fails (and is not prefixed with
&quot;&minus;&quot;), other lines are not executed, and the
unit is considered failed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Unless
<i>Type=forking</i> is set, the process started via this
command line will be considered the main process of the
daemon.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStartPre=</i>,
<i>ExecStartPost=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Additional
commands that are executed before or after the command in
<i>ExecStart=</i>, respectively. Syntax is the same as for
<i>ExecStart=</i>, except that multiple command lines are
allowed and the commands are executed one after the other,
serially.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
any of those commands (not prefixed with
&quot;&minus;&quot;) fail, the rest are not executed and the
unit is considered failed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that <i>ExecStartPre=</i> may not be used to start
long&minus;running processes. All processes forked off by
processes invoked via <i>ExecStartPre=</i> will be killed
before the next service process is run.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecReload=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
to execute to trigger a configuration reload in the service.
This argument takes multiple command lines, following the
same scheme as described for <i>ExecStart=</i> above. Use of
this setting is optional. Specifier and environment variable
substitution is supported here following the same scheme as
for <i>ExecStart=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">One
additional, special environment variable is set: if known,
<i>$MAINPID</i> is set to the main process of the daemon,
and may be used for command lines like the
following:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">/bin/kill
&minus;HUP $MAINPID</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
however that reloading a daemon by sending a signal (as with
the example line above) is usually not a good choice,
because this is an asynchronous operation and hence not
suitable to order reloads of multiple services against each
other. It is strongly recommended to set <i>ExecReload=</i>
to a command that not only triggers a configuration reload
of the daemon, but also synchronously waits for it to
complete.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStop=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Commands
to execute to stop the service started via
<i>ExecStart=</i>. This argument takes multiple command
lines, following the same scheme as described for
<i>ExecStart=</i> above. Use of this setting is optional.
After the commands configured in this option are run, all
processes remaining for a service are terminated according
to the <i>KillMode=</i> setting (see
<b>systemd.kill</b>(5)). If this option is not specified,
the process is terminated immediately when service stop is
requested. Specifier and environment variable substitution
is supported (including <i>$MAINPID</i>, see
above).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ExecStopPost=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Additional
commands that are executed after the service was stopped.
This includes cases where the commands configured in
<i>ExecStop=</i> were used, where the service does not have
any <i>ExecStop=</i> defined, or where the service exited
unexpectedly. This argument takes multiple command lines,
following the same scheme as described for <i>ExecStart</i>.
Use of these settings is optional. Specifier and environment
variable substitution is supported.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the time to sleep before restarting a service (as configured
with <i>Restart=</i>). Takes a unit&minus;less value in
seconds, or a time span value such as &quot;5min 20s&quot;.
Defaults to 100ms.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutStartSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the time to wait for start&minus;up. If a daemon service
does not signal start&minus;up completion within the
configured time, the service will be considered failed and
will be shut down again. Takes a unit&minus;less value in
seconds, or a time span value such as &quot;5min 20s&quot;.
Pass &quot;0&quot; to disable the timeout logic. Defaults to
<i>DefaultTimeoutStartSec=</i> from the manager
configuration file, except when <i>Type=oneshot</i> is used,
in which case the timeout is disabled by default (see
<b>systemd-system.conf</b>(5)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutStopSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the time to wait for stop. If a service is asked to stop,
but does not terminate in the specified time, it will be
terminated forcibly via <b>SIGTERM</b>, and after another
timeout of equal duration with <b>SIGKILL</b> (see
<i>KillMode=</i> in <b>systemd.kill</b>(5)). Takes a
unit&minus;less value in seconds, or a time span value such
as &quot;5min 20s&quot;. Pass &quot;0&quot; to disable the
timeout logic. Defaults to <i>DefaultTimeoutStopSec=</i>
from the manager configuration file (see
<b>systemd-system.conf</b>(5)).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>TimeoutSec=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
shorthand for configuring both <i>TimeoutStartSec=</i> and
<i>TimeoutStopSec=</i> to the specified value.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>WatchdogSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the watchdog timeout for a service. The watchdog is
activated when the start&minus;up is completed. The service
must call <b>sd_notify</b>(3) regularly with
&quot;WATCHDOG=1&quot; (i.e. the &quot;keep&minus;alive
ping&quot;). If the time between two such calls is larger
than the configured time, then the service is placed in a
failed state and it will be terminated with <i>SIGABRT</i>.
By setting <i>Restart=</i> to <b>on&minus;failure</b> or
<b>always</b>, the service will be automatically restarted.
The time configured here will be passed to the executed
service process in the <i>WATCHDOG_USEC=</i> environment
variable. This allows daemons to automatically enable the
keep&minus;alive pinging logic if watchdog support is
enabled for the service. If this option is used,
<i>NotifyAccess=</i> (see below) should be set to open
access to the notification socket provided by systemd. If
<i>NotifyAccess=</i> is not set, it will be implicitly set
to <b>main</b>. Defaults to 0, which disables this
feature.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Restart=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
whether the service shall be restarted when the service
process exits, is killed, or a timeout is reached. The
service process may be the main service process, but it may
also be one of the processes specified with
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecStop=</i>, <i>ExecStopPost=</i>, or
<i>ExecReload=</i>. When the death of the process is a
result of systemd operation (e.g. service stop or restart),
the service will not be restarted. Timeouts include missing
the watchdog &quot;keep&minus;alive ping&quot; deadline and
a service start, reload, and stop operation
timeouts.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Takes
one of <b>no</b>, <b>on&minus;success</b>,
<b>on&minus;failure</b>, <b>on&minus;abnormal</b>,
<b>on&minus;watchdog</b>, <b>on&minus;abort</b>, or
<b>always</b>. If set to <b>no</b> (the default), the
service will not be restarted. If set to
<b>on&minus;success</b>, it will be restarted only when the
service process exits cleanly. In this context, a clean exit
means an exit code of 0, or one of the signals
<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b> or
<b>SIGPIPE</b>, and additionally, exit statuses and signals
specified in <i>SuccessExitStatus=</i>. If set to
<b>on&minus;failure</b>, the service will be restarted when
the process exits with a non&minus;zero exit code, is
terminated by a signal (including on core dump, but
excluding the aforementiond four signals), when an operation
(such as service reload) times out, and when the configured
watchdog timeout is triggered. If set to
<b>on&minus;abnormal</b>, the service will be restarted when
the process is terminated by a signal (including on core
dump, excluding the aforementioned four signals), when an
operation times out, or when the watchdog timeout is
triggered. If set to <b>on&minus;abort</b>, the service will
be restarted only if the service process exits due to an
uncaught signal not specified as a clean exit status. If set
to <b>on&minus;watchdog</b>, the service will be restarted
only if the watchdog timeout for the service expires. If set
to <b>always</b>, the service will be restarted regardless
of whether it exited cleanly or not, got terminated
abnormally by a signal, or hit a timeout.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;1.&nbsp;Exit
causes and the effect of the</b> <i>Restart=</i> settings on
them <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <br>
As exceptions to the setting above the service will not be
restarted if the exit code or signal is specified in
<i>RestartPreventExitStatus=</i> (see below). Also, the
services will always be restarted if the exit code or signal
is specified in <i>RestartForceExitStatus=</i> (see
below).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Setting
this to <b>on&minus;failure</b> is the recommended choice
for long&minus;running services, in order to increase
reliability by attempting automatic recovery from errors.
For services that shall be able to terminate on their own
choice (and avoid immediate restarting),
<b>on&minus;abnormal</b> is an alternative
choice.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>SuccessExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that when returned by the
main service process will be considered successful
termination, in addition to the normal successful exit code
0 and the signals <b>SIGHUP</b>, <b>SIGINT</b>,
<b>SIGTERM</b>, and <b>SIGPIPE</b>. Exit status definitions
can either be numeric exit codes or termination signal
names, separated by spaces. For example:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">SuccessExitStatus=1
2 8 <br>
SIGKILL</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ensures
that exit codes 1, 2, 8 and the termination signal
<b>SIGKILL</b> are considered clean service
terminations.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that if a process has a signal handler installed and exits
by calling <b>_exit</b>(2) in response to a signal, the
information about the signal is lost. Programs should
instead perform cleanup and kill themselves with the same
signal instead. See</font> <b><font color="#0000FF">Proper
handling of SIGINT/SIGQUIT &mdash; How to be a proper
program</font></b>
<small><font color="#000000">[3]</font></small>
<font color="#000000">.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option may appear more than once, in which case the list of
successful exit statuses is merged. If the empty string is
assigned to this option, the list is reset, all prior
assignments of this option will have no effect.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartPreventExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that when returned by the
main service process will prevent automatic service
restarts, regardless of the restart setting configured with
<i>Restart=</i>. Exit status definitions can either be
numeric exit codes or termination signal names, and are
separated by spaces. Defaults to the empty list, so that, by
default, no exit status is excluded from the configured
restart logic. For example:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">RestartPreventExitStatus=1
6 <br>
SIGABRT</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ensures
that exit codes 1 and 6 and the termination signal
<b>SIGABRT</b> will not result in automatic service
restarting. This option may appear more than once, in which
case the list of restart&minus;preventing statuses is
merged. If the empty string is assigned to this option, the
list is reset and all prior assignments of this option will
have no effect.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RestartForceExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
list of exit status definitions that when returned by the
main service process will force automatic service restarts,
regardless of the restart setting configured with
<i>Restart=</i>. The argument format is similar to
<i>RestartPreventExitStatus=</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PermissionsStartOnly=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If true, the permission&minus;related
execution options, as configured with <i>User=</i> and
similar options (see <b>systemd.exec</b>(5) for more
information), are only applied to the process started with
<i>ExecStart=</i>, and not to the various other
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecReload=</i>, <i>ExecStop=</i>, and
<i>ExecStopPost=</i> commands. If false, the setting is
applied to all configured commands the same way. Defaults to
false.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RootDirectoryStartOnly=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If true, the root directory, as configured
with the <i>RootDirectory=</i> option (see
<b>systemd.exec</b>(5) for more information), is only
applied to the process started with <i>ExecStart=</i>, and
not to the various other <i>ExecStartPre=</i>,
<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>,
and <i>ExecStopPost=</i> commands. If false, the setting is
applied to all configured commands the same way. Defaults to
false.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>NonBlocking=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Set the
<b>O_NONBLOCK</b> flag for all file descriptors passed via
socket&minus;based activation. If true, all file descriptors
&gt;= 3 (i.e. all except stdin, stdout, and stderr) will
have the <b>O_NONBLOCK</b> flag set and hence are in
non&minus;blocking mode. This option is only useful in
conjunction with a socket unit, as described in
<b>systemd.socket</b>(5). Defaults to false.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>NotifyAccess=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Controls
access to the service status notification socket, as
accessible via the <b>sd_notify</b>(3) call. Takes one of
<b>none</b> (the default), <b>main</b> or <b>all</b>. If
<b>none</b>, no daemon status updates are accepted from the
service processes, all status update messages are ignored.
If <b>main</b>, only service updates sent from the main
process of the service are accepted. If <b>all</b>, all
services updates from all members of the service's control
group are accepted. This option should be set to open access
to the notification socket when using <i>Type=notify</i> or
<i>WatchdogSec=</i> (see above). If those options are used
but <i>NotifyAccess=</i> is not configured, it will be
implicitly set to <b>main</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Sockets=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Specifies
the name of the socket units this service shall inherit
socket file descriptors from when the service is started.
Normally it should not be necessary to use this setting as
all socket file descriptors whose unit shares the same name
as the service (subject to the different unit name suffix of
course) are passed to the spawned process.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that the same socket file descriptors may be passed to
multiple processes simultaneously. Also note that a
different service may be activated on incoming socket
traffic than the one which is ultimately configured to
inherit the socket file descriptors. Or in other words: the
<i>Service=</i> setting of .socket units does not have to
match the inverse of the <i>Sockets=</i> setting of the
.service it refers to.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option may appear more than once, in which case the list of
socket units is merged. If the empty string is assigned to
this option, the list of sockets is reset, and all prior
uses of this setting will have no effect.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>StartLimitInterval=</i>,
<i>StartLimitBurst=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
service start rate limiting. By default, services which are
started more than 5 times within 10 seconds are not
permitted to start any more times until the 10 second
interval ends. With these two options, this rate limiting
may be modified. Use <i>StartLimitInterval=</i> to configure
the checking interval (defaults to
<i>DefaultStartLimitInterval=</i> in manager configuration
file, set to 0 to disable any kind of rate limiting). Use
<i>StartLimitBurst=</i> to configure how many starts per
interval are allowed (defaults to
<i>DefaultStartLimitBurst=</i> in manager configuration
file). These configuration options are particularly useful
in conjunction with <i>Restart=</i>; however, they apply to
all kinds of starts (including manual), not just those
triggered by the <i>Restart=</i> logic. Note that units
which are configured for <i>Restart=</i> and which reach the
start limit are not attempted to be restarted anymore;
however, they may still be restarted manually at a later
point, from which point on, the restart logic is again
activated. Note that <b>systemctl reset&minus;failed</b>
will cause the restart rate counter for a service to be
flushed, which is useful if the administrator wants to
manually start a service and the start limit interferes with
that.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>StartLimitAction=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the action to take if the rate limit configured with
<i>StartLimitInterval=</i> and <i>StartLimitBurst=</i> is
hit. Takes one of <b>none</b>, <b>reboot</b>,
<b>reboot&minus;force</b>, <b>reboot&minus;immediate</b>,
<b>poweroff</b>, <b>poweroff&minus;force</b> or
<b>poweroff&minus;immediate</b>. If <b>none</b> is set,
hitting the rate limit will trigger no action besides that
the start will not be permitted. <b>reboot</b> causes a
reboot following the normal shutdown procedure (i.e.
equivalent to <b>systemctl reboot</b>).
<b>reboot&minus;force</b> causes a forced reboot which will
terminate all processes forcibly but should cause no dirty
file systems on reboot (i.e. equivalent to <b>systemctl
reboot &minus;f</b>) and <b>reboot&minus;immediate</b>
causes immediate execution of the <b>reboot</b>(2) system
call, which might result in data loss. Similar,
<b>poweroff</b>, <b>poweroff&minus;force</b>,
<b>poweroff&minus;immediate</b> have the effect of powering
down the system with similar semantics. Defaults to
<b>none</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FailureAction=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the action to take when the service enters a failed state.
Takes the same values as <i>StartLimitAction=</i> and
executes the same actions. Defaults to
<b>none</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RebootArgument=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the optional argument for the <b>reboot</b>(2) system call
if <i>StartLimitAction=</i> or <i>FailureAction=</i> is a
reboot action. This works just like the optional argument to
<b>systemctl reboot</b> command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FileDescriptorStoreMax=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
how many file descriptors may be stored in the service
manager for the service using
<b>sd_pid_notify_with_fds</b>(3)'s &quot;FDSTORE=1&quot;
messages. This is useful for implementing service restart
schemes where the state is serialized to /run and the file
descriptors passed to the service manager, to allow restarts
without losing state. Defaults to 0, i.e. no file
descriptors may be stored in the service manager by default.
All file descriptors passed to the service manager from a
specific service are passed back to the service's main
process on the next service restart. Any file descriptors
passed to the service manager are automatically closed when
POLLHUP or POLLERR is seen on them, or when the service is
fully stopped and no job queued or being executed for
it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Check
<b>systemd.exec</b>(5) and <b>systemd.kill</b>(5) for more
settings.</font></p>

<h2>COMMAND LINES
<a name="COMMAND LINES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
section describes command line parsing and variable and
specifier substitions for <i>ExecStart=</i>,
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecReload=</i>, <i>ExecStop=</i>, and
<i>ExecStopPost=</i> options.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Multiple
command lines may be concatenated in a single directive by
separating them with semicolons (these semicolons must be
passed as separate words). Lone semicolons may be escaped as
&quot;\;&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Each
command line is split on whitespace, with the first item
being the command to execute, and the subsequent items being
the arguments. Double quotes (&quot;...&quot;) and single
quotes ('...') may be used, in which case everything until
the next matching quote becomes part of the same argument.
C&minus;style escapes are also supported, see table below.
Quotes themselves are removed after parsing and escape
sequences substituted. In addition, a trailing backslash
(&quot;\&quot;) may be used to merge lines.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
syntax is intended to be very similar to shell syntax, but
only the meta&minus;characters and expansions described in
the following paragraphs are understood. Specifically,
redirection using &quot;&lt;&quot;, &quot;&lt;&lt;&quot;,
&quot;&gt;&quot;, and &quot;&gt;&gt;&quot;, pipes using
&quot;|&quot;, running programs in the background using
&quot;&amp;&quot;, and <i>other elements of shell syntax are
not supported</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command to execute must an absolute path name. It may
contain spaces, but control characters are not
allowed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command line accepts &quot;%&quot; specifiers as described
in <b>systemd.unit</b>(5). Note that the first argument of
the command line (i.e. the program to execute) may not
include specifiers.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Basic
environment variable substitution is supported. Use
&quot;${FOO}&quot; as part of a word, or as a word of its
own, on the command line, in which case it will be replaced
by the value of the environment variable including all
whitespace it contains, resulting in a single argument. Use
&quot;$FOO&quot; as a separate word on the command line, in
which case it will be replaced by the value of the
environment variable split at whitespace resulting in zero
or more arguments. For this type of expansion, quotes and
respected when splitting into words, and afterwards
removed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=&quot;ONE=one&quot;
'TWO=two two' <br>
ExecStart=/bin/echo $ONE $TWO ${TWO}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>/bin/echo</b> with four arguments:
&quot;one&quot;, &quot;two&quot;, &quot;two&quot;, and
&quot;two two&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=ONE='one'
&quot;TWO='two&nbsp;two'&nbsp;too&quot; THREE= <br>
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE} <br>
ExecStart=/bin/echo $ONE $TWO $THREE</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
results in echo being called twice, the first time with
arguments &quot;'one'&quot;,
&quot;'two&nbsp;two'&nbsp;too&quot;, &quot;&quot;, and the
second time with arguments &quot;one&quot;,
&quot;two&nbsp;two&quot;, &quot;too&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">To
pass a literal dollar sign, use &quot;$$&quot;. Variables
whose value is not known at expansion time are treated as
empty strings. Note that the first argument (i.e. the
program to execute) may not be a variable.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Variables
to be used in this fashion may be defined through
<i>Environment=</i> and <i>EnvironmentFile=</i>. In
addition, variables listed in the section &quot;Environment
variables in spawned processes&quot; in
<b>systemd.exec</b>(5), which are considered &quot;static
configuration&quot;, may be used (this includes e.g.
<i>$USER</i>, but not <i>$TERM</i>).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that shell command lines are not directly supported. If
shell command lines are to be used, they need to be passed
explicitly to a shell implementation of some kind.
Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=/bin/sh
&minus;c 'dmesg | tac'</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=/bin/echo
one ; /bin/echo &quot;two two&quot;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>/bin/echo</b> two times, each time with one
argument: &quot;one&quot; and &quot;two two&quot;,
respectively. Because two commands are specified,
<i>Type=oneshot</i> must be used.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=/bin/echo
/ &gt;/dev/null &amp; \; \ <br>
/bin/ls</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>/bin/echo</b> with five arguments:
&quot;/&quot;, &quot;&gt;/dev/null&quot;, &quot;&amp;&quot;,
&quot;;&quot;, and &quot;/bin/ls&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;2.&nbsp;C
escapes supported in command lines and environment
variables</b></font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;1.&nbsp;Simple
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following unit file creates a service that will execute
/usr/sbin/foo&minus;daemon. Since no <i>Type=</i> is
specified, the default <i>Type=</i><b>simple</b> will be
assumed. systemd will assume the unit to be started
immediately after the program has begun
executing.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Foo</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
ExecStart=/usr/sbin/foo&minus;daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd assumes here that the process started by
systemd will continue running until the service terminates.
If the program daemonizes itself (i.e. forks), please use
<i>Type=</i><b>forking</b> instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
no <i>ExecStop=</i> was specified, systemd will send SIGTERM
to all processes started from this service, and after a
timeout also SIGKILL. This behavior can be modified, see
<b>systemd.kill</b>(5) for details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that this unit type does not include any type of
notification when a service has completed initialization.
For this, you should use other unit types, such as
<i>Type=</i><b>notify</b> if the service understands
systemd's notification protocol, <i>Type=</i><b>forking</b>
if the service can background itself or
<i>Type=</i><b>dbus</b> if the unit acquires a DBus name
once initialization is complete. See below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Oneshot
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Sometimes
units should just execute an action without keeping active
processes, such as a filesystem check or a cleanup action on
boot. For this, <i>Type=</i><b>oneshot</b> exists. Units of
this type will wait until the process specified terminates
and then fall back to being inactive. The following unit
will perform a clenaup action:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Cleanup old Foo data</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
ExecStart=/usr/sbin/foo&minus;cleanup</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd will consider the unit to be in the state
'starting' until the program has terminated, so ordered
dependencies will wait for the program to finish before
starting themselves. The unit will revert to the 'inactive'
state after the execution is done, never reaching the
'active' state. That means another request to start the unit
will perform the action again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>oneshot</b>
are the only service units that may have more than one
<i>ExecStart=</i> specified. They will be executed in order
until either they are all successful or one of them
fails.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;3.&nbsp;Stoppable
oneshot service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly
to the oneshot services, there are sometimes units that need
to execute a program to set up something and then execute
another to shut it down, but no process remains active while
they are considered 'started'. Network configuration can
sometimes fall into this category. Another use case is if a
oneshot service shall not be executed a each time when they
are pulled in as a dependency, but only the first
time.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
this, systemd knows the setting
<i>RemainAfterExit=</i><b>yes</b>, which causes systemd to
consider the unit to be active if the start action exited
successfully. This directive can be used with all types, but
is most useful with <i>Type=</i><b>oneshot</b> and
<i>Type=</i><b>simple</b>. With <i>Type=</i><b>oneshot</b>
systemd waits until the start action has completed before it
considers the unit to be active, so dependencies start only
after the start action has succeeded. With
<i>Type=</i><b>simple</b> dependencies will start
immediately after the start action has been dispatched. The
following unit provides an example for a simple static
firewall.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple firewall</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
RemainAfterExit=yes <br>
ExecStart=/usr/local/sbin/simple&minus;firewall&minus;start
<br>

ExecStop=/usr/local/sbin/simple&minus;firewall&minus;stop</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
the unit is considered to be running after the start action
has exited, invoking <b>systemctl start</b> on that unit
again will cause no action to be taken.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;4.&nbsp;Traditional
forking services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Many
traditional daemons/services background (i.e. fork,
daemonize) themselves when starting. Set
<i>Type=</i><b>forking</b> in the service's unit file to
support this mode of operation. systemd will consider the
service to be in the process of initialization while the
original program is still running. Once it exits
successfully and at least a process remains (and
<i>RemainAfterExit=</i><b>no</b>), the service is considered
started.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Often
a traditional daemon only consists of one process.
Therefore, if only one process is left after the original
process terminates, systemd will consider that process the
main process of the service. In that case, the
<i>$MAINPID</i> variable will be available in
<i>ExecReload=</i>, <i>ExecStop=</i>, etc.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
case more than one process remains, systemd will be unable
to determine the main process, so it will not assume there
is one. In that case, <i>$MAINPID</i> will not expand to
anything. However, if the process decides to write a
traditional PID file, systemd will be able to read the main
PID from there. Please set <i>PIDFile=</i> accordingly. Note
that the daemon should write that file before finishing with
its initialization, otherwise systemd might try to read the
file before it exists.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following example shows a simple daemon that forks and just
starts one process in the background:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Some simple daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=forking <br>
ExecStart=/usr/sbin/my&minus;simple&minus;daemon
&minus;d</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;5.&nbsp;DBus
services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
services that acquire a name on the DBus system bus, use
<i>Type=</i><b>dbus</b> and set <i>BusName=</i> accordingly.
The service should not fork (daemonize). systemd will
consider the service to be initialized once the name has
been acquired on the system bus. The following example shows
a typical DBus service:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple DBus service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=dbus <br>
BusName=org.example.simple&minus;dbus&minus;service <br>

ExecStart=/usr/sbin/simple&minus;dbus&minus;service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
<i>bus&minus;activatable</i> services, don't include a
&quot;[Install]&quot; section in the systemd service file,
but use the <i>SystemdService=</i> option in the
corresponding DBus service file, for example
(/usr/share/dbus&minus;1/system&minus;services/org.example.simple&minus;dbus&minus;service.service):</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[D&minus;BUS
Service] <br>
Name=org.example.simple&minus;dbus&minus;service <br>
Exec=/usr/sbin/simple&minus;dbus&minus;service <br>
User=root <br>

SystemdService=simple&minus;dbus&minus;service.service</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;6.&nbsp;Services
that notify systemd about their
initialization</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>simple</b>
services are really easy to write, but have the major
disadvantage of systemd not being able to tell when
initialization of the given service is complete. For this
reason, systemd supports a simple notification protocol that
allows daemons to make systemd aware that they are done
initializing. Use <i>Type=</i><b>notify</b> for this. A
typical service file for such a daemon would look like
this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple notifying service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=notify <br>

ExecStart=/usr/sbin/simple&minus;notifying&minus;service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that the daemon has to support systemd's notification
protocol, else systemd will think the service hasn't started
yet and kill it after a timeout. For an example of how to
update daemons to support this protocol transparently, take
a look at <b>sd_notify</b>(3). systemd will consider the
unit to be in the 'starting' state until a readiness
notification has arrived.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>systemctl</b>(1), <b>systemd.unit</b>(5),
<b>systemd.exec</b>(5), <b>systemd.resource-control</b>(5),
<b>systemd.kill</b>(5),
<b>systemd.directives</b>(7)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="41%">



<p style="margin-top: 1em"><font color="#000000">Incompatibilities
with SysV</font></p></td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.freedesktop.org/wiki/Software/systemd/Incompatibilities</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="8%">



<p style="margin-top: 1em"><font color="#000000">kdbus</font></p> </td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://code.google.com/p/d-bus/</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">3.</font></p> </td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><font color="#000000">Proper
handling of SIGINT/SIGQUIT &mdash; How to be a proper
program</font></p> </td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.cons.org/cracauer/sigint.html</font></p>
<hr>
</body>
</html>
