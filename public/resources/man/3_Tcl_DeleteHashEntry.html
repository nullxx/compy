<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:14 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_Hash</title>

</head>
<body>

<h1 align="center">Tcl_Hash</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#THE TCL_HASHKEYTYPE STRUCTURE">THE TCL_HASHKEYTYPE STRUCTURE</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_InitHashTable,
Tcl_InitCustomHashTable, Tcl_InitObjHashTable,
Tcl_DeleteHashTable, Tcl_CreateHashEntry,
Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue,
Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry,
Tcl_NextHashEntry, Tcl_HashStats &minus; procedures to
manage hash tables</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitHashTable</b>(<i>tablePtr,
keyType</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitCustomHashTable</b>(<i>tablePtr,
keyType, typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitObjHashTable</b>(<i>tablePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_DeleteHashTable</b>(<i>tablePtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_HashEntry *
<b><br>
Tcl_CreateHashEntry</b>(<i>tablePtr, key, newPtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_DeleteHashEntry</b>(<i>entryPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_HashEntry *
<b><br>
Tcl_FindHashEntry</b>(<i>tablePtr, key</i>)</p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_GetHashValue</b>(<i>entryPtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SetHashValue</b>(<i>entryPtr,
value</i>)</p>

<p style="margin-left:11%; margin-top: 1em">char * <b><br>
Tcl_GetHashKey</b>(<i>tablePtr, entryPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_HashEntry *
<b><br>
Tcl_FirstHashEntry</b>(<i>tablePtr, searchPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_HashEntry *
<b><br>
Tcl_NextHashEntry</b>(<i>searchPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">char * <b><br>
Tcl_HashStats</b>(<i>tablePtr</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p style="margin-top: 1em">Tcl_HashTable <i>*tablePtr</i>
(in)</p> </td>
<td width="17%"></td>
<td width="26%">


<p style="margin-top: 1em">Address of hash table structure
(for all procedures but <b>Tcl_InitHashTable</b>, this must
have been initialized by previous call to
<b>Tcl_InitHashTable</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>keyType</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>Kind of keys to use for new hash table. Must be either
<b>TCL_STRING_KEYS</b>, <b>TCL_ONE_WORD_KEYS</b>,
<b>TCL_CUSTOM_TYPE_KEYS</b>, <b>TCL_CUSTOM_PTR_KEYS</b>, or
an integer value greater than 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_HashKeyType <i>*typePtr</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>Address of structure which defines the behaviour of the
hash table.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*key</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>Key to use for probe into table. Exact form depends on
<i>keyType</i> used to create table.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>*newPtr</i> (out)</p></td>
<td width="17%"></td>
<td width="26%">


<p>The word at <i>*newPtr</i> is set to 1 if a new entry
was created and 0 if there was already an entry for
<i>key</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_HashEntry <i>*entryPtr</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>Pointer to hash table entry.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>ClientData <i>value</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>New value to assign to hash table entry. Need not have
type ClientData, but must fit in same space as
ClientData.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_HashSearch <i>*searchPtr</i> (in)</p></td>
<td width="17%"></td>
<td width="26%">


<p>Pointer to record to use to keep track of progress in
enumerating all the entries in a hash table.</p></td></tr>
</table>


<p style="margin-left:74%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A hash table
consists of zero or more entries, each consisting of a key
and a value. Given the key for an entry, the hashing
routines can very quickly locate the entry, and hence its
value. There may be at most one entry in a hash table with a
particular key, but many entries may have the same value.
Keys can take one of four forms: strings, one-word values,
integer arrays, or custom keys defined by a Tcl_HashKeyType
structure (See section <b>THE TCL_HASHKEYTYPE STRUCTURE</b>
below). All of the keys in a given table have the same form,
which is specified when the table is initialized.</p>

<p style="margin-left:11%; margin-top: 1em">The value of a
hash table entry can be anything that fits in the same space
as a &ldquo;char *&rdquo; pointer. Values for hash table
entries are managed entirely by clients, not by the hash
module itself. Typically each entry&rsquo;s value is a
pointer to a data structure managed by client code.</p>

<p style="margin-left:11%; margin-top: 1em">Hash tables
grow gracefully as the number of entries increases, so that
there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the
number of entries in a table.</p>

<p style="margin-left:11%; margin-top: 1em">The core
provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitHashTable</b>
initializes a structure that describes a new hash table. The
space for the structure is provided by the caller, not by
the hash module. The value of <i>keyType</i> indicates what
kinds of keys will be used for all entries in the table. All
of the key types described later are allowed, with the
exception of <b>TCL_CUSTOM_TYPE_KEYS</b> and
<b>TCL_CUSTOM_PTR_KEYS</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitObjHashTable</b>
is a wrapper around <b>Tcl_InitCustomHashTable</b> and
initializes a hash table whose keys are Tcl_Obj *.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InitCustomHashTable</b>
initializes a structure that describes a new hash table. The
space for the structure is provided by the caller, not by
the hash module. The value of <i>keyType</i> indicates what
kinds of keys will be used for all entries in the table.
<i>KeyType</i> must have one of the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p style="margin-top: 1em"><b>TCL_STRING_KEYS</b></p></td>
<td width="7%"></td>
<td width="51%">


<p style="margin-top: 1em">Keys are null-terminated
strings. They are passed to hashing routines using the
address of the first character of the string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>TCL_ONE_WORD_KEYS</b></p></td>
<td width="7%"></td>
<td width="51%">


<p>Keys are single-word values; they are passed to hashing
routines and stored in hash table entries as &ldquo;char
*&rdquo; values. The pointer value is the key; it need not
(and usually does not) actually point to a string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>TCL_CUSTOM_TYPE_KEYS</b></p></td>
<td width="7%"></td>
<td width="51%">


<p>Keys are of arbitrary type, and are stored in the entry.
Hashing and comparison is determined by <i>typePtr</i>. The
Tcl_HashKeyType structure is described in the section <b>THE
TCL_HASHKEYTYPE STRUCTURE</b> below.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>TCL_CUSTOM_PTR_KEYS</b></p></td>
<td width="7%"></td>
<td width="51%">


<p>Keys are pointers to an arbitrary type, and are stored
in the entry. Hashing and comparison is determined by
<i>typePtr</i>. The Tcl_HashKeyType structure is described
in the section <b>THE TCL_HASHKEYTYPE STRUCTURE</b>
below.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><i>other</i></p></td>
<td width="7%"></td>
<td width="51%">


<p>If <i>keyType</i> is not one of the above, then it must
be an integer value greater than 1. In this case the keys
will be arrays of &ldquo;int&rdquo; values, where
<i>keyType</i> gives the number of ints in each key. This
allows structures to be used as keys. All keys must have the
same size. Array keys are passed into hashing functions
using the address of the first int in the array.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_DeleteHashTable</b>
deletes all of the entries in a hash table and frees up the
memory associated with the table&rsquo;s bucket array and
entries. It does not free the actual table structure
(pointed to by <i>tablePtr</i>), since that memory is
assumed to be managed by the client.
<b>Tcl_DeleteHashTable</b> also does not free or otherwise
manipulate the values of the hash table entries. If the
entry values point to dynamically-allocated memory, then it
is the client&rsquo;s responsibility to free these
structures before deleting the table.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateHashEntry</b>
locates the entry corresponding to a particular key,
creating a new entry in the table if there was not already
one with the given key. If an entry already existed with the
given key then <i>*newPtr</i> is set to zero. If a new entry
was created, then <i>*newPtr</i> is set to a non-zero value
and the value of the new entry will be set to zero. The
return value from <b>Tcl_CreateHashEntry</b> is a pointer to
the entry, which may be used to retrieve and modify the
entry&rsquo;s value or to delete the entry from the
table.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_DeleteHashEntry</b>
will remove an existing entry from a table. The memory
associated with the entry itself will be freed, but the
client is responsible for any cleanup associated with the
entry&rsquo;s value, such as freeing a structure that it
points to.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FindHashEntry</b>
is similar to <b>Tcl_CreateHashEntry</b> except that it does
not create a new entry if the key doesn&rsquo;t exist;
instead, it returns NULL as result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetHashValue</b>
and <b>Tcl_SetHashValue</b> are used to read and write an
entry&rsquo;s value, respectively. Values are stored and
retrieved as type &ldquo;ClientData&rdquo;, which is large
enough to hold a pointer value. On almost all machines this
is large enough to hold an integer value too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetHashKey</b>
returns the key for a given hash table entry, either as a
pointer to a string, a one-word (&ldquo;char *&rdquo;) key,
or as a pointer to the first word of an array of integers,
depending on the <i>keyType</i> used to create a hash table.
In all cases <b>Tcl_GetHashKey</b> returns a result with
type &ldquo;char *&rdquo;. When the key is a string or
array, the result of <b>Tcl_GetHashKey</b> points to
information in the table entry; this information will remain
valid until the entry is deleted or its table is
deleted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FirstHashEntry</b>
and <b>Tcl_NextHashEntry</b> may be used to scan all of the
entries in a hash table. A structure of type
&ldquo;Tcl_HashSearch&rdquo;, provided by the client, is
used to keep track of progress through the table.
<b>Tcl_FirstHashEntry</b> initializes the search record and
returns the first entry in the table (or NULL if the table
is empty). Each subsequent call to <b>Tcl_NextHashEntry</b>
returns the next entry in the table or NULL if the end of
the table has been reached. A call to
<b>Tcl_FirstHashEntry</b> followed by calls to
<b>Tcl_NextHashEntry</b> will return each of the entries in
the table exactly once, in an arbitrary order. It is
inadvisable to modify the structure of the table, e.g. by
creating or deleting entries, while the search is in
progress, with the exception of deleting the entry returned
by <b>Tcl_FirstHashEntry</b> or
<b>Tcl_NextHashEntry</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_HashStats</b>
returns a dynamically-allocated string with overall
information about a hash table, such as the number of
entries it contains, the number of buckets in its hash
array, and the utilization of the buckets. It is the
caller&rsquo;s responsibility to free the result string by
passing it to <b>ckfree</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The header file
<b>tcl.h</b> defines the actual data structures used to
implement hash tables. This is necessary so that clients can
allocate Tcl_HashTable structures and so that macros can be
used to read and write the values of entries. However, users
of the hashing routines should never refer directly to any
of the fields of any of the hash-related data structures;
use the procedures and macros defined here.</p>

<h2>THE TCL_HASHKEYTYPE STRUCTURE
<a name="THE TCL_HASHKEYTYPE STRUCTURE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Extension
writers can define new hash key types by defining four
procedures, initializing a <b>Tcl_HashKeyType</b> structure
to describe the type, and calling
<b>Tcl_InitCustomHashTable</b>. The <b>Tcl_HashKeyType</b>
structure is defined as follows:</p>

<p style="margin-left:22%;">typedef struct Tcl_HashKeyType
{ <br>
int <i>version</i>; <br>
int <i>flags</i>; <br>
Tcl_HashKeyProc *<i>hashKeyProc</i>; <br>
Tcl_CompareHashKeysProc *<i>compareKeysProc</i>; <br>
Tcl_AllocHashEntryProc *<i>allocEntryProc</i>; <br>
Tcl_FreeHashEntryProc *<i>freeEntryProc</i>; <br>
} Tcl_HashKeyType;</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>version</i> member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be
set to <b>TCL_HASH_KEY_TYPE_VERSION</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> member is 0 or one or more of the following
values OR&rsquo;ed together: <b><br>
TCL_HASH_KEY_RANDOMIZE_HASH</b></p>

<p style="margin-left:49%;">There are some things, pointers
for example which do not hash well because they do not use
the lower bits. If this flag is set then the hash table will
attempt to rectify this by randomizing the bits and then
using the upper N bits as the index into the table.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>TCL_HASH_KEY_SYSTEM_HASH</b></p></td>
<td width="1%"></td>
<td width="51%">


<p>This flag forces Tcl to use the memory
<big>&#9474;</big> allocation procedures provided by the
<big>&#9474;</big> operating system when allocating and
freeing <big>&#9474;</big> memory used to store the hash
table data <big>&#9474;</big> structures, and not any of
Tcl&rsquo;s own <big>&#9474;</big> customized memory
allocation routines. This is <big>&#9474;</big> important if
the hash table is to be used in <big>&#9474;</big> the
implementation of a custom set of <big>&#9474;</big>
allocation routines, or something that a <big>&#9474;</big>
custom set of allocation routines might depend
<big>&#9474;</big> on, in order to avoid any circular
dependency.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>hashKeyProc</i> member contains the address of a function
called to calculate a hash value for the key.</p>

<p style="margin-left:22%;">typedef unsigned int
(Tcl_HashKeyProc) ( <br>
Tcl_HashTable *<i>tablePtr</i>, <br>
void *<i>keyPtr</i>);</p>

<p style="margin-left:11%;">If this is NULL then
<i>keyPtr</i> is used and <b>TCL_HASH_KEY_RANDOMIZE_HASH</b>
is assumed.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>compareKeysProc</i> member contains the address of a
function called to compare two keys.</p>

<p style="margin-left:22%;">typedef int
(Tcl_CompareHashKeysProc) ( <br>
void *<i>keyPtr</i>, <br>
Tcl_HashEntry *<i>hPtr</i>);</p>

<p style="margin-left:11%;">If this is NULL then the
<i>keyPtr</i> pointers are compared. If the keys do not
match then the function returns 0, otherwise it returns
1.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>allocEntryProc</i> member contains the address of a
function called to allocate space for an entry and
initialize the key and clientData.</p>

<p style="margin-left:22%;">typedef Tcl_HashEntry
*(Tcl_AllocHashEntryProc) ( <br>
Tcl_HashTable *<i>tablePtr</i>, <br>
void *<i>keyPtr</i>);</p>

<p style="margin-left:11%;">If this is NULL then Tcl_Alloc
is used to allocate enough space for a Tcl_HashEntry, the
key pointer is assigned to key.oneWordValue and the
clientData is set to NULL. String keys and array keys use
this function to allocate enough space for the entry and the
key in one block, rather than doing it in two blocks. This
saves space for a pointer to the key from the entry and
another memory allocation. Tcl_Obj* keys use this function
to allocate enough space for an entry and increment the
reference count on the object.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>freeEntryProc</i> member contains the address of a
function called to free space for an entry.</p>

<p style="margin-left:22%;">typedef void
(Tcl_FreeHashEntryProc) (Tcl_HashEntry *<i>hPtr</i>);</p>

<p style="margin-left:11%;">If this is NULL then Tcl_Free
is used to free the space for the entry. Tcl_Obj* keys use
this function to decrement the reference count on the
object.</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hash table,
key, lookup, search, value</p>
<hr>
</body>
</html>
