<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:48 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_OpenFileChannel</title>

</head>
<body>

<h1 align="center">Tcl_OpenFileChannel</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#TCL_OPENFILECHANNEL">TCL_OPENFILECHANNEL</a><br>
<a href="#TCL_OPENCOMMANDCHANNEL">TCL_OPENCOMMANDCHANNEL</a><br>
<a href="#TCL_MAKEFILECHANNEL">TCL_MAKEFILECHANNEL</a><br>
<a href="#TCL_GETCHANNEL">TCL_GETCHANNEL</a><br>
<a href="#TCL_REGISTERCHANNEL">TCL_REGISTERCHANNEL</a><br>
<a href="#TCL_UNREGISTERCHANNEL">TCL_UNREGISTERCHANNEL</a><br>
<a href="#TCL_DETACHCHANNEL">TCL_DETACHCHANNEL</a><br>
<a href="#TCL_ISSTANDARDCHANNEL">TCL_ISSTANDARDCHANNEL</a><br>
<a href="#TCL_CLOSE">TCL_CLOSE</a><br>
<a href="#TCL_READCHARS AND TCL_READ">TCL_READCHARS AND TCL_READ</a><br>
<a href="#TCL_GETSOBJ AND TCL_GETS">TCL_GETSOBJ AND TCL_GETS</a><br>
<a href="#TCL_UNGETS">TCL_UNGETS</a><br>
<a href="#TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE">TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE</a><br>
<a href="#TCL_FLUSH">TCL_FLUSH</a><br>
<a href="#TCL_SEEK">TCL_SEEK</a><br>
<a href="#TCL_TELL">TCL_TELL</a><br>
<a href="#TCL_TRUNCATECHANNEL">TCL_TRUNCATECHANNEL</a><br>
<a href="#TCL_GETCHANNELOPTION">TCL_GETCHANNELOPTION</a><br>
<a href="#TCL_SETCHANNELOPTION">TCL_SETCHANNELOPTION</a><br>
<a href="#TCL_EOF">TCL_EOF</a><br>
<a href="#TCL_INPUTBLOCKED">TCL_INPUTBLOCKED</a><br>
<a href="#TCL_INPUTBUFFERED">TCL_INPUTBUFFERED</a><br>
<a href="#TCL_OUTPUTBUFFERED">TCL_OUTPUTBUFFERED</a><br>
<a href="#PLATFORM ISSUES">PLATFORM ISSUES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_OpenFileChannel,
Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel,
Tcl_GetChannelNames, Tcl_GetChannelNamesEx,
Tcl_RegisterChannel, Tcl_UnregisterChannel,
Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close,
Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets,
Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush,
Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel,
Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof,
Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered,
Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw &minus; buffered I/O
facilities using channels</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_OpenFileChannel</b>(<i>interp, fileName, mode,
permissions</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_OpenCommandChannel</b>(<i>interp, argc, argv,
flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_MakeFileChannel</b>(<i>handle, readOrWrite</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_GetChannel</b>(<i>interp, channelName, modePtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelNames</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelNamesEx</b>(<i>interp, pattern</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_RegisterChannel</b>(<i>interp, channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_UnregisterChannel</b>(<i>interp, channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_DetachChannel</b>(<i>interp, channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_IsStandardChannel</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Close</b>(<i>interp, channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_ReadChars</b>(<i>channel, readObjPtr, charsToRead,
appendFlag</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Read</b>(<i>channel, readBuf, bytesToRead</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetsObj</b>(<i>channel, lineObjPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Gets</b>(<i>channel, lineRead</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Ungets</b>(<i>channel, input, inputLen,
addAtEnd</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_WriteObj</b>(<i>channel, writeObjPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_WriteChars</b>(<i>channel, charBuf,
bytesToWrite</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Write</b>(<i>channel, byteBuf, bytesToWrite</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_ReadRaw</b>(<i>channel, readBuf, bytesToRead</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_WriteRaw</b>(<i>channel, byteBuf, bytesToWrite</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Eof</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_Flush</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_InputBlocked</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_InputBuffered</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_OutputBuffered</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_WideInt
<b><br>
Tcl_Seek</b>(<i>channel, offset, seekMode</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_WideInt
<b><br>
Tcl_Tell</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int
<big>&#9474;</big> <b><br>
Tcl_TruncateChannel</b>(<i>channel, length</i>)
<big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelOption</b>(<i>interp, channel, optionName,
optionValue</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_SetChannelOption</b>(<i>interp, channel, optionName,
newValue</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p style="margin-top: 1em">Tcl_Interp <i>*interp</i>
(in)</p> </td>
<td width="14%"></td>
<td width="29%">


<p style="margin-top: 1em">Used for error reporting and to
look up a channel registered in it.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*fileName</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The name of a local or network file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*mode</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Specifies how the file is to be accessed. May have any
of the values allowed for the <i>mode</i> argument to the
Tcl <b>open</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>permissions</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>POSIX-style permission flags such as 0644. If a new file
is created, these permissions will be set on the created
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>argc</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The number of elements in <i>argv</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>**argv</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Arguments for constructing a command pipeline. These
values have the same meaning as the non-switch arguments to
the Tcl <b>exec</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>flags</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Specifies the disposition of the stdio handles in
pipeline: OR-ed combination of <b>TCL_STDIN</b>,
<b>TCL_STDOUT</b>, <b>TCL_STDERR</b>, and
<b>TCL_ENFORCE_MODE</b>. If <b>TCL_STDIN</b> is set, stdin
for the first child in the pipe is the pipe channel,
otherwise it is the same as the standard input of the
invoking process; likewise for <b>TCL_STDOUT</b> and
<b>TCL_STDERR</b>. If <b>TCL_ENFORCE_MODE</b> is not set,
then the pipe can redirect stdio handles to override the
stdio handles for which <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>
and <b>TCL_STDERR</b> have been set. If it is set, then such
redirections cause an error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>ClientData <i>handle</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Operating system specific handle for I/O to a file. For
Unix this is a file descriptor, for Windows it is a
HANDLE.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>readOrWrite</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>OR-ed combination of <b>TCL_READABLE</b> and
<b>TCL_WRITABLE</b> to indicate what operations are valid on
<i>handle</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*channelName</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The name of the channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>*modePtr</i> (out)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Points at an integer variable that will receive an OR-ed
combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>
denoting whether the channel is open for reading and
writing.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*pattern</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The pattern to match on, passed to Tcl_StringMatch, or
NULL.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_Channel <i>channel</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A Tcl channel for input or output. Must have been the
return value from a procedure such as
<b>Tcl_OpenFileChannel</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_Obj <i>*readObjPtr</i> (in/out)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A pointer to a Tcl Object in which to store the
characters read from the channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>charsToRead</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The number of characters to read from the channel. If
the channel&rsquo;s encoding is <b>binary</b>, this is
equivalent to the number of bytes to read from the
channel.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>appendFlag</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>If non-zero, data read from the channel will be appended
to the object. Otherwise, the data will replace the existing
contents of the object.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>char <i>*readBuf</i> (out)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A buffer in which to store the bytes read from the
channel.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>bytesToRead</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The number of bytes to read from the channel. The buffer
<i>readBuf</i> must be large enough to hold this many
bytes.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_Obj <i>*lineObjPtr</i> (in/out)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A pointer to a Tcl object in which to store the line
read from the channel. The line read will be appended to the
current value of the object.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_DString <i>*lineRead</i> (in/out)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A pointer to a Tcl dynamic string in which to store the
line read from the channel. Must have been initialized by
the caller. The line read will be appended to any data
already in the dynamic string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*input</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The input to add to a channel buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>inputLen</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Length of the input</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>addAtEnd</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Flag indicating whether the input should be added to the
end or beginning of the channel buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_Obj <i>*writeObjPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A pointer to a Tcl Object whose contents will be output
to the channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*charBuf</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A buffer containing the characters to output to the
channel.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*byteBuf</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>A buffer containing the bytes to output to the
channel.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>bytesToWrite</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The number of bytes to consume from <i>charBuf</i> or
<i>byteBuf</i> and output to the channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_WideInt <i>offset</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>How far to move the access point in the channel at which
the next input or output operation will be applied, measured
in bytes from the position given by <i>seekMode</i>. May be
either positive or negative.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>seekMode</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Relative to which point to seek; used with <i>offset</i>
to calculate the new access point for the channel. Legal
values are <b>SEEK_SET</b>, <b>SEEK_CUR</b>, and
<b>SEEK_END</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_WideInt <i>length</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The (non-negative) length to truncate the channel the
channel to.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*optionName</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>The name of an option applicable to this channel, such
as <b>&minus;blocking</b>. May have any of the values
accepted by the <b>fconfigure</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_DString <i>*optionValue</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>Where to store the value of an option or a list of all
options and their values. Must have been initialized by the
caller.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*newValue</i> (in)</p></td>
<td width="14%"></td>
<td width="29%">


<p>New value for the option given by <i>optionName</i>.</p></td></tr>
</table>


<p style="margin-left:71%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Tcl channel
mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and
device types. The channel mechanism is extensible to new
channel types, by providing a low-level channel driver for
the new type; the channel driver interface is described in
the manual entry for <b>Tcl_CreateChannel</b>. The channel
mechanism provides a buffering scheme modeled after
Unix&rsquo;s standard I/O, and it also allows for
nonblocking I/O on channels.</p>

<p style="margin-left:11%; margin-top: 1em">The procedures
described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description
of the channel driver architecture and how to implement
channel drivers for new types of channels, see the manual
entry for <b>Tcl_CreateChannel</b>.</p>

<h2>TCL_OPENFILECHANNEL
<a name="TCL_OPENFILECHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_OpenFileChannel</b>
opens a file specified by <i>fileName</i> and returns a
channel handle that can be used to perform input and output
on the file. This API is modeled after the <b>fopen</b>
procedure of the Unix standard I/O library. The syntax and
meaning of all arguments is similar to those given in the
Tcl <b>open</b> command when opening a file. If an error
occurs while opening the channel, <b>Tcl_OpenFileChannel</b>
returns NULL and records a POSIX error code that can be
retrieved with <b>Tcl_GetErrno</b>. In addition, if
<i>interp</i> is non-NULL, <b>Tcl_OpenFileChannel</b> leaves
an error message in <i>interp</i>&rsquo;s result after any
error. As of Tcl 8.4, the object-based API
<b>Tcl_FSOpenFileChannel</b> should be used in preference to
<b>Tcl_OpenFileChannel</b> wherever possible.</p>

<p style="margin-left:11%; margin-top: 1em">The newly
created channel is not registered in the supplied
interpreter; to register it, use <b>Tcl_RegisterChannel</b>,
described below. If one of the standard channels, <b>stdin,
stdout</b> or <b>stderr</b> was previously closed, the act
of creating the new channel also assigns it as a replacement
for the standard channel.</p>

<h2>TCL_OPENCOMMANDCHANNEL
<a name="TCL_OPENCOMMANDCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_OpenCommandChannel</b>
provides a C-level interface to the functions of the
<b>exec</b> and <b>open</b> commands. It creates a sequence
of subprocesses specified by the <i>argv</i> and <i>argc</i>
arguments and returns a channel that can be used to
communicate with these subprocesses. The <i>flags</i>
argument indicates what sort of communication will exist
with the command pipeline.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>TCL_STDIN</b> flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the
channel will provide input to the subprocess. If
<b>TCL_STDIN</b> is not set, then standard input for the
first subprocess will be the same as this
application&rsquo;s standard input. If <b>TCL_STDOUT</b> is
set then standard output from the last subprocess can be
read from the channel; otherwise it goes to this
application&rsquo;s standard output. If <b>TCL_STDERR</b> is
set, standard error output for all subprocesses is returned
to the channel and results in an error when the channel is
closed; otherwise it goes to this application&rsquo;s
standard error. If <b>TCL_ENFORCE_MODE</b> is not set, then
<i>argc</i> and <i>argv</i> can redirect the stdio handles
to override <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and
<b>TCL_STDERR</b>; if it is set, then it is an error for
argc and argv to override stdio channels for which
<b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and <b>TCL_STDERR</b>
have been set.</p>

<p style="margin-left:11%; margin-top: 1em">If an error
occurs while opening the channel,
<b>Tcl_OpenCommandChannel</b> returns NULL and records a
POSIX error code that can be retrieved with
<b>Tcl_GetErrno</b>. In addition,
<b>Tcl_OpenCommandChannel</b> leaves an error message in the
interpreter&rsquo;s result if <i>interp</i> is not NULL.</p>

<p style="margin-left:11%; margin-top: 1em">The newly
created channel is not registered in the supplied
interpreter; to register it, use <b>Tcl_RegisterChannel</b>,
described below. If one of the standard channels, <b>stdin,
stdout</b> or <b>stderr</b> was previously closed, the act
of creating the new channel also assigns it as a replacement
for the standard channel.</p>

<h2>TCL_MAKEFILECHANNEL
<a name="TCL_MAKEFILECHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_MakeFileChannel</b>
makes a <b>Tcl_Channel</b> from an existing,
platform-specific, file handle. The newly created channel is
not registered in the supplied interpreter; to register it,
use <b>Tcl_RegisterChannel</b>, described below. If one of
the standard channels, <b>stdin, stdout</b> or <b>stderr</b>
was previously closed, the act of creating the new channel
also assigns it as a replacement for the standard
channel.</p>

<h2>TCL_GETCHANNEL
<a name="TCL_GETCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannel</b>
returns a channel given the <i>channelName</i> used to
create it with <b>Tcl_CreateChannel</b> and a pointer to a
Tcl interpreter in <i>interp</i>. If a channel by that name
is not registered in that interpreter, the procedure returns
NULL. If the <i>modePtr</i> argument is not NULL, it points
at an integer variable that will receive an OR-ed
combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>
describing whether the channel is open for reading and
writing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelNames</b>
and <b>Tcl_GetChannelNamesEx</b> write the names of the
registered channels to the interpreter&rsquo;s result as a
list object. <b>Tcl_GetChannelNamesEx</b> will filter these
names according to the <i>pattern</i>. If <i>pattern</i> is
NULL, then it will not do any filtering. The return value is
<b>TCL_OK</b> if no errors occurred writing to the result,
otherwise it is <b>TCL_ERROR</b>, and the error message is
left in the interpreter&rsquo;s result.</p>

<h2>TCL_REGISTERCHANNEL
<a name="TCL_REGISTERCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_RegisterChannel</b>
adds a channel to the set of channels accessible in
<i>interp</i>. After this call, Tcl programs executing in
that interpreter can refer to the channel in input or output
operations using the name given in the call to
<b>Tcl_CreateChannel</b>. After this call, the channel
becomes the property of the interpreter, and the caller
should not call <b>Tcl_Close</b> for the channel; the
channel will be closed automatically when it is unregistered
from the interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">Code executing
outside of any Tcl interpreter can call
<b>Tcl_RegisterChannel</b> with <i>interp</i> as NULL, to
indicate that it wishes to hold a reference to this channel.
Subsequently, the channel can be registered in a Tcl
interpreter and it will only be closed when the matching
number of calls to <b>Tcl_UnregisterChannel</b> have been
made. This allows code executing outside of any interpreter
to safely hold a reference to a channel that is also
registered in a Tcl interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">This procedure
interacts with the code managing the standard channels. If
no standard channels were initialized before the first call
to <b>Tcl_RegisterChannel</b>, they will get initialized by
that call. See <b>Tcl_StandardChannels</b> for a general
treatise about standard channels and the behaviour of the
Tcl library with regard to them.</p>

<h2>TCL_UNREGISTERCHANNEL
<a name="TCL_UNREGISTERCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UnregisterChannel</b>
removes a channel from the set of channels accessible in
<i>interp</i>. After this call, Tcl programs will no longer
be able to use the channel&rsquo;s name to refer to the
channel in that interpreter. If this operation removed the
last registration of the channel in any interpreter, the
channel is also closed and destroyed.</p>

<p style="margin-left:11%; margin-top: 1em">Code not
associated with a Tcl interpreter can call
<b>Tcl_UnregisterChannel</b> with <i>interp</i> as NULL, to
indicate to Tcl that it no longer holds a reference to that
channel. If this is the last reference to the channel, it
will now be closed. <b>Tcl_UnregisterChannel</b> is very
similar to <b>Tcl_DetachChannel</b> except that it will also
close the channel if no further references to it exist.</p>

<h2>TCL_DETACHCHANNEL
<a name="TCL_DETACHCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_DetachChannel</b>
removes a channel from the set of channels accessible in
<i>interp</i>. After this call, Tcl programs will no longer
be able to use the channel&rsquo;s name to refer to the
channel in that interpreter. Beyond that, this command has
no further effect. It cannot be used on the standard
channels (stdout, stderr, stdin), and will return
<b>TCL_ERROR</b> if passed one of those channels.</p>

<p style="margin-left:11%; margin-top: 1em">Code not
associated with a Tcl interpreter can call
<b>Tcl_DetachChannel</b> with <i>interp</i> as NULL, to
indicate to Tcl that it no longer holds a reference to that
channel. If this is the last reference to the channel,
unlike <b>Tcl_UnregisterChannel</b>, it will not be
closed.</p>

<h2>TCL_ISSTANDARDCHANNEL
<a name="TCL_ISSTANDARDCHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_IsStandardChannel</b>
tests whether a channel is one of the three standard
channels, stdin, stdout or stderr. If so, it returns 1,
otherwise 0.</p>

<p style="margin-left:11%; margin-top: 1em">No attempt is
made to check whether the given channel or the standard
channels are initialized or otherwise valid.</p>

<h2>TCL_CLOSE
<a name="TCL_CLOSE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Close</b>
destroys the channel <i>channel</i>, which must denote a
currently open channel. The channel should not be registered
in any interpreter when <b>Tcl_Close</b> is called. Buffered
output is flushed to the channel&rsquo;s output device prior
to destroying the channel, and any buffered input is
discarded. If this is a blocking channel, the call does not
return until all buffered data is successfully sent to the
channel&rsquo;s output device. If this is a nonblocking
channel and there is buffered output that cannot be written
without blocking, the call returns immediately; output is
flushed in the background and the channel will be closed
once all of the buffered data has been output. In this case
errors during flushing are not reported.</p>

<p style="margin-left:11%; margin-top: 1em">If the channel
was closed successfully, <b>Tcl_Close</b> returns
<b>TCL_OK</b>. If an error occurs, <b>Tcl_Close</b> returns
<b>TCL_ERROR</b> and records a POSIX error code that can be
retrieved with <b>Tcl_GetErrno</b>. If the channel is being
closed synchronously and an error occurs during closing of
the channel and <i>interp</i> is not NULL, an error message
is left in the interpreter&rsquo;s result.</p>

<p style="margin-left:11%; margin-top: 1em">Note: it is not
safe to call <b>Tcl_Close</b> on a channel that has been
registered using <b>Tcl_RegisterChannel</b>; see the
documentation for <b>Tcl_RegisterChannel</b>, above, for
details. If the channel has ever been given as the
<b>chan</b> argument in a call to
<b>Tcl_RegisterChannel</b>, you should instead use
<b>Tcl_UnregisterChannel</b>, which will internally call
<b>Tcl_Close</b> when all calls to
<b>Tcl_RegisterChannel</b> have been matched by
corresponding calls to <b>Tcl_UnregisterChannel</b>.</p>

<h2>TCL_READCHARS AND TCL_READ
<a name="TCL_READCHARS AND TCL_READ"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ReadChars</b>
consumes bytes from <i>channel</i>, converting the bytes to
UTF-8 based on the channel&rsquo;s encoding and storing the
produced data in <i>readObjPtr</i>&rsquo;s string
representation. The return value of <b>Tcl_ReadChars</b> is
the number of characters, up to <i>charsToRead</i>, that
were stored in <i>readObjPtr</i>. If an error occurs while
reading, the return value is &minus;1 and
<b>Tcl_ReadChars</b> records a POSIX error code that can be
retrieved with <b>Tcl_GetErrno</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Setting
<i>charsToRead</i> to <b>&minus;1</b> will cause the command
to read all characters currently available (non-blocking) or
everything until eof (blocking mode).</p>

<p style="margin-left:11%; margin-top: 1em">The return
value may be smaller than the value to read, indicating that
less data than requested was available. This is called a
<i>short read</i>. In blocking mode, this can only happen on
an end-of-file. In nonblocking mode, a short read can also
occur if there is not enough input currently available:
<b>Tcl_ReadChars</b> returns a short count rather than
waiting for more data.</p>

<p style="margin-left:11%; margin-top: 1em">If the channel
is in blocking mode, a return value of zero indicates an
end-of-file condition. If the channel is in nonblocking
mode, a return value of zero indicates either that no input
is currently available or an end-of-file condition. Use
<b>Tcl_Eof</b> and <b>Tcl_InputBlocked</b> to tell which of
these conditions actually occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ReadChars</b>
translates the various end-of-line representations into the
canonical <b>\n</b> internal representation according to the
current end-of-line recognition mode. End-of-line
recognition and the various platform-specific modes are
described in the manual entry for the Tcl <b>fconfigure</b>
command.</p>

<p style="margin-left:11%; margin-top: 1em">As a
performance optimization, when reading from a channel with
the encoding <b>binary</b>, the bytes are not converted to
UTF-8 as they are read. Instead, they are stored in
<i>readObjPtr</i>&rsquo;s internal representation as a
byte-array object. The string representation of this object
will only be constructed if it is needed (e.g., because of a
call to <b>Tcl_GetStringFromObj</b>). In this way,
byte-oriented data can be read from a channel, manipulated
by calling <b>Tcl_GetByteArrayFromObj</b> and related
functions, and then written to a channel without the expense
of ever converting to or from UTF-8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Read</b>
is similar to <b>Tcl_ReadChars</b>, except that it does not
do encoding conversions, regardless of the channel&rsquo;s
encoding. It is deprecated and exists for backwards
compatibility with non-internationalized Tcl extensions. It
consumes bytes from <i>channel</i> and stores them in
<i>readBuf</i>, performing end-of-line translations on the
way. The return value of <b>Tcl_Read</b> is the number of
bytes, up to <i>bytesToRead</i>, written in <i>readBuf</i>.
The buffer produced by <b>Tcl_Read</b> is not
null-terminated. Its contents are valid from the zeroth
position up to and excluding the position indicated by the
return value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ReadRaw</b>
is the same as <b>Tcl_Read</b> but does not compensate for
stacking. While <b>Tcl_Read</b> (and the other functions in
the API) always get their data from the topmost channel in
the stack the supplied channel is part of,
<b>Tcl_ReadRaw</b> does not. Thus this function is
<b>only</b> usable for transformational channel drivers,
i.e. drivers used in the middle of a stack of channels, to
move data from the channel below into the
transformation.</p>

<h2>TCL_GETSOBJ AND TCL_GETS
<a name="TCL_GETSOBJ AND TCL_GETS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetsObj</b>
consumes bytes from <i>channel</i>, converting the bytes to
UTF-8 based on the channel&rsquo;s encoding, until a full
line of input has been seen. If the channel&rsquo;s encoding
is <b>binary</b>, each byte read from the channel is treated
as an individual Unicode character. All of the characters of
the line except for the terminating end-of-line character(s)
are appended to <i>lineObjPtr</i>&rsquo;s string
representation. The end-of-line character(s) are read and
discarded.</p>

<p style="margin-left:11%; margin-top: 1em">If a line was
successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in
<i>lineObjPtr</i>. If an error occurs, <b>Tcl_GetsObj</b>
returns &minus;1 and records a POSIX error code that can be
retrieved with <b>Tcl_GetErrno</b>. <b>Tcl_GetsObj</b> also
returns &minus;1 if the end of the file is reached; the
<b>Tcl_Eof</b> procedure can be used to distinguish an error
from an end-of-file condition.</p>

<p style="margin-left:11%; margin-top: 1em">If the channel
is in nonblocking mode, the return value can also be
&minus;1 if no data was available or the data that was
available did not contain an end-of-line character. When
&minus;1 is returned, the <b>Tcl_InputBlocked</b> procedure
may be invoked to determine if the channel is blocked
because of input unavailability.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Gets</b>
is the same as <b>Tcl_GetsObj</b> except the resulting
characters are appended to the dynamic string given by
<i>lineRead</i> rather than a Tcl object.</p>

<h2>TCL_UNGETS
<a name="TCL_UNGETS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Ungets</b>
is used to add data to the input queue of a channel, at
either the head or tail of the queue. The pointer
<i>input</i> points to the data that is to be added. The
length of the input to add is given by <i>inputLen</i>. A
non-zero value of <i>addAtEnd</i> indicates that the data is
to be added at the end of queue; otherwise it will be added
at the head of the queue. If <i>channel</i> has a
&ldquo;sticky&rdquo; EOF set, no data will be added to the
input queue. <b>Tcl_Ungets</b> returns <i>inputLen</i> or
&minus;1 if an error occurs.</p>

<h2>TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE
<a name="TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_WriteChars</b>
accepts <i>bytesToWrite</i> bytes of character data at
<i>charBuf</i>. The UTF-8 characters in the buffer are
converted to the channel&rsquo;s encoding and queued for
output to <i>channel</i>. If <i>bytesToWrite</i> is
negative, <b>Tcl_WriteChars</b> expects <i>charBuf</i> to be
null-terminated and it outputs everything up to the
null.</p>

<p style="margin-left:11%; margin-top: 1em">Data queued for
output may not appear on the output device immediately, due
to internal buffering. If the data should appear
immediately, call <b>Tcl_Flush</b> after the call to
<b>Tcl_WriteChars</b>, or set the <b>&minus;buffering</b>
option on the channel to <b>none</b>. If you wish the data
to appear as soon as a complete line is accepted for output,
set the <b>&minus;buffering</b> option on the channel to
<b>line</b> mode.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value of <b>Tcl_WriteChars</b> is a count of how many bytes
were accepted for output to the channel. This is either
greater than zero to indicate success or &minus;1 to
indicate that an error occurred. If an error occurs,
<b>Tcl_WriteChars</b> records a POSIX error code that may be
retrieved with <b>Tcl_GetErrno</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Newline
characters in the output data are translated to
platform-specific end-of-line sequences according to the
<b>&minus;translation</b> option for the channel. This is
done even if the channel has no encoding.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_WriteObj</b>
is similar to <b>Tcl_WriteChars</b> except it accepts a Tcl
object whose contents will be output to the channel. The
UTF-8 characters in <i>writeObjPtr</i>&rsquo;s string
representation are converted to the channel&rsquo;s encoding
and queued for output to <i>channel</i>. As a performance
optimization, when writing to a channel with the encoding
<b>binary</b>, UTF-8 characters are not converted as they
are written. Instead, the bytes in
<i>writeObjPtr</i>&rsquo;s internal representation as a
byte-array object are written to the channel. The byte-array
representation of the object will be constructed if it is
needed. In this way, byte-oriented data can be read from a
channel, manipulated by calling
<b>Tcl_GetByteArrayFromObj</b> and related functions, and
then written to a channel without the expense of ever
converting to or from UTF-8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Write</b>
is similar to <b>Tcl_WriteChars</b> except that it does not
do encoding conversions, regardless of the channel&rsquo;s
encoding. It is deprecated and exists for backwards
compatibility with non-internationalized Tcl extensions. It
accepts <i>bytesToWrite</i> bytes of data at <i>byteBuf</i>
and queues them for output to <i>channel</i>. If
<i>bytesToWrite</i> is negative, <b>Tcl_Write</b> expects
<i>byteBuf</i> to be null-terminated and it outputs
everything up to the null.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_WriteRaw</b>
is the same as <b>Tcl_Write</b> but does not compensate for
stacking. While <b>Tcl_Write</b> (and the other functions in
the API) always feed their input to the topmost channel in
the stack the supplied channel is part of,
<b>Tcl_WriteRaw</b> does not. Thus this function is
<b>only</b> usable for transformational channel drivers,
i.e. drivers used in the middle of a stack of channels, to
move data from the transformation into the channel below
it.</p>

<h2>TCL_FLUSH
<a name="TCL_FLUSH"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Flush</b>
causes all of the buffered output data for <i>channel</i> to
be written to its underlying file or device as soon as
possible. If the channel is in blocking mode, the call does
not return until all the buffered data has been sent to the
channel or some error occurred. The call returns immediately
if the channel is nonblocking; it starts a background flush
that will write the buffered data to the channel eventually,
as fast as the channel is able to absorb it.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is normally <b>TCL_OK</b>. If an error occurs,
<b>Tcl_Flush</b> returns <b>TCL_ERROR</b> and records a
POSIX error code that can be retrieved with
<b>Tcl_GetErrno</b>.</p>

<h2>TCL_SEEK
<a name="TCL_SEEK"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Seek</b>
moves the access point in <i>channel</i> where subsequent
data will be read or written. Buffered output is flushed to
the channel and buffered input is discarded, prior to the
seek operation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Seek</b>
normally returns the new access point. If an error occurs,
<b>Tcl_Seek</b> returns &minus;1 and records a POSIX error
code that can be retrieved with <b>Tcl_GetErrno</b>. After
an error, the access point may or may not have been
moved.</p>

<h2>TCL_TELL
<a name="TCL_TELL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Tell</b>
returns the current access point for a channel. The returned
value is &minus;1 if the channel does not support
seeking.</p>

<h2>TCL_TRUNCATECHANNEL
<a name="TCL_TRUNCATECHANNEL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_TruncateChannel</b>
truncates the file underlying <i>channel</i> to a given
<big>&#9474;</big> <i>length</i> of bytes. It returns
<b>TCL_OK</b> if the operation succeeded, and
<big>&#9474;</big> <b>TCL_ERROR</b> otherwise.</p>

<h2>TCL_GETCHANNELOPTION
<a name="TCL_GETCHANNELOPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelOption</b>
retrieves, in <i>optionValue</i>, the value of one of the
options currently in effect for a channel, or a list of all
options and their values. The <i>channel</i> argument
identifies the channel for which to query an option or
retrieve all options and their values. If <i>optionName</i>
is not NULL, it is the name of the option to query; the
option&rsquo;s value is copied to the Tcl dynamic string
denoted by <i>optionValue</i>. If <i>optionName</i> is NULL,
the function stores an alternating list of option names and
their values in <i>optionValue</i>, using a series of calls
to <b>Tcl_DStringAppendElement</b>. The various preexisting
options and their possible values are described in the
manual entry for the Tcl <b>fconfigure</b> command. Other
options can be added by each channel type. These channel
type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for
example, the additional options for TCP based channels are
described in the manual entry for the Tcl <b>socket</b>
command. The procedure normally returns <b>TCL_OK</b>. If an
error occurs, it returns <b>TCL_ERROR</b> and calls
<b>Tcl_SetErrno</b> to store an appropriate POSIX error
code.</p>

<h2>TCL_SETCHANNELOPTION
<a name="TCL_SETCHANNELOPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SetChannelOption</b>
sets a new value <i>newValue</i> for an option
<i>optionName</i> on <i>channel</i>. The procedure normally
returns <b>TCL_OK</b>. If an error occurs, it returns
<b>TCL_ERROR</b>; in addition, if <i>interp</i> is non-NULL,
<b>Tcl_SetChannelOption</b> leaves an error message in the
interpreter&rsquo;s result.</p>

<h2>TCL_EOF
<a name="TCL_EOF"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Eof</b>
returns a nonzero value if <i>channel</i> encountered an end
of file during the last input operation.</p>

<h2>TCL_INPUTBLOCKED
<a name="TCL_INPUTBLOCKED"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InputBlocked</b>
returns a nonzero value if <i>channel</i> is in nonblocking
mode and the last input operation returned less data than
requested because there was insufficient data available. The
call always returns zero if the channel is in blocking
mode.</p>

<h2>TCL_INPUTBUFFERED
<a name="TCL_INPUTBUFFERED"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_InputBuffered</b>
returns the number of bytes of input currently buffered in
the internal buffers for a channel. If the channel is not
open for reading, this function always returns zero.</p>

<h2>TCL_OUTPUTBUFFERED
<a name="TCL_OUTPUTBUFFERED"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_OutputBuffered</b>
returns the number of bytes of output currently buffered in
the internal buffers for a channel. If the channel is not
open for writing, this function always returns zero.</p>

<h2>PLATFORM ISSUES
<a name="PLATFORM ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The handles
returned from <b>Tcl_GetChannelHandle</b> depend on the
platform and the channel type. On Unix platforms, the handle
is always a Unix file descriptor as returned from the
<b>open</b> system call. On Windows platforms, the handle is
a file <b>HANDLE</b> when the channel was created with
<b>Tcl_OpenFileChannel</b>, <b>Tcl_OpenCommandChannel</b>,
or <b>Tcl_MakeFileChannel</b>. Other channel types may
return a different type of handle on Windows platforms.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DString(3),
fconfigure(n), filename(n), fopen(3),
Tcl_CreateChannel(3)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">access point,
blocking, buffered I/O, channel, channel driver, end of
file, flush, input, nonblocking, output, read, seek,
write</p>
<hr>
</body>
</html>
