<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:01:46 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IOCTL_LIST</title>

</head>
<body>

<h1 align="center">IOCTL_LIST</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ioctl_list
&minus; list of ioctl calls in Linux/i386 kernel</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is Ioctl
List 1.3.27, a list of ioctl calls in Linux/i386 kernel
1.3.27. It contains 421 ioctls from
<i>&lt;/usr/include/{asm,linux}/*.h&gt;</i>. For each ioctl,
its numerical value, its name, and its argument type are
given.</p>

<p style="margin-left:11%; margin-top: 1em">An argument
type of <i>const struct foo&nbsp;*</i> means the argument is
input to the kernel. <i>struct foo&nbsp;*</i> means the
kernel outputs the argument. If the kernel uses the argument
for both input and output, this is marked with
<i>//&nbsp;I-O</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Some ioctls
take more arguments or return more values than a single
structure. These are marked <i>//&nbsp;MORE</i> and
documented further in a separate section.</p>

<p style="margin-left:11%; margin-top: 1em">This list is
very incomplete.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ioctl
structure</b> <br>
Ioctl command values are 32-bit constants. In principle
these constants are completely arbitrary, but people have
tried to build some structure into them.</p>

<p style="margin-left:11%; margin-top: 1em">The old Linux
situation was that of mostly 16-bit constants, where the
last byte is a serial number, and the preceding byte(s) give
a type indicating the driver. Sometimes the major number was
used: 0x03 for the <b>HDIO_*</b> ioctls, 0x06 for the
<b>LP*</b> ioctls. And sometimes one or more ASCII letters
were used. For example, <b>TCGETS</b> has value 0x00005401,
with 0x54 = 'T' indicating the terminal driver, and
<b>CYGETTIMEOUT</b> has value 0x00435906, with 0x43 0x59 =
'C' 'Y' indicating the cyclades driver.</p>

<p style="margin-left:11%; margin-top: 1em">Later (0.98p5)
some more information was built into the number. One has 2
direction bits (00: none, 01: write, 10: read, 11:
read/write) followed by 14 size bits (giving the size of the
argument), followed by an 8-bit type (collecting the ioctls
in groups for a common purpose or a common driver), and an
8-bit serial number.</p>

<p style="margin-left:11%; margin-top: 1em">The macros
describing this structure live in <i>&lt;asm/ioctl.h&gt;</i>
and are <b>_IO(type,nr)</b> and
<b>{_IOR,_IOW,_IOWR}(type,nr,size)</b>. They use
<i>sizeof(size)</i> so that size is a misnomer here: this
third argument is a data type.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
size bits are very unreliable: in lots of cases they are
wrong, either because of buggy macros using
<i>sizeof(sizeof(struct))</i>, or because of legacy
values.</p>

<p style="margin-left:11%; margin-top: 1em">Thus, it seems
that the new structure only gave disadvantages: it does not
help in checking, but it causes varying values for the
various architectures.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Decent ioctls
return 0 on success and &minus;1 on error, while any output
value is stored via the argument. However, quite a few
ioctls in fact return an output value. This is not yet
indicated below.</p>

<p style="margin-left:11%; margin-top: 1em">// Main
table.</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/asm-i386/socket.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/asm-i386/termios.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/ax25.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/cdk.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/cdrom.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/cm206.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/cyclades.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/ext2_fs.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/fd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/fs.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/hdreg.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/if_eql.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/if_plip.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/if_ppp.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/ipx.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/kd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/lp.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/mroute.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/mtio.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/netrom.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/sbpcd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/scc.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/scsi.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/smb_fs.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/sockios.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/soundcard.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/umsdos_fs.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">//
&lt;include/linux/vt.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">// More
arguments. Some ioctl&rsquo;s take a pointer to a structure
which contains additional pointers. These are documented
here in alphabetical order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CDROMREADAUDIO</b>
takes an input pointer <i>const struct
cdrom_read_audio&nbsp;*</i>. The <i>buf</i> field points to
an output buffer of length <i>nframes&nbsp;*
CD_FRAMESIZE_RAW</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CDROMREADCOOKED</b>,
<b>CDROMREADMODE1</b>, <b>CDROMREADMODE2</b>, and
<b>CDROMREADRAW</b> take an input pointer <i>const struct
cdrom_msf&nbsp;*</i>. They use the same pointer as an output
pointer to <i>char []</i>. The length varies by request. For
<b>CDROMREADMODE1</b>, most drivers use CD_FRAMESIZE, but
the Optics Storage driver uses OPT_BLOCKSIZE instead (both
have the numerical value 2048).</p>


<p style="margin-left:11%; margin-top: 1em">CDROMREADCOOKED
char [CD_FRAMESIZE] <br>
CDROMREADMODE1 char [CD_FRAMESIZE or OPT_BLOCKSIZE] <br>
CDROMREADMODE2 char [CD_FRAMESIZE_RAW0] <br>
CDROMREADRAW char [CD_FRAMESIZE_RAW]</p>


<p style="margin-left:11%; margin-top: 1em"><b>EQL_ENSLAVE</b>,
<b>EQL_EMANCIPATE</b>, <b>EQL_GETSLAVECFG</b>,
<b>EQL_SETSLAVECFG</b>, <b>EQL_GETMASTERCFG</b>, and
<b>EQL_SETMASTERCFG</b> take a <i>struct ifreq&nbsp;*</i>.
The <i>ifr_data</i> field is a pointer to another structure
as follows:</p>

<p style="margin-left:11%; margin-top: 1em">EQL_ENSLAVE
const struct slaving_request * <br>
EQL_EMANCIPATE const struct slaving_request * <br>
EQL_GETSLAVECFG struct slave_config * // I-O <br>
EQL_SETSLAVECFG const struct slave_config * <br>
EQL_GETMASTERCFG struct master_config * <br>
EQL_SETMASTERCFG const struct master_config *</p>


<p style="margin-left:11%; margin-top: 1em"><b>FDRAWCMD</b>
takes a <i>struct floppy raw_cmd&nbsp;*</i>. If <i>flags
&amp; FD_RAW_WRITE</i> is nonzero, then <i>data</i> points
to an input buffer of length <i>length</i>. If <i>flags
&amp; FD_RAW_READ</i> is nonzero, then <i>data</i> points to
an output buffer of length <i>length</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GIO_FONTX</b>
and <b>PIO_FONTX</b> take a <i>struct
console_font_desc&nbsp;*</i> or a <i>const struct
console_font_desc&nbsp;*</i>, respectively. <i>chardata</i>
points to a buffer of <i>char [charcount]</i>. This is an
output buffer for <b>GIO_FONTX</b> and an input buffer for
<b>PIO_FONTX</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GIO_UNIMAP</b>
and <b>PIO_UNIMAP</b> take a <i>struct unimapdesc&nbsp;*</i>
or a <i>const struct unimapdesc&nbsp;*</i>, respectively.
<i>entries</i> points to a buffer of <i>struct unipair
[entry_ct]</i>. This is an output buffer for
<b>GIO_UNIMAP</b> and an input buffer for
<b>PIO_UNIMAP</b>.</p>

<p style="margin-left:11%; margin-top: 1em">KDADDIO,
KDDELIO, KDDISABIO, and KDENABIO enable or disable access to
I/O ports. They are essentially alternate interfaces to
&rsquo;ioperm&rsquo;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>KDMAPDISP</b>
and <b>KDUNMAPDISP</b> enable or disable memory mappings or
I/O port access. They are not implemented in the kernel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SCSI_IOCTL_PROBE_HOST</b>
takes an input pointer <i>const int&nbsp;*</i>, which is a
length. It uses the same pointer as an output pointer to a
<i>char []</i> buffer of this length.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SIOCADDRT</b>
and <b>SIOCDELRT</b> take an input pointer whose type
depends on the protocol:</p>

<p style="margin-left:11%; margin-top: 1em">Most protocols
const struct rtentry * <br>
AX.25 const struct ax25_route * <br>
NET/ROM const struct nr_route_struct *</p>


<p style="margin-left:11%; margin-top: 1em"><b>SIOCGIFCONF</b>
takes a <i>struct ifconf&nbsp;*</i>. The <i>ifc_buf</i>
field points to a buffer of length <i>ifc_len</i> bytes,
into which the kernel writes a list of type <i>struct ifreq
[]</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SIOCSIFHWADDR</b>
takes an input pointer whose type depends on the
protocol:</p>

<p style="margin-left:11%; margin-top: 1em">Most protocols
const struct ifreq * <br>
AX.25 const char [AX25_ADDR_LEN]</p>


<p style="margin-left:11%; margin-top: 1em"><b>TIOCLINUX</b>
takes a <i>const char&nbsp;*</i>. It uses this to
distinguish several independent subcases. In the table
below, <i>N + foo</i> means <i>foo</i> after an N-byte pad.
<i>struct selection</i> is implicitly defined in
<i>drivers/char/selection.c</i></p>

<p style="margin-left:11%; margin-top: 1em">TIOCLINUX-2 1 +
const struct selection * <br>
TIOCLINUX-3 void <br>
TIOCLINUX-4 void <br>
TIOCLINUX-5 4 + const struct { long [8]; } * <br>
TIOCLINUX-6 char * <br>
TIOCLINUX-7 char * <br>
TIOCLINUX-10 1 + const char *</p>

<p style="margin-left:11%; margin-top: 1em">// Duplicate
ioctls</p>

<p style="margin-left:11%; margin-top: 1em">This list does
not include ioctls in the range <b>SIOCDEVPRIVATE</b> and
<b>SIOCPROTOPRIVATE</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ioctl</b>(2)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
