<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:25:41 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>xfs_db</title>

</head>
<body>

<h1 align="center">xfs_db</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#CONCEPTS">CONCEPTS</a><br>
<a href="#COMMANDS">COMMANDS</a><br>
<a href="#TYPES">TYPES</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">xfs_db &minus;
debug an XFS filesystem</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xfs_db</b> [
<b>&minus;c</b> <i>cmd</i> ] ... [
<b>&minus;i</b>|<b>r</b>|<b>x</b>|<b>F</b> ] [
<b>&minus;f</b> ] [ <b>&minus;l</b> <i>logdev</i> ] [
<b>&minus;p</b> <i>progname</i> ] <i>device</i> <b><br>
xfs_db &minus;V</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xfs_db</b>
is used to examine an XFS filesystem. Under rare
circumstances it can also be used to modify an XFS
filesystem, but that task is normally left to
<b>xfs_repair</b>(8) or to scripts such as
<b>xfs_admin</b>(8) that run <b>xfs_db</b>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&minus;c</b> <i>cmd</i></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><b>xfs_db</b> commands may be
run interactively (the default) or as arguments on the
command line. Multiple <b>&minus;c</b> arguments may be
given. The commands are run in the sequence given, then the
program exits.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;f</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Specifies that the filesystem image to be processed is
stored in a regular file at <i>device</i> (see the
<b>mkfs.xfs</b>(8) <b>-d</b> <i>file</i> option). This might
happen if an image copy of a filesystem has been made into
an ordinary file with <b>xfs_copy</b>(8).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;F</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Specifies that we want to continue even if the
superblock magic is not correct. For use in
<b>xfs_metadump</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;i</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Allows execution on a mounted filesystem, provided it is
mounted read-only. Useful for shell scripts which must only
operate on filesystems in a guaranteed consistent state
(either unmounted or mounted read-only). These semantics are
slightly different to that of the <b>-r</b> option.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;l</b>
<i>logdev</i></p>

<p style="margin-left:22%;">Specifies the device where the
filesystems external log resides. Only for those filesystems
which use an external log. See the <b>mkfs.xfs</b>(8)
<b>&minus;l</b> option, and refer to <b>xfs</b>(5) for a
detailed description of the XFS log.</p>

<p style="margin-left:11%;"><b>&minus;p</b>
<i>progname</i></p>

<p style="margin-left:22%;">Set the program name to
<i>progname</i> for prompts and some error messages, the
default value is <b>xfs_db</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-r</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Open <i>device</i> or <i>filename</i> read-only. This
option is required if the filesystem is mounted. It is only
necessary to omit this flag if a command that changes data
(<b>write</b>, <b>blocktrash</b>) is to be used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;x</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Specifies expert mode. This enables the <b>write</b> and
<b>blocktrash</b> commands.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Prints the version number and exits.</p></td></tr>
</table>

<h2>CONCEPTS
<a name="CONCEPTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xfs_db</b>
commands can be broken up into two classes. Most commands
are for the navigation and display of data structures in the
filesystem. Other commands are for scanning the filesystem
in some way.</p>

<p style="margin-left:11%; margin-top: 1em">Commands which
are used to navigate the filesystem structure take arguments
which reflect the names of filesystem structure fields.
There can be multiple field names separated by dots when the
underlying structures are nested, as in C. The field names
can be indexed (as an array index) if the underlying field
is an array. The array indices can be specified as a range,
two numbers separated by a dash.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xfs_db</b>
maintains a current address in the filesystem. The
granularity of the address is a filesystem structure. This
can be a filesystem block, an inode or quota (smaller than a
filesystem block), or a directory block (could be larger
than a filesystem block). There are a variety of commands to
set the current address. Associated with the current address
is the current data type, which is the structural type of
this data. Commands which follow the structure of the
filesystem always set the type as well as the address.
Commands which examine pieces of an individual file (inode)
need the current inode to be set, this is done with the
<b>inode</b> command.</p>

<p style="margin-left:11%; margin-top: 1em">The current
address/type information is actually maintained in a stack
that can be explicitly manipulated with the <b>push</b>,
<b>pop</b>, and <b>stack</b> commands. This allows for easy
examination of a nested filesystem structure. Also, the last
several locations visited are stored in a ring buffer which
can be manipulated with the <b>forward</b>, <b>back</b>, and
<b>ring</b> commands.</p>

<p style="margin-left:11%; margin-top: 1em">XFS filesystems
are divided into a small number of allocation groups.
<b>xfs_db</b> maintains a notion of the current allocation
group which is manipulated by some commands. The initial
allocation group is 0.</p>

<h2>COMMANDS
<a name="COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many commands
have extensive online help. Use the <b>help</b> command for
more details on any command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>a</b></p></td>
<td width="10%"></td>
<td width="32%">


<p style="margin-top: 1em">See the <b>addr</b> command.</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ablock</b> <i>filoff</i></p>

<p style="margin-left:22%;">Set current address to the
offset <i>filoff</i> (a filesystem block number) in the
attribute area of the current inode.</p>

<p style="margin-left:11%;"><b>addr
[</b><i>field-expression</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the
value of the <i>field-expression</i>. This is used to
&quot;follow&quot; a reference in one structure to the
object being referred to. If no argument is given, the
current address is printed.</p>

<p style="margin-left:11%;"><b>agf
[</b><i>agno</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the AGF
block for allocation group <i>agno</i>. If no argument is
given, use the current allocation group.</p>

<p style="margin-left:11%;"><b>agfl
[</b><i>agno</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the AGFL
block for allocation group <i>agno</i>. If no argument is
given, use the current allocation group.</p>

<p style="margin-left:11%;"><b>agi
[</b><i>agno</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the AGI
block for allocation group <i>agno</i>. If no argument is
given, use the current allocation group.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>b</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>See the <b>back</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>back</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Move to the previous location in the position ring.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>blockfree</b></p>

<p style="margin-left:22%;">Free block usage information
collected by the last execution of the <b>blockget</b>
command. This must be done before another <b>blockget</b>
command can be given, presumably with different arguments
than the previous one.</p>

<p style="margin-left:11%;"><b>blockget [&minus;npvs]
[&minus;b</b> <i>bno</i><b>] ... [&minus;i</b>
<i>ino</i><b>] ...</b></p>

<p style="margin-left:22%;">Get block usage and check
filesystem consistency. The information is saved for use by
a subsequent <b>blockuse</b>, <b>ncheck</b>, or
<b>blocktrash</b> command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;b</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>is used to specify filesystem block numbers about which
verbose information should be printed.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;i</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>is used to specify inode numbers about which verbose
information should be printed.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>is used to save pathnames for inodes visited, this is
used to support the <b>xfs_ncheck</b>(8) command. It also
means that pathnames will be printed for inodes that have
problems. This option uses a lot of memory so is not enabled
by default.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;p</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>causes error messages to be prefixed with the filesystem
name being processed. This is useful if several copies of
<b>xfs_db</b> are run in parallel.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;s</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>restricts output to severe errors only. This is useful
if the output is too long otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables verbose output. Messages will be printed for
every block and inode processed.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>blocktrash [&minus;n</b>
<i>count</i><b>] [&minus;x</b> <i>min</i><b>] [&minus;y</b>
<i>max</i><b>] [&minus;s</b> <i>seed</i><b>]
[&minus;0|1|2|3] [&minus;t</b> <i>type</i><b>] <br>
...</b></p>

<p style="margin-left:22%;">Trash randomly selected
filesystem metadata blocks. Trashing occurs to randomly
selected bits in the chosen blocks. This command is
available only in debugging versions of <b>xfs_db</b>. It is
useful for testing <b>xfs_repair</b>(8).</p>

<p style="margin-left:26%;"><b>&minus;0</b> | <b>-1</b> |
<b>-2</b> | <b>-3</b></p>

<p style="margin-left:32%;">These are used to set the
operating mode for <b>blocktrash</b>. Only one can be used:
<b>&minus;0</b> changed bits are cleared; <b>&minus;1</b>
changed bits are set; <b>-2</b> changed bits are inverted;
<b>-3</b> changed bits are randomized.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>supplies the <i>count</i> of block-trashings to perform
(default 1).</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;s</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>supplies a <i>seed</i> to the random processing.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;t</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>gives a <i>type</i> of blocks to be selected for
trashing. Multiple <b>&minus;t</b> options may be given. If
no <b>&minus;t</b> options are given then all metadata types
can be trashed.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;x</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>sets the <i>minimum</i> size of bit range to be trashed.
The default value is 1.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;y</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>sets the <i>maximum</i> size of bit range to be trashed.
The default value is 1024.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>blockuse [&minus;n]
[&minus;c</b> <i>count</i><b>]</b></p>

<p style="margin-left:22%;">Print usage for current
filesystem block(s). For each block, the type and (if any)
inode are printed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies a <i>count</i> of blocks to process. The
default value is 1 (the current block only).</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that file names should be printed. The prior
<b>blockget</b> command must have also specified the
<b>&minus;n</b> option.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>bmap [&minus;a] [&minus;d]
[</b><i>block</i> <b>[</b><i>len</i><b>]]</b></p>

<p style="margin-left:22%;">Show the block map for the
current inode. The map display can be restricted to an area
of the file with the <i>block</i> and <i>len</i> arguments.
If <i>block</i> is given and <i>len</i> is omitted then 1 is
assumed for len.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>&minus;a</b> and <b>&minus;d</b> options are used to
select the attribute or data area of the inode, if neither
option is given then both areas are shown.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>check</b></p></td>
<td width="4%"></td>
<td width="38%">


<p>See the <b>blockget</b> command.</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>convert</b> <i>type
number</i> <b>[</b><i>type number</i><b>] ...</b>
<i>type</i></p>

<p style="margin-left:22%;">Convert from one address form
to another. The known <i>type</i>s, with alternate names,
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="11%">


<p><b>agblock</b></p></td>
<td width="63%">


<p>or <b>agbno</b> (filesystem block within an allocation
group)</p> </td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="11%">


<p><b>agino</b></p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:26%;">or <b>aginode</b> (inode number
within an allocation group)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="12%">


<p><b>agnumber</b></p></td>
<td width="2%"></td>
<td width="51%">


<p>or <b>agno</b> (allocation group number)</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="12%">


<p><b>bboff</b></p></td>
<td width="2%"></td>
<td width="51%"></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:26%;">or <b>daddroff</b> (byte offset
in a <b>daddr</b>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="9%">


<p><b>blkoff</b></p></td>
<td width="2%"></td>
<td width="63%">


<p>or <b>fsboff or agboff</b> (byte offset in a
<b>agblock</b> or <b>fsblock</b>)</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="9%">


<p><b>byte</b></p></td>
<td width="2%"></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:26%;">or <b>fsbyte</b> (byte address
in filesystem)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="8%">


<p><b>daddr</b></p></td>
<td width="1%"></td>
<td width="57%">


<p>or <b>bb</b> (disk address, 512-byte blocks)</p></td>
<td width="8%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="5%">


<p><b>fsblock</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>or <b>fsb</b> or <b>fsbno</b> (filesystem block, see the
<b>fsblock</b> command)</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="5%">


<p><b>ino</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>or <b>inode</b> (inode number)</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="9%">


<p><b>inoidx</b></p></td>
<td width="2%"></td>
<td width="63%">


<p>or <b>offset</b> (index of inode in filesystem
block)</p> </td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="9%">


<p><b>inooff</b></p></td>
<td width="2%"></td>
<td width="63%">


<p>or <b>inodeoff</b> (byte offset in inode)</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Only
conversions that &quot;make sense&quot; are allowed. The
compound form (with more than three arguments) is useful for
conversions such as <b>convert agno</b> <i>ag</i>
<b>agbno</b> <i>agb</i> <b>fsblock</b>.</p>

<p style="margin-left:11%;"><b>daddr
[</b><i>d</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the
daddr (512 byte block) given by <i>d</i>. If no value for
<i>d</i> is given, the current address is printed, expressed
as a daddr. The type is set to <b>data</b>
(uninterpreted).</p>

<p style="margin-left:11%;"><b>dblock</b> <i>filoff</i></p>

<p style="margin-left:22%;">Set current address to the
offset <i>filoff</i> (a filesystem block number) in the data
area of the current inode.</p>

<p style="margin-left:11%;"><b>debug
[</b><i>flagbits</i><b>]</b></p>

<p style="margin-left:22%;">Set debug option bits. These
are used for debugging <b>xfs_db</b>. If no value is given
for <i>flagbits</i>, print the current debug option bits.
These are for the use of the implementor.</p>

<p style="margin-left:11%;"><b>dquot
[</b><i>projectid_or_userid</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to a
project or user quota block.</p>

<p style="margin-left:11%;"><b>echo [</b><i>arg</i><b>]
...</b></p>

<p style="margin-left:22%;">Echo the arguments to the
output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>f</b></p></td>
<td width="10%"></td>
<td width="36%">


<p>See the <b>forward</b> command.</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>forward</b></p>

<p style="margin-left:22%;">Move forward to the next entry
in the position ring.</p>

<p style="margin-left:11%;"><b>frag
[&minus;adflqRrv]</b></p>

<p style="margin-left:22%;">Get file fragmentation data.
This prints information about fragmentation of file data in
the filesystem (as opposed to fragmentation of freespace,
for which see the <b>freesp</b> command). Every file in the
filesystem is examined to see how far from ideal its extent
mappings are. A summary is printed giving the totals.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>sets verbosity, every inode has information printed for
it. The remaining options select which inodes and extents
are examined. If no options are given then all are assumed
set, otherwise just those given are enabled.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;a</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of attribute data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;d</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of directory data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;f</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of regular file data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;l</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of symbolic link data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;q</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of quota file data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;R</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of realtime control file data.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;r</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>enables processing of realtime file data.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>freesp [&minus;bcds]
[&minus;a</b> <i>ag</i><b>] ... [&minus;e</b> <i>i</i><b>]
[&minus;h</b> <i>h1</i><b>] ... [&minus;m</b>
<i>m</i><b>]</b></p>

<p style="margin-left:22%;">Summarize free space for the
filesystem. The free blocks are examined and totalled, and
displayed in the form of a histogram, with a count of
extents in each range of free extent sizes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;a</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>adds <i>ag</i> to the list of allocation groups to be
processed. If no <b>&minus;a</b> options are given then all
allocation groups are processed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;b</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that the histogram buckets are binary-sized,
with the starting sizes being the powers of 2.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;c</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that <b>freesp</b> will search the by-size
(cnt) space Btree instead of the default by-block (bno)
space Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;d</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that every free extent will be displayed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;e</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that the histogram buckets are equal-sized,
with the size specified as <i>i</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;h</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies a starting block number for a histogram bucket
as <i>h1</i>. Multiple <b>&minus;h</b>&rsquo;s are given to
specify the complete set of buckets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;m</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that the histogram starting block numbers are
powers of <i>m</i>. This is the general case of
<b>&minus;b</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;s</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that a final summary of total free extents,
free blocks, and the average free extent size is
printed.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>fsb</b></p></td>
<td width="3%"></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">See the
<b>fsblock</b> command.</p>

<p style="margin-left:11%;"><b>fsblock
[</b><i>fsb</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to the
fsblock value given by <i>fsb</i>. If no value for
<i>fsb</i> is given the current address is printed,
expressed as an fsb. The type is set to <b>data</b>
(uninterpreted). XFS filesystem block numbers are computed
((<i>agno</i> &lt;&lt; <i>agshift</i>) | <i>agblock</i>)
where <i>agshift</i> depends on the size of an allocation
group. Use the <b>convert</b> command to convert to and from
this form. Block numbers given for file blocks (for instance
from the <b>bmap</b> command) are in this form.</p>

<p style="margin-left:11%;"><b>hash</b> <i>string</i></p>

<p style="margin-left:22%;">Prints the hash value of
<i>string</i> using the hash function of the XFS directory
and attribute implementation.</p>

<p style="margin-left:11%;"><b>help
[</b><i>command</i><b>]</b></p>

<p style="margin-left:22%;">Print help for one or all
commands.</p>

<p style="margin-left:11%;"><b>inode
[</b><i>inode#</i><b>]</b></p>

<p style="margin-left:22%;">Set the current inode number.
If no <i>inode#</i> is given, print the current inode
number.</p>

<p style="margin-left:11%;"><b>label
[</b><i>label</i><b>]</b></p>

<p style="margin-left:22%;">Set the filesystem label. The
filesystem label can be used by <b>mount</b>(8) instead of
using a device special file. The maximum length of an XFS
label is 12 characters &minus; use of a longer <i>label</i>
will result in truncation and a warning will be issued. If
no <i>label</i> is given, the current filesystem label is
printed.</p>

<p style="margin-left:11%;"><b>log [stop | start</b>
<i>filename</i><b>]</b></p>

<p style="margin-left:22%;">Start logging output to
<i>filename</i>, stop logging, or print the current logging
status.</p>

<p style="margin-left:11%;"><b>metadump [&minus;egow]</b>
<i>filename</i></p>

<p style="margin-left:22%;">Dumps metadata to a file. See
<b>xfs_metadump</b>(8) for more information.</p>

<p style="margin-left:11%;"><b>ncheck [&minus;s]
[&minus;i</b> <i>ino</i><b>] ...</b></p>

<p style="margin-left:22%;">Print name-inode pairs. A
<b>blockget &minus;n</b> command must be run first to gather
the information.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;i</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies an inode number to be printed. If no
<b>&minus;i</b> options are given then all inodes are
printed.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>&minus;s</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>specifies that only setuid and setgid files are
printed.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>p</b></p></td>
<td width="3%"></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">See the
<b>print</b> command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>pop</b></p></td>
<td width="7%"></td>
<td width="43%">


<p style="margin-top: 1em">Pop location from the stack.</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>print
[</b><i>field-expression</i><b>] ...</b></p>

<p style="margin-left:22%;">Print field values. If no
argument is given, print all fields in the current
structure.</p>

<p style="margin-left:11%;"><b>push
[</b><i>command</i><b>]</b></p>

<p style="margin-left:22%;">Push location to the stack. If
<i>command</i> is supplied, set the current location to the
results of <i>command</i> after pushing the old
location.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>q</b></p></td>
<td width="5%"></td>
<td width="32%">


<p>See the <b>quit</b> command.</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>quit</b></p></td>
<td width="5%"></td>
<td width="32%">


<p>Exit <b>xfs_db</b>.</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ring
[</b><i>index</i><b>]</b></p>

<p style="margin-left:22%;">Show position ring (if no
<i>index</i> argument is given), or move to a specific entry
in the position ring given by <i>index</i>.</p>

<p style="margin-left:11%;"><b>sb
[</b><i>agno</i><b>]</b></p>

<p style="margin-left:22%;">Set current address to SB
header in allocation group <i>agno</i>. If no <i>agno</i> is
given, use the current allocation group number.</p>

<p style="margin-left:11%;"><b>source</b>
<i>source-file</i></p>

<p style="margin-left:22%;">Process commands from
<i>source-file</i>. <b>source</b> commands can be
nested.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>stack</b></p></td>
<td width="4%"></td>
<td width="36%">


<p>View the location stack.</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>type
[</b><i>type</i><b>]</b></p>

<p style="margin-left:22%;">Set the current data type to
<i>type</i>. If no argument is given, show the current data
type. The possible data types are: <b>agf</b>, <b>agfl</b>,
<b>agi</b>, <b>attr</b>, <b>bmapbta</b>, <b>bmapbtd</b>,
<b>bnobt</b>, <b>cntbt</b>, <b>data</b>, <b>dir</b>,
<b>dir2</b>, <b>dqblk</b>, <b>inobt</b>, <b>inode</b>,
<b>log</b>, <b>rtbitmap</b>, <b>rtsummary</b>, <b>sb</b>,
<b>symlink</b> and <b>text</b>. See the TYPES section below
for more information on these data types.</p>

<p style="margin-left:11%;"><b>uuid [</b><i>uuid</i>
<b>|</b> <i>generate</i> <b>|</b> <i>rewrite</i><b>]</b></p>

<p style="margin-left:22%;">Set the filesystem universally
unique identifier (UUID). The filesystem UUID can be used by
<b>mount</b>(8) instead of using a device special file. The
<i>uuid</i> can be set directly to the desired UUID, or it
can be automatically generated using the <b>generate</b>
option. These options will both write the UUID into every
copy of the superblock in the filesystem. <b>rewrite</b>
copies the current UUID from the primary superblock to all
secondary copies of the superblock. If no argument is given,
the current filesystem UUID is printed.</p>

<p style="margin-left:11%;"><b>version [</b><i>feature</i>
<b>|</b> <i>versionnum features2</i><b>]</b></p>

<p style="margin-left:22%;">Enable selected features for a
filesystem (certain features can be enabled on an unmounted
filesystem, after <b>mkfs.xfs</b>(8) has created the
filesystem). Support for unwritten extents can be enabled
using the <b>extflg</b> option. Support for version 2 log
format can be enabled using the <b>log2</b> option. Support
for extended attributes can be enabled using the
<b>attr1</b> or <b>attr2</b> option. Once enabled, extended
attributes cannot be disabled, but the user may toggle
between <b>attr1</b> and <b>attr2</b> at will (older kernels
may not support the newer version).</p>

<p style="margin-left:22%; margin-top: 1em">If no argument
is given, the current version and feature bits are printed.
With one argument, this command will write the updated
version number into every copy of the superblock in the
filesystem. If two arguments are given, they will be used as
numeric values for the <i>versionnum</i> and
<i>features2</i> bits respectively, and their string
equivalent reported (but no modifications are made).</p>

<p style="margin-left:11%;"><b>write [&minus;c]
[</b><i>field value</i><b>] ...</b></p>

<p style="margin-left:22%;">Write a value to disk. Specific
fields can be set in structures (struct mode), or a block
can be set to data values (data mode), or a block can be set
to string values (string mode, for symlink blocks). The
operation happens immediately: there is no buffering.</p>

<p style="margin-left:22%; margin-top: 1em">Struct mode is
in effect when the current type is structural, i.e. not
data. For struct mode, the syntax is &quot;<b>write</b>
<i>field value</i>&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">Data mode is in
effect when the current type is data. In this case the
contents of the block can be shifted or rotated left or
right, or filled with a sequence, a constant value, or a
random value. In this mode <b>write</b> with no arguments
gives more information on the allowed commands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Skip write verifiers and CRC recalculation; allows
invalid data to be written to disk.</p></td></tr>
</table>

<h2>TYPES
<a name="TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
gives the fields in each structure type and their meanings.
Note that some types of block cover multiple actual
structures, for instance directory blocks.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>agf</b></p></td>
<td width="11%"></td>
<td width="74%">


<p style="margin-top: 1em">The AGF block is the header for
block allocation information; it is in the second 512-byte
block of each allocation group. The following fields are
defined:</p> </td></tr>
</table>


<p style="margin-left:32%; margin-top: 1em"><b>magicnum</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%"></td>
<td width="3%"></td>
<td width="49%">


<p style="margin-top: 1em">AGF block magic number,
0x58414746 (&rsquo;XAGF&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>versionnum</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>version number, currently 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>seqno</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>sequence number starting from 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>length</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>size in filesystem blocks of the allocation group. All
allocation groups except the last one of the filesystem have
the superblock&rsquo;s <b>agblocks</b> value here.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>bnoroot</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>block number of the root of the Btree holding free space
information sorted by block number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>cntroot</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>block number of the root of the Btree holding free space
information sorted by block count.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>bnolevel</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of levels in the by-block-number Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>cntlevel</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of levels in the by-block-count Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>flfirst</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>index into the AGFL block of the first active entry.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>fllast</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>index into the AGFL block of the last active entry.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>flcount</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>count of active entries in the AGFL block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>freeblks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>count of blocks represented in the freespace Btrees.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>longest</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>longest free space represented in the freespace
Btrees.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>btreeblks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of blocks held in the AGF Btrees.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>agfl</b></p></td>
<td width="3%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The AGFL block
contains block numbers for use of the block allocator; it is
in the fourth 512-byte block of each allocation group. Each
entry in the active list is a block number within the
allocation group that can be used for any purpose if space
runs low. The AGF block fields <b>flfirst</b>,
<b>fllast</b>, and <b>flcount</b> designate which entries
are currently active. Entry space is allocated in a circular
manner within the AGFL block. Fields defined:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p style="margin-top: 1em"><b>bno</b></p></td>
<td width="14%"></td>
<td width="49%">


<p style="margin-top: 1em">array of all block numbers. Even
those which are not active are printed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p><b>agi</b></p></td>
<td width="14%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The AGI block
is the header for inode allocation information; it is in the
third 512-byte block of each allocation group. Fields
defined:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p style="margin-top: 1em"><b>magicnum</b></p></td>
<td width="3%"></td>
<td width="49%">


<p style="margin-top: 1em">AGI block magic number,
0x58414749 (&rsquo;XAGI&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>versionnum</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>version number, currently 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>seqno</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>sequence number starting from 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>length</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>size in filesystem blocks of the allocation group.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>count</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>count of inodes allocated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>root</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>block number of the root of the Btree holding inode
allocation information.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>level</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of levels in the inode allocation Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>freecount</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>count of allocated inodes that are not in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>newino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>last inode number allocated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>dirino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>unused.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>unlinked</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>an array of inode numbers within the allocation group.
The entries in the AGI block are the heads of lists which
run through the inode <b>next_unlinked</b> field. These
inodes are to be unlinked the next time the filesystem is
mounted.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>attr</b></p></td>
<td width="3%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">An attribute
fork is organized as a Btree with the actual data embedded
in the leaf blocks. The root of the Btree is found in block
0 of the fork. The index (sort order) of the Btree is the
hash value of the attribute name. All the blocks contain a
<b>blkinfo</b> structure at the beginning, see type
<b>dir</b> for a description. Nonleaf blocks are identical
in format to those for version 1 and version 2 directories,
see type <b>dir</b> for a description. Leaf blocks can refer
to &quot;local&quot; or &quot;remote&quot; attribute values.
Local values are stored directly in the leaf block. Remote
values are stored in an independent block in the attribute
fork (with no structure). Leaf blocks contain the following
fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">


<p style="margin-top: 1em"><b>hdr</b></p></td>
<td width="8%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing a
<b>blkinfo</b> structure <b>info</b> (magic number 0xfbee),
a <b>count</b> of active entries, <b>usedbytes</b> total
bytes of names and values, the <b>firstused</b> byte in the
name area, <b>holes</b> set if the block needs compaction,
and array <b>freemap</b> as for <b>dir</b> leaf blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">


<p><b>entries</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>array of structures containing a <b>hashval</b>,
<b>nameidx</b> (index into the block of the name), and flags
<b>incomplete</b>, <b>root</b>, and <b>local</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">


<p><b>nvlist</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>array of structures describing the attribute names and
values. Fields always present: <b>valuelen</b> (length of
value in bytes), <b>namelen</b>, and <b>name</b>. Fields
present for local values: <b>value</b> (value string).
Fields present for remote values: <b>valueblk</b> (fork
block number of containing the value).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">


<p><b>bmapbt</b></p></td>
<td width="8%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">Files with many
extents in their data or attribute fork will have the
extents described by the contents of a Btree for that fork,
instead of being stored directly in the inode. Each bmap
Btree starts with a root block contained within the inode.
The other levels of the Btree are stored in filesystem
blocks. The blocks are linked to sibling left and right
blocks at each level, as well as by pointers from parent to
child blocks. Each block contains the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="6%"></td>
<td width="49%">


<p style="margin-top: 1em">bmap Btree block magic number,
0x424d4150 (&rsquo;BMAP&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>level</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>level of this block above the leaf level.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>numrecs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>number of records or keys in the block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>leftsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>left (logically lower) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>rightsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>right (logically higher) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>recs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[leaf blocks only] array of extent records. Each record
contains <b>startoff</b>, <b>startblock</b>,
<b>blockcount</b>, and <b>extentflag</b> (1 if the extent is
unwritten).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>keys</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of key records. These are
the first key value of each block in the level below this
one. Each record contains <b>startoff</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>ptrs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of child block pointers.
Each pointer is a filesystem block number to the next level
in the Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>bnobt</b></p></td>
<td width="6%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">There is one
set of filesystem blocks forming the by-block-number
allocation Btree for each allocation group. The root block
of this Btree is designated by the <b>bnoroot</b> field in
the corresponding AGF block. The blocks are linked to
sibling left and right blocks at each level, as well as by
pointers from parent to child blocks. Each block has the
following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="6%"></td>
<td width="49%">


<p style="margin-top: 1em">BNOBT block magic number,
0x41425442 (&rsquo;ABTB&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>level</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>level number of this block, 0 is a leaf.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>numrecs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>number of data entries in the block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>leftsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>left (logically lower) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>rightsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>right (logically higher) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>recs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[leaf blocks only] array of freespace records. Each
record contains <b>startblock</b> and <b>blockcount</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>keys</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains <b>startblock</b> and
<b>blockcount</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>ptrs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>cntbt</b></p></td>
<td width="6%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">There is one
set of filesystem blocks forming the by-block-count
allocation Btree for each allocation group. The root block
of this Btree is designated by the <b>cntroot</b> field in
the corresponding AGF block. The blocks are linked to
sibling left and right blocks at each level, as well as by
pointers from parent to child blocks. Each block has the
following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="6%"></td>
<td width="49%">


<p style="margin-top: 1em">CNTBT block magic number,
0x41425443 (&rsquo;ABTC&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>level</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>level number of this block, 0 is a leaf.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>numrecs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>number of data entries in the block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>leftsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>left (logically lower) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>rightsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>right (logically higher) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>recs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[leaf blocks only] array of freespace records. Each
record contains <b>startblock</b> and <b>blockcount</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>keys</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains <b>blockcount</b> and
<b>startblock</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>ptrs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>data</b></p></td>
<td width="6%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">User file
blocks, and other blocks whose type is unknown, have this
type for display purposes in <b>xfs_db</b>. The block data
is displayed in hexadecimal format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>dir</b></p></td>
<td width="11%"></td>
<td width="74%">


<p style="margin-top: 1em">A version 1 directory is
organized as a Btree with the directory data embedded in the
leaf blocks. The root of the Btree is found in block 0 of
the file. The index (sort order) of the Btree is the hash
value of the entry name. All the blocks contain a
<b>blkinfo</b> structure at the beginning with the following
fields:</p> </td></tr>
</table>


<p style="margin-left:32%; margin-top: 1em"><b>forw</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%"></td>
<td width="11%"></td>
<td width="49%">


<p style="margin-top: 1em">next sibling block.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>back</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>previous sibling block.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>magic</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>magic number for this block type.</p></td></tr>
</table>

<p style="margin-left:26%;">The non-leaf (node) blocks have
the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>hdr</b></p></td>
<td width="11%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing a
<b>blkinfo</b> structure <b>info</b> (magic number 0xfebe),
the <b>count</b> of active entries, and the <b>level</b> of
this block above the leaves.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>btree</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>array of entries containing <b>hashval</b> and
<b>before</b> fields. The <b>before</b> value is a block
number within the directory file to the child block, the
<b>hashval</b> is the last hash value in that block.</p></td></tr>
</table>

<p style="margin-left:26%;">The leaf blocks have the
following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>hdr</b></p></td>
<td width="6%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing a
<b>blkinfo</b> structure <b>info</b> (magic number 0xfeeb),
the <b>count</b> of active entries, <b>namebytes</b> (total
name string bytes), <b>holes</b> flag (block needs
compaction), and <b>freemap</b> (array of <b>base</b>,
<b>size</b> entries for free regions).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>entries</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>array of structures containing <b>hashval</b>,
<b>nameidx</b> (byte index into the block of the name
string), and <b>namelen</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>namelist</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>array of structures containing <b>inumber</b> and
<b>name</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>dir2</b></p></td>
<td width="6%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">A version 2
directory has four kinds of blocks. Data blocks start at
offset 0 in the file. There are two kinds of data blocks:
single-block directories have the leaf information embedded
at the end of the block, data blocks in multi-block
directories do not. Node and leaf blocks start at offset
32GiB (with either a single leaf block or the root node
block). Freespace blocks start at offset 64GiB. The node and
leaf blocks form a Btree, with references to the data in the
data blocks. The freespace blocks form an index of longest
free spaces within the data blocks.</p>

<p style="margin-left:26%; margin-top: 1em">A single-block
directory block contains the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>bhdr</b></p></td>
<td width="11%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing <b>magic</b>
number 0x58443242 (&rsquo;XD2B&rsquo;) and an array
<b>bestfree</b> of the longest 3 free spaces in the block
(<b>offset</b>, <b>length</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>bu</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>array of union structures. Each element is either an
entry or a freespace. For entries, there are the following
fields: <b>inumber</b>, <b>namelen</b>, <b>name</b>, and
<b>tag</b>. For freespace, there are the following fields:
<b>freetag</b> (0xffff), <b>length</b>, and <b>tag</b>. The
<b>tag</b> value is the byte offset in the block of the
start of the entry it is contained in.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>bleaf</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>array of leaf entries containing <b>hashval</b> and
<b>address</b>. The <b>address</b> is a 64-bit word offset
into the file.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="8%">


<p><b>btail</b></p></td>
<td width="11%"></td>
<td width="49%">


<p>tail structure containing the total <b>count</b> of leaf
entries and <b>stale</b> count of unused leaf entries.</p></td></tr>
</table>

<p style="margin-left:26%;">A data block contains the
following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>dhdr</b></p></td>
<td width="13%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing <b>magic</b>
number 0x58443244 (&rsquo;XD2D&rsquo;) and an array
<b>bestfree</b> of the longest 3 free spaces in the block
(<b>offset</b>, <b>length</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="6%">


<p><b>du</b></p></td>
<td width="13%"></td>
<td width="49%">


<p>array of union structures as for <b>bu</b>.</p></td></tr>
</table>

<p style="margin-left:26%;">Leaf blocks have two possible
forms. If the Btree consists of a single leaf then the
freespace information is in the leaf block, otherwise it is
in separate blocks and the root of the Btree is a node
block. A leaf block contains the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="10%">


<p style="margin-top: 1em"><b>lhdr</b></p></td>
<td width="9%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing a
<b>blkinfo</b> structure <b>info</b> (magic number 0xd2f1
for the single leaf case, 0xd2ff for the true Btree case),
the total <b>count</b> of leaf entries, and <b>stale</b>
count of unused leaf entries.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="10%">


<p><b>lents</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>leaf entries, as for <b>bleaf</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="10%">


<p><b>lbests</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>[single leaf only] array of values which represent the
longest freespace in each data block in the directory.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="10%">


<p><b>ltail</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>[single leaf only] tail structure containing
<b>bestcount</b> count of <b>lbests</b>.</p></td></tr>
</table>

<p style="margin-left:26%;">A node block is identical to
that for types <b>attr</b> and <b>dir</b>.</p>

<p style="margin-left:26%; margin-top: 1em">A freespace
block contains the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p style="margin-top: 1em"><b>fhdr</b></p></td>
<td width="9%"></td>
<td width="49%">


<p style="margin-top: 1em">header containing <b>magic</b>
number 0x58443246 (&rsquo;XD2F&rsquo;), <b>firstdb</b> first
data block number covered by this freespace block,
<b>nvalid</b> number of valid entries, and <b>nused</b>
number of entries representing real data blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>fbests</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>array of values as for <b>lbests</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>dqblk</b></p></td>
<td width="9%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The quota
information is stored in files referred to by the superblock
<b>uquotino</b> and <b>pquotino</b> fields. Each filesystem
block in a quota file contains a constant number of quota
entries. The quota entry size is currently 136 bytes, so
with a 4KiB filesystem block size there are 30 quota entries
per block. The <b>dquot</b> command is used to locate these
entries in the filesystem. The file entries are indexed by
the user or project identifier to determine the block and
offset. Each quota entry has the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="3%"></td>
<td width="45%">


<p style="margin-top: 1em">magic number, 0x4451
(&rsquo;DQ&rsquo;).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>version</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>version number, currently 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>flags</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>flags, values include 0x01 for user quota, 0x02 for
project quota.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>id</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>user or project identifier.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>blk_hardlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>absolute limit on blocks in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>blk_softlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>preferred limit on blocks in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>ino_hardlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>absolute limit on inodes in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>ino_softlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>preferred limit on inodes in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>bcount</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>blocks actually in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>icount</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>inodes actually in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>itimer</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>time when service will be refused if soft limit is
violated for inodes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>btimer</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>time when service will be refused if soft limit is
violated for blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>iwarns</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>number of warnings issued about inode limit
violations.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>bwarns</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>number of warnings issued about block limit
violations.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>rtb_hardlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>absolute limit on realtime blocks in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>rtb_softlimit</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>preferred limit on realtime blocks in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>rtbcount</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>realtime blocks actually in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>rtbtimer</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>time when service will be refused if soft limit is
violated for realtime blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>rtbwarns</b></p></td>
<td width="3%"></td>
<td width="45%">


<p>number of warnings issued about realtime block limit
violations.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p><b>inobt</b></p></td>
<td width="3%"></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">There is one
set of filesystem blocks forming the inode allocation Btree
for each allocation group. The root block of this Btree is
designated by the <b>root</b> field in the corresponding AGI
block. The blocks are linked to sibling left and right
blocks at each level, as well as by pointers from parent to
child blocks. Each block has the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="6%"></td>
<td width="49%">


<p style="margin-top: 1em">INOBT block magic number,
0x49414254 (&rsquo;IABT&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>level</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>level number of this block, 0 is a leaf.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>numrecs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>number of data entries in the block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>leftsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>left (logically lower) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>rightsib</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>right (logically higher) sibling block, 0 if none.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>recs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[leaf blocks only] array of inode records. Each record
contains <b>startino</b> allocation-group relative inode
number, <b>freecount</b> count of free inodes in this chunk,
and <b>free</b> bitmap, LSB corresponds to inode 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>keys</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of key records. These are
the first value of each block in the level below this one.
Each record contains <b>startino</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>ptrs</b></p></td>
<td width="6%"></td>
<td width="49%">


<p>[non-leaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group
to the next level in the Btree.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p><b>inode</b></p></td>
<td width="6%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">Inodes are
allocated in &quot;chunks&quot; of 64 inodes each. Usually a
chunk is multiple filesystem blocks, although there are
cases with large filesystem blocks where a chunk is less
than one block. The inode Btree (see <b>inobt</b> above)
refers to the inode numbers per allocation group. The inode
numbers directly reflect the location of the inode block on
disk. Use the <b>inode</b> command to point <b>xfs_db</b> to
a specific inode. Each inode contains four regions:
<b>core</b>, <b>next_unlinked</b>, <b>u</b>, and <b>a</b>.
<b>core</b> contains the fixed information.
<b>next_unlinked</b> is separated from the core due to
journaling considerations, see type <b>agi</b> field
<b>unlinked</b>. <b>u</b> is a union structure that is
different in size and format depending on the type and
representation of the file data (&quot;data fork&quot;).
<b>a</b> is an optional union structure to describe
attribute data, that is different in size, format, and
location depending on the presence and representation of
attribute data, and the size of the <b>u</b> data
(&quot;attribute fork&quot;). <b>xfs_db</b> automatically
selects the proper union members based on information in the
inode.</p>

<p style="margin-left:26%; margin-top: 1em">The following
are fields in the inode core:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>magic</b></p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em">inode magic number, 0x494e
(&rsquo;IN&rsquo;).</p> </td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>mode</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>mode and type of file, as described in <b>chmod</b>(2),
<b>mknod</b>(2), and <b>stat</b>(2).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>version</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>inode version, 1 or 2.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>format</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>format of <b>u</b> union data (0: xfs_dev_t, 1: local
file &minus; in-inode directory or symlink, 2: extent list,
3: Btree root, 4: unique id [unused]).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>nlinkv1</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>number of links to the file in a version 1 inode.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>nlinkv2</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>number of links to the file in a version 2 inode.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>projid_lo</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>owner&rsquo;s project id (low word; version 2 inode
only). <b>projid_hi</b> owner&rsquo;s project id (high word;
version 2 inode only).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>uid</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>owner&rsquo;s user id.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>gid</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>owner&rsquo;s group id.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>atime</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>time last accessed (seconds and nanoseconds).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>mtime</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>time last modified.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>ctime</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>time created or inode last modified.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>size</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>number of bytes in the file.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>nblocks</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>total number of blocks in the file including indirect
and attribute.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>extsize</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>basic/minimum extent size for the file.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>nextents</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>number of extents in the data fork.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>naextents</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>number of extents in the attribute fork.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>forkoff</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>attribute fork offset in the inode, in 64-bit words from
the start of <b>u</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>aformat</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>format of <b>a</b> data (1: local attribute data, 2:
extent list, 3: Btree root).</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>dmevmask</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>DMAPI event mask.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>dmstate</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>DMAPI state information.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>newrtbm</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>file is the realtime bitmap and is &quot;new&quot;
format.</p> </td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>prealloc</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>file has preallocated data space after EOF.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>realtime</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>file data is in the realtime subvolume.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="14%">


<p><b>gen</b></p></td>
<td width="5%"></td>
<td width="49%">


<p>inode generation number.</p></td></tr>
</table>

<p style="margin-left:26%;">The following fields are in the
<b>u</b> data fork union:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>bmbt</b></p></td>
<td width="8%"></td>
<td width="49%">


<p style="margin-top: 1em">bmap Btree root. This looks like
a <b>bmapbtd</b> block with redundant information
removed.</p> </td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p><b>bmx</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>array of extent descriptors.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p><b>dev</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>dev_t for the block or character device.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p><b>sfdir</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>shortform (in-inode) version 1 directory. This consists
of a <b>hdr</b> containing the <b>parent</b> inode number
and a <b>count</b> of active entries in the directory,
followed by an array <b>list</b> of <b>hdr.count</b>
entries. Each such entry contains <b>inumber</b>,
<b>namelen</b>, and <b>name</b> string.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p><b>sfdir2</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>shortform (in-inode) version 2 directory. This consists
of a <b>hdr</b> containing a <b>count</b> of active entries
in the directory, an <b>i8count</b> of entries with inumbers
that don&rsquo;t fit in a 32-bit value, and the
<b>parent</b> inode number, followed by an array <b>list</b>
of <b>hdr.count</b> entries. Each such entry contains
<b>namelen</b>, a saved <b>offset</b> used when the
directory is converted to a larger form, a <b>name</b>
string, and the <b>inumber</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="11%">


<p><b>symlink</b></p></td>
<td width="8%"></td>
<td width="49%">


<p>symbolic link string value.</p></td></tr>
</table>

<p style="margin-left:26%;">The following fields are in the
<b>a</b> attribute fork union if it exists:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p style="margin-top: 1em"><b>bmbt</b></p></td>
<td width="9%"></td>
<td width="49%">


<p style="margin-top: 1em">bmap Btree root, as above.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>bmx</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>array of extent descriptors.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>sfattr</b></p></td>
<td width="9%"></td>
<td width="49%">


<p>shortform (in-inode) attribute values. This consists of
a <b>hdr</b> containing a <b>totsize</b> (total size in
bytes) and a <b>count</b> of active entries, followed by an
array <b>list</b> of <b>hdr.count</b> entries. Each such
entry contains <b>namelen</b>, <b>valuelen</b>, <b>root</b>
flag, <b>name</b>, and <b>value</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p><b>log</b></p></td>
<td width="9%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">Log blocks
contain the journal entries for XFS. It&rsquo;s not useful
to examine these with <b>xfs_db</b>, use
<b>xfs_logprint</b>(8) instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>rtbitmap</b></p></td>
<td width="1%"></td>
<td width="74%">


<p style="margin-top: 1em">If the filesystem has a realtime
subvolume, then the <b>rbmino</b> field in the superblock
refers to a file that contains the realtime bitmap. Each bit
in the bitmap file controls the allocation of a single
realtime extent (set == free). The bitmap is processed in
32-bit words, the LSB of a word is used for the first extent
controlled by that bitmap word. The <b>atime</b> field of
the realtime bitmap inode contains a counter that is used to
control where the next new realtime file will start.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>rtsummary</b></p></td>
<td width="1%"></td>
<td width="74%">


<p>If the filesystem has a realtime subvolume, then the
<b>rsumino</b> field in the superblock refers to a file that
contains the realtime summary data. The summary file
contains a two-dimensional array of 16-bit values. Each
value counts the number of free extent runs (consecutive
free realtime extents) of a given range of sizes that starts
in a given bitmap block. The size ranges are binary buckets
(low size in the bucket is a power of 2). There are as many
size ranges as are necessary given the size of the realtime
subvolume. The first dimension is the size range, the second
dimension is the starting bitmap block number (adjacent
entries are for the same size, adjacent bitmap blocks).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>sb</b></p></td>
<td width="1%"></td>
<td width="74%">


<p>There is one sb (superblock) structure per allocation
group. It is the first disk block in the allocation group.
Only the first one (block 0 of the filesystem) is actually
used; the other blocks are redundant information for
<b>xfs_repair</b>(8) to use if the first superblock is
damaged. Fields defined:</p></td></tr>
</table>


<p style="margin-left:32%; margin-top: 1em"><b>magicnum</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%"></td>
<td width="3%"></td>
<td width="49%">


<p style="margin-top: 1em">superblock magic number,
0x58465342 (&rsquo;XFSB&rsquo;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>blocksize</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>filesystem block size in bytes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>dblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of filesystem blocks present in the data
subvolume.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of filesystem blocks present in the realtime
subvolume.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rextents</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of realtime extents that <b>rblocks</b>
contain.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>uuid</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>unique identifier of the filesystem.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>logstart</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>starting filesystem block number of the log (journal).
If this value is 0 the log is &quot;external&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rootino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>root inode number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rbmino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>realtime bitmap inode number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rsumino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>realtime summary data inode number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rextsize</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>realtime extent size in filesystem blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>agblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>size of an allocation group in filesystem blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>agcount</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of allocation groups.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rbmblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of realtime bitmap blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>logblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of log blocks (filesystem blocks).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>versionnum</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>filesystem version information. This value is currently
1, 2, 3, or 4 in the low 4 bits. If the low bits are 4 then
the other bits have additional meanings. 1 is the original
value. 2 means that attributes were used. 3 means that
version 2 inodes (large link counts) were used. 4 is the
bitmask version of the version number. In this case, the
other bits are used as flags (0x0010: attributes were used,
0x0020: version 2 inodes were used, 0x0040: quotas were
used, 0x0080: inode cluster alignment is in force, 0x0100:
data stripe alignment is in force, 0x0200: the
<b>shared_vn</b> field is used, 0x1000: unwritten extent
tracking is on, 0x2000: version 2 directories are in
use).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>sectsize</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>sector size in bytes, currently always 512. This is the
size of the superblock and the other header blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inodesize</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>inode size in bytes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inopblock</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of inodes per filesystem block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>fname</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>obsolete, filesystem name.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>fpack</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>obsolete, filesystem pack name.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>blocklog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>blocksize</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>sectlog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>sectsize</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inodelog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>inodesize</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inopblog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>inopblock</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>agblklog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>agblocks</b> (rounded up).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>rextslog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of <b>rextents</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inprogress</b></p></td>
<td width="3%"></td>
<td width="49%">


<p><b>mkfs.xfs</b>(8) or <b>xfs_copy</b>(8) aborted before
completing this filesystem.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>imax_pct</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>maximum percentage of filesystem space used for inode
blocks.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>icount</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of allocated inodes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>ifree</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of allocated inodes that are not in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>fdblocks</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of free data blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>frextents</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>number of free realtime extents.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>uquotino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>user quota inode number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>pquotino</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>project quota inode number; this is currently
unused.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>qflags</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>quota status flags (0x01: user quota accounting is on,
0x02: user quota limits are enforced, 0x04: quotacheck has
been run on user quotas, 0x08: project quota accounting is
on, 0x10: project quota limits are enforced, 0x20:
quotacheck has been run on project quotas).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>flags</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>random flags. 0x01: only read-only mounts are
allowed.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>shared_vn</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>shared version number (shared readonly filesystems).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>inoalignmt</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>inode chunk alignment in filesystem blocks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>unit</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>stripe or RAID unit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>width</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>stripe or RAID width.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>dirblklog</b></p></td>
<td width="3%"></td>
<td width="49%">


<p>log2 of directory block size (filesystem blocks).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p><b>symlink</b></p></td>
<td width="3%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">Symbolic link
blocks are used only when the symbolic link value does not
fit inside the inode. The block content is just the string
value. Bytes past the logical end of the symbolic link value
have arbitrary values.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>text</b></p></td>
<td width="9%"></td>
<td width="74%">


<p style="margin-top: 1em">User file blocks, and other
blocks whose type is unknown, have this type for display
purposes in <b>xfs_db</b>. The block data is displayed in
two columns: Hexadecimal format and printable ASCII
chars.</p> </td></tr>
</table>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many messages
can come from the <b>check</b> (<b>blockget</b>) command. If
the filesystem is completely corrupt, a core dump might be
produced instead of the message</p>

<p style="margin-left:22%;"><i>device</i> <b>is not a valid
filesystem</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
filesystem is very large (has many files) then <b>check</b>
might run out of memory. In this case the message</p>

<p style="margin-left:22%;"><b>out of memory</b></p>

<p style="margin-left:11%;">is printed.</p>

<p style="margin-left:11%; margin-top: 1em">The following
is a description of the most likely problems and the
associated messages. Most of the diagnostics produced are
only meaningful with an understanding of the structure of
the filesystem. <b><br>
agf_freeblks</b> <i>n</i><b>, counted</b> <i>m</i> <b>in
ag</b> <i>a</i></p>

<p style="margin-left:22%;">The freeblocks count in the
allocation group header for allocation group <i>a</i>
doesn&rsquo;t match the number of blocks counted free.</p>

<p style="margin-left:11%;"><b>agf_longest</b> <i>n</i><b>,
counted</b> <i>m</i> <b>in ag</b> <i>a</i></p>

<p style="margin-left:22%;">The longest free extent in the
allocation group header for allocation group <i>a</i>
doesn&rsquo;t match the longest free extent found in the
allocation group.</p>

<p style="margin-left:11%;"><b>agi_count</b> <i>n</i><b>,
counted</b> <i>m</i> <b>in ag</b> <i>a</i></p>

<p style="margin-left:22%;">The allocated inode count in
the allocation group header for allocation group <i>a</i>
doesn&rsquo;t match the number of inodes counted in the
allocation group.</p>

<p style="margin-left:11%;"><b>agi_freecount</b>
<i>n</i><b>, counted</b> <i>m</i> <b>in ag</b> <i>a</i></p>

<p style="margin-left:22%;">The free inode count in the
allocation group header for allocation group <i>a</i>
doesn&rsquo;t match the number of inodes counted free in the
allocation group.</p>

<p style="margin-left:11%;"><b>block</b> <i>a/b</i>
<b>expected inum 0 got</b> <i>i</i></p>

<p style="margin-left:22%;">The block number is specified
as a pair (allocation group number, block in the allocation
group). The block is used multiple times (shared), between
multiple inodes. This message usually follows a message of
the next type.</p>

<p style="margin-left:11%;"><b>block</b> <i>a/b</i>
<b>expected type unknown got</b> <i>y</i></p>

<p style="margin-left:22%;">The block is used multiple
times (shared).</p>

<p style="margin-left:11%;"><b>block</b> <i>a/b</i> <b>type
unknown not expected</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>mkfs.xfs</b>(8),
<b>xfs_admin</b>(8), <b>xfs_copy</b>(8),
<b>xfs_logprint</b>(8), <b>xfs_metadump</b>(8),
<b>xfs_ncheck</b>(8), <b>xfs_repair</b>(8), <b>mount</b>(8),
<b>chmod</b>(2), <b>mknod</b>(2), <b>stat</b>(2),
<b>xfs</b>(5).</p>
<hr>
</body>
</html>
