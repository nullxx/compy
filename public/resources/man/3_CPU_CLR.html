<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:02:25 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CPU_SET</title>

</head>
<body>

<h1 align="center">CPU_SET</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">CPU_SET,
CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR,
CPU_XOR, CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE,
CPU_SET_S, CPU_CLR_S, CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S,
CPU_AND_S, CPU_OR_S, CPU_XOR_S, CPU_EQUAL_S &minus; macros
for manipulating CPU sets</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#define
_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>
#include &lt;sched.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_ZERO(cpu_set_t *</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_SET(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>); <br>
void CPU_CLR(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>); <br>
int CPU_ISSET(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
CPU_COUNT(cpu_set_t *</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_AND(cpu_set_t *</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br>
void CPU_OR(cpu_set_t *</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br>
void CPU_XOR(cpu_set_t *</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
CPU_EQUAL(cpu_set_t *</b><i>set1</i><b>, cpu_set_t
*</b><i>set2</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>cpu_set_t
*CPU_ALLOC(int</b> <i>num_cpus</i><b>); <br>
void CPU_FREE(cpu_set_t *</b><i>set</i><b>); <br>
size_t CPU_ALLOC_SIZE(int</b> <i>num_cpus</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_ZERO_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_SET_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br>
void CPU_CLR_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br>
int CPU_ISSET_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
CPU_COUNT_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
CPU_AND_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br>
void CPU_OR_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br>
void CPU_XOR_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
CPU_EQUAL_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>cpu_set_t</i> data structure represents a set of CPUs.
CPU sets are used by <b>sched_setaffinity</b>(2) and similar
interfaces.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>cpu_set_t</i> data type is implemented as a bitset.
However, the data structure treated as considered opaque:
all manipulation of CPU sets should be done via the macros
described in this page.</p>

<p style="margin-left:11%; margin-top: 1em">The following
macros are provided to operate on the CPU set
<i>set</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_ZERO</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Clears <i>set</i>, so that it contains no CPUs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_SET</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Add CPU <i>cpu</i> to <i>set</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_CLR</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Remove CPU <i>cpu</i> from <i>set</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_ISSET</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Test to see if CPU <i>cpu</i> is a member of
<i>set</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_COUNT</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Return the number of CPUs in <i>set</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Where a
<i>cpu</i> argument is specified, it should not produce side
effects, since the above macros may evaluate the argument
more than once.</p>

<p style="margin-left:11%; margin-top: 1em">The first
available CPU on the system corresponds to a <i>cpu</i>
value of 0, the next CPU corresponds to a <i>cpu</i> value
of 1, and so on. The constant <b>CPU_SETSIZE</b> (currently
1024) specifies a value one greater than the maximum CPU
number that can be stored in <i>cpu_set_t</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
macros perform logical operations on CPU sets:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>CPU_AND</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p style="margin-top: 1em">Store the intersection of the
sets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i>
(which may be one of the source sets).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_OR</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Store the union of the sets <i>srcset1</i> and
<i>srcset2</i> in <i>destset</i> (which may be one of the
source sets).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_XOR</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Store the XOR of the sets <i>srcset1</i> and
<i>srcset2</i> in <i>destset</i> (which may be one of the
source sets). The XOR means the set of CPUs that are in
either <i>srcset1</i> or <i>srcset2</i>, but not both.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>CPU_EQUAL</b>()</p></td>
<td width="9%"></td>
<td width="63%">


<p>Test whether two CPU set contain exactly the same
CPUs.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Dynamically
sized CPU sets</b> <br>
Because some applications may require the ability to
dynamically size CPU sets (e.g., to allocate sets larger
than that defined by the standard <i>cpu_set_t</i> data
type), glibc nowadays provides a set of macros to support
this.</p>

<p style="margin-left:11%; margin-top: 1em">The following
macros are used to allocate and deallocate CPU sets:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>CPU_ALLOC</b>()</p></td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em">Allocate a CPU set large enough
to hold CPUs in the range 0 to <i>num_cpus-1</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p><b>CPU_ALLOC_SIZE</b>()</p></td>
<td width="2%"></td>
<td width="63%">


<p>Return the size in bytes of the CPU set that would be
needed to hold CPUs in the range 0 to <i>num_cpus-1</i>.
This macro provides the value that can be used for the
<i>setsize</i> argument in the <b>CPU_*_S</b>() macros
described below.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p><b>CPU_FREE</b>()</p></td>
<td width="2%"></td>
<td width="63%">


<p>Free a CPU set previously allocated by
<b>CPU_ALLOC</b>().</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The macros
whose names end with &quot;_S&quot; are the analogs of the
similarly named macros without the suffix. These macros
perform the same tasks as their analogs, but operate on the
dynamically allocated CPU set(s) whose size is
<i>setsize</i> bytes.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>CPU_ISSET</b>()
and <b>CPU_ISSET_S</b>() return nonzero if <i>cpu</i> is in
<i>set</i>; otherwise, it returns 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_COUNT</b>()
and <b>CPU_COUNT_S</b>() return the number of CPUs in
<i>set</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_EQUAL</b>()
and <b>CPU_EQUAL_S</b>() return nonzero if the two CPU sets
are equal; otherwise it returns 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_ALLOC</b>()
returns a pointer on success, or NULL on failure. (Errors
are as for <b>malloc</b>(3).)</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_ALLOC_SIZE</b>()
returns the number of bytes required to store a CPU set of
the specified cardinality.</p>

<p style="margin-left:11%; margin-top: 1em">The other
functions do not return a value.</p>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and
<b>CPU_ISSET</b>() macros were added in glibc 2.3.3.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_COUNT</b>()
first appeared in glibc 2.6.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CPU_AND</b>(),
<b>CPU_OR</b>(), <b>CPU_XOR</b>(), <b>CPU_EQUAL</b>(),
<b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(),
<b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(), <b>CPU_SET_S</b>(),
<b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(),
<b>CPU_AND_S</b>(), <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(),
and <b>CPU_EQUAL_S</b>() first appeared in glibc 2.7.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These
interfaces are Linux-specific.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To duplicate a
CPU set, use <b>memcpy</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Since CPU sets
are bitsets allocated in units of long words, the actual
number of CPUs in a dynamically allocated CPU set will be
rounded up to the next multiple of <i>sizeof(unsigned
long)</i>. An application should consider the contents of
these extra bits to be undefined.</p>


<p style="margin-left:11%; margin-top: 1em">Notwithstanding
the similarity in the names, note that the constant
<b>CPU_SETSIZE</b> indicates the number of CPUs in the
<i>cpu_set_t</i> data type (thus, it is effectively a count
of bits in the bitset), while the <i>setsize</i> argument of
the <b>CPU_*_S</b>() macros is a size in bytes.</p>

<p style="margin-left:11%; margin-top: 1em">The data types
for arguments and return values shown in the SYNOPSIS are
hints what about is expected in each case. However, since
these interfaces are implemented as macros, the compiler
won&rsquo;t necessarily catch all type errors if you violate
the suggestions.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On 32-bit
platforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>()
allocates twice as much space as is required, and
<b>CPU_ALLOC_SIZE</b>() returns a value twice as large as it
should. This bug should not affect the semantics of a
program, but does result in wasted memory and less efficient
operation of the macros that operate on dynamically
allocated CPU sets. These bugs are fixed in glibc 2.9.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
program demonstrates the use of some of the macros used for
dynamically allocated CPU sets.</p>

<p style="margin-left:11%; margin-top: 1em">#define
_GNU_SOURCE <br>
#include &lt;sched.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;unistd.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;assert.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
cpu_set_t *cpusetp; <br>
size_t size; <br>
int num_cpus, cpu;</p>

<p style="margin-left:11%; margin-top: 1em">if (argc &lt;
2) { <br>
fprintf(stderr, &quot;Usage: %s
&lt;num&minus;cpus&gt;\n&quot;, argv[0]); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">num_cpus =
atoi(argv[1]);</p>

<p style="margin-left:11%; margin-top: 1em">cpusetp =
CPU_ALLOC(num_cpus); <br>
if (cpusetp == NULL) { <br>
perror(&quot;CPU_ALLOC&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">size =
CPU_ALLOC_SIZE(num_cpus);</p>


<p style="margin-left:11%; margin-top: 1em">CPU_ZERO_S(size,
cpusetp); <br>
for (cpu = 0; cpu &lt; num_cpus; cpu += 2) <br>
CPU_SET_S(cpu, size, cpusetp);</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;CPU_COUNT()
of set: %d\n&quot;, CPU_COUNT_S(size, cpusetp));</p>


<p style="margin-left:11%; margin-top: 1em">CPU_FREE(cpusetp);
<br>
exit(EXIT_SUCCESS); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>sched_setaffinity</b>(2),
<b>pthread_attr_setaffinity_np</b>(3),
<b>pthread_setaffinity_np</b>(3), <b>cpuset</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
