<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:00:45 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>AWK</title>

</head>
<body>

<h1 align="center">AWK</h1>

<a href="#PROLOG">PROLOG</a><br>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#OPERANDS">OPERANDS</a><br>
<a href="#STDIN">STDIN</a><br>
<a href="#INPUT FILES">INPUT FILES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#ASYNCHRONOUS EVENTS">ASYNCHRONOUS EVENTS</a><br>
<a href="#STDOUT">STDOUT</a><br>
<a href="#STDERR">STDERR</a><br>
<a href="#OUTPUT FILES">OUTPUT FILES</a><br>
<a href="#EXTENDED DESCRIPTION">EXTENDED DESCRIPTION</a><br>
<a href="#EXIT STATUS">EXIT STATUS</a><br>
<a href="#CONSEQUENCES OF ERRORS">CONSEQUENCES OF ERRORS</a><br>
<a href="#APPLICATION USAGE">APPLICATION USAGE</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#RATIONALE">RATIONALE</a><br>
<a href="#FUTURE DIRECTIONS">FUTURE DIRECTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>PROLOG
<a name="PROLOG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This manual
page is part of the POSIX Programmer&rsquo;s Manual. The
Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux
behavior), or the interface may not be implemented on
Linux.</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">awk &minus;
pattern scanning and processing language</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>awk [-F</b>
<i>ERE</i><b>][-v</b> <i>assignment</i><b>] ...</b>
<i>program</i> <b>[</b><i>argument</i> <b>...]</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>awk [-F</b>
<i>ERE</i><b>] -f</b> <i>progfile</i> <b>... [-v</b>
<i>assignment</i><b>] ...[</b><i>argument</i>
<b>...]</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>awk</i>
utility shall execute programs written in the <i>awk</i>
programming language, which is specialized for textual data
manipulation. An <i>awk</i> program is a sequence of
patterns and corresponding actions. When input is read that
matches a pattern, the action associated with that pattern
is carried out.</p>

<p style="margin-left:11%; margin-top: 1em">Input shall be
interpreted as a sequence of records. By default, a record
is a line, less its terminating &lt;newline&gt;, but this
can be changed by using the <b>RS</b> built-in variable.
Each record of input shall be matched in turn against each
pattern in the program. For each pattern matched, the
associated action shall be executed.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>awk</i>
utility shall interpret each input record as a sequence of
fields where, by default, a field is a string of non-
&lt;blank&gt;s. This default white-space field delimiter can
be changed by using the <b>FS</b> built-in variable or
<b>-F</b> <i>ERE</i>. The <i>awk</i> utility shall denote
the first field in a record $1, the second $2, and so on.
The symbol $0 shall refer to the entire record; setting any
other field causes the re-evaluation of $0. Assigning to $0
shall reset the values of all other fields and the <b>NF</b>
built-in variable.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>awk</i>
utility shall conform to the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, Section 12.2, Utility Syntax
Guidelines.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options shall be supported: <b><br>
-F&nbsp;</b> <i>ERE</i></p>

<p style="margin-left:22%;">Define the input field
separator to be the extended regular expression <i>ERE</i>,
before any input is read; see Regular Expressions .</p>

<p style="margin-left:11%;"><b>-f&nbsp;</b>
<i>progfile</i></p>

<p style="margin-left:22%;">Specify the pathname of the
file <i>progfile</i> containing an <i>awk</i> program. If
multiple instances of this option are specified, the
concatenation of the files specified as <i>progfile</i> in
the order specified shall be the <i>awk</i> program. The
<i>awk</i> program can alternatively be specified in the
command line as a single argument.</p>

<p style="margin-left:11%;"><b>-v&nbsp;</b>
<i>assignment</i></p>

<p style="margin-left:22%;">The application shall ensure
that the <i>assignment</i> argument is in the same form as
an <i>assignment</i> operand. The specified variable
assignment shall occur prior to executing the <i>awk</i>
program, including the actions associated with <b>BEGIN</b>
patterns (if any). Multiple occurrences of this option can
be specified.</p>

<h2>OPERANDS
<a name="OPERANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
operands shall be supported: <i><br>
program</i></p>

<p style="margin-left:22%;">If no <b>-f</b> option is
specified, the first operand to <i>awk</i> shall be the text
of the <i>awk</i> program. The application shall supply the
<i>program</i> operand as a single argument to <i>awk</i>.
If the text does not end in a &lt;newline&gt;, <i>awk</i>
shall interpret the text as if it did.</p>

<p style="margin-left:11%;"><i>argument</i></p>

<p style="margin-left:22%;">Either of the following two
types of <i>argument</i> can be intermixed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>file</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>A pathname of a file that contains the input to be read,
which is matched against the set of patterns in the program.
If no <i>file</i> operands are specified, or if a
<i>file</i> operand is <b>&rsquo;-&rsquo;</b>, the standard
input shall be used.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>assignment</i></p>

<p style="margin-left:22%;">An operand that begins with an
underscore or alphabetic character from the portable
character set (see the table in the Base Definitions volume
of IEEE&nbsp;Std&nbsp;1003.1-2001, Section 6.1, Portable
Character Set), followed by a sequence of underscores,
digits, and alphabetics from the portable character set,
followed by the <b>&rsquo;=&rsquo;</b> character, shall
specify a variable assignment rather than a pathname. The
characters before the <b>&rsquo;=&rsquo;</b> represent the
name of an <i>awk</i> variable; if that name is an
<i>awk</i> reserved word (see Grammar ) the behavior is
undefined. The characters following the equal sign shall be
interpreted as if they appeared in the <i>awk</i> program
preceded and followed by a double-quote ( <b>&rsquo;
)&rsquo;</b> character, as a <b>STRING</b> token (see
Grammar ), except that if the last character is an unescaped
backslash, it shall be interpreted as a literal backslash
rather than as the first character of the sequence
<b>&quot;\&quot;&quot;</b> . The variable shall be assigned
the value of that <b>STRING</b> token and, if appropriate,
shall be considered a <i>numeric string</i> (see Expressions
in awk ), the variable shall also be assigned its numeric
value. Each such variable assignment shall occur just prior
to the processing of the following <i>file</i>, if any.
Thus, an assignment before the first <i>file</i> argument
shall be executed after the <b>BEGIN</b> actions (if any),
while an assignment after the last <i>file</i> argument
shall occur before the <b>END</b> actions (if any). If there
are no <i>file</i> arguments, assignments shall be executed
before processing the standard input.</p>

<h2>STDIN
<a name="STDIN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The standard
input shall be used only if no <i>file</i> operands are
specified, or if a <i>file</i> operand is
<b>&rsquo;-&rsquo;</b> ; see the INPUT FILES section. If the
<i>awk</i> program contains no actions and no patterns, but
is otherwise a valid <i>awk</i> program, standard input and
any <i>file</i> operands shall not be read and <i>awk</i>
shall exit with a return status of zero.</p>

<h2>INPUT FILES
<a name="INPUT FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Input files to
the <i>awk</i> program from any of the following sources
shall be text files:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Any <i>file</i> operands or their equivalents, achieved
by modifying the <i>awk</i> variables <b>ARGV</b> and
<b>ARGC</b></p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Standard input in the absence of any <i>file</i>
operands</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Arguments to the <b>getline</b> function</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Whether the
variable <b>RS</b> is set to a value other than a
&lt;newline&gt; or not, for these files, implementations
shall support records terminated with the specified
separator up to {LINE_MAX} bytes and may support longer
records.</p>

<p style="margin-left:11%; margin-top: 1em">If <b>-f</b>
<i>progfile</i> is specified, the application shall ensure
that the files named by each of the <i>progfile</i>
option-arguments are text files and their concatenation, in
the same order as they appear in the arguments, is an
<i>awk</i> program.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
environment variables shall affect the execution of
<i>awk</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>LANG</i></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Provide a default value for the
internationalization variables that are unset or null. (See
the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, Section 8.2,
Internationalization Variables for the precedence of
internationalization variables used to determine the values
of locale categories.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>LC_ALL</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>If set to a non-empty string value, override the values
of all the other internationalization variables.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>LC_COLLATE</i></p>

<p style="margin-left:22%;">Determine the locale for the
behavior of ranges, equivalence classes, and multi-character
collating elements within regular expressions and in
comparisons of string values.</p>

<p style="margin-left:11%;"><i>LC_CTYPE</i></p>

<p style="margin-left:22%;">Determine the locale for the
interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments and input files), the
behavior of character classes within regular expressions,
the identification of characters as letters, and the mapping
of uppercase and lowercase characters for the <b>toupper</b>
and <b>tolower</b> functions.</p>

<p style="margin-left:11%;"><i>LC_MESSAGES</i></p>

<p style="margin-left:22%;">Determine the locale that
should be used to affect the format and contents of
diagnostic messages written to standard error.</p>

<p style="margin-left:11%;"><i>LC_NUMERIC</i></p>

<p style="margin-left:22%;">Determine the radix character
used when interpreting numeric input, performing conversions
between numeric and string values, and formatting numeric
output. Regardless of locale, the period character (the
decimal-point character of the POSIX locale) is the
decimal-point character recognized in processing <i>awk</i>
programs (including assignments in command line
arguments).</p>

<p style="margin-left:11%;"><i>NLSPATH</i></p>

<p style="margin-left:22%;">Determine the location of
message catalogs for the processing of <i>LC_MESSAGES
.</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>PATH</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>Determine the search path when looking for commands
executed by <i>system</i>(<i>expr</i>), or input and output
pipes; see the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 8, Environment
Variables.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In addition,
all environment variables shall be visible via the
<i>awk</i> variable <b>ENVIRON</b>.</p>

<h2>ASYNCHRONOUS EVENTS
<a name="ASYNCHRONOUS EVENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Default.</p>

<h2>STDOUT
<a name="STDOUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The nature of
the output files depends on the <i>awk</i> program.</p>

<h2>STDERR
<a name="STDERR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The standard
error shall be used only for diagnostic messages.</p>

<h2>OUTPUT FILES
<a name="OUTPUT FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The nature of
the output files depends on the <i>awk</i> program.</p>

<h2>EXTENDED DESCRIPTION
<a name="EXTENDED DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Overall
Program Structure</b> <br>
An <i>awk</i> program is composed of pairs of the form:</p>

<p style="margin-left:22%; margin-top: 1em"><i>pattern</i>
<b>{</b> <i>action</i> <b>}</b></p>

<p style="margin-left:11%; margin-top: 1em">Either the
pattern or the action (including the enclosing brace
characters) can be omitted.</p>

<p style="margin-left:11%; margin-top: 1em">A missing
pattern shall match any record of input, and a missing
action shall be equivalent to:</p>

<p style="margin-left:22%; margin-top: 1em"><b>{ print
}</b></p>

<p style="margin-left:11%; margin-top: 1em">Execution of
the <i>awk</i> program shall start by first executing the
actions associated with all <b>BEGIN</b> patterns in the
order they occur in the program. Then each <i>file</i>
operand (or standard input if no files were specified) shall
be processed in turn by reading data from the file until a
record separator is seen ( &lt;newline&gt; by default).
Before the first reference to a field in the record is
evaluated, the record shall be split into fields, according
to the rules in Regular Expressions, using the value of
<b>FS</b> that was current at the time the record was read.
Each pattern in the program then shall be evaluated in the
order of occurrence, and the action associated with each
pattern that matches the current record executed. The action
for a matching pattern shall be executed before evaluating
subsequent patterns. Finally, the actions associated with
all <b>END</b> patterns shall be executed in the order they
occur in the program.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Expressions
in awk</b> <br>
Expressions describe computations used in <i>patterns</i>
and <i>actions</i>. In the following table, valid expression
operations are given in groups from highest precedence first
to lowest precedence last, with equal-precedence operators
grouped between horizontal lines. In expression evaluation,
where the grammar is formally ambiguous, higher precedence
operators shall be evaluated before lower precedence
operators. In this table <i>expr</i>, <i>expr1</i>,
<i>expr2</i>, and <i>expr3</i> represent any expression,
while lvalue represents any entity that can be assigned to
(that is, on the left side of an assignment operator). The
precise syntax of expressions is given in Grammar .</p>

<p align="center" style="margin-top: 1em"><b>Table:
Expressions in Decreasing Precedence in</b> <i>awk</i></p>

<p style="margin-top: 1em"><i>&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;</i></p>

<p style="margin-top: 1em">Each expression shall have
either a string value, a numeric value, or both. Except as
stated for specific contexts, the value of an expression
shall be implicitly converted to the type needed for the
context in which it is used. A string value shall be
converted to a numeric value by the equivalent of the
following calls to functions defined by the ISO&nbsp;C
standard:</p>


<p style="margin-left:22%; margin-top: 1em"><b>setlocale(LC_NUMERIC,
&quot;&quot;);</b> <i><br>
numeric_value</i> <b>=
atof(</b><i>string_value</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">A numeric value
that is exactly equal to the value of an integer (see
<i>Concepts Derived from the ISO C Standard</i> ) shall be
converted to a string by the equivalent of a call to the
<b>sprintf</b> function (see String Functions ) with the
string <b>&quot;%d&quot;</b> as the <i>fmt</i> argument and
the numeric value being converted as the first and only
<i>expr</i> argument. Any other numeric value shall be
converted to a string by the equivalent of a call to the
<b>sprintf</b> function with the value of the variable
<b>CONVFMT</b> as the <i>fmt</i> argument and the numeric
value being converted as the first and only <i>expr</i>
argument. The result of the conversion is unspecified if the
value of <b>CONVFMT</b> is not a floating-point format
specification. This volume of IEEE&nbsp;Std&nbsp;1003.1-2001
specifies no explicit conversions between numbers and
strings. An application can force an expression to be
treated as a number by adding zero to it, or can force it to
be treated as a string by concatenating the null string (
<b>&quot;&quot;</b> ) to it.</p>

<p style="margin-left:11%; margin-top: 1em">A string value
shall be considered a <i>numeric string</i> if it comes from
one of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Field variables</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p>Input from the <i>getline</i>() function</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>FILENAME</b></p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>ARGV</b> array elements</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>5.</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>ENVIRON</b> array elements</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>6.</p></td>
<td width="2%"></td>
<td width="83%">


<p>Array elements created by the <i>split</i>()
function</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>7.</p></td>
<td width="2%"></td>
<td width="83%">


<p>A command line variable assignment</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>8.</p></td>
<td width="2%"></td>
<td width="83%">


<p>Variable assignment from another numeric string
variable</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">and after all
the following conversions have been applied, the resulting
string would lexically be recognized as a <b>NUMBER</b>
token as described by the lexical conventions in Grammar
:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">All leading and trailing
&lt;blank&gt;s are discarded.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the first non- &lt;blank&gt; is
<b>&rsquo;+&rsquo;</b> or <b>&rsquo;-&rsquo;</b>, it is
discarded.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Changing each occurrence of the decimal point character
from the current locale to a period.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If a
<b>&rsquo;-&rsquo;</b> character is ignored in the preceding
description, the numeric value of the <i>numeric string</i>
shall be the negation of the numeric value of the recognized
<b>NUMBER</b> token. Otherwise, the numeric value of the
<i>numeric string</i> shall be the numeric value of the
recognized <b>NUMBER</b> token. Whether or not a string is a
<i>numeric string</i> shall be relevant only in contexts
where that term is used in this section.</p>

<p style="margin-left:11%; margin-top: 1em">When an
expression is used in a Boolean context, if it has a numeric
value, a value of zero shall be treated as false and any
other value shall be treated as true. Otherwise, a string
value of the null string shall be treated as false and any
other value shall be treated as true. A Boolean context
shall be one of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">The first subexpression of a
conditional expression</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>An expression operated on by logical NOT, logical AND,
or logical OR</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The second expression of a <b>for</b> statement</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The expression of an <b>if</b> statement</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The expression of the <b>while</b> clause in either a
<b>while</b> or <b>do</b>... <b>while</b> statement</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>An expression used as a pattern (as in Overall Program
Structure)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">All arithmetic
shall follow the semantics of floating-point arithmetic as
specified by the ISO&nbsp;C standard (see <i>Concepts
Derived from the ISO C Standard</i> ).</p>

<p style="margin-left:11%; margin-top: 1em">The value of
the expression:</p>

<p style="margin-left:22%; margin-top: 1em"><i>expr1</i>
<b>^</b> <i>expr2</i></p>

<p style="margin-left:11%; margin-top: 1em">shall be
equivalent to the value returned by the ISO&nbsp;C standard
function call:</p>


<p style="margin-left:22%; margin-top: 1em"><b>pow(</b><i>expr1</i><b>,</b>
<i>expr2</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">The
expression:</p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue
^=</b> <i>expr</i></p>

<p style="margin-left:11%; margin-top: 1em">shall be
equivalent to the ISO&nbsp;C standard expression:</p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue =
pow(lvalue,</b> <i>expr</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">except that
lvalue shall be evaluated only once. The value of the
expression:</p>

<p style="margin-left:22%; margin-top: 1em"><i>expr1</i>
<b>%</b> <i>expr2</i></p>

<p style="margin-left:11%; margin-top: 1em">shall be
equivalent to the value returned by the ISO&nbsp;C standard
function call:</p>


<p style="margin-left:22%; margin-top: 1em"><b>fmod(</b><i>expr1</i><b>,</b>
<i>expr2</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">The
expression:</p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue
%=</b> <i>expr</i></p>

<p style="margin-left:11%; margin-top: 1em">shall be
equivalent to the ISO&nbsp;C standard expression:</p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue =
fmod(lvalue,</b> <i>expr</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">except that
lvalue shall be evaluated only once.</p>

<p style="margin-left:11%; margin-top: 1em">Variables and
fields shall be set by the assignment statement:</p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue =</b>
<i>expression</i></p>

<p style="margin-left:11%; margin-top: 1em">and the type of
<i>expression</i> shall determine the resulting variable
type. The assignment includes the arithmetic assignments (
<b>&quot;+=&quot;</b>, <b>&quot;-=&quot;</b>,
<b>&quot;*=&quot;</b>, <b>&quot;/=&quot;</b>,
<b>&quot;%=&quot;</b>, <b>&quot;^=&quot;</b>,
<b>&quot;++&quot;</b>, <b>&quot;--&quot;</b> ) all of which
shall produce a numeric result. The left-hand side of an
assignment and the target of increment and decrement
operators can be one of a variable, an array with index, or
a field selector.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>awk</i>
language supplies arrays that are used for storing numbers
or strings. Arrays need not be declared. They shall
initially be empty, and their sizes shall change
dynamically. The subscripts, or element identifiers, are
strings, providing a type of associative array capability.
An array name followed by a subscript within square brackets
can be used as an lvalue and thus as an expression, as
described in the grammar; see Grammar . Unsubscripted array
names can be used in only the following contexts:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">A parameter in a function
definition or function call</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The <b>NAME</b> token following any use of the keyword
<b>in</b> as specified in the grammar (see Grammar ); if the
name used in this context is not an array name, the behavior
is undefined</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A valid array
<i>index</i> shall consist of one or more comma-separated
expressions, similar to the way in which multi-dimensional
arrays are indexed in some programming languages. Because
<i>awk</i> arrays are really one-dimensional, such a
comma-separated list shall be converted to a single string
by concatenating the string values of the separate
expressions, each separated from the other by the value of
the <b>SUBSEP</b> variable. Thus, the following two index
operations shall be equivalent:</p>


<p style="margin-left:22%; margin-top: 1em"><i>var</i><b>[</b><i>expr1</i><b>,</b>
<i>expr2</i><b>, ...</b> <i>exprn</i><b>]</b></p>


<p style="margin-left:22%; margin-top: 1em"><i>var</i><b>[</b><i>expr1</i>
<b>SUBSEP</b> <i>expr2</i> <b>SUBSEP ... SUBSEP</b>
<i>exprn</i><b>]</b></p>

<p style="margin-left:11%; margin-top: 1em">The application
shall ensure that a multi-dimensioned <i>index</i> used with
the <b>in</b> operator is parenthesized. The <b>in</b>
operator, which tests for the existence of a particular
array element, shall not cause that element to exist. Any
other reference to a nonexistent array element shall
automatically create it.</p>

<p style="margin-left:11%; margin-top: 1em">Comparisons
(with the <b>&rsquo;&lt;&rsquo;</b>,
<b>&quot;&lt;=&quot;</b>, <b>&quot;!=&quot;</b>,
<b>&quot;==&quot;</b>, <b>&rsquo;&gt;&rsquo;</b>, and
<b>&quot;&gt;=&quot;</b> operators) shall be made
numerically if both operands are numeric, if one is numeric
and the other has a string value that is a numeric string,
or if one is numeric and the other has the uninitialized
value. Otherwise, operands shall be converted to strings as
required and a string comparison shall be made using the
locale-specific collation sequence. The value of the
comparison expression shall be 1 if the relation is true, or
0 if the relation is false.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Variables
and Special Variables</b> <br>
Variables can be used in an <i>awk</i> program by
referencing them. With the exception of function parameters
(see User-Defined Functions ), they are not explicitly
declared. Function parameter names shall be local to the
function; all other variable names shall be global. The same
name shall not be used as both a function parameter name and
as the name of a function or a special <i>awk</i> variable.
The same name shall not be used both as a variable name with
global scope and as the name of a function. The same name
shall not be used within the same scope both as a scalar
variable and as an array. Uninitialized variables, including
scalar variables, array elements, and field variables, shall
have an uninitialized value. An uninitialized value shall
have both a numeric value of zero and a string value of the
empty string. Evaluation of variables with an uninitialized
value, to either string or numeric, shall be determined by
the context in which they are used.</p>

<p style="margin-left:11%; margin-top: 1em">Field variables
shall be designated by a <b>&rsquo;$&rsquo;</b> followed by
a number or numerical expression. The effect of the field
number <i>expression</i> evaluating to anything other than a
non-negative integer is unspecified; uninitialized variables
or string values need not be converted to numeric values in
this context. New field variables can be created by
assigning a value to them. References to nonexistent fields
(that is, fields after $<b>NF</b>), shall evaluate to the
uninitialized value. Such references shall not create new
fields. However, assigning to a nonexistent field (for
example, $(<b>NF</b>+2)=5) shall increase the value of
<b>NF</b>; create any intervening fields with the
uninitialized value; and cause the value of $0 to be
recomputed, with the fields being separated by the value of
<b>OFS</b>. Each field variable shall have a string value or
an uninitialized value when created. Field variables shall
have the uninitialized value when created from $0 using
<b>FS</b> and the variable does not contain any characters.
If appropriate, the field variable shall be considered a
numeric string (see Expressions in awk ).</p>


<p style="margin-left:11%; margin-top: 1em">Implementations
shall support the following other special variables that are
set by <i>awk</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>ARGC</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">The number of elements in the
<b>ARGV</b> array.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>ARGV</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>An array of command line arguments, excluding options
and the <i>program</i> argument, numbered from zero to
<b>ARGC</b>-1.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The arguments
in <b>ARGV</b> can be modified or added to; <b>ARGC</b> can
be altered. As each input file ends, <i>awk</i> shall treat
the next non-null element of <b>ARGV</b>, up to the current
value of <b>ARGC</b>-1, inclusive, as the name of the next
input file. Thus, setting an element of <b>ARGV</b> to null
means that it shall not be treated as an input file. The
name <b>&rsquo;-&rsquo;</b> indicates the standard input. If
an argument matches the format of an <i>assignment</i>
operand, this argument shall be treated as an
<i>assignment</i> rather than a <i>file</i> argument.
<b><br>
CONVFMT</b></p>

<p style="margin-left:22%;">The <b>printf</b> format for
converting numbers to strings (except for output statements,
where <b>OFMT</b> is used); <b>&quot;%.6g&quot;</b> by
default.</p>

<p style="margin-left:11%;"><b>ENVIRON</b></p>

<p style="margin-left:22%;">An array representing the value
of the environment, as described in the <i>exec</i>
functions defined in the System Interfaces volume of
IEEE&nbsp;Std&nbsp;1003.1-2001. The indices of the array
shall be strings consisting of the names of the environment
variables, and the value of each array element shall be a
string consisting of the value of that variable. If
appropriate, the environment variable shall be considered a
<i>numeric string</i> (see Expressions in awk ); the array
element shall also have its numeric value.</p>

<p style="margin-left:11%; margin-top: 1em">In all cases
where the behavior of <i>awk</i> is affected by environment
variables (including the environment of any commands that
<i>awk</i> executes via the <b>system</b> function or via
pipeline redirections with the <b>print</b> statement, the
<b>printf</b> statement, or the <b>getline</b> function),
the environment used shall be the environment at the time
<i>awk</i> began executing; it is implementation-defined
whether any modification of <b>ENVIRON</b> affects this
environment. <b><br>
FILENAME</b></p>

<p style="margin-left:22%;">A pathname of the current input
file. Inside a <b>BEGIN</b> action the value is undefined.
Inside an <b>END</b> action the value shall be the name of
the last input file processed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>FNR</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The ordinal number of the current record in the current
file. Inside a <b>BEGIN</b> action the value shall be zero.
Inside an <b>END</b> action the value shall be the number of
the last record processed in the last file processed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>FS</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Input field separator regular expression; a
&lt;space&gt; by default.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>NF</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The number of fields in the current record. Inside a
<b>BEGIN</b> action, the use of <b>NF</b> is undefined
unless a <b>getline</b> function without a <i>var</i>
argument is executed previously. Inside an <b>END</b>
action, <b>NF</b> shall retain the value it had for the last
record read, unless a subsequent, redirected, <b>getline</b>
function without a <i>var</i> argument is performed prior to
entering the <b>END</b> action.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>NR</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The ordinal number of the current record from the start
of input. Inside a <b>BEGIN</b> action the value shall be
zero. Inside an <b>END</b> action the value shall be the
number of the last record processed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>OFMT</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <b>printf</b> format for converting numbers to
strings in output statements (see Output Statements );
<b>&quot;%.6g&quot;</b> by default. The result of the
conversion is unspecified if the value of <b>OFMT</b> is not
a floating-point format specification.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>OFS</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <b>print</b> statement output field separation;
&lt;space&gt; by default.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>ORS</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <b>print</b> statement output record separator; a
&lt;newline&gt; by default.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>RLENGTH</b></p>

<p style="margin-left:22%;">The length of the string
matched by the <b>match</b> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>RS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The first character of the string value of <b>RS</b>
shall be the input record separator; a &lt;newline&gt; by
default. If <b>RS</b> contains more than one character, the
results are unspecified. If <b>RS</b> is null, then records
are separated by sequences consisting of a &lt;newline&gt;
plus one or more blank lines, leading or trailing blank
lines shall not result in empty records at the beginning or
end of the input, and a &lt;newline&gt; shall always be a
field separator, no matter what the value of <b>FS</b>
is.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>RSTART</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The starting position of the string matched by the
<b>match</b> function, numbering from 1. This shall always
be equivalent to the return value of the <b>match</b>
function.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>SUBSEP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The subscript separator string for multi-dimensional
arrays; the default value is implementation-defined.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Regular
Expressions</b> <br>
The <i>awk</i> utility shall make use of the extended
regular expression notation (see the Base Definitions volume
of IEEE&nbsp;Std&nbsp;1003.1-2001, Section 9.4, Extended
Regular Expressions) except that it shall allow the use of
C-language conventions for escaping special characters
within the EREs, as specified in the table in the Base
Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
Chapter 5, File Format Notation ( <b>&rsquo;\\&rsquo;</b>,
<b>&rsquo;\a&rsquo;</b>, <b>&rsquo;\b&rsquo;</b>,
<b>&rsquo;\f&rsquo;</b>, <b>&rsquo;\n&rsquo;</b>,
<b>&rsquo;\r&rsquo;</b>, <b>&rsquo;\t&rsquo;</b>,
<b>&rsquo;\v&rsquo;</b> ) and the following table; these
escape sequences shall be recognized both inside and outside
bracket expressions. Note that records need not be separated
by &lt;newline&gt;s and string constants can contain
&lt;newline&gt;s, so even the <b>&quot;\n&quot;</b> sequence
is valid in <i>awk</i> EREs. Using a slash character within
an ERE requires the escaping shown in the following
table.</p>

<p align="center" style="margin-top: 1em"><b>Table: Escape
Sequences in</b> <i>awk</i></p>

<p style="margin-top: 1em"><i>&nbsp; &nbsp; &nbsp;
&nbsp;</i></p>

<p style="margin-top: 1em">A regular expression can be
matched against a specific field or string by using one of
the two regular expression matching operators,
<b>&rsquo;~&rsquo;</b> and <b>&quot;!~&quot;</b> . These
operators shall interpret their right-hand operand as a
regular expression and their left-hand operand as a string.
If the regular expression matches the string, the
<b>&rsquo;~&rsquo;</b> expression shall evaluate to a value
of 1, and the <b>&quot;!~&quot;</b> expression shall
evaluate to a value of 0. (The regular expression matching
operation is as defined by the term matched in the Base
Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
Section 9.1, Regular Expression Definitions, where a match
occurs on any part of the string unless the regular
expression is limited with the circumflex or dollar sign
special characters.) If the regular expression does not
match the string, the <b>&rsquo;~&rsquo;</b> expression
shall evaluate to a value of 0, and the
<b>&quot;!~&quot;</b> expression shall evaluate to a value
of 1. If the right-hand operand is any expression other than
the lexical token <b>ERE</b>, the string value of the
expression shall be interpreted as an extended regular
expression, including the escape conventions described
above. Note that these same escape conventions shall also be
applied in determining the value of a string literal (the
lexical token <b>STRING</b>), and thus shall be applied a
second time when a string literal is used in this
context.</p>

<p style="margin-top: 1em">When an <b>ERE</b> token appears
as an expression in any context other than as the right-hand
of the <b>&rsquo;~&rsquo;</b> or <b>&quot;!~&quot;</b>
operator or as one of the built-in function arguments
described below, the value of the resulting expression shall
be the equivalent of:</p>

<p style="margin-left:22%; margin-top: 1em"><b>$0 ~
/</b><i>ere</i><b>/</b></p>

<p style="margin-left:11%; margin-top: 1em">The <i>ere</i>
argument to the <b>gsub</b>, <b>match</b>, <b>sub</b>
functions, and the <i>fs</i> argument to the <b>split</b>
function (see String Functions ) shall be interpreted as
extended regular expressions. These can be either <b>ERE</b>
tokens or arbitrary expressions, and shall be interpreted in
the same manner as the right-hand side of the
<b>&rsquo;~&rsquo;</b> or <b>&quot;!~&quot;</b>
operator.</p>

<p style="margin-left:11%; margin-top: 1em">An extended
regular expression can be used to separate fields by using
the <b>-F</b> <i>ERE</i> option or by assigning a string
containing the expression to the built-in variable
<b>FS</b>. The default value of the <b>FS</b> variable shall
be a single &lt;space&gt;. The following describes <b>FS</b>
behavior:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em">If <b>FS</b> is a null string,
the behavior is unspecified.</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="80%">


<p>If <b>FS</b> is a single character:</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:17%;">a.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="10%"></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">If <b>FS</b> is &lt;space&gt;,
skip leading and trailing &lt;blank&gt;s; fields shall be
delimited by sets of one or more &lt;blank&gt;s.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="10%">


<p>b.</p></td>
<td width="1%"></td>
<td width="77%">


<p>Otherwise, if <b>FS</b> is any other character <i>c</i>,
fields shall be delimited by each single occurrence of
<i>c</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="10%">


<p>3.</p></td>
<td width="1%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Otherwise, the
string value of <b>FS</b> shall be considered to be an
extended regular expression. Each occurrence of a sequence
matching the extended regular expression shall delimit
fields.</p>

<p style="margin-left:11%; margin-top: 1em">Except for the
<b>&rsquo;~&rsquo;</b> and <b>&quot;!~&quot;</b> operators,
and in the <b>gsub</b>, <b>match</b>, <b>split</b>, and
<b>sub</b> built-in functions, ERE matching shall be based
on input records; that is, record separator characters (the
first character of the value of the variable <b>RS</b>,
&lt;newline&gt; by default) cannot be embedded in the
expression, and no expression shall match the record
separator character. If the record separator is not
&lt;newline&gt;, &lt;newline&gt;s embedded in the expression
can be matched. For the <b>&rsquo;~&rsquo;</b> and
<b>&quot;!~&quot;</b> operators, and in those four built-in
functions, ERE matching shall be based on text strings; that
is, any character (including &lt;newline&gt; and the record
separator) can be embedded in the pattern, and an
appropriate pattern shall match any character. However, in
all <i>awk</i> ERE matching, the use of one or more NUL
characters in the pattern, input record, or text string
produces undefined results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Patterns</b>
<br>
A <i>pattern</i> is any valid <i>expression</i>, a range
specified by two expressions separated by a comma, or one of
the two special patterns <b>BEGIN</b> or <b>END</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Special
Patterns</b> <br>
The <i>awk</i> utility shall recognize two special patterns,
<b>BEGIN</b> and <b>END</b>. Each <b>BEGIN</b> pattern shall
be matched once and its associated action executed before
the first record of input is read (except possibly by use of
the <b>getline</b> function-see Input/Output and General
Functions - in a prior <b>BEGIN</b> action) and before
command line assignment is done. Each <b>END</b> pattern
shall be matched once and its associated action executed
after the last record of input has been read. These two
patterns shall have associated actions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>BEGIN</b>
and <b>END</b> shall not combine with other patterns.
Multiple <b>BEGIN</b> and <b>END</b> patterns shall be
allowed. The actions associated with the <b>BEGIN</b>
patterns shall be executed in the order specified in the
program, as are the <b>END</b> actions. An <b>END</b>
pattern can precede a <b>BEGIN</b> pattern in a program.</p>

<p style="margin-left:11%; margin-top: 1em">If an
<i>awk</i> program consists of only actions with the pattern
<b>BEGIN</b>, and the <b>BEGIN</b> action contains no
<b>getline</b> function, <i>awk</i> shall exit without
reading its input when the last statement in the last
<b>BEGIN</b> action is executed. If an <i>awk</i> program
consists of only actions with the pattern <b>END</b> or only
actions with the patterns <b>BEGIN</b> and <b>END</b>, the
input shall be read before the statements in the <b>END</b>
actions are executed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Expression
Patterns</b> <br>
An expression pattern shall be evaluated as if it were an
expression in a Boolean context. If the result is true, the
pattern shall be considered to match, and the associated
action (if any) shall be executed. If the result is false,
the action shall not be executed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pattern
Ranges</b> <br>
A pattern range consists of two expressions separated by a
comma; in this case, the action shall be performed for all
records between a match of the first expression and the
following match of the second expression, inclusive. At this
point, the pattern range can be repeated starting at input
records subsequent to the end of the matched range.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Actions</b>
<br>
An action is a sequence of statements as shown in the
grammar in Grammar . Any single statement can be replaced by
a statement list enclosed in braces. The application shall
ensure that statements in a statement list are separated by
&lt;newline&gt;s or semicolons. Statements in a statement
list shall be executed sequentially in the order that they
appear.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>expression</i> acting as the conditional in an <b>if</b>
statement shall be evaluated and if it is non-zero or
non-null, the following statement shall be executed;
otherwise, if <b>else</b> is present, the statement
following the <b>else</b> shall be executed.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>if</b>,
<b>while</b>, <b>do</b>... <b>while</b>, <b>for</b>,
<b>break</b>, and <b>continue</b> statements are based on
the ISO&nbsp;C standard (see <i>Concepts Derived from the
ISO C Standard</i> ), except that the Boolean expressions
shall be treated as described in Expressions in awk , and
except in the case of:</p>

<p style="margin-left:22%; margin-top: 1em"><b>for
(</b><i>variable</i> <b>in</b> <i>array</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">which shall
iterate, assigning each <i>index</i> of <i>array</i> to
<i>variable</i> in an unspecified order. The results of
adding new elements to <i>array</i> within such a <b>for</b>
loop are undefined. If a <b>break</b> or <b>continue</b>
statement occurs outside of a loop, the behavior is
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>delete</b> statement shall remove an individual array
element. Thus, the following code deletes an entire
array:</p>

<p style="margin-left:22%; margin-top: 1em"><b>for (index
in array) <br>
delete array[index]</b></p>

<p style="margin-left:11%; margin-top: 1em">The <b>next</b>
statement shall cause all further processing of the current
input record to be abandoned. The behavior is undefined if a
<b>next</b> statement appears or is invoked in a
<b>BEGIN</b> or <b>END</b> action.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>exit</b>
statement shall invoke all <b>END</b> actions in the order
in which they occur in the program source and then terminate
the program without reading further input. An <b>exit</b>
statement inside an <b>END</b> action shall terminate the
program without further execution of <b>END</b> actions. If
an expression is specified in an <b>exit</b> statement, its
numeric value shall be the exit status of <i>awk</i>, unless
subsequent errors are encountered or a subsequent
<b>exit</b> statement with an expression is executed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Output
Statements</b> <br>
Both <b>print</b> and <b>printf</b> statements shall write
to standard output by default. The output shall be written
to the location specified by <i>output_redirection</i> if
one is supplied, as follows:</p>

<p style="margin-left:22%; margin-top: 1em"><b>&gt;</b>
<i>expression</i><b>&gt;&gt;</b> <i>expression</i><b>|</b>
<i>expression</i></p>

<p style="margin-left:11%; margin-top: 1em">In all cases,
the <i>expression</i> shall be evaluated to produce a string
that is used as a pathname into which to write (for
<b>&rsquo;&gt;&rsquo;</b> or <b>&quot;&gt;&gt;&quot;</b> )
or as a command to be executed (for <b>&rsquo;|&rsquo;</b>
). Using the first two forms, if the file of that name is
not currently open, it shall be opened, creating it if
necessary and using the first form, truncating the file. The
output then shall be appended to the file. As long as the
file remains open, subsequent calls in which
<i>expression</i> evaluates to the same string value shall
simply append output to the file. The file remains open
until the <b>close</b> function (see Input/Output and
General Functions ) is called with an expression that
evaluates to the same string value.</p>

<p style="margin-left:11%; margin-top: 1em">The third form
shall write output onto a stream piped to the input of a
command. The stream shall be created if no stream is
currently open with the value of <i>expression</i> as its
command name. The stream created shall be equivalent to one
created by a call to the <i>popen</i>() function defined in
the System Interfaces volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 with the value of
<i>expression</i> as the <i>command</i> argument and a value
of <i>w</i> as the <i>mode</i> argument. As long as the
stream remains open, subsequent calls in which
<i>expression</i> evaluates to the same string value shall
write output to the existing stream. The stream shall remain
open until the <b>close</b> function (see Input/Output and
General Functions ) is called with an expression that
evaluates to the same string value. At that time, the stream
shall be closed as if by a call to the <i>pclose</i>()
function defined in the System Interfaces volume of
IEEE&nbsp;Std&nbsp;1003.1-2001.</p>

<p style="margin-left:11%; margin-top: 1em">As described in
detail by the grammar in Grammar , these output statements
shall take a comma-separated list of <i>expression</i>s
referred to in the grammar by the non-terminal symbols
<b>expr_list</b>, <b>print_expr_list</b>, or
<b>print_expr_list_opt</b>. This list is referred to here as
the <i>expression list</i>, and each member is referred to
as an <i>expression argument</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>print</b> statement shall write the value of each
expression argument onto the indicated output stream
separated by the current output field separator (see
variable <b>OFS</b> above), and terminated by the output
record separator (see variable <b>ORS</b> above). All
expression arguments shall be taken as strings, being
converted if necessary; this conversion shall be as
described in Expressions in awk , with the exception that
the <b>printf</b> format in <b>OFMT</b> shall be used
instead of the value in <b>CONVFMT</b>. An empty expression
list shall stand for the whole input record ($0).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>printf</b> statement shall produce output based on a
notation similar to the File Format Notation used to
describe file formats in this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 (see the Base Definitions
volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 5, File
Format Notation). Output shall be produced as specified with
the first <i>expression</i> argument as the string
<i>format</i> and subsequent <i>expression</i> arguments as
the strings <i>arg1</i> to <i>argn</i>, inclusive, with the
following exceptions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The <i>format</i> shall be an
actual character string rather than a graphical
representation. Therefore, it cannot contain empty character
positions. The &lt;space&gt; in the <i>format</i> string, in
any context other than a <i>flag</i> of a conversion
specification, shall be treated as an ordinary character
that is copied to the output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p>If the character set contains a <b>&rsquo; &rsquo;</b>
character and that character appears in the <i>format</i>
string, it shall be treated as an ordinary character that is
copied to the output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The <i>escape sequences</i> beginning with a backslash
character shall be treated as sequences of ordinary
characters that are copied to the output. Note that these
same sequences shall be interpreted lexically by <i>awk</i>
when they appear in literal strings, but they shall not be
treated specially by the <b>printf</b> statement.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>4.</p></td>
<td width="2%"></td>
<td width="83%">


<p>A <i>field width</i> or <i>precision</i> can be
specified as the <b>&rsquo;*&rsquo;</b> character instead of
a digit string. In this case the next argument from the
expression list shall be fetched and its numeric value taken
as the field width or precision.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>5.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The implementation shall not precede or follow output
from the <b>d</b> or <b>u</b> conversion specifier
characters with &lt;blank&gt;s not specified by the
<i>format</i> string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>6.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The implementation shall not precede output from the
<b>o</b> conversion specifier character with leading zeros
not specified by the <i>format</i> string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>7.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For the <b>c</b> conversion specifier character: if the
argument has a numeric value, the character whose encoding
is that value shall be output. If the value is zero or is
not the encoding of any character in the character set, the
behavior is undefined. If the argument does not have a
numeric value, the first character of the string value shall
be output; if the string does not contain any characters,
the behavior is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>8.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each conversion specification that consumes an
argument, the next expression argument shall be evaluated.
With the exception of the <b>c</b> conversion specifier
character, the value shall be converted (according to the
rules specified in Expressions in awk ) to the appropriate
type for the conversion specification.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>9.</p></td>
<td width="2%"></td>
<td width="83%">


<p>If there are insufficient expression arguments to
satisfy all the conversion specifications in the
<i>format</i> string, the behavior is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>10.</p></td>
<td width="2%"></td>
<td width="83%">


<p>If any character sequence in the <i>format</i> string
begins with a <b>&rsquo;%&rsquo;</b> character, but does not
form a valid conversion specification, the behavior is
unspecified.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Both
<b>print</b> and <b>printf</b> can output at least
{LINE_MAX} bytes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b>
<br>
The <i>awk</i> language has a variety of built-in functions:
arithmetic, string, input/output, and general.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Arithmetic
Functions</b> <br>
The arithmetic functions, except for <b>int</b>, shall be
based on the ISO&nbsp;C standard (see <i>Concepts Derived
from the ISO C Standard</i> ). The behavior is undefined in
cases where the ISO&nbsp;C standard specifies that an error
be returned or that the behavior is undefined. Although the
grammar (see Grammar ) permits built-in functions to appear
with no arguments or parentheses, unless the argument or
parentheses are indicated as optional in the following list
(by displaying them within the <b>&quot;[]&quot;</b>
brackets), such use is undefined. <b><br>
atan2</b>(<i>y</i>,<i>x</i>)</p>

<p style="margin-left:22%;">Return arctangent of
<i>y</i>/<i>x</i> in radians in the range [-pi,pi].</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>cos</b>(<i>x</i>)</p></td>
<td width="2%"></td>
<td width="64%">


<p>Return cosine of <i>x</i>, where <i>x</i> is in
radians.</p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>sin</b>(<i>x</i>)</p></td>
<td width="2%"></td>
<td width="64%">


<p>Return sine of <i>x</i>, where <i>x</i> is in
radians.</p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>exp</b>(<i>x</i>)</p></td>
<td width="2%"></td>
<td width="64%">


<p>Return the exponential function of <i>x</i>.</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>log</b>(<i>x</i>)</p></td>
<td width="2%"></td>
<td width="64%">


<p>Return the natural logarithm of <i>x</i>.</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>sqrt</b>(<i>x</i>)</p>

<p style="margin-left:22%;">Return the square root of
<i>x</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>int</b>(<i>x</i>)</p></td>
<td width="2%"></td>
<td width="78%">


<p>Return the argument truncated to an integer. Truncation
shall be toward 0 when <i>x</i>&gt;0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>rand</b>()</p></td>
<td width="2%"></td>
<td width="78%">


<p>Return a random number <i>n</i>, such that
0&lt;=<i>n</i>&lt;1.</p> </td></tr>
</table>


<p style="margin-left:11%;"><b>srand</b>(<b>[</b><i>expr</i><b>]</b>)</p>

<p style="margin-left:22%;">Set the seed value for
<i>rand</i> to <i>expr</i> or use the time of day if
<i>expr</i> is omitted. The previous seed value shall be
returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>String
Functions</b> <br>
The string functions in the following list shall be
supported. Although the grammar (see Grammar ) permits
built-in functions to appear with no arguments or
parentheses, unless the argument or parentheses are
indicated as optional in the following list (by displaying
them within the <b>&quot;[]&quot;</b> brackets), such use is
undefined. <b><br>

gsub</b>(<i>ere</i>,&nbsp;<i>repl</i><b>[</b>,&nbsp;<i>in</i><b>]</b>)</p>

<p style="margin-left:22%;">Behave like <b>sub</b> (see
below), except that it shall replace all occurrences of the
regular expression (like the <i>ed</i> utility global
substitute) in $0 or in the <i>in</i> argument, when
specified.</p>


<p style="margin-left:11%;"><b>index</b>(<i>s</i>,&nbsp;<i>t</i>)</p>

<p style="margin-left:22%;">Return the position, in
characters, numbering from 1, in string <i>s</i> where
string <i>t</i> first occurs, or zero if it does not occur
at all.</p>


<p style="margin-left:11%;"><b>length[</b>(<b>[</b><i>s</i><b>]</b>)<b>]</b></p>

<p style="margin-left:22%;">Return the length, in
characters, of its argument taken as a string, or of the
whole record, $0, if there is no argument.</p>


<p style="margin-left:11%;"><b>match</b>(<i>s</i>,&nbsp;<i>ere</i>)</p>

<p style="margin-left:22%;">Return the position, in
characters, numbering from 1, in string <i>s</i> where the
extended regular expression <i>ere</i> occurs, or zero if it
does not occur at all. RSTART shall be set to the starting
position (which is the same as the returned value), zero if
no match is found; RLENGTH shall be set to the length of the
matched string, -1 if no match is found.</p>


<p style="margin-left:11%;"><b>split</b>(<i>s</i>,&nbsp;<i>a</i><b>[</b>,&nbsp;<i>fs&nbsp;</i>
<b>]</b>)</p>

<p style="margin-left:22%;">Split the string <i>s</i> into
array elements <i>a</i>[1], <i>a</i>[2], ...,
<i>a</i>[<i>n</i>], and return <i>n</i>. All elements of the
array shall be deleted before the split is performed. The
separation shall be done with the ERE <i>fs</i> or with the
field separator <b>FS</b> if <i>fs</i> is not given. Each
array element shall have a string value when created and, if
appropriate, the array element shall be considered a numeric
string (see Expressions in awk ). The effect of a null
string as the value of <i>fs</i> is unspecified.</p>


<p style="margin-left:11%;"><b>sprintf</b>(<i>fmt</i>,&nbsp;<i>expr</i>,&nbsp;<i>expr</i>,&nbsp;...)</p>

<p style="margin-left:22%;">Format the expressions
according to the <b>printf</b> format given by <i>fmt</i>
and return the resulting string.</p>


<p style="margin-left:11%;"><b>sub(</b><i>ere</i>,&nbsp;<i>repl</i><b>[</b>,&nbsp;<i>in&nbsp;</i>
<b>]</b>)</p>

<p style="margin-left:22%;">Substitute the string
<i>repl</i> in place of the first instance of the extended
regular expression <i>ERE</i> in string <i>in</i> and return
the number of substitutions. An ampersand (
<b>&rsquo;&amp;&rsquo;</b> ) appearing in the string
<i>repl</i> shall be replaced by the string from <i>in</i>
that matches the ERE. An ampersand preceded with a backslash
( <b>&rsquo;\&rsquo;</b> ) shall be interpreted as the
literal ampersand character. An occurrence of two
consecutive backslashes shall be interpreted as just a
single literal backslash character. Any other occurrence of
a backslash (for example, preceding any other character)
shall be treated as a literal backslash character. Note that
if <i>repl</i> is a string literal (the lexical token
<b>STRING</b>; see Grammar ), the handling of the ampersand
character occurs after any lexical processing, including any
lexical backslash escape sequence processing. If <i>in</i>
is specified and it is not an lvalue (see Expressions in awk
), the behavior is undefined. If <i>in</i> is omitted,
<i>awk</i> shall use the current record ($0) in its
place.</p>


<p style="margin-left:11%;"><b>substr</b>(<i>s</i>,&nbsp;<i>m</i><b>[</b>,&nbsp;<i>n&nbsp;</i>
<b>]</b>)</p>

<p style="margin-left:22%;">Return the at most
<i>n</i>-character substring of <i>s</i> that begins at
position <i>m</i>, numbering from 1. If <i>n</i> is omitted,
or if <i>n</i> specifies more characters than are left in
the string, the length of the substring shall be limited by
the length of the string <i>s</i>.</p>

<p style="margin-left:11%;"><b>tolower</b>(<i>s</i>)</p>

<p style="margin-left:22%;">Return a string based on the
string <i>s</i>. Each character in <i>s</i> that is an
uppercase letter specified to have a <b>tolower</b> mapping
by the <i>LC_CTYPE</i> category of the current locale shall
be replaced in the returned string by the lowercase letter
specified by the mapping. Other characters in <i>s</i> shall
be unchanged in the returned string.</p>

<p style="margin-left:11%;"><b>toupper</b>(<i>s</i>)</p>

<p style="margin-left:22%;">Return a string based on the
string <i>s</i>. Each character in <i>s</i> that is a
lowercase letter specified to have a <b>toupper</b> mapping
by the <i>LC_CTYPE</i> category of the current locale is
replaced in the returned string by the uppercase letter
specified by the mapping. Other characters in <i>s</i> are
unchanged in the returned string.</p>

<p style="margin-left:11%; margin-top: 1em">All of the
preceding functions that take <i>ERE</i> as a parameter
expect a pattern or a string valued expression that is a
regular expression as defined in Regular Expressions .</p>


<p style="margin-left:11%; margin-top: 1em"><b>Input/Output
and General Functions</b> <br>
The input/output and general functions are: <b><br>
close</b>(<i>expression</i>)</p>

<p style="margin-left:22%;">Close the file or pipe opened
by a <b>print</b> or <b>printf</b> statement or a call to
<b>getline</b> with the same string-valued
<i>expression</i>. The limit on the number of open
<i>expression</i> arguments is implementation-defined. If
the close was successful, the function shall return zero;
otherwise, it shall return non-zero.</p>

<p style="margin-left:11%;"><i>expression&nbsp;|&nbsp;</i>
<b>getline&nbsp;[</b><i>var</i><b>]</b></p>

<p style="margin-left:22%;">Read a record of input from a
stream piped from the output of a command. The stream shall
be created if no stream is currently open with the value of
<i>expression</i> as its command name. The stream created
shall be equivalent to one created by a call to the
<i>popen</i>() function with the value of <i>expression</i>
as the <i>command</i> argument and a value of <i>r</i> as
the <i>mode</i> argument. As long as the stream remains
open, subsequent calls in which <i>expression</i> evaluates
to the same string value shall read subsequent records from
the stream. The stream shall remain open until the
<b>close</b> function is called with an expression that
evaluates to the same string value. At that time, the stream
shall be closed as if by a call to the <i>pclose</i>()
function. If <i>var</i> is omitted, $0 and <b>NF</b> shall
be set; otherwise, <i>var</i> shall be set and, if
appropriate, it shall be considered a numeric string (see
Expressions in awk ).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>getline</b> operator can form ambiguous constructs when
there are unparenthesized operators (including concatenate)
to the left of the <b>&rsquo;|&rsquo;</b> (to the beginning
of the expression containing <b>getline</b>). In the context
of the <b>&rsquo;$&rsquo;</b> operator,
<b>&rsquo;|&rsquo;</b> shall behave as if it had a lower
precedence than <b>&rsquo;$&rsquo;</b> . The result of
evaluating other operators is unspecified, and conforming
applications shall parenthesize properly all such usages.
<b><br>
getline</b></p>

<p style="margin-left:22%;">Set $0 to the next input record
from the current input file. This form of <b>getline</b>
shall set the <b>NF</b>, <b>NR</b>, and <b>FNR</b>
variables.</p>

<p style="margin-left:11%;"><b>getline&nbsp;</b>
<i>var</i></p>

<p style="margin-left:22%;">Set variable <i>var</i> to the
next input record from the current input file and, if
appropriate, <i>var</i> shall be considered a numeric string
(see Expressions in awk ). This form of <b>getline</b> shall
set the <b>FNR</b> and <b>NR</b> variables.</p>


<p style="margin-left:11%;"><b>getline&nbsp;[</b><i>var</i><b>]&nbsp;</b>
&lt;&nbsp;<i>expression</i></p>

<p style="margin-left:22%;">Read the next record of input
from a named file. The <i>expression</i> shall be evaluated
to produce a string that is used as a pathname. If the file
of that name is not currently open, it shall be opened. As
long as the stream remains open, subsequent calls in which
<i>expression</i> evaluates to the same string value shall
read subsequent records from the file. The file shall remain
open until the <b>close</b> function is called with an
expression that evaluates to the same string value. If
<i>var</i> is omitted, $0 and <b>NF</b> shall be set;
otherwise, <i>var</i> shall be set and, if appropriate, it
shall be considered a numeric string (see Expressions in awk
).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>getline</b> operator can form ambiguous constructs when
there are unparenthesized binary operators (including
concatenate) to the right of the <b>&rsquo;&lt;&rsquo;</b>
(up to the end of the expression containing the
<b>getline</b>). The result of evaluating such a construct
is unspecified, and conforming applications shall
parenthesize properly all such usages. <b><br>
system</b>(<i>expression</i>)</p>

<p style="margin-left:22%;">Execute the command given by
<i>expression</i> in a manner equivalent to the
<i>system</i>() function defined in the System Interfaces
volume of IEEE&nbsp;Std&nbsp;1003.1-2001 and return the exit
status of the command.</p>

<p style="margin-left:11%; margin-top: 1em">All forms of
<b>getline</b> shall return 1 for successful input, zero for
end-of-file, and -1 for an error.</p>

<p style="margin-left:11%; margin-top: 1em">Where strings
are used as the name of a file or pipeline, the application
shall ensure that the strings are textually identical. The
terminology &quot;same string value&quot; implies that
&quot;equivalent strings&quot;, even those that differ only
by &lt;space&gt;s, represent different files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>User-Defined
Functions</b> <br>
The <i>awk</i> language also provides user-defined
functions. Such functions can be defined as:</p>


<p style="margin-left:22%; margin-top: 1em"><b>function</b>
<i>name</i><b>([</b><i>parameter</i><b>, ...]) {</b>
<i>statements</i> <b>}</b></p>

<p style="margin-left:11%; margin-top: 1em">A function can
be referred to anywhere in an <i>awk</i> program; in
particular, its use can precede its definition. The scope of
a function is global.</p>

<p style="margin-left:11%; margin-top: 1em">Function
parameters, if present, can be either scalars or arrays; the
behavior is undefined if an array name is passed as a
parameter that the function uses as a scalar, or if a scalar
expression is passed as a parameter that the function uses
as an array. Function parameters shall be passed by value if
scalar and by reference if array name.</p>

<p style="margin-left:11%; margin-top: 1em">The number of
parameters in the function definition need not match the
number of parameters in the function call. Excess formal
parameters can be used as local variables. If fewer
arguments are supplied in a function call than are in the
function definition, the extra parameters that are used in
the function body as scalars shall evaluate to the
uninitialized value until they are otherwise initialized,
and the extra parameters that are used in the function body
as arrays shall be treated as uninitialized arrays where
each element evaluates to the uninitialized value until
otherwise initialized.</p>

<p style="margin-left:11%; margin-top: 1em">When invoking a
function, no white space can be placed between the function
name and the opening parenthesis. Function calls can be
nested and recursive calls can be made upon functions. Upon
return from any nested or recursive function call, the
values of all of the calling function&rsquo;s parameters
shall be unchanged, except for array parameters passed by
reference. The <b>return</b> statement can be used to return
a value. If a <b>return</b> statement appears outside of a
function definition, the behavior is undefined.</p>

<p style="margin-left:11%; margin-top: 1em">In the function
definition, &lt;newline&gt;s shall be optional before the
opening brace and after the closing brace. Function
definitions can appear anywhere in the program where a
<i>pattern-action</i> pair is allowed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Grammar</b>
<br>
The grammar in this section and the lexical conventions in
the following section shall together describe the syntax for
<i>awk</i> programs. The general conventions for this style
of grammar are described in <i>Grammar Conventions</i> . A
valid program can be represented as the non-terminal symbol
<i>program</i> in the grammar. This formal syntax shall take
precedence over the preceding text syntax description.</p>

<p style="margin-left:22%; margin-top: 1em"><b>%token NAME
NUMBER STRING ERE <br>
%token FUNC_NAME /* Name followed by &rsquo;(&rsquo; without
white space. */</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/* Keywords
*/ <br>
%token Begin End <br>
/* &rsquo;BEGIN&rsquo; &rsquo;END&rsquo; */</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>%token Break
Continue Delete Do Else <br>
/* &rsquo;break&rsquo; &rsquo;continue&rsquo;
&rsquo;delete&rsquo; &rsquo;do&rsquo; &rsquo;else&rsquo;
*/</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>%token Exit
For Function If In <br>
/* &rsquo;exit&rsquo; &rsquo;for&rsquo;
&rsquo;function&rsquo; &rsquo;if&rsquo; &rsquo;in&rsquo;
*/</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>%token Next
Print Printf Return While <br>
/* &rsquo;next&rsquo; &rsquo;print&rsquo;
&rsquo;printf&rsquo; &rsquo;return&rsquo;
&rsquo;while&rsquo; */</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/* Reserved
function names */ <br>
%token BUILTIN_FUNC_NAME <br>
/* One token for the following: <br>
* atan2 cos sin exp log sqrt int rand srand <br>
* gsub index length match split sprintf sub <br>
* substr tolower toupper close system <br>
*/ <br>
%token GETLINE <br>
/* Syntactically different from other built-ins. */</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/*
Two-character tokens. */ <br>
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN
MOD_ASSIGN POW_ASSIGN <br>
/* &rsquo;+=&rsquo; &rsquo;-=&rsquo; &rsquo;*=&rsquo;
&rsquo;/=&rsquo; &rsquo;%=&rsquo; &rsquo;^=&rsquo;
*/</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>%token OR
AND NO_MATCH EQ LE GE NE INCR DECR APPEND <br>
/* &rsquo;||&rsquo; &rsquo;&amp;&amp;&rsquo;
&rsquo;!~&rsquo; &rsquo;==&rsquo; &rsquo;&lt;=&rsquo;
&rsquo;&gt;=&rsquo; &rsquo;!=&rsquo; &rsquo;++&rsquo;
&rsquo;--&rsquo; &rsquo;&gt;&gt;&rsquo; */</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/*
One-character tokens. */ <br>
%token &rsquo;{&rsquo; &rsquo;}&rsquo; &rsquo;(&rsquo;
&rsquo;)&rsquo; &rsquo;[&rsquo; &rsquo;]&rsquo;
&rsquo;,&rsquo; &rsquo;;&rsquo; NEWLINE <br>
%token &rsquo;+&rsquo; &rsquo;-&rsquo; &rsquo;*&rsquo;
&rsquo;%&rsquo; &rsquo;^&rsquo; &rsquo;!&rsquo;
&rsquo;&gt;&rsquo; &rsquo;&lt;&rsquo; &rsquo;|&rsquo;
&rsquo;?&rsquo; &rsquo;:&rsquo; &rsquo;~&rsquo;
&rsquo;$&rsquo; &rsquo;=&rsquo;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>%start
program <br>
%%</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>program :
item_list <br>
| actionless_item_list <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>item_list :
newline_opt <br>
| actionless_item_list item terminator <br>
| item_list item terminator <br>
| item_list action terminator <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>actionless_item_list
: item_list pattern terminator <br>
| actionless_item_list pattern terminator <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>item :
pattern action <br>
| Function NAME &rsquo;(&rsquo; param_list_opt
&rsquo;)&rsquo; <br>
newline_opt action <br>
| Function FUNC_NAME &rsquo;(&rsquo; param_list_opt
&rsquo;)&rsquo; <br>
newline_opt action <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>param_list_opt
: /* empty */ <br>
| param_list <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>param_list :
NAME <br>
| param_list &rsquo;,&rsquo; NAME <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>pattern :
Begin <br>
| End <br>
| expr <br>
| expr &rsquo;,&rsquo; newline_opt expr <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>action :
&rsquo;{&rsquo; newline_opt &rsquo;}&rsquo; <br>
| &rsquo;{&rsquo; newline_opt terminated_statement_list
&rsquo;}&rsquo; <br>
| &rsquo;{&rsquo; newline_opt unterminated_statement_list
&rsquo;}&rsquo; <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>terminator :
terminator &rsquo;;&rsquo; <br>
| terminator NEWLINE <br>
| &rsquo;;&rsquo; <br>
| NEWLINE <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>terminated_statement_list
: terminated_statement <br>
| terminated_statement_list terminated_statement <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>unterminated_statement_list
: unterminated_statement <br>
| terminated_statement_list unterminated_statement <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>terminated_statement
: action newline_opt <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
Else newline_opt terminated_statement <br>
| While &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
| For &rsquo;(&rsquo; simple_statement_opt &rsquo;;&rsquo;
<br>
expr_opt &rsquo;;&rsquo; simple_statement_opt
&rsquo;)&rsquo; newline_opt <br>
terminated_statement <br>
| For &rsquo;(&rsquo; NAME In NAME &rsquo;)&rsquo;
newline_opt <br>
terminated_statement <br>
| &rsquo;;&rsquo; newline_opt <br>
| terminatable_statement NEWLINE newline_opt <br>
| terminatable_statement &rsquo;;&rsquo; newline_opt <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>unterminated_statement
: terminatable_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
unterminated_statement <br>
| If &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
terminated_statement <br>
Else newline_opt unterminated_statement <br>
| While &rsquo;(&rsquo; expr &rsquo;)&rsquo; newline_opt
unterminated_statement <br>
| For &rsquo;(&rsquo; simple_statement_opt &rsquo;;&rsquo;
<br>
expr_opt &rsquo;;&rsquo; simple_statement_opt
&rsquo;)&rsquo; newline_opt <br>
unterminated_statement <br>
| For &rsquo;(&rsquo; NAME In NAME &rsquo;)&rsquo;
newline_opt <br>
unterminated_statement <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>terminatable_statement
: simple_statement <br>
| Break <br>
| Continue <br>
| Next <br>
| Exit expr_opt <br>
| Return expr_opt <br>
| Do newline_opt terminated_statement While &rsquo;(&rsquo;
expr &rsquo;)&rsquo; <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>simple_statement_opt
: /* empty */ <br>
| simple_statement <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>simple_statement
: Delete NAME &rsquo;[&rsquo; expr_list &rsquo;]&rsquo; <br>
| expr <br>
| print_statement <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>print_statement
: simple_print_statement <br>
| simple_print_statement output_redirection <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>simple_print_statement
: Print print_expr_list_opt <br>
| Print &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo;
<br>
| Printf print_expr_list <br>
| Printf &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo;
<br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>output_redirection
: &rsquo;&gt;&rsquo; expr <br>
| APPEND expr <br>
| &rsquo;|&rsquo; expr <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>expr_list_opt
: /* empty */ <br>
| expr_list <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>expr_list :
expr <br>
| multiple_expr_list <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>multiple_expr_list
: expr &rsquo;,&rsquo; newline_opt expr <br>
| multiple_expr_list &rsquo;,&rsquo; newline_opt expr <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>expr_opt :
/* empty */ <br>
| expr <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>expr :
unary_expr <br>
| non_unary_expr <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>unary_expr :
&rsquo;+&rsquo; expr <br>
| &rsquo;-&rsquo; expr <br>
| unary_expr &rsquo;^&rsquo; expr <br>
| unary_expr &rsquo;*&rsquo; expr <br>
| unary_expr &rsquo;/&rsquo; expr <br>
| unary_expr &rsquo;%&rsquo; expr <br>
| unary_expr &rsquo;+&rsquo; expr <br>
| unary_expr &rsquo;-&rsquo; expr <br>
| unary_expr non_unary_expr <br>
| unary_expr &rsquo;&lt;&rsquo; expr <br>
| unary_expr LE expr <br>
| unary_expr NE expr <br>
| unary_expr EQ expr <br>
| unary_expr &rsquo;&gt;&rsquo; expr <br>
| unary_expr GE expr <br>
| unary_expr &rsquo;~&rsquo; expr <br>
| unary_expr NO_MATCH expr <br>
| unary_expr In NAME <br>
| unary_expr AND newline_opt expr <br>
| unary_expr OR newline_opt expr <br>
| unary_expr &rsquo;?&rsquo; expr &rsquo;:&rsquo; expr <br>
| unary_input_function <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>non_unary_expr
: &rsquo;(&rsquo; expr &rsquo;)&rsquo; <br>
| &rsquo;!&rsquo; expr <br>
| non_unary_expr &rsquo;^&rsquo; expr <br>
| non_unary_expr &rsquo;*&rsquo; expr <br>
| non_unary_expr &rsquo;/&rsquo; expr <br>
| non_unary_expr &rsquo;%&rsquo; expr <br>
| non_unary_expr &rsquo;+&rsquo; expr <br>
| non_unary_expr &rsquo;-&rsquo; expr <br>
| non_unary_expr non_unary_expr <br>
| non_unary_expr &rsquo;&lt;&rsquo; expr <br>
| non_unary_expr LE expr <br>
| non_unary_expr NE expr <br>
| non_unary_expr EQ expr <br>
| non_unary_expr &rsquo;&gt;&rsquo; expr <br>
| non_unary_expr GE expr <br>
| non_unary_expr &rsquo;~&rsquo; expr <br>
| non_unary_expr NO_MATCH expr <br>
| non_unary_expr In NAME <br>
| &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo; In NAME
<br>
| non_unary_expr AND newline_opt expr <br>
| non_unary_expr OR newline_opt expr <br>
| non_unary_expr &rsquo;?&rsquo; expr &rsquo;:&rsquo; expr
<br>
| NUMBER <br>
| STRING <br>
| lvalue <br>
| ERE <br>
| lvalue INCR <br>
| lvalue DECR <br>
| INCR lvalue <br>
| DECR lvalue <br>
| lvalue POW_ASSIGN expr <br>
| lvalue MOD_ASSIGN expr <br>
| lvalue MUL_ASSIGN expr <br>
| lvalue DIV_ASSIGN expr <br>
| lvalue ADD_ASSIGN expr <br>
| lvalue SUB_ASSIGN expr <br>
| lvalue &rsquo;=&rsquo; expr <br>
| FUNC_NAME &rsquo;(&rsquo; expr_list_opt &rsquo;)&rsquo;
<br>
/* no white space allowed before &rsquo;(&rsquo; */ <br>
| BUILTIN_FUNC_NAME &rsquo;(&rsquo; expr_list_opt
&rsquo;)&rsquo; <br>
| BUILTIN_FUNC_NAME <br>
| non_unary_input_function <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>print_expr_list_opt
: /* empty */ <br>
| print_expr_list <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>print_expr_list
: print_expr <br>
| print_expr_list &rsquo;,&rsquo; newline_opt print_expr
<br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>print_expr :
unary_print_expr <br>
| non_unary_print_expr <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>unary_print_expr
: &rsquo;+&rsquo; print_expr <br>
| &rsquo;-&rsquo; print_expr <br>
| unary_print_expr &rsquo;^&rsquo; print_expr <br>
| unary_print_expr &rsquo;*&rsquo; print_expr <br>
| unary_print_expr &rsquo;/&rsquo; print_expr <br>
| unary_print_expr &rsquo;%&rsquo; print_expr <br>
| unary_print_expr &rsquo;+&rsquo; print_expr <br>
| unary_print_expr &rsquo;-&rsquo; print_expr <br>
| unary_print_expr non_unary_print_expr <br>
| unary_print_expr &rsquo;~&rsquo; print_expr <br>
| unary_print_expr NO_MATCH print_expr <br>
| unary_print_expr In NAME <br>
| unary_print_expr AND newline_opt print_expr <br>
| unary_print_expr OR newline_opt print_expr <br>
| unary_print_expr &rsquo;?&rsquo; print_expr
&rsquo;:&rsquo; print_expr <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>non_unary_print_expr
: &rsquo;(&rsquo; expr &rsquo;)&rsquo; <br>
| &rsquo;!&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;^&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;*&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;/&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;%&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;+&rsquo; print_expr <br>
| non_unary_print_expr &rsquo;-&rsquo; print_expr <br>
| non_unary_print_expr non_unary_print_expr <br>
| non_unary_print_expr &rsquo;~&rsquo; print_expr <br>
| non_unary_print_expr NO_MATCH print_expr <br>
| non_unary_print_expr In NAME <br>
| &rsquo;(&rsquo; multiple_expr_list &rsquo;)&rsquo; In NAME
<br>
| non_unary_print_expr AND newline_opt print_expr <br>
| non_unary_print_expr OR newline_opt print_expr <br>
| non_unary_print_expr &rsquo;?&rsquo; print_expr
&rsquo;:&rsquo; print_expr <br>
| NUMBER <br>
| STRING <br>
| lvalue <br>
| ERE <br>
| lvalue INCR <br>
| lvalue DECR <br>
| INCR lvalue <br>
| DECR lvalue <br>
| lvalue POW_ASSIGN print_expr <br>
| lvalue MOD_ASSIGN print_expr <br>
| lvalue MUL_ASSIGN print_expr <br>
| lvalue DIV_ASSIGN print_expr <br>
| lvalue ADD_ASSIGN print_expr <br>
| lvalue SUB_ASSIGN print_expr <br>
| lvalue &rsquo;=&rsquo; print_expr <br>
| FUNC_NAME &rsquo;(&rsquo; expr_list_opt &rsquo;)&rsquo;
<br>
/* no white space allowed before &rsquo;(&rsquo; */ <br>
| BUILTIN_FUNC_NAME &rsquo;(&rsquo; expr_list_opt
&rsquo;)&rsquo; <br>
| BUILTIN_FUNC_NAME <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>lvalue :
NAME <br>
| NAME &rsquo;[&rsquo; expr_list &rsquo;]&rsquo; <br>
| &rsquo;$&rsquo; expr <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>non_unary_input_function
: simple_get <br>
| simple_get &rsquo;&lt;&rsquo; expr <br>
| non_unary_expr &rsquo;|&rsquo; simple_get <br>
;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>unary_input_function
: unary_expr &rsquo;|&rsquo; simple_get <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>simple_get :
GETLINE <br>
| GETLINE lvalue <br>
;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>newline_opt
: /* empty */ <br>
| newline_opt NEWLINE <br>
;</b></p>

<p style="margin-left:11%; margin-top: 1em">This grammar
has several ambiguities that shall be resolved as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Operator precedence and associativity shall be as
described in Expressions in Decreasing Precedence in
<i>awk</i> .</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>In case of ambiguity, an <b>else</b> shall be associated
with the most immediately preceding <b>if</b> that would
satisfy the grammar.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>In some contexts, a slash ( <b>&rsquo;/&rsquo;</b> )
that is used to surround an ERE could also be the division
operator. This shall be resolved in such a way that wherever
the division operator could appear, a slash is assumed to be
the division operator. (There is no unary division
operator.)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">One convention
that might not be obvious from the formal grammar is where
&lt;newline&gt;s are acceptable. There are several obvious
placements such as terminating a statement, and a backslash
can be used to escape &lt;newline&gt;s between any lexical
tokens. In addition, &lt;newline&gt;s without backslashes
can follow a comma, an open brace, logical AND operator (
<b>&quot;&amp;&amp;&quot;</b> ), logical OR operator (
<b>&quot;||&quot;</b> ), the <b>do</b> keyword, the
<b>else</b> keyword, and the closing parenthesis of an
<b>if</b>, <b>for</b>, or <b>while</b> statement. For
example:</p>

<p style="margin-left:22%; margin-top: 1em"><b>{ print $1,
<br>
$2 }</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Lexical
Conventions</b> <br>
The lexical conventions for <i>awk</i> programs, with
respect to the preceding grammar, shall be as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Except as noted, <i>awk</i>
shall recognize the longest possible token or delimiter
beginning at a given point.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p>A comment shall consist of any characters beginning with
the number sign character and terminated by, but excluding
the next occurrence of, a &lt;newline&gt;. Comments shall
have no effect, except to delimit lexical tokens.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The &lt;newline&gt; shall be recognized as the token
<b>NEWLINE</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="83%">


<p>A backslash character immediately followed by a
&lt;newline&gt; shall have no effect.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>5.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The token <b>STRING</b> shall represent a string
constant. A string constant shall begin with the character
<b>&rsquo; .&rsquo;</b> Within a string constant, a
backslash character shall be considered to begin an escape
sequence as specified in the table in the Base Definitions
volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 5, File
Format Notation ( <b>&rsquo;\\&rsquo;</b>,
<b>&rsquo;\a&rsquo;</b>, <b>&rsquo;\b&rsquo;</b>,
<b>&rsquo;\f&rsquo;</b>, <b>&rsquo;\n&rsquo;</b>,
<b>&rsquo;\r&rsquo;</b>, <b>&rsquo;\t&rsquo;</b>,
<b>&rsquo;\v&rsquo;</b> ). In addition, the escape sequences
in Expressions in Decreasing Precedence in <i>awk</i> shall
be recognized. A &lt;newline&gt; shall not occur within a
string constant. A string constant shall be terminated by
the first unescaped occurrence of the character
<b>&rsquo;&rsquo;</b> after the one that begins the string
constant. The value of the string shall be the sequence of
all unescaped characters and values of escape sequences
between, but not including, the two delimiting
<b>&rsquo;&rsquo;</b> characters.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>6.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The token <b>ERE</b> represents an extended regular
expression constant. An ERE constant shall begin with the
slash character. Within an ERE constant, a backslash
character shall be considered to begin an escape sequence as
specified in the table in the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 5, File Format
Notation. In addition, the escape sequences in Expressions
in Decreasing Precedence in <i>awk</i> shall be recognized.
The application shall ensure that a &lt;newline&gt; does not
occur within an ERE constant. An ERE constant shall be
terminated by the first unescaped occurrence of the slash
character after the one that begins the ERE constant. The
extended regular expression represented by the ERE constant
shall be the sequence of all unescaped characters and values
of escape sequences between, but not including, the two
delimiting slash characters.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>7.</p></td>
<td width="2%"></td>
<td width="83%">


<p>A &lt;blank&gt; shall have no effect, except to delimit
lexical tokens or within <b>STRING</b> or <b>ERE</b>
tokens.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>8.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The token <b>NUMBER</b> shall represent a numeric
constant. Its form and numeric value shall be equivalent to
either of the tokens <b>floating-constant</b> or
<b>integer-constant</b> as specified by the ISO&nbsp;C
standard, with the following exceptions:</p></td></tr>
</table>

<p style="margin-left:17%;">a.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="4%"></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">An integer constant cannot begin
with 0x or include the hexadecimal digits
<b>&rsquo;a&rsquo;</b>, <b>&rsquo;b&rsquo;</b>,
<b>&rsquo;c&rsquo;</b>, <b>&rsquo;d&rsquo;</b>,
<b>&rsquo;e&rsquo;</b>, <b>&rsquo;f&rsquo;</b>,
<b>&rsquo;A&rsquo;</b>, <b>&rsquo;B&rsquo;</b>,
<b>&rsquo;C&rsquo;</b>, <b>&rsquo;D&rsquo;</b>,
<b>&rsquo;E&rsquo;</b>, or <b>&rsquo;F&rsquo;</b> .</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="4%">


<p>b.</p></td>
<td width="1%"></td>
<td width="77%">


<p>The value of an integer constant beginning with 0 shall
be taken in decimal rather than octal.</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="4%">


<p>c.</p></td>
<td width="1%"></td>
<td width="77%">


<p>An integer constant cannot include a suffix (
<b>&rsquo;u&rsquo;</b>, <b>&rsquo;U&rsquo;</b>,
<b>&rsquo;l&rsquo;</b>, or <b>&rsquo;L&rsquo;</b> ).</p></td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="4%">


<p>d.</p></td>
<td width="1%"></td>
<td width="77%">


<p>A floating constant cannot include a suffix (
<b>&rsquo;f&rsquo;</b>, <b>&rsquo;F&rsquo;</b>,
<b>&rsquo;l&rsquo;</b>, or <b>&rsquo;L&rsquo;</b> ).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the value is
too large or too small to be representable (see <i>Concepts
Derived from the ISO C Standard</i> ), the behavior is
undefined.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">9.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">A sequence of underscores,
digits, and alphabetics from the portable character set (see
the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, Section 6.1, Portable
Character Set), beginning with an underscore or alphabetic,
shall be considered a word.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>10.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The following words are keywords that shall be
recognized as individual tokens; the name of the token is
the same as the keyword:</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">11.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The following words are names of
built-in functions and shall be recognized as the token
<b>BUILTIN_FUNC_NAME</b>:</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
above-listed keywords and names of built-in functions are
considered reserved words.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">12.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The token <b>NAME</b> shall
consist of a word that is not a keyword or a name of a
built-in function and is not followed immediately (without
any delimiters) by the <b>&rsquo;(&rsquo;</b> character.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>13.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The token <b>FUNC_NAME</b> shall consist of a word that
is not a keyword or a name of a built-in function, followed
immediately (without any delimiters) by the
<b>&rsquo;(&rsquo;</b> character. The <b>&rsquo;(&rsquo;</b>
character shall not be included as part of the token.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>14.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The following two-character sequences shall be
recognized as the named tokens:</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">15.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The following single characters
shall be recognized as tokens whose names are the
character:</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><b>&lt;newline&gt;
{ } ( ) [ ] , ; + - * % ^ ! &gt; &lt; | ? : ~ $ =</b></p>

<p style="margin-left:11%; margin-top: 1em">There is a
lexical ambiguity between the token <b>ERE</b> and the
tokens <b>&rsquo;/&rsquo;</b> and <b>DIV_ASSIGN</b>. When an
input sequence begins with a slash character in any
syntactic context where the token <b>&rsquo;/&rsquo;</b> or
<b>DIV_ASSIGN</b> could appear as the next token in a valid
program, the longer of those two tokens that can be
recognized shall be recognized. In any other syntactic
context where the token <b>ERE</b> could appear as the next
token in a valid program, the token <b>ERE</b> shall be
recognized.</p>

<h2>EXIT STATUS
<a name="EXIT STATUS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
exit values shall be returned:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">&nbsp; 0</p></td>
<td width="8%"></td>
<td width="67%">


<p style="margin-top: 1em">All input files were processed
successfully.</p> </td>
<td width="11%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&gt;0</p></td>
<td width="8%"></td>
<td width="67%">


<p>An error occurred.</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The exit status
can be altered within the program by using an <b>exit</b>
expression.</p>

<h2>CONSEQUENCES OF ERRORS
<a name="CONSEQUENCES OF ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If any
<i>file</i> operand is specified and the named file cannot
be accessed, <i>awk</i> shall write a diagnostic message to
standard error and terminate without any further action.</p>

<p style="margin-left:11%; margin-top: 1em">If the program
specified by either the <i>program</i> operand or a
<i>progfile</i> operand is not a valid <i>awk</i> program
(as specified in the EXTENDED DESCRIPTION section), the
behavior is undefined.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
following sections are informative.</i></p>

<h2>APPLICATION USAGE
<a name="APPLICATION USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>index</b>, <b>length</b>, <b>match</b>, and <b>substr</b>
functions should not be confused with similar functions in
the ISO&nbsp;C standard; the <i>awk</i> versions deal with
characters, while the ISO&nbsp;C standard deals with
bytes.</p>

<p style="margin-left:11%; margin-top: 1em">Because the
concatenation operation is represented by adjacent
expressions rather than an explicit operator, it is often
necessary to use parentheses to enforce the proper
evaluation precedence.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>awk</i>
program specified in the command line is most easily
specified within single-quotes (for example,
<i>&rsquo;program&rsquo;</i>) for applications using
<i>sh</i>, because <i>awk</i> programs commonly contain
characters that are special to the shell, including
double-quotes. In the cases where an <i>awk</i> program
contains single-quote characters, it is usually easiest to
specify most of the program as strings within single-quotes
concatenated by the shell with quoted single-quote
characters. For example:</p>

<p style="margin-left:22%; margin-top: 1em"><b>awk
&rsquo;/&rsquo;\&rsquo;&rsquo;/ { print &quot;quote:&quot;,
$0 }&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">prints all
lines from the standard input containing a single-quote
character, prefixed with <i>quote</i>:.</p>

<p style="margin-left:11%; margin-top: 1em">The following
are examples of simple <i>awk</i> programs:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write to the standard output all
input lines for which field 3 is greater than 5:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>$3 &gt;
5</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em">Write every tenth line:</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>(NR % 10) ==
0</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write any line with a substring
matching the regular expression:</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><b>/(G|D)(2[0-9][[:alpha:]]*)/</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Print any line with a substring
containing a <b>&rsquo;G&rsquo;</b> or
<b>&rsquo;D&rsquo;</b>, followed by a sequence of digits and
characters. This example uses character classes <b>digit</b>
and <b>alpha</b> to match language-independent digit and
alphabetic characters respectively:</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><b>/(G|D)([[:digit:][:alpha:]]*)/</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write any line in which the
second field matches the regular expression and the fourth
field does not:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>$2 ~ /xyz/
&amp;&amp; $4 !~ /xyz/</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">6.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write any line in which the
second field contains a backslash:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>$2 ~
/\\/</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">7.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write any line in which the
second field contains a backslash. Note that backslash
escapes are interpreted twice; once in lexical processing of
the string and once in processing the regular
expression:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>$2 ~
&quot;\\\\&quot;</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">8.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write the second to the last and
the last field in each line. Separate the fields by a
colon:</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><b>{OFS=&quot;:&quot;;print
$(NF-1), $NF}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">9.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write the line number and number
of fields in each line. The three strings representing the
line number, the colon, and the number of fields are
concatenated and that string is written to standard
output:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>{print NR
&quot;:&quot; NF}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">10.</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em">Write lines longer than 72
characters:</p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>length($0)
&gt; 72</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">11.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write the first two fields in
opposite order separated by <b>OFS</b>:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>{ print $2,
$1 }</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">12.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Same, with input fields
separated by a comma or &lt;space&gt;s and &lt;tab&gt;s, or
both:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>BEGIN { FS =
&quot;,[ \t]*|[ \t]+&quot; } <br>
{ print $2, $1 }</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">13.</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em">Add up the first column, print
sum, and average:</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>{s += $1 }
<br>
END {print &quot;sum is &quot;, s, &quot; average is&quot;,
s/NR}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">14.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write fields in reverse order,
one per line (many lines out for each line in):</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>{ for (i =
NF; i &gt; 0; --i) print $i }</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">15.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write all lines between
occurrences of the strings <b>start</b> and <b>stop</b>:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>/start/,
/stop/</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">16.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write all lines whose first
field is different from the previous one:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>$1 != prev {
print; prev = $1 }</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">17.</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Simulate <i>echo</i>:</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>BEGIN { <br>
for (i = 1; i &lt; ARGC; ++i) <br>
printf(&quot;%s%s&quot;, ARGV[i],
i==ARGC-1?&quot;\n&quot;:&quot; &quot;) <br>
}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">18.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Write the path prefixes
contained in the <i>PATH</i> environment variable, one per
line:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>BEGIN { <br>
n = split (ENVIRON[&quot;PATH&quot;], path, &quot;:&quot;)
<br>
for (i = 1; i &lt;= n; ++i) <br>
print path[i] <br>
}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">19.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">If there is a file named
<b>input</b> containing page headers of the form:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Page #</p>

<p style="margin-left:11%; margin-top: 1em">and a file
named <b>program</b> that contains:</p>

<p style="margin-left:22%; margin-top: 1em"><b>/Page/ { $2
= n++; } <br>
{ print }</b></p>

<p style="margin-left:11%; margin-top: 1em">then the
command line:</p>

<p style="margin-left:22%; margin-top: 1em"><b>awk -f
program n=5 input</b></p>

<p style="margin-left:11%; margin-top: 1em">prints the file
<b>input</b>, filling in page numbers starting at 5.</p>

<h2>RATIONALE
<a name="RATIONALE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
description is based on the new <i>awk</i>,
&quot;nawk&quot;, (see the referenced <i>The AWK Programming
Language</i>), which introduced a number of new features to
the historical <i>awk</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">New keywords: <b>delete</b>,
<b>do</b>, <b>function</b>, <b>return</b></p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="83%">


<p>New built-in functions: <b>atan2</b>, <b>close</b>,
<b>cos</b>, <b>gsub</b>, <b>match</b>, <b>rand</b>,
<b>sin</b>, <b>srand</b>, <b>sub</b>, <b>system</b></p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="83%">


<p>New predefined variables: <b>FNR</b>, <b>ARGC</b>,
<b>ARGV</b>, <b>RSTART</b>, <b>RLENGTH</b>,
<b>SUBSEP</b></p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="83%">


<p>New expression operators: <b>?</b>, <b>:</b>, <b>,</b>,
<b>^</b></p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>5.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The <b>FS</b> variable and the third argument to
<b>split</b>, now treated as extended regular
expressions.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">


<p>6.</p></td>
<td width="2%"></td>
<td width="83%">


<p>The operator precedence, changed to more closely match
the C language. Two examples of code that operate
differently are:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>while ( n /=
10 &gt; 1) ... <br>
if (!&quot;wk&quot; ~ /bwk/) ...</b></p>

<p style="margin-left:11%; margin-top: 1em">Several
features have been added based on newer implementations of
<i>awk</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">Multiple instances of <b>-f</b>
<i>progfile</i> are permitted.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new option <b>-v</b> <i>assignment.</i></p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new predefined variable <b>ENVIRON</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>New built-in functions <b>toupper</b> and
<b>tolower</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>More formatting capabilities are added to <b>printf</b>
to match the ISO&nbsp;C standard.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The overall
<i>awk</i> syntax has always been based on the C language,
with a few features from the shell command language and
other sources. Because of this, it is not completely
compatible with any other language, which has caused
confusion for some users. It is not the intent of the
standard developers to address such issues. A few relatively
minor changes toward making the language more compatible
with the ISO&nbsp;C standard were made; most of these
changes are based on similar changes in recent
implementations, as described above. There remain several
C-language conventions that are not in <i>awk</i>. One of
the notable ones is the comma operator, which is commonly
used to specify multiple expressions in the C language
<b>for</b> statement. Also, there are various places where
<i>awk</i> is more restrictive than the C language regarding
the type of expression that can be used in a given context.
These limitations are due to the different features that the
<i>awk</i> language does provide.</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expressions in <i>awk</i> have been extended somewhat from
historical implementations to make them a pure superset of
extended regular expressions, as defined by
IEEE&nbsp;Std&nbsp;1003.1-2001 (see the Base Definitions
volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Section 9.4,
Extended Regular Expressions). The main extensions are
internationalization features and interval expressions.
Historical implementations of <i>awk</i> have long supported
backslash escape sequences as an extension to extended
regular expressions, and this extension has been retained
despite inconsistency with other utilities. The number of
escape sequences recognized in both extended regular
expressions and strings has varied (generally increasing
with time) among implementations. The set specified by
IEEE&nbsp;Std&nbsp;1003.1-2001 includes most sequences known
to be supported by popular implementations and by the
ISO&nbsp;C standard. One sequence that is not supported is
hexadecimal value escapes beginning with
<b>&rsquo;\x&rsquo;</b> . This would allow values expressed
in more than 9 bits to be used within <i>awk</i> as in the
ISO&nbsp;C standard. However, because this syntax has a
non-deterministic length, it does not permit the subsequent
character to be a hexadecimal digit. This limitation can be
dealt with in the C language by the use of lexical string
concatenation. In the <i>awk</i> language, concatenation
could also be a solution for strings, but not for extended
regular expressions (either lexical ERE tokens or strings
used dynamically as regular expressions). Because of this
limitation, the feature has not been added to
IEEE&nbsp;Std&nbsp;1003.1-2001.</p>

<p style="margin-left:11%; margin-top: 1em">When a string
variable is used in a context where an extended regular
expression normally appears (where the lexical token ERE is
used in the grammar) the string does not contain the literal
slashes.</p>

<p style="margin-left:11%; margin-top: 1em">Some versions
of <i>awk</i> allow the form:</p>

<p style="margin-left:22%; margin-top: 1em"><b>func
name(args, ... ) { statements }</b></p>

<p style="margin-left:11%; margin-top: 1em">This has been
deprecated by the authors of the language, who asked that it
not be specified.</p>

<p style="margin-left:11%; margin-top: 1em">Historical
implementations of <i>awk</i> produce an error if a
<b>next</b> statement is executed in a <b>BEGIN</b> action,
and cause <i>awk</i> to terminate if a <b>next</b> statement
is executed in an <b>END</b> action. This behavior has not
been documented, and it was not believed that it was
necessary to standardize it.</p>

<p style="margin-left:11%; margin-top: 1em">The
specification of conversions between string and numeric
values is much more detailed than in the documentation of
historical implementations or in the referenced <i>The AWK
Programming Language</i>. Although most of the behavior is
designed to be intuitive, the details are necessary to
ensure compatible behavior from different implementations.
This is especially important in relational expressions since
the types of the operands determine whether a string or
numeric comparison is performed. From the perspective of an
application writer, it is usually sufficient to expect
intuitive behavior and to force conversions (by adding zero
or concatenating a null string) when the type of an
expression does not obviously match what is needed. The
intent has been to specify historical practice in almost all
cases. The one exception is that, in historical
implementations, variables and constants maintain both
string and numeric values after their original value is
converted by any use. This means that referencing a variable
or constant can have unexpected side effects. For example,
with historical implementations the following program:</p>

<p style="margin-left:22%; margin-top: 1em"><b>{ <br>
a = &quot;+2&quot; <br>
b = 2 <br>
if (NR % 2) <br>
c = a + b <br>
if (a == b) <br>
print &quot;numeric comparison&quot; <br>
else <br>
print &quot;string comparison&quot; <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">would perform a
numeric comparison (and output numeric comparison) for each
odd-numbered line, but perform a string comparison (and
output string comparison) for each even-numbered line.
IEEE&nbsp;Std&nbsp;1003.1-2001 ensures that comparisons will
be numeric if necessary. With historical implementations,
the following program:</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN { <br>
OFMT = &quot;%e&quot; <br>
print 3.14 <br>
OFMT = &quot;%f&quot; <br>
print 3.14 <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">would output
<b>&quot;3.140000e+00&quot;</b> twice, because in the second
<b>print</b> statement the constant <b>&quot;3.14&quot;</b>
would have a string value from the previous conversion.
IEEE&nbsp;Std&nbsp;1003.1-2001 requires that the output of
the second <b>print</b> statement be
<b>&quot;3.140000&quot;</b> . The behavior of historical
implementations was seen as too unintuitive and
unpredictable.</p>

<p style="margin-left:11%; margin-top: 1em">It was pointed
out that with the rules contained in early drafts, the
following script would print nothing:</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN { <br>
y[1.5] = 1 <br>
OFMT = &quot;%e&quot; <br>
print y[1.5] <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">Therefore, a
new variable, <b>CONVFMT</b>, was introduced. The
<b>OFMT</b> variable is now restricted to affecting output
conversions of numbers to strings and <b>CONVFMT</b> is used
for internal conversions, such as comparisons or array
indexing. The default value is the same as that for
<b>OFMT</b>, so unless a program changes <b>CONVFMT</b>
(which no historical program would do), it will receive the
historical behavior associated with internal string
conversions.</p>

<p style="margin-left:11%; margin-top: 1em">The POSIX
<i>awk</i> lexical and syntactic conventions are specified
more formally than in other sources. Again the intent has
been to specify historical practice. One convention that may
not be obvious from the formal grammar as in other verbal
descriptions is where &lt;newline&gt;s are acceptable. There
are several obvious placements such as terminating a
statement, and a backslash can be used to escape
&lt;newline&gt;s between any lexical tokens. In addition,
&lt;newline&gt;s without backslashes can follow a comma, an
open brace, a logical AND operator (
<b>&quot;&amp;&amp;&quot;</b> ), a logical OR operator (
<b>&quot;||&quot;</b> ), the <b>do</b> keyword, the
<b>else</b> keyword, and the closing parenthesis of an
<b>if</b>, <b>for</b>, or <b>while</b> statement. For
example:</p>

<p style="margin-left:22%; margin-top: 1em"><b>{ print $1,
<br>
$2 }</b></p>

<p style="margin-left:11%; margin-top: 1em">The requirement
that <i>awk</i> add a trailing &lt;newline&gt; to the
program argument text is to simplify the grammar, making it
match a text file in form. There is no way for an
application or test suite to determine whether a literal
&lt;newline&gt; is added or whether <i>awk</i> simply acts
as if it did.</p>


<p style="margin-left:11%; margin-top: 1em">IEEE&nbsp;Std&nbsp;1003.1-2001
requires several changes from historical implementations in
order to support internationalization. Probably the most
subtle of these is the use of the decimal-point character,
defined by the <i>LC_NUMERIC</i> category of the locale, in
representations of floating-point numbers. This
locale-specific character is used in recognizing numeric
input, in converting between strings and numeric values, and
in formatting output. However, regardless of locale, the
period character (the decimal-point character of the POSIX
locale) is the decimal-point character recognized in
processing <i>awk</i> programs (including assignments in
command line arguments). This is essentially the same
convention as the one used in the ISO&nbsp;C standard. The
difference is that the C language includes the
<i>setlocale</i>() function, which permits an application to
modify its locale. Because of this capability, a C
application begins executing with its locale set to the C
locale, and only executes in the environment-specified
locale after an explicit call to <i>setlocale</i>().
However, adding such an elaborate new feature to the
<i>awk</i> language was seen as inappropriate for
IEEE&nbsp;Std&nbsp;1003.1-2001. It is possible to execute an
<i>awk</i> program explicitly in any desired locale by
setting the environment in the shell.</p>

<p style="margin-left:11%; margin-top: 1em">The undefined
behavior resulting from NULs in extended regular expressions
allows future extensions for the GNU <i>gawk</i> program to
process binary data.</p>

<p style="margin-left:11%; margin-top: 1em">The behavior in
the case of invalid <i>awk</i> programs (including lexical,
syntactic, and semantic errors) is undefined because it was
considered overly limiting on implementations to specify. In
most cases such errors can be expected to produce a
diagnostic and a non-zero exit status. However, some
implementations may choose to extend the language in ways
that make use of certain invalid constructs. Other invalid
constructs might be deemed worthy of a warning, but
otherwise cause some reasonable behavior. Still other
constructs may be very difficult to detect in some
implementations. Also, different implementations might
detect a given error during an initial parsing of the
program (before reading any input files) while others might
detect it when executing the program after reading some
input. Implementors should be aware that diagnosing errors
as early as possible and producing useful diagnostics can
ease debugging of applications, and thus make an
implementation more usable.</p>

<p style="margin-left:11%; margin-top: 1em">The unspecified
behavior from using multi-character <b>RS</b> values is to
allow possible future extensions based on extended regular
expressions used for record separators. Historical
implementations take the first character of the string and
ignore the others.</p>

<p style="margin-left:11%; margin-top: 1em">Unspecified
behavior when <i>split</i>( <i>string</i>, <i>array</i>,
&lt;null&gt;) is used is to allow a proposed future
extension that would split up a string into an array of
individual characters.</p>

<p style="margin-left:11%; margin-top: 1em">In the context
of the <b>getline</b> function, equally good arguments for
different precedences of the <b>|</b> and <b>&lt;</b>
operators can be made. Historical practice has been
that:</p>

<p style="margin-left:22%; margin-top: 1em"><b>getline &lt;
&quot;a&quot; &quot;b&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">is parsed
as:</p>

<p style="margin-left:22%; margin-top: 1em"><b>( getline
&lt; &quot;a&quot; ) &quot;b&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">although many
would argue that the intent was that the file <b>ab</b>
should be read. However:</p>

<p style="margin-left:22%; margin-top: 1em"><b>getline &lt;
&quot;x&quot; + 1</b></p>

<p style="margin-left:11%; margin-top: 1em">parses as:</p>

<p style="margin-left:22%; margin-top: 1em"><b>getline &lt;
( &quot;x&quot; + 1 )</b></p>

<p style="margin-left:11%; margin-top: 1em">Similar
problems occur with the <b>|</b> version of <b>getline</b>,
particularly in combination with <b>$</b>. For example:</p>

<p style="margin-left:22%; margin-top: 1em"><b>$&quot;echo
hi&quot; | getline</b></p>

<p style="margin-left:11%; margin-top: 1em">(This situation
is particularly problematic when used in a <b>print</b>
statement, where the <b>|getline</b> part might be a
redirection of the <b>print</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">Since in most
cases such constructs are not (or at least should not) be
used (because they have a natural ambiguity for which there
is no conventional parsing), the meaning of these constructs
has been made explicitly unspecified. (The effect is that a
conforming application that runs into the problem must
parenthesize to resolve the ambiguity.) There appeared to be
few if any actual uses of such constructs.</p>

<p style="margin-left:11%; margin-top: 1em">Grammars can be
written that would cause an error under these circumstances.
Where backwards-compatibility is not a large consideration,
implementors may wish to use such grammars.</p>

<p style="margin-left:11%; margin-top: 1em">Some historical
implementations have allowed some built-in functions to be
called without an argument list, the result being a default
argument list chosen in some &quot;reasonable&quot; way. Use
of <b>length</b> as a synonym for <b>length($0)</b> is the
only one of these forms that is thought to be widely known
or widely used; this particular form is documented in
various places (for example, most historical <i>awk</i>
reference pages, although not in the referenced <i>The AWK
Programming Language</i>) as legitimate practice. With this
exception, default argument lists have always been
undocumented and vaguely defined, and it is not at all clear
how (or if) they should be generalized to user-defined
functions. They add no useful functionality and preclude
possible future extensions that might need to name functions
without calling them. Not standardizing them seems the
simplest course. The standard developers considered that
<b>length</b> merited special treatment, however, since it
has been documented in the past and sees possibly
substantial use in historical programs. Accordingly, this
usage has been made legitimate, but Issue&nbsp;5 removed the
obsolescent marking for XSI-conforming implementations and
many otherwise conforming applications depend on this
feature.</p>

<p style="margin-left:11%; margin-top: 1em">In <b>sub</b>
and <b>gsub</b>, if <i>repl</i> is a string literal (the
lexical token <b>STRING</b>), then two consecutive backslash
characters should be used in the string to ensure a single
backslash will precede the ampersand when the resultant
string is passed to the function. (For example, to specify
one literal ampersand in the replacement string, use
<b>gsub</b>( <b>ERE</b>, <b>&quot;\\&amp;&quot;</b> ).)</p>

<p style="margin-left:11%; margin-top: 1em">Historically
the only special character in the <i>repl</i> argument of
<b>sub</b> and <b>gsub</b> string functions was the
ampersand ( <b>&rsquo;&amp;&rsquo;</b> ) character and
preceding it with the backslash character was used to turn
off its special meaning.</p>

<p style="margin-left:11%; margin-top: 1em">The description
in the ISO&nbsp;POSIX-2:1993 standard introduced behavior
such that the backslash character was another special
character and it was unspecified whether there were any
other special characters. This description introduced
several portability problems, some of which are described
below, and so it has been replaced with the more historical
description. Some of the problems include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">Historically, to create the
replacement string, a script could use <b>gsub</b>(
<b>ERE</b>, <b>&quot;\\&amp;&quot;</b> ), but with the
ISO&nbsp;POSIX-2:1993 standard wording, it was necessary to
use <b>gsub</b>( <b>ERE</b>, <b>&quot;\\\\&amp;&quot;</b> ).
Backslash characters are doubled here because all string
literals are subject to lexical analysis, which would reduce
each pair of backslash characters to a single backslash
before being passed to <b>gsub</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Since it was unspecified what the special characters
were, for portable scripts to guarantee that characters are
printed literally, each character had to be preceded with a
backslash. (For example, a portable script had to use
<b>gsub</b>( <b>ERE</b>, <b>&quot;\\h\\i&quot;</b> ) to
produce a replacement string of <b>&quot;hi&quot;</b> .)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The description
for comparisons in the ISO&nbsp;POSIX-2:1993 standard did
not properly describe historical practice because of the way
numeric strings are compared as numbers. The current rules
cause the following code:</p>

<p style="margin-left:22%; margin-top: 1em"><b>if (0 ==
&quot;000&quot;) <br>
print &quot;strange, but true&quot; <br>
else <br>
print &quot;not true&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">to do a numeric
comparison, causing the <b>if</b> to succeed. It should be
intuitively obvious that this is incorrect behavior, and
indeed, no historical implementation of <i>awk</i> actually
behaves this way.</p>

<p style="margin-left:11%; margin-top: 1em">To fix this
problem, the definition of <i>numeric string</i> was
enhanced to include only those values obtained from specific
circumstances (mostly external sources) where it is not
possible to determine unambiguously whether the value is
intended to be a string or a numeric.</p>

<p style="margin-left:11%; margin-top: 1em">Variables that
are assigned to a numeric string shall also be treated as a
numeric string. (For example, the notion of a numeric string
can be propagated across assignments.) In comparisons, all
variables having the uninitialized value are to be treated
as a numeric operand evaluating to the numeric value
zero.</p>

<p style="margin-left:11%; margin-top: 1em">Uninitialized
variables include all types of variables including scalars,
array elements, and fields. The definition of an
uninitialized value in Variables and Special Variables is
necessary to describe the value placed on uninitialized
variables and on fields that are valid (for example, <b>&lt;
$NF</b>) but have no characters in them and to describe how
these variables are to be used in comparisons. A valid
field, such as <b>$1</b>, that has no characters in it can
be obtained from an input line of <b>&quot;\t\t&quot;</b>
when <b>FS= &rsquo;\t&rsquo;</b> . Historically, the
comparison ( <b>$1&lt;</b>10) was done numerically after
evaluating <b>$1</b> to the value zero.</p>

<p style="margin-left:11%; margin-top: 1em">The phrase
&quot;... also shall have the numeric value of the numeric
string&quot; was removed from several sections of the
ISO&nbsp;POSIX-2:1993 standard because is specifies an
unnecessary implementation detail. It is not necessary for
IEEE&nbsp;Std&nbsp;1003.1-2001 to specify that these objects
be assigned two different values. It is only necessary to
specify that these objects may evaluate to two different
values depending on context.</p>

<p style="margin-left:11%; margin-top: 1em">The description
of numeric string processing is based on the behavior of the
<i>atof</i>() function in the ISO&nbsp;C standard. While it
is not a requirement for an implementation to use this
function, many historical implementations of <i>awk</i> do.
In the ISO&nbsp;C standard, floating-point constants use a
period as a decimal point character for the language itself,
independent of the current locale, but the <i>atof</i>()
function and the associated <i>strtod</i>() function use the
decimal point character of the current locale when
converting strings to numeric values. Similarly in
<i>awk</i>, floating-point constants in an <i>awk</i> script
use a period independent of the locale, but input strings
use the decimal point character of the locale.</p>

<h2>FUTURE DIRECTIONS
<a name="FUTURE DIRECTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>Grammar
Conventions</i>, <i>grep</i>, <i>lex</i>, <i>sed</i>, the
System Interfaces volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
<i>atof</i>(), <i>exec</i>, <i>popen</i>(),
<i>setlocale</i>(), <i>strtod</i>()</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Portions of
this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information
Technology -- Portable Operating System Interface (POSIX),
The Open Group Base Specifications Issue 6, Copyright (C)
2001-2003 by the Institute of Electrical and Electronics
Engineers, Inc and The Open Group. In the event of any
discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open
Group Standard is the referee document. The original
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>
<hr>
</body>
</html>
