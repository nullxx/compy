<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:26 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IPC::Open2</title>

</head>
<body>

<h1 align="center">IPC::Open2</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#WARNING">WARNING</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">IPC::Open2
&minus; open a process for both reading and writing using
open2()</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use IPC::Open2;
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some cmd and args');
      # or without using the shell
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some', 'cmd', 'and', 'args');
    # or with handle autovivification
    my($chld_out, $chld_in);
    $pid = open2($chld_out, $chld_in, 'some cmd and args');
      # or without using the shell
    $pid = open2($chld_out, $chld_in, 'some', 'cmd', 'and', 'args');
    waitpid( $pid, 0 );
    my $child_exit_status = $? &gt;&gt; 8;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>open2()</i> function runs the given <tt>$cmd</tt> and
connects <tt>$chld_out</tt> for reading and
<tt>$chld_in</tt> for writing. It&rsquo;s what you think
should work when you try</p>

<pre style="margin-left:11%; margin-top: 1em">    $pid = open(HANDLE, &quot;|cmd args|&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">The write
filehandle will have autoflush turned on.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>$chld_out</tt> is a string (that is, a bareword
filehandle rather than a glob or a reference) and it begins
with <tt>&quot;&gt;&amp;&quot;</tt>, then the child will
send output directly to that file handle. If
<tt>$chld_in</tt> is a string that begins with
<tt>&quot;&lt;&amp;&quot;</tt>, then <tt>$chld_in</tt> will
be closed in the parent, and the child will read from it
directly. In both cases, there will be a <i>dup</i>(2)
instead of a <i>pipe</i>(2) made.</p>

<p style="margin-left:11%; margin-top: 1em">If either
reader or writer is the null string, this will be replaced
by an autogenerated filehandle. If so, you must pass a valid
lvalue in the parameter slot so it can be overwritten in the
caller, or an exception will be raised.</p>

<p style="margin-left:11%; margin-top: 1em"><i>open2()</i>
returns the process <small>ID</small> of the child process.
It doesn&rsquo;t return on failure: it just raises an
exception matching <tt>&quot;/^open2:/&quot;</tt>. However,
<tt>&quot;exec&quot;</tt> failures in the child are not
detected. You&rsquo;ll have to trap <small>SIGPIPE</small>
yourself.</p>

<p style="margin-left:11%; margin-top: 1em"><i>open2()</i>
does not wait for and reap the child process after it exits.
Except for short programs where it&rsquo;s acceptable to let
the operating system take care of this, you need to do this
yourself. This is normally as simple as calling
<tt>&quot;waitpid $pid, 0&quot;</tt> when you&rsquo;re done
with the process. Failing to do this can result in an
accumulation of defunct or &quot;zombie&quot; processes. See
&quot;waitpid&quot; in perlfunc for more information.</p>

<p style="margin-left:11%; margin-top: 1em">This whole
affair is quite dangerous, as you may block forever. It
assumes it&rsquo;s going to talk to something like
<b>bc</b>, both writing to it and reading from it. This is
presumably safe because you &quot;know&quot; that commands
like <b>bc</b> will read a line at a time and output a line
at a time. Programs like <b>sort</b> that read their entire
input stream first, however, are quite apt to cause
deadlock.</p>

<p style="margin-left:11%; margin-top: 1em">The big problem
with this approach is that if you don&rsquo;t have control
over source code being run in the child process, you
can&rsquo;t control what it does with pipe buffering. Thus
you can&rsquo;t just open a pipe to <tt>&quot;cat
&minus;v&quot;</tt> and continually read and write a line
from it.</p>

<p style="margin-left:11%; margin-top: 1em">The IO::Pty and
Expect modules from <small>CPAN</small> can help with this,
as they provide a real tty (well, a pseudo-tty, actually),
which gets you back to line buffering in the invoked command
again.</p>

<h2>WARNING
<a name="WARNING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The order of
arguments differs from that of <i>open3()</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See IPC::Open3
for an alternative that handles <small>STDERR</small> as
well. This function is really just a wrapper around
<i>open3()</i>.</p>
<hr>
</body>
</html>
