<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:26:08 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ttk::intro</title>

</head>
<body>

<h1 align="center">ttk::intro</h1>

<a href="#NAME">NAME</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#THEMES">THEMES</a><br>
<a href="#ELEMENTS">ELEMENTS</a><br>
<a href="#LAYOUTS">LAYOUTS</a><br>
<a href="#STATES">STATES</a><br>
<a href="#STYLES">STYLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ttk::intro
&minus; Introduction to the Tk theme engine
_________________________________________________________________</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Tk themed
widget set is based on a revised and enhanced version of TIP
#48 (http://tip.tcl.tk/48) specified style engine. The main
concepts are described below. The basic idea is to separate,
to the extent possible, the code implementing a
widget&rsquo;s behavior from the code implementing its
appearance. Widget class bindings are primarily responsible
for maintaining the widget state and invoking callbacks; all
aspects of the widget&rsquo;s appearance are controlled by
the style of the widget (i.e. the style of the elements of
the widget).</p>

<h2>THEMES
<a name="THEMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A <i>theme</i>
is a collection of elements and styles that determine the
look and feel of the widget set. Themes can be used to:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>isolate platform differences (X11 vs. classic Windows
vs. XP vs. Aqua ...)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>adapt to display limitations (low-color, grayscale,
monochrome, tiny screens)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>accessibility (high contrast, large type)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>application suite branding</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>blend in with the rest of the desktop (Gnome, KDE,
Java)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>and, of course: eye candy.</p></td></tr>
</table>

<h2>ELEMENTS
<a name="ELEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An
<i>element</i> displays an individual part of a widget. For
example, a vertical scrollbar widget contains
<b>uparrow</b>, <b>downarrow</b>, <b>trough</b> and
<b>slider</b> elements.</p>

<p style="margin-left:11%; margin-top: 1em">Element names
use a recursive dotted notation. For example, <b>uparrow</b>
identifies a generic arrow element, and
<b>Scrollbar.uparrow</b> and <b>Combobox.uparrow</b>
identify widget-specific elements. When looking for an
element, the style engine looks for the specific name first,
and if an element of that name is not found it looks for
generic elements by stripping off successive leading
components of the element name.</p>

<p style="margin-left:11%; margin-top: 1em">Like widgets,
elements have <i>options</i> which specify what to display
and how to display it. For example, the <b>text</b> element
(which displays a text string) has <b>&minus;text</b>,
<b>&minus;font</b>, <b>&minus;foreground</b>,
<b>&minus;background</b>, <b>&minus;underline</b>, and
<b>&minus;width</b> options. The value of an element option
is taken from:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">an option of the same name and
type in the widget containing the element;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>a dynamic setting specified by <b>style map</b> and the
current state;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>the default setting specified by <b>style configure</b>;
or</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>the element&rsquo;s built-in default value for the
option.</p> </td></tr>
</table>

<h2>LAYOUTS
<a name="LAYOUTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A <i>layout</i>
specifies which elements make up a widget and how they are
arranged. The layout engine uses a simplified version of the
<b>pack</b> algorithm: starting with an initial cavity equal
to the size of the widget, elements are allocated a parcel
within the cavity along the side specified by the
<b>&minus;side</b> option, and placed within the parcel
according to the <b>&minus;sticky</b> option. For example,
the layout for a horizontal scrollbar is:</p>

<p style="margin-left:22%; margin-top: 1em">ttk::<b>style
layout</b> Horizontal.TScrollbar { <br>
Scrollbar.trough &minus;children {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="92%">


<p>Scrollbar.leftarrow &minus;side left &minus;sticky w</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="92%">


<p>Scrollbar.rightarrow &minus;side right &minus;sticky
e</p> </td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="92%">


<p>Scrollbar.thumb &minus;side left &minus;expand true
&minus;sticky ew</p></td></tr>
</table>

<p style="margin-left:22%;">} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
layout for a widget is the same as its class name. Some
widgets may override this (for example, the
<b>ttk::scrollbar</b> widget chooses different layouts based
on the <b>&minus;orient</b> option).</p>

<h2>STATES
<a name="STATES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In standard Tk,
many widgets have a <b>&minus;state</b> option which (in
most cases) is either <b>normal</b> or <b>disabled</b>. Some
widgets support additional states, such as the <b>entry</b>
widget which has a <b>readonly</b> state and the various
flavors of buttons which have <b>active</b> state.</p>

<p style="margin-left:11%; margin-top: 1em">The themed Tk
widgets generalizes this idea: every widget has a bitmap of
independent state flags. Widget state flags include
<b>active</b>, <b>disabled</b>, <b>pressed</b>,
<b>focus</b>, etc., (see <i>ttk::widget(n)</i> for the full
list of state flags).</p>

<p style="margin-left:11%; margin-top: 1em">Instead of a
<b>&minus;state</b> option, every widget now has a
<b>state</b> widget command which is used to set or query
the state. A <i>state specification</i> is a list of
symbolic state names indicating which bits are set, each
optionally prefixed with an exclamation point indicating
that the bit is cleared instead.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the class bindings for the <b>ttk::button</b> widget
are:</p>

<p style="margin-left:22%; margin-top: 1em">bind TButton
&lt;Enter&gt;{ %W state active } <br>
bind TButton &lt;Leave&gt;{ %W state !active } <br>
bind TButton &lt;ButtonPress-1&gt;{ %W state pressed } <br>
bind TButton &lt;Button1-Leave&gt;{ %W state !pressed } <br>
bind TButton &lt;Button1-Enter&gt;{ %W state pressed } <br>
bind TButton &lt;ButtonRelease-1&gt;\ <br>
{ %W instate {pressed} { %W state !pressed ; %W invoke }
}</p>

<p style="margin-left:11%; margin-top: 1em">This specifies
that the widget becomes <b>active</b> when the pointer
enters the widget, and inactive when it leaves. Similarly it
becomes <b>pressed</b> when the mouse button is pressed, and
<b>!pressed</b> on the ButtonRelease event. In addition, the
button unpresses if pointer is dragged outside the widget
while Button-1 is held down, and represses if it&rsquo;s
dragged back in. Finally, when the mouse button is released,
the widget&rsquo;s <b>&minus;command</b> is invoked, but
only if the button is currently in the <b>pressed</b> state.
(The actual bindings are a little more complicated than the
above, but not by much).</p>

<h2>STYLES
<a name="STYLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Each widget is
associated with a <i>style</i>, which specifies values for
element options. Style names use a recursive dotted notation
like layouts and elements; by default, widgets use the class
name to look up a style in the current theme. For
example:</p>

<p style="margin-left:22%; margin-top: 1em">ttk::<b>style
configure</b> TButton \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;background #d9d9d9 \</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;foreground black \</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;relief raised \</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Many elements
are displayed differently depending on the widget state. For
example, buttons have a different background when they are
active, a different foreground when disabled, and a
different relief when pressed. The <b>style map</b> command
specifies dynamic option settings for a particular
style:</p>

<p style="margin-left:22%; margin-top: 1em">ttk::<b>style
map</b> TButton \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;background [list disabled #d9d9d9 active #ececec]
\</p> </td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;foreground [list disabled #a3a3a3] \</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>&minus;relief [list {pressed !disabled} sunken] \</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>;</p></td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">ttk::widget(n),
ttk::style(n)</p>
<hr>
</body>
</html>
