<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:19:14 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>pem</title>

</head>
<body>

<h1 align="center">pem</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PEM FUNCTION ARGUMENTS">PEM FUNCTION ARGUMENTS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#PEM ENCRYPTION FORMAT">PEM ENCRYPTION FORMAT</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#RETURN CODES">RETURN CODES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PEM,
PEM_read_bio_PrivateKey, PEM_read_PrivateKey,
PEM_write_bio_PrivateKey, PEM_write_PrivateKey,
PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
PEM_write_bio_PKCS8PrivateKey_nid,
PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY,
PEM_read_PUBKEY, PEM_write_bio_PUBKEY, PEM_write_PUBKEY,
PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey,
PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey,
PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey,
PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey,
PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY,
PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY,
PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey,
PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY,
PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY,
PEM_read_bio_DSAparams, PEM_read_DSAparams,
PEM_write_bio_DSAparams, PEM_write_DSAparams,
PEM_read_bio_DHparams, PEM_read_DHparams,
PEM_write_bio_DHparams, PEM_write_DHparams,
PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509,
PEM_write_X509, PEM_read_bio_X509_AUX, PEM_read_X509_AUX,
PEM_write_bio_X509_AUX, PEM_write_X509_AUX,
PEM_read_bio_X509_REQ, PEM_read_X509_REQ,
PEM_write_bio_X509_REQ, PEM_write_X509_REQ,
PEM_write_bio_X509_REQ_NEW, PEM_write_X509_REQ_NEW,
PEM_read_bio_X509_CRL, PEM_read_X509_CRL,
PEM_write_bio_X509_CRL, PEM_write_X509_CRL,
PEM_read_bio_PKCS7, PEM_read_PKCS7, PEM_write_bio_PKCS7,
PEM_write_PKCS7, PEM_read_bio_NETSCAPE_CERT_SEQUENCE,
PEM_read_NETSCAPE_CERT_SEQUENCE,
PEM_write_bio_NETSCAPE_CERT_SEQUENCE,
PEM_write_NETSCAPE_CERT_SEQUENCE &minus; PEM routines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> #include &lt;openssl/pem.h&gt;
 EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
 EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
 EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
 int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);
 RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
 RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
 RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);
 int PEM_write_RSAPublicKey(FILE *fp, RSA *x);
 RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,
                                        pem_password_cb *cb, void *u);
 RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);
 int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);
 DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);
 DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                        unsigned char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
 DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,
                                        pem_password_cb *cb, void *u);
 DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);
 int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);
 DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
 DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_DSAparams(BIO *bp, DSA *x);
 int PEM_write_DSAparams(FILE *fp, DSA *x);
 DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
 DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_DHparams(BIO *bp, DH *x);
 int PEM_write_DHparams(FILE *fp, DH *x);
 X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
 X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_X509(BIO *bp, X509 *x);
 int PEM_write_X509(FILE *fp, X509 *x);
 X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
 X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);
 int PEM_write_X509_AUX(FILE *fp, X509 *x);
 X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);
 X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);
 int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);
 int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);
 int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);
 X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,
                                        pem_password_cb *cb, void *u);
 int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
 int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);
 PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);
 PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);
 int PEM_write_PKCS7(FILE *fp, PKCS7 *x);
 NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);
 NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,
                                                NETSCAPE_CERT_SEQUENCE **x,
                                                pem_password_cb *cb, void *u);
 int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);
 int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions read or write structures in
<small>PEM</small> format. In this sense <small>PEM</small>
format is simply base64 encoded data surrounded by header
lines.</p>

<p style="margin-left:11%; margin-top: 1em">For more
details about the meaning of arguments see the <b><small>PEM
FUNCTION ARGUMENTS</small></b> section.</p>

<p style="margin-left:11%; margin-top: 1em">Each operation
has four functions associated with it. For clarity the term
&quot;<b>foobar</b> functions&quot; will be used to
collectively refer to the <i>PEM_read_bio_foobar()</i>,
<i>PEM_read_foobar()</i>, <i>PEM_write_bio_foobar()</i> and
<i>PEM_write_foobar()</i> functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PrivateKey</b> functions read or write a private key in
<small>PEM</small> format using an <small>EVP_PKEY</small>
structure. The write routines use &quot;traditional&quot;
private key format and can handle both <small>RSA</small>
and <small>DSA</small> private keys. The read functions can
additionally transparently handle PKCS#8 format encrypted
and unencrypted keys too.</p>


<p style="margin-left:11%; margin-top: 1em"><i>PEM_write_bio_PKCS8PrivateKey()</i>
and <i>PEM_write_PKCS8PrivateKey()</i> write a private key
in an <small>EVP_PKEY</small> structure in PKCS#8
EncryptedPrivateKeyInfo format using PKCS#5 v2.0 password
based encryption algorithms. The <b>cipher</b> argument
specifies the encryption algoritm to use: unlike all other
<small>PEM</small> routines the encryption is applied at the
PKCS#8 level and not in the <small>PEM</small> headers. If
<b>cipher</b> is <small>NULL</small> then no encryption is
used and a PKCS#8 PrivateKeyInfo structure is used
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><i>PEM_write_bio_PKCS8PrivateKey_nid()</i>
and <i>PEM_write_PKCS8PrivateKey_nid()</i> also write out a
private key as a PKCS#8 EncryptedPrivateKeyInfo however it
uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead.
The algorithm to use is specified in the <b>nid</b>
parameter and should be the <small>NID</small> of the
corresponding <small>OBJECT IDENTIFIER</small> (see
<small>NOTES</small> section).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>PUBKEY</small></b> functions process a public key
using an <small>EVP_PKEY</small> structure. The public key
is encoded as a SubjectPublicKeyInfo structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>RSAPrivateKey</b> functions process an <small>RSA</small>
private key using an <small>RSA</small> structure. It
handles the same formats as the <b>PrivateKey</b> functions
but an error occurs if the private key is not
<small>RSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>RSAPublicKey</b> functions process an <small>RSA</small>
public key using an <small>RSA</small> structure. The public
key is encoded using a PKCS#1 RSAPublicKey structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>RSA_PUBKEY</small></b> functions also process an
<small>RSA</small> public key using an <small>RSA</small>
structure. However the public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the
public key is not <small>RSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DSAPrivateKey</b> functions process a <small>DSA</small>
private key using a <small>DSA</small> structure. It handles
the same formats as the <b>PrivateKey</b> functions but an
error occurs if the private key is not
<small>DSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DSA_PUBKEY</small></b> functions process a
<small>DSA</small> public key using a <small>DSA</small>
structure. The public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the
public key is not <small>DSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DSAparams</b> functions process <small>DSA</small>
parameters using a <small>DSA</small> structure. The
parameters are encoded using a foobar structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DHparams</b> functions process <small>DH</small>
parameters using a <small>DH</small> structure. The
parameters are encoded using a PKCS#3 DHparameter
structure.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>X509</b>
functions process an X509 certificate using an X509
structure. They will also process a trusted X509 certificate
but any trust settings are discarded.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_AUX</b> functions process a trusted X509 certificate
using an X509 structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_REQ</b> and <b>X509_REQ_NEW</b> functions process a
PKCS#10 certificate request using an X509_REQ structure. The
<b>X509_REQ</b> write functions use <b><small>CERTIFICATE
REQUEST</small></b> in the header whereas the
<b>X509_REQ_NEW</b> functions use <b><small>NEW CERTIFICATE
REQUEST</small></b> (as required by some CAs). The
<b>X509_REQ</b> read functions will handle either form so
there are no <b>X509_REQ_NEW</b> read functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_CRL</b> functions process an X509 <small>CRL</small>
using an X509_CRL structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>PKCS7</small></b> functions process a PKCS#7
ContentInfo using a <small>PKCS7</small> structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>NETSCAPE_CERT_SEQUENCE</small></b> functions
process a Netscape Certificate Sequence using a
<small>NETSCAPE_CERT_SEQUENCE</small> structure.</p>

<h2>PEM FUNCTION ARGUMENTS
<a name="PEM FUNCTION ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions have many common arguments.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>bp</b>
<small>BIO</small> parameter (if present) specifies the
<small>BIO</small> to read from or write to.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>fp</b>
<small>FILE</small> parameter (if present) specifies the
<small>FILE</small> pointer to read from or write to.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> read functions all take an argument
<b><small>TYPE</small> **x</b> and return a
<b><small>TYPE</small> *</b> pointer. Where
<b><small>TYPE</small></b> is whatever structure the
function uses. If <b>x</b> is <small>NULL</small> then the
parameter is ignored. If <b>x</b> is not <small>NULL</small>
but <b>*x</b> is <small>NULL</small> then the structure
returned will be written to <b>*x</b>. If neither <b>x</b>
nor <b>*x</b> is <small>NULL</small> then an attempt is made
to reuse the structure at <b>*x</b> (but see
<small>BUGS</small> and <small>EXAMPLES</small> sections).
Irrespective of the value of <b>x</b> a pointer to the
structure is always returned (or <small>NULL</small> if an
error occurred).</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions which write private keys take
an <b>enc</b> parameter which specifies the encryption
algorithm to use, encryption is done at the
<small>PEM</small> level. If this parameter is set to
<small>NULL</small> then the private key is written in
unencrypted form.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>cb</b>
argument is the callback to use when querying for the pass
phrase used for encrypted <small>PEM</small> structures
(normally only private keys).</p>

<p style="margin-left:11%; margin-top: 1em">For the
<small>PEM</small> write routines if the <b>kstr</b>
parameter is not <small>NULL</small> then <b>klen</b> bytes
at <b>kstr</b> are used as the passphrase and <b>cb</b> is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>cb</b> parameters is set to <small>NULL</small> and the
<b>u</b> parameter is not <small>NULL</small> then the
<b>u</b> parameter is interpreted as a null terminated
string to use as the passphrase. If both <b>cb</b> and
<b>u</b> are <small>NULL</small> then the default callback
routine is used which will typically prompt for the
passphrase on the current terminal with echoing turned
off.</p>

<p style="margin-left:11%; margin-top: 1em">The default
passphrase callback is sometimes inappropriate (for example
in a <small>GUI</small> application) so an alternative can
be supplied. The callback routine has the following
form:</p>

<pre style="margin-left:11%; margin-top: 1em"> int cb(char *buf, int size, int rwflag, void *u);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>buf</b> is
the buffer to write the passphrase to. <b>size</b> is the
maximum length of the passphrase (i.e. the size of buf).
<b>rwflag</b> is a flag which is set to 0 when reading and 1
when writing. A typical routine will ask the user to verify
the passphrase (for example by prompting for it twice) if
<b>rwflag</b> is 1. The <b>u</b> parameter has the same
value as the <b>u</b> parameter passed to the
<small>PEM</small> routine. It allows arbitrary data to be
passed to the callback by the application (for example a
window handle in a <small>GUI</small> application). The
callback <b>must</b> return the number of characters in the
passphrase or 0 if an error occurred.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although the
<small>PEM</small> routines take several arguments in almost
all applications most of them are set to 0 or
<small>NULL.</small></p>

<p style="margin-left:11%; margin-top: 1em">Read a
certificate in <small>PEM</small> format from a
<small>BIO:</small></p>

<pre style="margin-left:11%; margin-top: 1em"> X509 *x;
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);
 if (x == NULL)
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Alternative
method:</p>

<pre style="margin-left:11%; margin-top: 1em"> X509 *x = NULL;
 if (!PEM_read_bio_X509(bp, &amp;x, 0, NULL))
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Write a
certificate to a <small>BIO:</small></p>

<pre style="margin-left:11%; margin-top: 1em"> if (!PEM_write_bio_X509(bp, x))
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Write an
unencrypted private key to a <small>FILE</small>
pointer:</p>

<pre style="margin-left:11%; margin-top: 1em"> if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Write a private
key (using traditional format) to a <small>BIO</small> using
triple <small>DES</small> encryption, the pass phrase is
prompted for:</p>

<pre style="margin-left:11%; margin-top: 1em"> if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Write a private
key (using PKCS#8 format) to a <small>BIO</small> using
triple <small>DES</small> encryption, using the pass phrase
&quot;hello&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em"> if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, &quot;hello&quot;))
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Read a private
key from a <small>BIO</small> using the pass phrase
&quot;hello&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em"> key = PEM_read_bio_PrivateKey(bp, NULL, 0, &quot;hello&quot;);
 if (key == NULL)
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Read a private
key from a <small>BIO</small> using a pass phrase
callback:</p>

<pre style="margin-left:11%; margin-top: 1em"> key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, &quot;My Private Key&quot;);
 if (key == NULL)
        {
        /* Error */
        }</pre>


<p style="margin-left:11%; margin-top: 1em">Skeleton pass
phrase callback:</p>

<pre style="margin-left:11%; margin-top: 1em"> int pass_cb(char *buf, int size, int rwflag, void *u);
        {
        int len;
        char *tmp;
        /* We'd probably do something else if 'rwflag' is 1 */
        printf(&quot;Enter pass phrase for \&quot;%s\&quot;\n&quot;, u);
        /* get pass phrase, length 'len' into 'tmp' */
        tmp = &quot;hello&quot;;
        len = strlen(tmp);
        if (len &lt;= 0) return 0;
        /* if too long, truncate */
        if (len &gt; size) len = size;
        memcpy(buf, tmp, len);
        return len;
        }</pre>


<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The old
<b>PrivateKey</b> write routines are retained for
compatibility. New applications should write private keys
using the <i>PEM_write_bio_PKCS8PrivateKey()</i> or
<i>PEM_write_PKCS8PrivateKey()</i> routines because they are
more secure (they use an iteration count of 2048 whereas the
traditional routines use a count of 1) unless compatibility
with older versions of OpenSSL is important.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PrivateKey</b> read routines can be used in all
applications because they handle all formats
transparently.</p>

<p style="margin-left:11%; margin-top: 1em">A frequent
cause of problems is attempting to use the
<small>PEM</small> routines like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> X509 *x;
 PEM_read_bio_X509(bp, &amp;x, 0, NULL);</pre>


<p style="margin-left:11%; margin-top: 1em">this is a bug
because an attempt will be made to reuse the data at
<b>x</b> which is an uninitialised pointer.</p>

<h2>PEM ENCRYPTION FORMAT
<a name="PEM ENCRYPTION FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This old
<b>PrivateKey</b> routines use a non standard technique for
encryption.</p>

<p style="margin-left:11%; margin-top: 1em">The private key
(or other data) takes the following form:</p>

<pre style="margin-left:11%; margin-top: 1em"> &minus;&minus;&minus;&minus;&minus;BEGIN RSA PRIVATE KEY&minus;&minus;&minus;&minus;&minus;
 Proc&minus;Type: 4,ENCRYPTED
 DEK&minus;Info: DES&minus;EDE3&minus;CBC,3F17F5316E2BAC89
 ...base64 encoded data...
 &minus;&minus;&minus;&minus;&minus;END RSA PRIVATE KEY&minus;&minus;&minus;&minus;&minus;</pre>


<p style="margin-left:11%; margin-top: 1em">The line
beginning DEK-Info contains two comma separated pieces of
information: the encryption algorithm name as used by
<i>EVP_get_cipherbyname()</i> and an 8 byte <b>salt</b>
encoded as a set of hexadecimal digits.</p>

<p style="margin-left:11%; margin-top: 1em">After this is
the base64 encoded encrypted data.</p>

<p style="margin-left:11%; margin-top: 1em">The encryption
key is determined using <i>EVP_bytestokey()</i>, using
<b>salt</b> and an iteration count of 1. The
<small>IV</small> used is the value of <b>salt</b> and *not*
the <small>IV</small> returned by
<i>EVP_bytestokey()</i>.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> read routines in some versions of OpenSSL
will not correctly reuse an existing structure. Therefore
the following:</p>

<pre style="margin-left:11%; margin-top: 1em"> PEM_read_bio_X509(bp, &amp;x, 0, NULL);</pre>


<p style="margin-left:11%; margin-top: 1em">where <b>x</b>
already contains a valid certificate, may not work,
whereas:</p>

<pre style="margin-left:11%; margin-top: 1em"> X509_free(x);
 x = PEM_read_bio_X509(bp, NULL, 0, NULL);</pre>


<p style="margin-left:11%; margin-top: 1em">is guaranteed
to work.</p>

<h2>RETURN CODES
<a name="RETURN CODES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The read
routines return either a pointer to the structure read or
<small>NULL</small> if an error occurred.</p>

<p style="margin-left:11%; margin-top: 1em">The write
routines return 1 for success or 0 for failure.</p>
<hr>
</body>
</html>
