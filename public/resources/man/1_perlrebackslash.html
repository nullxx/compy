<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:26 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLREBACKSLASH</title>

</head>
<body>

<h1 align="center">PERLREBACKSLASH</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">perlrebackslash
&minus; Perl Regular Expression Backslash Sequences and
Escapes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The top level
documentation about Perl regular expressions is found in
perlre.</p>

<p style="margin-left:11%; margin-top: 1em">This document
describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the
sequences that have a special meaning in Perl regular
expressions (in alphabetical order), then describes each of
them.</p>

<p style="margin-left:11%; margin-top: 1em">Most sequences
are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide
describing all backslash and escape sequences.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
backslash</b> <br>
In a regular expression, the backslash can perform one of
two tasks: it either takes away the special meaning of the
character following it (for instance,
<tt>&quot;\|&quot;</tt> matches a vertical bar, it&rsquo;s
not an alternation), or it is the start of a backslash or
escape sequence.</p>

<p style="margin-left:11%; margin-top: 1em">The rules
determining what it is are quite simple: if the character
following the backslash is an <small>ASCII</small>
punctuation (non-word) character (that is, anything that is
not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following
it.</p>

<p style="margin-left:11%; margin-top: 1em">If the
character following the backslash is an <small>ASCII</small>
letter or an <small>ASCII</small> digit, then the sequence
may be special; if so, it&rsquo;s listed below. A few
letters have not been used yet, so escaping them with a
backslash doesn&rsquo;t change them to be special. A future
version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you
use such a sequence. [1].</p>

<p style="margin-left:11%; margin-top: 1em">It is however
guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and
not in a future version of Perl 5. So it is safe to put a
backslash in front of a non-word character.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
backslash itself is special; if you want to match a
backslash, you have to escape the backslash with a
backslash: <tt>&quot;/\\/&quot;</tt> matches a single
backslash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>There is one exception. If you use an alphanumeric
character as the delimiter of your pattern (which you
probably shouldn&rsquo;t do for readability reasons), you
have to escape the delimiter if you want to match it. Perl
won&rsquo;t warn then. See also &quot;Gory details of
parsing quoted constructs&quot; in perlop.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>All the
sequences and escapes</b> <br>
Those not usable within a bracketed character class (like
<tt>&quot;[\da&minus;z]&quot;</tt>) are marked as
<tt>&quot;Not in [].&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>\000 Octal
escape sequence. See also \o{}. <br>
\1 Absolute backreference. Not in []. <br>
\a Alarm or bell. <br>
\A Beginning of string. Not in []. <br>
\b Word/non&minus;word boundary. (Backspace in []). <br>
\B Not a word/non&minus;word boundary. Not in []. <br>
\cX Control&minus;X <br>
\C Single octet, even under UTF&minus;8. Not in []. <br>
\d Character class for digits. <br>
\D Character class for non&minus;digits. <br>
\e Escape character. <br>
\E Turn off \Q, \L and \U processing. Not in []. <br>
\f Form feed. <br>
\F Foldcase till \E. Not in []. <br>
\g{}, \g1 Named, absolute or relative backreference. Not in
[] <br>
\G Pos assertion. Not in []. <br>
\h Character class for horizontal whitespace. <br>
\H Character class for non horizontal whitespace. <br>
\k{}, \k&lt;&gt;, \k'' Named backreference. Not in []. <br>
\K Keep the stuff left of \K. Not in []. <br>
\l Lowercase next character. Not in []. <br>
\L Lowercase till \E. Not in []. <br>
\n (Logical) newline character. <br>
\N Any character but newline. Experimental. Not in []. <br>
\N{} Named or numbered (Unicode) character or sequence. <br>
\o{} Octal escape sequence. <br>
\p{}, \pP Character with the given Unicode property. <br>
\P{}, \PP Character without the given Unicode property. <br>
\Q Quote (disable) pattern metacharacters till \E. Not <br>
in []. <br>
\r Return character. <br>
\R Generic new line. Not in []. <br>
\s Character class for whitespace. <br>
\S Character class for non whitespace. <br>
\t Tab character. <br>
\u Titlecase next character. Not in []. <br>
\U Uppercase till \E. Not in []. <br>
\v Character class for vertical whitespace. <br>
\V Character class for non vertical whitespace. <br>
\w Character class for word characters. <br>
\W Character class for non&minus;word characters. <br>
\x{}, \x00 Hexadecimal escape sequence. <br>
\X Unicode &quot;extended grapheme cluster&quot;. Not in [].
<br>
\z End of string. Not in []. <br>
\Z End of string. Not in [].</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Character
Escapes</b> <i><br>
Fixed characters</i></p>

<p style="margin-left:11%; margin-top: 1em">A handful of
characters have a dedicated <i>character escape</i>. The
following table shows them, along with their
<small>ASCII</small> code points (in decimal and hex), their
<small>ASCII</small> name, the control escape on
<small>ASCII</small> platforms and a short description. (For
<small>EBCDIC</small> platforms, see &quot; <small>OPERATOR
DIFFERENCES</small> &quot; in perlebcdic.)</p>

<pre style="margin-left:11%; margin-top: 1em"> Seq.  Code Point  ASCII   Cntrl   Description.
       Dec    Hex
  \a     7     07    BEL    \cG    alarm or bell
  \b     8     08     BS    \cH    backspace [1]
  \e    27     1B    ESC    \c[    escape character
  \f    12     0C     FF    \cL    form feed
  \n    10     0A     LF    \cJ    line feed [2]
  \r    13     0D     CR    \cM    carriage return
  \t     9     09    TAB    \cI    tab</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;\b&quot;</tt> is the
backspace character only inside a character class. Outside a
character class, <tt>&quot;\b&quot;</tt> is a
word/non&minus;word boundary.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p><tt>&quot;\n&quot;</tt> matches a logical newline. Perl
converts between <tt>&quot;\n&quot;</tt> and your
<small>OS</small> &rsquo;s native newline character when
reading from or writing to text files.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<pre style="margin-left:11%; margin-top: 1em"> $str =~ /\t/;   # Matches if $str contains a (horizontal) tab.</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Control
characters</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\c&quot;</tt>
is used to denote a control character; the character
following <tt>&quot;\c&quot;</tt> determines the value of
the construct. For example the value of
<tt>&quot;\cA&quot;</tt> is <tt>chr(1)</tt>, and the value
of <tt>&quot;\cb&quot;</tt> is <tt>chr(2)</tt>, etc. The
gory details are in &quot;Regexp Quote-Like Operators&quot;
in perlop. A complete list of what <tt>chr(1)</tt>, etc.
means for <small>ASCII</small> and <small>EBCDIC</small>
platforms is in &quot; <small>OPERATOR DIFFERENCES</small>
&quot; in perlebcdic.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<tt>&quot;\c\&quot;</tt> alone at the end of a regular
expression (or doubled-quoted string) is not valid. The
backslash must be followed by another character. That is,
<tt>&quot;\c\</tt><i>X</i><tt>&quot;</tt> means
<tt>&quot;chr(28) . '</tt><i>X</i><tt>'&quot;</tt> for all
characters <i>X</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To write
platform-independent code, you must use
<tt>&quot;\N{</tt><i>NAME</i><tt>}&quot;</tt> instead, like
<tt>&quot;\N{ESCAPE}&quot;</tt> or
<tt>&quot;\N{U+001B}&quot;</tt>, see charnames.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>c</i>ontrol character.</p>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<pre style="margin-left:11%; margin-top: 1em"> $str =~ /\cK/;  # Matches if $str contains a vertical tab (control&minus;K).</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Named or
numbered characters and character sequences</i></p>

<p style="margin-left:11%; margin-top: 1em">Unicode
characters have a Unicode name and numeric code point
(ordinal) value. Use the <tt>&quot;\N{}&quot;</tt> construct
to specify a character by either of these values. Certain
sequences of characters also have names.</p>

<p style="margin-left:11%; margin-top: 1em">To specify by
name, the name of the character or character sequence goes
between the curly braces.</p>

<p style="margin-left:11%; margin-top: 1em">To specify a
character by Unicode code point, use the form
<tt>&quot;\N{U+</tt><i>code point</i><tt>}&quot;</tt>, where
<i>code point</i> is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired
character. It is customary but not required to use leading
zeros to pad the number to 4 digits. Thus
<tt>&quot;\N{U+0041}&quot;</tt> means <tt>&quot;LATIN
CAPITAL LETTER A&quot;</tt>, and you will rarely see it
written without the two leading zeros.
<tt>&quot;\N{U+0041}&quot;</tt> means &quot;A&quot; even on
<small>EBCDIC</small> machines (where the ordinal value of
&quot;A&quot; is not 0x41).</p>

<p style="margin-left:11%; margin-top: 1em">It is even
possible to give your own names to characters and character
sequences. For details, see charnames.</p>

<p style="margin-left:11%; margin-top: 1em">(There is an
expanded internal form that you may see in debug output:
<tt>&quot;\N{U+</tt><i>code point</i><tt>.</tt><i>code
point</i><tt>...}&quot;</tt>. The <tt>&quot;...&quot;</tt>
means any number of these <i>code point</i>s separated by
dots. This represents the sequence formed by the characters.
This is an internal form only, subject to change, and you
should not try to use it yourself.)</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>N</i>amed character.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character or character sequence expressed as a named or
numbered character is considered a character without special
meaning by the regex engine, and will match &quot;as
is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<pre style="margin-left:11%; margin-top: 1em"> $str =~ /\N{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character
 use charnames 'Cyrillic';            # Loads Cyrillic names.
 $str =~ /\N{ZHE}\N{KA}/;             # Match &quot;ZHE&quot; followed by &quot;KA&quot;.</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Octal
escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">There are two
forms of octal escapes. Each is used to specify a character
by its code point specified in octal notation.</p>

<p style="margin-left:11%; margin-top: 1em">One form,
available starting in Perl 5.14 looks like
<tt>&quot;\o{...}&quot;</tt>, where the dots represent one
or more octal digits. It can be used for any Unicode
character.</p>

<p style="margin-left:11%; margin-top: 1em">It was
introduced to avoid the potential problems with the other
form, available in all Perls. That form consists of a
backslash followed by three octal digits. One problem with
this form is that it can look exactly like an old-style
backreference (see &quot;Disambiguation rules between
old-style octal escapes and backreferences&quot; below.) You
can avoid this by making the first of the three digits
always a zero, but that makes \077 the largest code point
specifiable.</p>

<p style="margin-left:11%; margin-top: 1em">In some
contexts, a backslash followed by two or even one octal
digits may be interpreted as an octal escape, sometimes with
a warning, and because of some bugs, sometimes with
surprising results. Also, if you are creating a regex out of
smaller snippets concatenated together, and you use fewer
than three digits, the beginning of one snippet may be
interpreted as adding digits to the ending of the snippet
before it. See &quot;Absolute referencing&quot; for more
discussion and examples of the snippet problem.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character expressed as an octal escape is considered a
character without special meaning by the regex engine, and
will match &quot;as is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To summarize,
the <tt>&quot;\o{}&quot;</tt> form is always safe to use,
and the other form is safe to use for code points through
\077 when you use exactly three digits to specify them.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>0</i>ctal or <i>o</i>ctal.</p>

<p style="margin-left:11%; margin-top: 1em">Examples
(assuming an <small>ASCII</small> platform)</p>

<pre style="margin-left:11%; margin-top: 1em"> $str = &quot;Perl&quot;;
 $str =~ /\o{120}/;  # Match, &quot;\120&quot; is &quot;P&quot;.
 $str =~ /\120/;     # Same.
 $str =~ /\o{120}+/; # Match, &quot;\120&quot; is &quot;P&quot;, it's repeated at least once
 $str =~ /\120+/;    # Same.
 $str =~ /P\053/;    # No match, &quot;\053&quot; is &quot;+&quot; and taken literally.
 /\o{23073}/         # Black foreground, white background smiling face.
 /\o{4801234567}/    # Raises a warning, and yields chr(4)</pre>


<p style="margin-left:11%; margin-top: 1em">Disambiguation
rules between old-style octal escapes and backreferences</p>

<p style="margin-left:11%; margin-top: 1em">Octal escapes
of the <tt>&quot;\000&quot;</tt> form outside of bracketed
character classes potentially clash with old-style
backreferences. (see &quot;Absolute referencing&quot;
below). They both consist of a backslash followed by
numbers. So Perl has to use heuristics to determine whether
it is a backreference or an octal escape. Perl uses the
following rules to disambiguate:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the backslash is followed by
a single digit, it&rsquo;s a backreference.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the first digit following the backslash is a 0,
it&rsquo;s an octal escape.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the number following the backslash is N (in decimal),
and Perl already has seen N capture groups, Perl considers
this a backreference. Otherwise, it considers it an octal
escape. If N has more than three digits, Perl takes only the
first three for the octal escape; the rest are matched as
is.</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> my $pat  = &quot;(&quot; x 999;
    $pat .= &quot;a&quot;;
    $pat .= &quot;)&quot; x 999;
 /^($pat)\1000$/;   #  Matches 'aa'; there are 1000 capture groups.
 /^$pat\1000$/;     #  Matches 'a@0'; there are 999 capture groups
                    #    and \1000 is seen as \100 (a '@') and a '0'</pre>


<p style="margin-left:11%; margin-top: 1em">You can force a
backreference interpretation always by using the
<tt>&quot;\g{...}&quot;</tt> form. You can the force an
octal interpretation always by using the
<tt>&quot;\o{...}&quot;</tt> form, or for numbers up through
\077 (= 63 decimal), by using three digits, beginning with a
&quot;0&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Hexadecimal
escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">Like octal
escapes, there are two forms of hexadecimal escapes, but
both start with the same thing, <tt>&quot;\x&quot;</tt>.
This is followed by either exactly two hexadecimal digits
forming a number, or a hexadecimal number of arbitrary
length surrounded by curly braces. The hexadecimal number is
the code point of the character you want to express.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and
will match &quot;as is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
he<i>x</i>adecimal.</p>

<p style="margin-left:11%; margin-top: 1em">Examples
(assuming an <small>ASCII</small> platform)</p>

<pre style="margin-left:11%; margin-top: 1em"> $str = &quot;Perl&quot;;
 $str =~ /\x50/;    # Match, &quot;\x50&quot; is &quot;P&quot;.
 $str =~ /\x50+/;   # Match, &quot;\x50&quot; is &quot;P&quot;, it is repeated at least once
 $str =~ /P\x2B/;   # No match, &quot;\x2B&quot; is &quot;+&quot; and taken literally.
 /\x{2603}\x{2602}/ # Snowman with an umbrella.
                    # The Unicode character 2603 is a snowman,
                    # the Unicode character 2602 is an umbrella.
 /\x{263B}/         # Black smiling face.
 /\x{263b}/         # Same, the hex digits A &minus; F are case insensitive.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Modifiers</b>
<br>
A number of backslash sequences have to do with changing the
character, or characters following them.
<tt>&quot;\l&quot;</tt> will lowercase the character
following it, while <tt>&quot;\u&quot;</tt> will uppercase
(or, more accurately, titlecase) the character following it.
They provide functionality similar to the functions
<tt>&quot;lcfirst&quot;</tt> and
<tt>&quot;ucfirst&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To uppercase or
lowercase several characters, one might want to use
<tt>&quot;\L&quot;</tt> or <tt>&quot;\U&quot;</tt>, which
will lowercase/uppercase all characters following them,
until either the end of the pattern or the next occurrence
of <tt>&quot;\E&quot;</tt>, whichever comes first. They
provide functionality similar to what the functions
<tt>&quot;lc&quot;</tt> and <tt>&quot;uc&quot;</tt>
provide.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\Q&quot;</tt>
is used to quote (disable) pattern metacharacters, up to the
next <tt>&quot;\E&quot;</tt> or the end of the pattern.
<tt>&quot;\Q&quot;</tt> adds a backslash to any character
that could have special meaning to Perl. In the
<small>ASCII</small> range, it quotes every character that
isn&rsquo;t a letter, digit, or underscore. See
&quot;quotemeta&quot; in perlfunc for details on what gets
quoted for non-ASCII code points. Using this ensures that
any character between <tt>&quot;\Q&quot;</tt> and
<tt>&quot;\E&quot;</tt> will be matched literally, not
interpreted as a metacharacter by the regex engine.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\F&quot;</tt>
can be used to casefold all characters following, up to the
next <tt>&quot;\E&quot;</tt> or the end of the pattern. It
provides the functionality similar to the
<tt>&quot;fc&quot;</tt> function.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>L</i>owercase, <i>U</i>ppercase, <i>F</i>old-case,
<i>Q</i>uotemeta, <i>E</i>nd.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em"> $sid     = &quot;sid&quot;;
 $greg    = &quot;GrEg&quot;;
 $miranda = &quot;(Miranda)&quot;;
 $str     =~ /\u$sid/;        # Matches 'Sid'
 $str     =~ /\L$greg/;       # Matches 'greg'
 $str     =~ /\Q$miranda\E/;  # Matches '(Miranda)', as if the pattern
                              #   had been written as /\(Miranda\)/</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Character
classes</b> <br>
Perl regular expressions have a large range of character
classes. Some of the character classes are written as a
backslash sequence. We will briefly discuss those here; full
details of character classes can be found in
perlrecharclass.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\w&quot;</tt>
is a character class that matches any single <i>word</i>
character (letters, digits, Unicode marks, and connector
punctuation (like the underscore)). <tt>&quot;\d&quot;</tt>
is a character class that matches any decimal digit, while
the character class <tt>&quot;\s&quot;</tt> matches any
whitespace character. New in perl 5.10.0 are the classes
<tt>&quot;\h&quot;</tt> and <tt>&quot;\v&quot;</tt> which
match horizontal and vertical whitespace characters.</p>

<p style="margin-left:11%; margin-top: 1em">The exact set
of characters matched by <tt>&quot;\d&quot;</tt>,
<tt>&quot;\s&quot;</tt>, and <tt>&quot;\w&quot;</tt> varies
depending on various pragma and regular expression
modifiers. It is possible to restrict the match to the
<small>ASCII</small> range by using the
<tt>&quot;/a&quot;</tt> regular expression modifier. See
perlrecharclass.</p>

<p style="margin-left:11%; margin-top: 1em">The uppercase
variants (<tt>&quot;\W&quot;</tt>, <tt>&quot;\D&quot;</tt>,
<tt>&quot;\S&quot;</tt>, <tt>&quot;\H&quot;</tt>, and
<tt>&quot;\V&quot;</tt>) are character classes that match,
respectively, any character that isn&rsquo;t a word
character, digit, whitespace, horizontal whitespace, or
vertical whitespace.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonics:
<i>w</i>ord, <i>d</i>igit, <i>s</i>pace, <i>h</i>orizontal,
<i>v</i>ertical.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Unicode
classes</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\pP&quot;</tt>
(where <tt>&quot;P&quot;</tt> is a single letter) and
<tt>&quot;\p{Property}&quot;</tt> are used to match a
character that matches the given Unicode property;
properties include things like &quot;letter&quot;, or
&quot;thai character&quot;. Capitalizing the sequence to
<tt>&quot;\PP&quot;</tt> and
<tt>&quot;\P{Property}&quot;</tt> make the sequence match a
character that doesn&rsquo;t match the given Unicode
property. For more details, see &quot;Backslash
sequences&quot; in perlrecharclass and &quot;Unicode
Character Properties&quot; in perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>p</i>roperty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Referencing</b>
<br>
If capturing parenthesis are used in a regular expression,
we can refer to the part of the source string that was
matched, and match exactly the same thing. There are three
ways of referring to such <i>backreference</i>: absolutely,
relatively, and by name.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Absolute
referencing</i></p>

<p style="margin-left:11%; margin-top: 1em">Either
<tt>&quot;\g</tt><i>N</i><tt>&quot;</tt> (starting in Perl
5.10.0), or <tt>&quot;\</tt><i>N</i><tt>&quot;</tt>
(old-style) where <i>N</i> is a positive (unsigned) decimal
number of any length is an absolute reference to a capturing
group.</p>

<p style="margin-left:11%; margin-top: 1em"><i>N</i> refers
to the Nth set of parentheses, so
<tt>&quot;\g</tt><i>N</i><tt>&quot;</tt> refers to whatever
has been matched by that set of parentheses. Thus
<tt>&quot;\g1&quot;</tt> refers to the first capture group
in the regex.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\g</tt><i>N</i><tt>&quot;</tt> form can be
equivalently written as
<tt>&quot;\g{</tt><i>N</i><tt>}&quot;</tt> which avoids
ambiguity when building a regex by concatenating shorter
strings. Otherwise if you had a regex
<tt>&quot;qr/$a$b/&quot;</tt>, and <tt>$a</tt> contained
<tt>&quot;\g1&quot;</tt>, and <tt>$b</tt> contained
<tt>&quot;37&quot;</tt>, you would get
<tt>&quot;/\g137/&quot;</tt> which is probably not what you
intended.</p>

<p style="margin-left:11%; margin-top: 1em">In the
<tt>&quot;\</tt><i>N</i><tt>&quot;</tt> form, <i>N</i> must
not begin with a &quot;0&quot;, and there must be at least
<i>N</i> capturing groups, or else <i>N</i> is considered an
octal escape (but something like <tt>&quot;\18&quot;</tt> is
the same as <tt>&quot;\0018&quot;</tt>; that is, the octal
escape <tt>&quot;\001&quot;</tt> followed by a literal digit
<tt>&quot;8&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>g</i>roup.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em"> /(\w+) \g1/;    # Finds a duplicated word, (e.g. &quot;cat cat&quot;).
 /(\w+) \1/;     # Same thing; written old&minus;style
 /(.)(.)\g2\g1/;  # Match a four letter palindrome (e.g. &quot;ABBA&quot;).</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Relative
referencing</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\g&minus;</tt><i>N</i><tt>&quot;</tt>
(starting in Perl 5.10.0) is used for relative addressing.
(It can be written as
<tt>&quot;\g{&minus;</tt><i>N</i><tt>&quot;</tt>.) It refers
to the <i>N</i>th group before the
<tt>&quot;\g{&minus;</tt><i>N</i><tt>}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The big
advantage of this form is that it makes it much easier to
write patterns with references that can be interpolated in
larger patterns, even if the larger pattern also contains
capture groups.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em"> /(A)        # Group 1
  (          # Group 2
    (B)      # Group 3
    \g{&minus;1}   # Refers to group 3 (B)
    \g{&minus;3}   # Refers to group 1 (A)
  )
 /x;         # Matches &quot;ABBA&quot;.
 my $qr = qr /(.)(.)\g{&minus;2}\g{&minus;1}/;  # Matches 'abab', 'cdcd', etc.
 /$qr$qr/                           # Matches 'ababcdcd'.</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Named
referencing</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\g{</tt><i>name</i><tt>}&quot;</tt>
(starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to
think about capture buffer positions.</p>

<p style="margin-left:11%; margin-top: 1em">To be
compatible with .Net regular expressions,
<tt>&quot;\g{name}&quot;</tt> may also be written as
<tt>&quot;\k{name}&quot;</tt>,
<tt>&quot;\k&lt;name&gt;&quot;</tt> or
<tt>&quot;\k'name'&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent any
ambiguity, <i>name</i> must not start with a digit nor
contain a hyphen.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em"> /(?&lt;word&gt;\w+) \g{word}/ # Finds duplicated word, (e.g. &quot;cat cat&quot;)
 /(?&lt;word&gt;\w+) \k{word}/ # Same.
 /(?&lt;word&gt;\w+) \k&lt;word&gt;/ # Same.
 /(?&lt;letter1&gt;.)(?&lt;letter2&gt;.)\g{letter2}\g{letter1}/
                         # Match a four letter palindrome (e.g. &quot;ABBA&quot;)</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Assertions</b>
<br>
Assertions are conditions that have to be true; they
don&rsquo;t actually match parts of the substring. There are
six assertions that are written as backslash sequences.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\A</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;\A&quot;</tt> only
matches at the beginning of the string. If the
<tt>&quot;/m&quot;</tt> modifier isn&rsquo;t used, then
<tt>&quot;/\A/&quot;</tt> is equivalent to
<tt>&quot;/^/&quot;</tt>. However, if the
<tt>&quot;/m&quot;</tt> modifier is used, then
<tt>&quot;/^/&quot;</tt> matches internal newlines, but the
meaning of <tt>&quot;/\A/&quot;</tt> isn&rsquo;t changed by
the <tt>&quot;/m&quot;</tt> modifier.
<tt>&quot;\A&quot;</tt> matches at the beginning of the
string regardless whether the <tt>&quot;/m&quot;</tt>
modifier is used.</p></td></tr>
</table>

<p style="margin-left:11%;">\z, \Z</p>

<p style="margin-left:17%;"><tt>&quot;\z&quot;</tt> and
<tt>&quot;\Z&quot;</tt> match at the end of the string. If
the <tt>&quot;/m&quot;</tt> modifier isn&rsquo;t used, then
<tt>&quot;/\Z/&quot;</tt> is equivalent to
<tt>&quot;/$/&quot;</tt>; that is, it matches at the end of
the string, or one before the newline at the end of the
string. If the <tt>&quot;/m&quot;</tt> modifier is used,
then <tt>&quot;/$/&quot;</tt> matches at internal newlines,
but the meaning of <tt>&quot;/\Z/&quot;</tt> isn&rsquo;t
changed by the <tt>&quot;/m&quot;</tt> modifier.
<tt>&quot;\Z&quot;</tt> matches at the end of the string (or
just before a trailing newline) regardless whether the
<tt>&quot;/m&quot;</tt> modifier is used.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;\z&quot;</tt>
is just like <tt>&quot;\Z&quot;</tt>, except that it does
not match before a trailing newline. <tt>&quot;\z&quot;</tt>
matches at the end of the string only, regardless of the
modifiers used, and not just before a newline. It is how to
anchor the match to the true end of the string under all
conditions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>\G</p></td>
<td width="3%"></td>
<td width="83%">


<p><tt>&quot;\G&quot;</tt> is usually used only in
combination with the <tt>&quot;/g&quot;</tt> modifier. If
the <tt>&quot;/g&quot;</tt> modifier is used and the match
is done in scalar context, Perl remembers where in the
source string the last match ended, and the next time, it
will start the match from where it ended the previous
time.</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;\G&quot;</tt>
matches the point where the previous match on that string
ended, or the beginning of that string if there was no
previous match.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>G</i>lobal.</p>

<p style="margin-left:11%;">\b, \B</p>

<p style="margin-left:17%;"><tt>&quot;\b&quot;</tt> matches
at any place between a word and a non-word character;
<tt>&quot;\B&quot;</tt> matches at any place between
characters where <tt>&quot;\b&quot;</tt> doesn&rsquo;t
match. <tt>&quot;\b&quot;</tt> and <tt>&quot;\B&quot;</tt>
assume there&rsquo;s a non-word character before the
beginning and after the end of the source string; so
<tt>&quot;\b&quot;</tt> will match at the beginning (or end)
of the source string if the source string begins (or ends)
with a word character. Otherwise, <tt>&quot;\B&quot;</tt>
will match.</p>

<p style="margin-left:17%; margin-top: 1em">Do not use
something like <tt>&quot;\b=head\d\b&quot;</tt> and expect
it to match the beginning of a line. It can&rsquo;t, because
for there to be a boundary before the non-word
&quot;=&quot;, there must be a word character immediately
previous. All boundary determinations look for word
characters alone, not for non-words characters nor for
string ends. It may help to understand how &lt;\b&gt; and
&lt;\B&gt; work by equating them as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">    \b  really means    (?:(?&lt;=\w)(?!\w)|(?&lt;!\w)(?=\w))
    \B  really means    (?:(?&lt;=\w)(?=\w)|(?&lt;!\w)(?!\w))</pre>


<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>b</i>oundary.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em">  &quot;cat&quot;   =~ /\Acat/;     # Match.
  &quot;cat&quot;   =~ /cat\Z/;     # Match.
  &quot;cat\n&quot; =~ /cat\Z/;     # Match.
  &quot;cat\n&quot; =~ /cat\z/;     # No match.
  &quot;cat&quot;   =~ /\bcat\b/;   # Matches.
  &quot;cats&quot;  =~ /\bcat\b/;   # No match.
  &quot;cat&quot;   =~ /\bcat\B/;   # No match.
  &quot;cats&quot;  =~ /\bcat\B/;   # Match.
  while (&quot;cat dog&quot; =~ /(\w+)/g) {
      print $1;           # Prints 'catdog'
  }
  while (&quot;cat dog&quot; =~ /\G(\w+)/g) {
      print $1;           # Prints 'cat'
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Misc</b>
<br>
Here we document the backslash sequences that don&rsquo;t
fall in one of the categories above. These are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>\C</p></td>
<td width="3%"></td>
<td width="83%">


<p><tt>&quot;\C&quot;</tt> always matches a single octet,
even if the source string is encoded in
<small>UTF&minus;8</small> format, and the character to be
matched is a multi-octet character. <tt>&quot;\C&quot;</tt>
was introduced in perl 5.6. This is very dangerous, because
it violates the logical character abstraction and can cause
<small>UTF&minus;8</small> sequences to become
malformed.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
o<i>C</i>tet.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\K</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">This appeared in perl 5.10.0.
Anything matched left of <tt>&quot;\K&quot;</tt> is not
included in <tt>$&amp;</tt>, and will not be replaced if the
pattern is used in a substitution. This lets you write
<tt>&quot;s/PAT1 \K PAT2/REPL/x&quot;</tt> instead of
<tt>&quot;s/(PAT1) PAT2/${1}REPL/x&quot;</tt> or
<tt>&quot;s/(?&lt;=PAT1) PAT2/REPL/x&quot;</tt>.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>K</i>eep.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\N</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">This is an experimental feature
new to perl 5.12.0. It matches any character that is
<b>not</b> a newline. It is a short-hand for writing
<tt>&quot;[^\n]&quot;</tt>, and is identical to the
<tt>&quot;.&quot;</tt> metasymbol, except under the
<tt>&quot;/s&quot;</tt> flag, which changes the meaning of
<tt>&quot;.&quot;</tt>, but not <tt>&quot;\N&quot;</tt>.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>&quot;\N{...}&quot;</tt> can mean a named or numbered
character .</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
Complement of <i>\n</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\R</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;\R&quot;</tt> matches
a <i>generic newline</i>; that is, anything considered a
linebreak sequence by Unicode. This includes all characters
matched by <tt>&quot;\v&quot;</tt> (vertical whitespace),
and the multi character sequence
<tt>&quot;\x0D\x0A&quot;</tt> (carriage return followed by a
line feed, sometimes called the network newline; it&rsquo;s
the end of line sequence used in Microsoft text files opened
in binary mode). <tt>&quot;\R&quot;</tt> is equivalent to
<tt>&quot;(?&gt;\x0D\x0A|\v)&quot;</tt>. (The reason it
doesn&rsquo;t backtrack is that the sequence is considered
inseparable. That means that</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> &quot;\x0D\x0A&quot; =~ /^\R\x0A$/   # No match</pre>


<p style="margin-left:17%; margin-top: 1em">fails, because
the <tt>&quot;\R&quot;</tt> matches the entire string, and
won&rsquo;t backtrack to match just the
<tt>&quot;\x0D&quot;</tt>.) Since <tt>&quot;\R&quot;</tt>
can match a sequence of more than one character, it cannot
be put inside a bracketed character class;
<tt>&quot;/[\R]/&quot;</tt> is an error; use
<tt>&quot;\v&quot;</tt> instead. <tt>&quot;\R&quot;</tt> was
introduced in perl 5.10.0.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
does not respect any locale that might be in effect; it
matches according to the platform&rsquo;s native character
set.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic: none
really. <tt>&quot;\R&quot;</tt> was picked because
<small>PCRE</small> already uses <tt>&quot;\R&quot;</tt>,
and more importantly because Unicode recommends such a
regular expression metacharacter, and suggests
<tt>&quot;\R&quot;</tt> as its notation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\X</p></td>
<td width="3%"></td>
<td width="75%">


<p style="margin-top: 1em">This matches a Unicode
<i>extended grapheme cluster</i>.</p></td>
<td width="8%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;\X&quot;</tt>
matches quite well what normal (non-Unicode-programmer)
usage would consider a single character. As an example,
consider a G with some sort of diacritic mark, such as an
arrow. There is no such single character in Unicode, but one
can be composed by using a G followed by a Unicode &quot;
<small>COMBINING UPWARDS ARROW BELOW</small> &quot;, and
would be displayed by Unicode-aware software as if it were a
single character.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
e<i>X</i>tended Unicode character.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<pre style="margin-left:11%; margin-top: 1em"> &quot;\x{256}&quot; =~ /^\C\C$/;    # Match as chr (0x256) takes 2 octets in UTF&minus;8.
 $str =~ s/foo\Kbar/baz/g; # Change any 'bar' following a 'foo' to 'baz'
 $str =~ s/(.)\K\g1//g;    # Delete duplicated characters.
 &quot;\n&quot;   =~ /^\R$/;         # Match, \n   is a generic newline.
 &quot;\r&quot;   =~ /^\R$/;         # Match, \r   is a generic newline.
 &quot;\r\n&quot; =~ /^\R$/;         # Match, \r\n is a generic newline.
 &quot;P\x{307}&quot; =~ /^\X$/     # \X matches a P with a dot above.</pre>
<hr>
</body>
</html>
