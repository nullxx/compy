<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:15:17 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FORK</title>

</head>
<body>

<h1 align="center">FORK</h1>

<a href="#PROLOG">PROLOG</a><br>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#APPLICATION USAGE">APPLICATION USAGE</a><br>
<a href="#RATIONALE">RATIONALE</a><br>
<a href="#FUTURE DIRECTIONS">FUTURE DIRECTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>PROLOG
<a name="PROLOG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This manual
page is part of the POSIX Programmer&rsquo;s Manual. The
Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux
behavior), or the interface may not be implemented on
Linux.</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fork &minus;
create a new process</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;unistd.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pid_t
fork(void);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>fork</i>() function shall create a new process. The new
process (child process) shall be an exact copy of the
calling process (parent process) except as detailed
below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have a unique process ID.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process ID also shall not match any active
process group ID.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have a different parent process
ID, which shall be the process ID of the calling
process.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have its own copy of the
parent&rsquo;s file descriptors. Each of the child&rsquo;s
file descriptors shall refer to the same open file
description with the corresponding file descriptor of the
parent.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have its own copy of the
parent&rsquo;s open directory streams. Each open directory
stream in the child process may share directory stream
positioning with the corresponding directory stream of the
parent.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have its own copy of the
parent&rsquo;s message catalog descriptors.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process&rsquo; values of <i>tms_utime</i>,
<i>tms_stime</i>, <i>tms_cutime</i>, and <i>tms_cstime</i>
shall be set to 0.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The time left until an alarm clock signal shall be reset
to zero, and the alarm, if any, shall be canceled; see
<i>alarm</i>().</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>All <i>semadj</i> values shall be cleared.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>File locks set by the parent process shall not be
inherited by the child process.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The set of signals pending for the child process shall
be initialized to the empty set.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Interval timers shall be reset in the child process.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Any semaphores that are open in the parent process shall
also be open in the child process.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall not inherit any address space
memory locks established by the parent process via calls to
<i>mlockall</i>() or <i>mlock</i>().</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Memory mappings created in the parent shall be retained
in the child process. MAP_PRIVATE mappings inherited from
the parent shall also be MAP_PRIVATE mappings in the child,
and any modifications to the data in these mappings made by
the parent prior to calling <i>fork</i>() shall be visible
to the child. Any modifications to the data in MAP_PRIVATE
mappings made by the parent after <i>fork</i>() returns
shall be visible only to the parent. Modifications to the
data in MAP_PRIVATE mappings made by the child shall be
visible only to the child.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>For the SCHED_FIFO and SCHED_RR scheduling policies, the
child process shall inherit the policy and priority settings
of the parent process during a <i>fork</i>() function. For
other scheduling policies, the policy and priority settings
on <i>fork</i>() are implementation-defined.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>Per-process timers created by the parent shall not be
inherited by the child process.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The child process shall have its own copy of the message
queue descriptors of the parent. Each of the message
descriptors of the child shall refer to the same open
message queue description as the corresponding message
descriptor of the parent.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>No asynchronous input or asynchronous output operations
shall be inherited by the child process.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>A process shall be created with a single thread. If a
multi-threaded process calls <i>fork</i>(), the new process
shall contain a replica of the calling thread and its entire
address space, possibly including the states of mutexes and
other resources. Consequently, to avoid errors, the child
process may only execute async-signal-safe operations until
such time as one of the <i>exec</i> functions is called.
Fork handlers may be established by means of the
<i>pthread_atfork</i>() function in order to maintain
application invariants across <i>fork</i>() calls.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">When the
application calls <i>fork</i>() from a signal handler and
any of the fork handlers registered by
<i>pthread_atfork</i>() calls a function that is not
asynch-signal-safe, the behavior is undefined.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the Trace option and the
Trace Inherit option are both supported:</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the calling
process was being traced in a trace stream that had its
inheritance policy set to POSIX_TRACE_INHERITED, the child
process shall be traced into that trace stream, and the
child process shall inherit the parent&rsquo;s mapping of
trace event names to trace event type identifiers. If the
trace stream in which the calling process was being traced
had its inheritance policy set to
POSIX_TRACE_CLOSE_FOR_CHILD, the child process shall not be
traced into that trace stream. The inheritance policy is set
by a call to the <i>posix_trace_attr_setinherited</i>()
function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the Trace option is
supported, but the Trace Inherit option is not
supported:</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The child
process shall not be traced into any of the trace streams of
its parent process.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p style="margin-top: 1em">*</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the Trace option is
supported, the child process of a trace controller process
shall not control the trace streams controlled by its parent
process.</p> </td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The initial value of the CPU-time clock of the child
process shall be set to zero.</p></td></tr>
<tr valign="top" align="left">
<td width="12%"></td>
<td width="2%">


<p>*</p></td>
<td width="1%"></td>
<td width="85%">


<p>The initial value of the CPU-time clock of the single
thread of the child process shall be set to zero.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">All other
process characteristics defined by
IEEE&nbsp;Std&nbsp;1003.1-2001 shall be the same in the
parent and child processes. The inheritance of process
characteristics not defined by
IEEE&nbsp;Std&nbsp;1003.1-2001 is unspecified by
IEEE&nbsp;Std&nbsp;1003.1-2001.</p>

<p style="margin-left:11%; margin-top: 1em">After
<i>fork</i>(), both the parent and the child processes shall
be capable of executing independently before either one
terminates.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Upon successful
completion, <i>fork</i>() shall return 0 to the child
process and shall return the process ID of the child process
to the parent process. Both processes shall continue to
execute from the <i>fork</i>() function. Otherwise, -1 shall
be returned to the parent process, no child process shall be
created, and <i>errno</i> shall be set to indicate the
error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>fork</i>() function shall fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The system lacked the necessary
resources to create another process, or the system-imposed
limit on the total number of processes under execution
system-wide or by a single user {CHILD_MAX} would be
exceeded.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>fork</i>() function may fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em">Insufficient storage space is
available.</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>The
following sections are informative.</i></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>APPLICATION USAGE
<a name="APPLICATION USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>RATIONALE
<a name="RATIONALE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many historical
implementations have timing windows where a signal sent to a
process group (for example, an interactive SIGINT) just
prior to or during execution of <i>fork</i>() is delivered
to the parent following the <i>fork</i>() but not to the
child because the <i>fork</i>() code clears the
child&rsquo;s set of pending signals. This volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 does not require, or even
permit, this behavior. However, it is pragmatic to expect
that problems of this nature may continue to exist in
implementations that appear to conform to this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 and pass available
verification suites. This behavior is only a consequence of
the implementation failing to make the interval between
signal generation and delivery totally invisible. From the
application&rsquo;s perspective, a <i>fork</i>() call should
appear atomic. A signal that is generated prior to the
<i>fork</i>() should be delivered prior to the
<i>fork</i>(). A signal sent to the process group after the
<i>fork</i>() should be delivered to both parent and child.
The implementation may actually initialize internal data
structures corresponding to the child&rsquo;s set of pending
signals to include signals sent to the process group during
the <i>fork</i>(). Since the <i>fork</i>() call can be
considered as atomic from the application&rsquo;s
perspective, the set would be initialized as empty and such
signals would have arrived after the <i>fork</i>(); see also
<i>&lt;signal.h&gt;</i>.</p>

<p style="margin-left:11%; margin-top: 1em">One approach
that has been suggested to address the problem of signal
inheritance across <i>fork</i>() is to add an [EINTR] error,
which would be returned when a signal is detected during the
call. While this is preferable to losing signals, it was not
considered an optimal solution. Although it is not
recommended for this purpose, such an error would be an
allowable extension for an implementation.</p>

<p style="margin-left:11%; margin-top: 1em">The [ENOMEM]
error value is reserved for those implementations that
detect and distinguish such a condition. This condition
occurs when an implementation detects that there is not
enough memory to create the process. This is intended to be
returned when [EAGAIN] is inappropriate because there can
never be enough memory (either primary or secondary storage)
to perform the operation. Since <i>fork</i>() duplicates an
existing process, this must be a condition where there is
sufficient memory for one such process, but not for two.
Many historical implementations actually return [ENOMEM] due
to temporary lack of memory, a case that is not generally
distinct from [EAGAIN] from the perspective of a conforming
application.</p>

<p style="margin-left:11%; margin-top: 1em">Part of the
reason for including the optional error [ENOMEM] is because
the SVID specifies it and it should be reserved for the
error condition specified there. The condition is not
applicable on many implementations.</p>


<p style="margin-left:11%; margin-top: 1em">IEEE&nbsp;Std&nbsp;1003.1-1988
neglected to require concurrent execution of the parent and
child of <i>fork</i>(). A system that single-threads
processes was clearly not intended and is considered an
unacceptable &quot;toy implementation&quot; of this volume
of IEEE&nbsp;Std&nbsp;1003.1-2001. The only objection
anticipated to the phrase &quot;executing
independently&quot; is testability, but this assertion
should be testable. Such tests require that both the parent
and child can block on a detectable action of the other,
such as a write to a pipe or a signal. An interactive
exchange of such actions should be possible for the system
to conform to the intent of this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001.</p>

<p style="margin-left:11%; margin-top: 1em">The [EAGAIN]
error exists to warn applications that such a condition
might occur. Whether it occurs or not is not in any
practical sense under the control of the application because
the condition is usually a consequence of the user&rsquo;s
use of the system, not of the application&rsquo;s code.
Thus, no application can or should rely upon its occurrence
under any circumstances, nor should the exact semantics of
what concept of &quot;user&quot; is used be of concern to
the application writer. Validation writers should be
cognizant of this limitation.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
reasons why POSIX programmers call <i>fork</i>(). One reason
is to create a new thread of control within the same program
(which was originally only possible in POSIX by creating a
new process); the other is to create a new process running a
different program. In the latter case, the call to
<i>fork</i>() is soon followed by a call to one of the
<i>exec</i> functions.</p>

<p style="margin-left:11%; margin-top: 1em">The general
problem with making <i>fork</i>() work in a multi-threaded
world is what to do with all of the threads. There are two
alternatives. One is to copy all of the threads into the new
process. This causes the programmer or implementation to
deal with threads that are suspended on system calls or that
might be about to execute system calls that should not be
executed in the new process. The other alternative is to
copy only the thread that calls <i>fork</i>(). This creates
the difficulty that the state of process-local resources is
usually held in process memory. If a thread that is not
calling <i>fork</i>() holds a resource, that resource is
never released in the child process because the thread whose
job it is to release the resource does not exist in the
child process.</p>

<p style="margin-left:11%; margin-top: 1em">When a
programmer is writing a multi-threaded program, the first
described use of <i>fork</i>(), creating new threads in the
same program, is provided by the <i>pthread_create</i>()
function. The <i>fork</i>() function is thus used only to
run new programs, and the effects of calling functions that
require certain resources between the call to <i>fork</i>()
and the call to an <i>exec</i> function are undefined.</p>

<p style="margin-left:11%; margin-top: 1em">The addition of
the <i>forkall</i>() function to the standard was considered
and rejected. The <i>forkall</i>() function lets all the
threads in the parent be duplicated in the child. This
essentially duplicates the state of the parent in the child.
This allows threads in the child to continue processing and
allows locks and the state to be preserved without explicit
<i>pthread_atfork</i>() code. The calling process has to
ensure that the threads processing state that is shared
between the parent and child (that is, file descriptors or
MAP_SHARED memory) behaves properly after <i>forkall</i>().
For example, if a thread is reading a file descriptor in the
parent when <i>forkall</i>() is called, then two threads
(one in the parent and one in the child) are reading the
file descriptor after the <i>forkall</i>(). If this is not
desired behavior, the parent process has to synchronize with
such threads before calling <i>forkall</i>().</p>

<p style="margin-left:11%; margin-top: 1em">While the
<i>fork</i>() function is async-signal-safe, there is no way
for an implementation to determine whether the fork handlers
established by <i>pthread_atfork</i>() are
async-signal-safe. The fork handlers may attempt to execute
portions of the implementation that are not
async-signal-safe, such as those that are protected by
mutexes, leading to a deadlock condition. It is therefore
undefined for the fork handlers to execute functions that
are not async-signal-safe when <i>fork</i>() is called from
a signal handler.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>forkall</i>() is called, threads, other than the calling
thread, that are in functions that can return with an
[EINTR] error may have those functions return [EINTR] if the
implementation cannot ensure that the function behaves
correctly in the parent and child. In particular,
<i>pthread_cond_wait</i>() and
<i>pthread_cond_timedwait</i>() need to return in order to
ensure that the condition has not changed. These functions
can be awakened by a spurious condition wakeup rather than
returning [EINTR].</p>

<h2>FUTURE DIRECTIONS
<a name="FUTURE DIRECTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>alarm</i>(),
<i>exec</i>(), <i>fcntl</i>(),
<i>posix_trace_attr_getinherited</i>(),
<i>posix_trace_trid_eventid_open</i>(),
<i>pthread_atfork</i>(), <i>semop</i>(), <i>signal</i>(),
<i>times</i>(), the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <i>&lt;sys/types.h&gt;</i>,
<i>&lt;unistd.h&gt;</i></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Portions of
this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information
Technology -- Portable Operating System Interface (POSIX),
The Open Group Base Specifications Issue 6, Copyright (C)
2001-2003 by the Institute of Electrical and Electronics
Engineers, Inc and The Open Group. In the event of any
discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open
Group Standard is the referee document. The original
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>
<hr>
</body>
</html>
