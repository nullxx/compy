<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:15:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IOCTL</title>

</head>
<body>

<h1 align="center">IOCTL</h1>

<a href="#PROLOG">PROLOG</a><br>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#APPLICATION USAGE">APPLICATION USAGE</a><br>
<a href="#RATIONALE">RATIONALE</a><br>
<a href="#FUTURE DIRECTIONS">FUTURE DIRECTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>PROLOG
<a name="PROLOG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This manual
page is part of the POSIX Programmer&rsquo;s Manual. The
Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux
behavior), or the interface may not be implemented on
Linux.</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ioctl &minus;
control a STREAMS device (<b>STREAMS</b>)</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;stropts.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ioctl(int</b> <i>fildes</i><b>, int</b> <i>request</i><b>,
... /* arg */);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function shall perform a variety of control
functions on STREAMS devices. For non-STREAMS devices, the
functions performed by this call are unspecified. The
<i>request</i> argument and an optional third argument (with
varying type) shall be passed to and interpreted by the
appropriate part of the STREAM associated with
<i>fildes</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>fildes</i> argument is an open file descriptor that
refers to a device.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>request</i> argument selects the control function to be
performed and shall depend on the STREAMS device being
addressed.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>arg</i>
argument represents additional information that is needed by
this specific STREAMS device to perform the requested
function. The type of <i>arg</i> depends upon the particular
control request, but it shall be either an integer or a
pointer to a device-specific data structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() commands applicable to STREAMS, their
arguments, and error conditions that apply to each
individual command are described below.</p>

<p style="margin-left:11%; margin-top: 1em">The following
<i>ioctl</i>() commands, with error values indicated, are
applicable to all STREAMS files:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_PUSH</p></td>
<td width="2%"></td>
<td width="78%">


<p>Pushes the module whose name is pointed to by <i>arg</i>
onto the top of the current STREAM, just below the STREAM
head. It then calls the <i>open</i>() function of the
newly-pushed module.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_PUSH command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Invalid module name.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Open function of new module failed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_POP</p></td>
<td width="2%"></td>
<td width="78%">


<p>Removes the module just below the STREAM head of the
STREAM pointed to by <i>fildes</i>. The <i>arg</i> argument
should be 0 in an I_POP request.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_POP command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">No module present in the
STREAM.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_LOOK</p></td>
<td width="2%"></td>
<td width="78%">


<p>Retrieves the name of the module just below the STREAM
head of the STREAM pointed to by <i>fildes</i>, and places
it in a character string pointed to by <i>arg</i>. The
buffer pointed to by <i>arg</i> should be at least
FMNAMESZ+1 bytes long, where FMNAMESZ is defined in
<i>&lt;stropts.h&gt;</i>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_LOOK command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em">No module present in the
STREAM.</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%;">I_FLUSH</p>

<p style="margin-left:22%;">Flushes read and/or write
queues, depending on the value of <i>arg</i>. Valid
<i>arg</i> values are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>FLUSHR</p></td>
<td width="2%"></td>
<td width="35%">


<p>Flush all read queues.</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>FLUSHW</p></td>
<td width="2%"></td>
<td width="35%">


<p>Flush all write queues.</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:11%;">FLUSHRW</p>

<p style="margin-left:22%;">Flush all read and all write
queues.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_FLUSH command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="27%">


<p>Invalid <i>arg</i> value.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate buffers for flush message.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="40%">


<p>Hangup received on <i>fildes</i>.</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%;">I_FLUSHBAND</p>

<p style="margin-left:22%;">Flushes a particular band of
messages. The <i>arg</i> argument points to a
<b>bandinfo</b> structure. The <i>bi_flag</i> member may be
one of FLUSHR, FLUSHW, or FLUSHRW as described above. The
<i>bi_pri</i> member determines the priority band to be
flushed.</p>

<p style="margin-left:11%;">I_SETSIG</p>

<p style="margin-left:22%;">Requests that the STREAMS
implementation send the SIGPOLL signal to the calling
process when a particular event has occurred on the STREAM
associated with <i>fildes</i>. I_SETSIG supports an
asynchronous processing capability in STREAMS. The value of
<i>arg</i> is a bitmask that specifies the events for which
the process should be signaled. It is the bitwise-inclusive
OR of any combination of the following constants:</p>

<p style="margin-left:11%;">S_RDNORM</p>

<p style="margin-left:22%;">A normal (priority band set to
0) message has arrived at the head of a STREAM head read
queue. A signal shall be generated even if the message is of
zero length.</p>

<p style="margin-left:11%;">S_RDBAND</p>

<p style="margin-left:22%;">A message with a non-zero
priority band has arrived at the head of a STREAM head read
queue. A signal shall be generated even if the message is of
zero length.</p>

<p style="margin-left:11%;">S_INPUT</p>

<p style="margin-left:22%;">A message, other than a
high-priority message, has arrived at the head of a STREAM
head read queue. A signal shall be generated even if the
message is of zero length.</p>

<p style="margin-left:11%;">S_HIPRI</p>

<p style="margin-left:22%;">A high-priority message is
present on a STREAM head read queue. A signal shall be
generated even if the message is of zero length.</p>

<p style="margin-left:11%;">S_OUTPUT</p>

<p style="margin-left:22%;">The write queue for normal data
(priority band 0) just below the STREAM head is no longer
full. This notifies the process that there is room on the
queue for sending (or writing) normal data downstream.</p>

<p style="margin-left:11%;">S_WRNORM</p>

<p style="margin-left:22%;">Equivalent to S_OUTPUT.</p>

<p style="margin-left:11%;">S_WRBAND</p>

<p style="margin-left:22%;">The write queue for a non-zero
priority band just below the STREAM head is no longer full.
This notifies the process that there is room on the queue
for sending (or writing) priority data downstream.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>S_MSG</p></td>
<td width="4%"></td>
<td width="78%">


<p>A STREAMS signal message that contains the SIGPOLL
signal has reached the front of the STREAM head read
queue.</p> </td></tr>
</table>

<p style="margin-left:11%;">S_ERROR</p>

<p style="margin-left:22%;">Notification of an error
condition has reached the STREAM head.</p>

<p style="margin-left:11%;">S_HANGUP</p>

<p style="margin-left:22%;">Notification of a hangup has
reached the STREAM head.</p>

<p style="margin-left:11%;">S_BANDURG</p>

<p style="margin-left:22%;">When used in conjunction with
S_RDBAND, SIGURG is generated instead of SIGPOLL when a
priority message reaches the front of the STREAM head read
queue.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>arg</i>
is 0, the calling process shall be unregistered and shall
not receive further SIGPOLL signals for the stream
associated with <i>fildes</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Processes that
wish to receive SIGPOLL signals shall ensure that they
explicitly register to receive them using I_SETSIG. If
several processes register to receive this signal for the
same event on the same STREAM, each process shall be
signaled when the event occurs.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_SETSIG command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The value of <i>arg</i> is invalid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The value of <i>arg</i> is 0 and the calling process is
not registered to receive the SIGPOLL signal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>There were insufficient resources to store the signal
request.</p> </td></tr>
</table>

<p style="margin-left:11%;">I_GETSIG</p>

<p style="margin-left:22%;">Returns the events for which
the calling process is currently registered to be sent a
SIGPOLL signal. The events are returned as a bitmask in an
<b>int</b> pointed to by <i>arg</i>, where the events are
those specified in the description of I_SETSIG above.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_GETSIG command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Process is not registered to receive the SIGPOLL
signal.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_FIND</p></td>
<td width="2%"></td>
<td width="78%">


<p>Compares the names of all modules currently present in
the STREAM to the name pointed to by <i>arg</i>, and returns
1 if the named module is present in the STREAM, or returns 0
if the named module is not present.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_FIND command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>arg</i> does not contain a
valid module name.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_PEEK</p></td>
<td width="2%"></td>
<td width="78%">


<p>Retrieves the information in the first message on the
STREAM head read queue without taking the message off the
queue. It is analogous to <i>getmsg</i>() except that this
command does not remove the message from the queue. The
<i>arg</i> argument points to a <b>strpeek</b>
structure.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The application
shall ensure that the <i>maxlen</i> member in the
<b>ctlbuf</b> and <b>databuf strbuf</b> structures is set to
the number of bytes of control information and/or data
information, respectively, to retrieve. The <i>flags</i>
member may be marked RS_HIPRI or 0, as described by
<i>getmsg</i>(). If the process sets <i>flags</i> to
RS_HIPRI, for example, I_PEEK shall only look for a
high-priority message on the STREAM head read queue.</p>

<p style="margin-left:11%; margin-top: 1em">I_PEEK returns
1 if a message was retrieved, and returns 0 if no message
was found on the STREAM head read queue, or if the RS_HIPRI
flag was set in <i>flags</i> and a high-priority message was
not present on the STREAM head read queue. It does not wait
for a message to arrive. On return, <b>ctlbuf</b> specifies
information in the control buffer, <b>databuf</b> specifies
information in the data buffer, and <i>flags</i> contains
the value RS_HIPRI or 0. <br>
I_SRDOPT</p>

<p style="margin-left:22%;">Sets the read mode using the
value of the argument <i>arg</i>. Read modes are described
in <i>read</i>(). Valid <i>arg</i> flags are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>RNORM</p></td>
<td width="4%"></td>
<td width="46%">


<p>Byte-stream mode, the default.</p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>RMSGD</p></td>
<td width="4%"></td>
<td width="46%">


<p>Message-discard mode.</p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>RMSGN</p></td>
<td width="4%"></td>
<td width="46%">


<p>Message-nondiscard mode.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
bitwise-inclusive OR of RMSGD and RMSGN shall return
[EINVAL]. The bitwise-inclusive OR of RNORM and either RMSGD
or RMSGN shall result in the other flag overriding RNORM
which is the default.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
treatment of control messages by the STREAM head may be
changed by setting any of the following flags in <i>arg</i>:
<br>
RPROTNORM</p>

<p style="margin-left:22%;">Fail <i>read</i>() with
[EBADMSG] if a message containing a control part is at the
front of the STREAM head read queue.</p>

<p style="margin-left:11%;">RPROTDAT</p>

<p style="margin-left:22%;">Deliver the control part of a
message as data when a process issues a <i>read</i>().</p>

<p style="margin-left:11%;">RPROTDIS</p>

<p style="margin-left:22%;">Discard the control part of a
message, delivering any data portion, when a process issues
a <i>read</i>().</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_SRDOPT command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="46%">


<p>The <i>arg</i> argument is not valid.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%;">I_GRDOPT</p>

<p style="margin-left:22%;">Returns the current read mode
setting, as described above, in an <b>int</b> pointed to by
the argument <i>arg</i>. Read modes are described in
<i>read</i>().</p>

<p style="margin-left:11%;">I_NREAD</p>

<p style="margin-left:22%;">Counts the number of data bytes
in the data part of the first message on the STREAM head
read queue and places this value in the <b>int</b> pointed
to by <i>arg</i>. The return value for the command shall be
the number of messages on the STREAM head read queue. For
example, if 0 is returned in <i>arg</i>, but the
<i>ioctl</i>() return value is greater than 0, this
indicates that a zero-length message is next on the
queue.</p>

<p style="margin-left:11%;">I_FDINSERT</p>

<p style="margin-left:22%;">Creates a message from
specified buffer(s), adds information about another STREAM,
and sends the message downstream. The message contains a
control part and an optional data part. The data and control
parts to be sent are distinguished by placement in separate
buffers, as described below. The <i>arg</i> argument points
to a <b>strfdinsert</b> structure.</p>

<p style="margin-left:11%; margin-top: 1em">The application
shall ensure that the <i>len</i> member in the <b>ctlbuf
strbuf</b> structure is set to the size of a
<b>t_uscalar_t</b> plus the number of bytes of control
information to be sent with the message. The <i>fildes</i>
member specifies the file descriptor of the other STREAM,
and the <i>offset</i> member, which must be suitably aligned
for use as a <b>t_uscalar_t</b>, specifies the offset from
the start of the control buffer where I_FDINSERT shall store
a <b>t_uscalar_t</b> whose interpretation is specific to the
STREAM end. The application shall ensure that the <i>len</i>
member in the <b>databuf strbuf</b> structure is set to the
number of bytes of data information to be sent with the
message, or to 0 if no data part is to be sent.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> member specifies the type of message to be
created. A normal message is created if <i>flags</i> is set
to 0, and a high-priority message is created if <i>flags</i>
is set to RS_HIPRI. For non-priority messages, I_FDINSERT
shall block if the STREAM write queue is full due to
internal flow control conditions. For priority messages,
I_FDINSERT does not block on this condition. For
non-priority messages, I_FDINSERT does not block when the
write queue is full and O_NONBLOCK is set. Instead, it fails
and sets <i>errno</i> to [EAGAIN].</p>

<p style="margin-left:11%; margin-top: 1em">I_FDINSERT also
blocks, unless prevented by lack of internal resources,
waiting for the availability of message blocks in the
STREAM, regardless of priority or whether O_NONBLOCK has
been specified. No partial message is sent.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_FDINSERT command shall
fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A non-priority message is specified, the O_NONBLOCK flag
is set, and the STREAM write queue is full due to internal
flow control conditions.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Buffers cannot
be allocated for the message that is to be created.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="32%">


<p>One of the following:</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">*</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%"></td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em">The <i>fildes</i> member of the
<b>strfdinsert</b> structure is not a valid, open STREAM
file descriptor.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p>The size of a <b>t_uscalar_t</b> plus <i>offset</i> is
greater than the <i>len</i> member for the buffer specified
through <b>ctlbuf</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p>The <i>offset</i> member does not specify a
properly-aligned location in the data buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p>*</p></td>
<td width="2%"></td>
<td width="63%">


<p>An undefined value is stored in <i>flags</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Hangup received
on the STREAM identified by either the <i>fildes</i>
argument or the <i>fildes</i> member of the
<b>strfdinsert</b> structure.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>ERANGE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>len</i> member for the
buffer specified through <b>databuf</b> does not fall within
the range specified by the maximum and minimum packet sizes
of the topmost STREAM module; or the <i>len</i> member for
the buffer specified through <b>databuf</b> is larger than
the maximum configured size of the data part of a message;
or the <i>len</i> member for the buffer specified through
<b>ctlbuf</b> is larger than the maximum configured size of
the control part of a message.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_STR</p></td>
<td width="2%"></td>
<td width="78%">


<p>Constructs an internal STREAMS <i>ioctl</i>() message
from the data pointed to by <i>arg</i>, and sends that
message downstream.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This mechanism
is provided to send <i>ioctl</i>() requests to downstream
modules and drivers. It allows information to be sent with
<i>ioctl</i>(), and returns to the process any information
sent upstream by the downstream recipient. I_STR shall block
until the system responds with either a positive or negative
acknowledgement message, or until the request times out
after some period of time. If the request times out, it
shall fail with <i>errno</i> set to [ETIME].</p>

<p style="margin-left:11%; margin-top: 1em">At most, one
I_STR can be active on a STREAM. Further I_STR calls shall
block until the active I_STR completes at the STREAM head.
The default timeout interval for these requests is 15
seconds. The O_NONBLOCK flag has no effect on this call.</p>

<p style="margin-left:11%; margin-top: 1em">To send
requests downstream, the application shall ensure that
<i>arg</i> points to a <b>strioctl</b> structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ic_cmd</i> member is the internal <i>ioctl</i>() command
intended for a downstream module or driver and
<i>ic_timout</i> is the number of seconds (-1=infinite,
0=use implementation-defined timeout interval, &gt;0=as
specified) an I_STR request shall wait for acknowledgement
before timing out. <i>ic_len</i> is the number of bytes in
the data argument, and <i>ic_dp</i> is a pointer to the data
argument. The <i>ic_len</i> member has two uses: on input,
it contains the length of the data argument passed in, and
on return from the command, it contains the number of bytes
being returned to the process (the buffer pointed to by
<i>ic_dp</i> should be large enough to contain the maximum
amount of data that any module or the driver in the STREAM
can return).</p>

<p style="margin-left:11%; margin-top: 1em">The STREAM head
shall convert the information pointed to by the
<b>strioctl</b> structure to an internal <i>ioctl</i>()
command message and send it downstream.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_STR command shall fail
if: <b><br>
EAGAIN</b> or <b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate buffers for the <i>ioctl</i>() message.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>ic_len</i> member is less than 0 or larger than
the maximum configured size of the data part of a message,
or <i>ic_timout</i> is less than -1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ETIME</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A downstream <i>ioctl</i>() timed out before
acknowledgement was received.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An I_STR can
also fail while waiting for an acknowledgement if a message
indicating an error or a hangup is received at the STREAM
head. In addition, an error code can be returned in the
positive or negative acknowledgement message, in the event
the <i>ioctl</i>() command sent downstream fails. For these
cases, I_STR shall fail with <i>errno</i> set to the value
in the message. <br>
I_SWROPT</p>

<p style="margin-left:22%;">Sets the write mode using the
value of the argument <i>arg</i>. Valid bit settings for
<i>arg</i> are:</p>

<p style="margin-left:11%;">SNDZERO</p>

<p style="margin-left:22%;">Send a zero-length message
downstream when a <i>write</i>() of 0 bytes occurs. To not
send a zero-length message when a <i>write</i>() of 0 bytes
occurs, the application shall ensure that this bit is not
set in <i>arg</i> (for example, <i>arg</i> would be set to
0).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_SWROPT command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="41%">


<p><i>arg</i> is not the above value.</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%;">I_GWROPT</p>

<p style="margin-left:22%;">Returns the current write mode
setting, as described above, in the <b>int</b> that is
pointed to by the argument <i>arg</i>.</p>

<p style="margin-left:11%;">I_SENDFD</p>

<p style="margin-left:22%;">Creates a new reference to the
open file description associated with the file descriptor
<i>arg</i>, and writes a message on the STREAMS-based pipe
<i>fildes</i> containing this reference, together with the
user ID and group ID of the calling process.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_SENDFD command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The sending STREAM is unable to allocate a message block
to contain the file pointer; or the read queue of the
receiving STREAM head is full and cannot accept the message
sent by I_SENDFD.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>arg</i> argument is not a valid, open file
descriptor.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>fildes</i> argument is not connected to a STREAM
pipe.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
</table>

<p style="margin-left:11%;">I_RECVFD</p>

<p style="margin-left:22%;">Retrieves the reference to an
open file description from a message written to a
STREAMS-based pipe using the I_SENDFD command, and allocates
a new file descriptor in the calling process that refers to
this open file description. The <i>arg</i> argument is a
pointer to a <b>strrecvfd</b> data structure as defined in
<i>&lt;stropts.h&gt;</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>fd</i>
member is a file descriptor. The <i>uid</i> and <i>gid</i>
members are the effective user ID and effective group ID,
respectively, of the sending process.</p>

<p style="margin-left:11%; margin-top: 1em">If O_NONBLOCK
is not set, I_RECVFD shall block until a message is present
at the STREAM head. If O_NONBLOCK is set, I_RECVFD shall
fail with <i>errno</i> set to [EAGAIN] if no message is
present at the STREAM head.</p>

<p style="margin-left:11%; margin-top: 1em">If the message
at the STREAM head is a message sent by an I_SENDFD, a new
file descriptor shall be allocated for the open file
descriptor referenced in the message. The new file
descriptor is placed in the <i>fd</i> member of the
<b>strrecvfd</b> structure pointed to by <i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_RECVFD command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A message is not present at the STREAM head read queue
and the O_NONBLOCK flag is set.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EBADMSG</b></p>

<p style="margin-left:22%;">The message at the STREAM head
read queue is not a message containing a passed file
descriptor.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The process has the maximum number of file descriptors
currently open that it is allowed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_LIST</p></td>
<td width="2%"></td>
<td width="78%">


<p>Allows the process to list all the module names on the
STREAM, up to and including the topmost driver name. If
<i>arg</i> is a null pointer, the return value shall be the
number of modules, including the driver, that are on the
STREAM pointed to by <i>fildes</i>. This lets the process
allocate enough space for the module names. Otherwise, it
should point to a <b>str_list</b> structure.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>sl_nmods</i> member indicates the number of entries the
process has allocated in the array. Upon return, the
<i>sl_modlist</i> member of the <b>str_list</b> structure
shall contain the list of module names, and the number of
entries that have been filled into the <i>sl_modlist</i>
array is found in the <i>sl_nmods</i> member (the number
includes the number of modules including the driver). The
return value from <i>ioctl</i>() shall be 0. The entries are
filled in starting at the top of the STREAM and continuing
downstream until either the end of the STREAM is reached, or
the number of requested modules ( <i>sl_nmods</i>) is
satisfied.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_LIST command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="53%">


<p style="margin-top: 1em">The <i>sl_nmods</i> member is
less than 1.</p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate buffers.</p>

<p style="margin-left:11%;">I_ATMARK</p>

<p style="margin-left:22%;">Allows the process to see if
the message at the head of the STREAM head read queue is
marked by some module downstream. The <i>arg</i> argument
determines how the checking is done when there may be
multiple marked messages on the STREAM head read queue. It
may take on the following values:</p>

<p style="margin-left:11%;">ANYMARK</p>

<p style="margin-left:22%;">Check if the message is
marked.</p>

<p style="margin-left:11%;">LASTMARK</p>

<p style="margin-left:22%;">Check if the message is the
last one marked on the queue.</p>

<p style="margin-left:11%; margin-top: 1em">The
bitwise-inclusive OR of the flags ANYMARK and LASTMARK is
permitted.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value shall be 1 if the mark condition is satisfied;
otherwise, the value shall be 0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_ATMARK command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="27%">


<p>Invalid <i>arg</i> value.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;">I_CKBAND</p>

<p style="margin-left:22%;">Checks if the message of a
given priority band exists on the STREAM head read queue.
This shall return 1 if a message of the given priority
exists, 0 if no such message exists, or -1 on error.
<i>arg</i> should be of type <b>int</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_CKBAND command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="27%">


<p>Invalid <i>arg</i> value.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;">I_GETBAND</p>

<p style="margin-left:22%;">Returns the priority band of
the first message on the STREAM head read queue in the
integer referenced by <i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_GETBAND command shall
fail if: <b><br>
ENODATA</b></p>

<p style="margin-left:22%;">No message on the STREAM head
read queue.</p>

<p style="margin-left:11%;">I_CANPUT</p>

<p style="margin-left:22%;">Checks if a certain band is
writable. <i>arg</i> is set to the priority band in
question. The return value shall be 0 if the band is
flow-controlled, 1 if the band is writable, or -1 on
error.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_CANPUT command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="27%">


<p>Invalid <i>arg</i> value.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;">I_SETCLTIME</p>

<p style="margin-left:22%;">This request allows the process
to set the time the STREAM head shall delay when a STREAM is
closing and there is data on the write queues. Before
closing each module or driver, if there is data on its write
queue, the STREAM head shall delay for the specified amount
of time to allow the data to drain. If, after the delay,
data is still present, it shall be flushed. The <i>arg</i>
argument is a pointer to an integer specifying the number of
milliseconds to delay, rounded up to the nearest valid
value. If I_SETCLTIME is not performed on a STREAM, an
implementation-defined default timeout interval is used.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_SETCLTIME command shall
fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="27%">


<p>Invalid <i>arg</i> value.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;">I_GETCLTIME</p>

<p style="margin-left:22%;">Returns the close time delay in
the integer pointed to by <i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Multiplexed
STREAMS Configurations</b> <br>
The following commands are used for connecting and
disconnecting multiplexed STREAMS configurations. These
commands use an implementation-defined default timeout
interval.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>I_LINK</p></td>
<td width="2%"></td>
<td width="78%">


<p>Connects two STREAMs, where <i>fildes</i> is the file
descriptor of the STREAM connected to the multiplexing
driver, and <i>arg</i> is the file descriptor of the STREAM
connected to another driver. The STREAM designated by
<i>arg</i> is connected below the multiplexing driver.
I_LINK requires the multiplexing driver to send an
acknowledgement message to the STREAM head regarding the
connection. This call shall return a multiplexer ID number
(an identifier used to disconnect the multiplexer; see
I_UNLINK) on success, and -1 on failure.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_LINK command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">Hangup received on
<i>fildes</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ETIME</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Timeout before acknowledgement message was received at
STREAM head.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate STREAMS storage to perform the I_LINK.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>arg</i> argument is not a valid, open file
descriptor.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>fildes</i> argument does not support
multiplexing; or <i>arg</i> is not a STREAM or is already
connected downstream from a multiplexer; or the specified
I_LINK operation would connect the STREAM head in more than
one place in the multiplexed STREAM.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An I_LINK can
also fail while waiting for the multiplexing driver to
acknowledge the request, if a message indicating an error or
a hangup is received at the STREAM head of <i>fildes</i>. In
addition, an error code can be returned in the positive or
negative acknowledgement message. For these cases, I_LINK
fails with <i>errno</i> set to the value in the message.
<br>
I_UNLINK</p>

<p style="margin-left:22%;">Disconnects the two STREAMs
specified by <i>fildes</i> and <i>arg</i>. <i>fildes</i> is
the file descriptor of the STREAM connected to the
multiplexing driver. The <i>arg</i> argument is the
multiplexer ID number that was returned by the I_LINK
<i>ioctl</i>() command when a STREAM was connected
downstream from the multiplexing driver. If <i>arg</i> is
MUXID_ALL, then all STREAMs that were connected to
<i>fildes</i> shall be disconnected. As in I_LINK, this
command requires acknowledgement.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_UNLINK command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ETIME</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Timeout before acknowledgement message was received at
STREAM head.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate buffers for the acknowledgement message.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="46%">


<p>Invalid multiplexer ID number.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An I_UNLINK can
also fail while waiting for the multiplexing driver to
acknowledge the request if a message indicating an error or
a hangup is received at the STREAM head of <i>fildes</i>. In
addition, an error code can be returned in the positive or
negative acknowledgement message. For these cases, I_UNLINK
shall fail with <i>errno</i> set to the value in the
message. <br>
I_PLINK</p>

<p style="margin-left:22%;">Creates a <i>persistent
connection</i> between two STREAMs, where <i>fildes</i> is
the file descriptor of the STREAM connected to the
multiplexing driver, and <i>arg</i> is the file descriptor
of the STREAM connected to another driver. This call shall
create a persistent connection which can exist even if the
file descriptor <i>fildes</i> associated with the upper
STREAM to the multiplexing driver is closed. The STREAM
designated by <i>arg</i> gets connected via a persistent
connection below the multiplexing driver. I_PLINK requires
the multiplexing driver to send an acknowledgement message
to the STREAM head. This call shall return a multiplexer ID
number (an identifier that may be used to disconnect the
multiplexer; see I_PUNLINK) on success, and -1 on
failure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_PLINK command shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ETIME</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Timeout before acknowledgement message was received at
STREAM head.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate STREAMS storage to perform the I_PLINK.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>arg</i> argument is not a valid, open file
descriptor.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>fildes</i> argument does not support
multiplexing; or <i>arg</i> is not a STREAM or is already
connected downstream from a multiplexer; or the specified
I_PLINK operation would connect the STREAM head in more than
one place in the multiplexed STREAM.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An I_PLINK can
also fail while waiting for the multiplexing driver to
acknowledge the request, if a message indicating an error or
a hangup is received at the STREAM head of <i>fildes</i>. In
addition, an error code can be returned in the positive or
negative acknowledgement message. For these cases, I_PLINK
shall fail with <i>errno</i> set to the value in the
message. <br>
I_PUNLINK</p>

<p style="margin-left:22%;">Disconnects the two STREAMs
specified by <i>fildes</i> and <i>arg</i> from a persistent
connection. The <i>fildes</i> argument is the file
descriptor of the STREAM connected to the multiplexing
driver. The <i>arg</i> argument is the multiplexer ID number
that was returned by the I_PLINK <i>ioctl</i>() command when
a STREAM was connected downstream from the multiplexing
driver. If <i>arg</i> is MUXID_ALL, then all STREAMs which
are persistent connections to <i>fildes</i> shall be
disconnected. As in I_PLINK, this command requires the
multiplexing driver to acknowledge the request.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>ioctl</i>() function with the I_PUNLINK command shall
fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ENXIO</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Hangup received on <i>fildes</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ETIME</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Timeout before acknowledgement message was received at
STREAM head.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAGAIN</b> or
<b>ENOSR</b></p>

<p style="margin-left:22%; margin-top: 1em">Unable to
allocate buffers for the acknowledgement message.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="46%">


<p>Invalid multiplexer ID number.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An I_PUNLINK
can also fail while waiting for the multiplexing driver to
acknowledge the request if a message indicating an error or
a hangup is received at the STREAM head of <i>fildes</i>. In
addition, an error code can be returned in the positive or
negative acknowledgement message. For these cases, I_PUNLINK
shall fail with <i>errno</i> set to the value in the
message.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Upon successful
completion, <i>ioctl</i>() shall return a value other than
-1 that depends upon the STREAMS device control function.
Otherwise, it shall return -1 and set <i>errno</i> to
indicate the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Under the
following general conditions, <i>ioctl</i>() shall fail
if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>fildes</i> argument is
not a valid open file descriptor.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>A signal was caught during the <i>ioctl</i>()
operation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The STREAM or multiplexer referenced by <i>fildes</i> is
linked (directly or indirectly) downstream from a
multiplexer.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If an
underlying device driver detects an error, then
<i>ioctl</i>() shall fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>request</i> or <i>arg</i>
argument is not valid for this device.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Some physical I/O error has occurred.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOTTY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>fildes</i> argument is not associated with a
STREAMS device that accepts control functions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENXIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>request</i> and <i>arg</i> arguments are valid
for this device driver, but the service requested cannot be
performed on this particular sub-device.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENODEV</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The <i>fildes</i> argument refers to a valid STREAMS
device, but the corresponding device driver does not support
the <i>ioctl</i>() function.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If a STREAM is
connected downstream from a multiplexer, any <i>ioctl</i>()
command except I_UNLINK and I_PUNLINK shall set <i>errno</i>
to [EINVAL].</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
following sections are informative.</i></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>APPLICATION USAGE
<a name="APPLICATION USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
implementation-defined timeout interval for STREAMS has
historically been 15 seconds.</p>

<h2>RATIONALE
<a name="RATIONALE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>FUTURE DIRECTIONS
<a name="FUTURE DIRECTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>STREAMS</i>,
<i>close</i>(), <i>fcntl</i>(), <i>getmsg</i>(),
<i>open</i>(), <i>pipe</i>(), <i>poll</i>(),
<i>putmsg</i>(), <i>read</i>(), <i>sigaction</i>(),
<i>write</i>(), the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <i>&lt;stropts.h&gt;</i></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Portions of
this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information
Technology -- Portable Operating System Interface (POSIX),
The Open Group Base Specifications Issue 6, Copyright (C)
2001-2003 by the Institute of Electrical and Electronics
Engineers, Inc and The Open Group. In the event of any
discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open
Group Standard is the referee document. The original
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>
<hr>
</body>
</html>
