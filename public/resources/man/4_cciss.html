<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:22:47 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CCISS</title>

</head>
<body>

<h1 align="center">CCISS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">cciss &minus;
HP Smart Array block driver</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">modprobe cciss
[ cciss_allow_hpsa=1 ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>cciss</b> is
a block driver for older HP Smart Array RAID
controllers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options</b>
<i><br>
cciss_allow_hpsa=1</i>: This option prevents the
<b>cciss</b> driver from attempting to drive any controllers
that the <b>hpsa</b>(4) driver is capable of controlling,
which is to say, the <b>cciss</b> driver is restricted by
this option to the following controllers:</p>

<p style="margin-left:11%; margin-top: 1em">Smart Array
5300 <br>
Smart Array 5i <br>
Smart Array 532 <br>
Smart Array 5312 <br>
Smart Array 641 <br>
Smart Array 642 <br>
Smart Array 6400 <br>
Smart Array 6400 EM <br>
Smart Array 6i <br>
Smart Array P600 <br>
Smart Array P400i <br>
Smart Array E200i <br>
Smart Array E200 <br>
Smart Array E200i <br>
Smart Array E200i <br>
Smart Array E200i <br>
Smart Array E500</p>

<p style="margin-left:11%; margin-top: 1em"><b>Supported
hardware</b> <br>
The <b>cciss</b> driver supports the following Smart Array
boards:</p>

<p style="margin-left:11%; margin-top: 1em">Smart Array
5300 <br>
Smart Array 5i <br>
Smart Array 532 <br>
Smart Array 5312 <br>
Smart Array 641 <br>
Smart Array 642 <br>
Smart Array 6400 <br>
Smart Array 6400 U320 Expansion Module <br>
Smart Array 6i <br>
Smart Array P600 <br>
Smart Array P800 <br>
Smart Array E400 <br>
Smart Array P400i <br>
Smart Array E200 <br>
Smart Array E200i <br>
Smart Array E500 <br>
Smart Array P700m <br>
Smart Array P212 <br>
Smart Array P410 <br>
Smart Array P410i <br>
Smart Array P411 <br>
Smart Array P812 <br>
Smart Array P712m <br>
Smart Array P711m</p>


<p style="margin-left:11%; margin-top: 1em"><b>Configuration
details</b> <br>
To configure HP Smart Array controllers, use the HP Array
Configuration Utility (either <b>hpacuxe</b>(8) or
<b>hpacucli</b>(8)) or the Offline ROM-based Configuration
Utility (ORCA) run from the Smart Array&rsquo;s option ROM
at boot time.</p>

<h2>FILES
<a name="FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Device
nodes</b> <br>
The device naming scheme is as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Major
numbers:</p>

<p style="margin-left:11%; margin-top: 1em">104 cciss0 <br>
105 cciss1 <br>
106 cciss2 <br>
105 cciss3 <br>
108 cciss4 <br>
109 cciss5 <br>
110 cciss6 <br>
111 cciss7</p>

<p style="margin-left:11%; margin-top: 1em">Minor
numbers:</p>

<p style="margin-left:11%; margin-top: 1em">b7 b6 b5 b4 b3
b2 b1 b0 <br>
|----+----| |----+----| <br>
| | <br>
| +-------- Partition ID (0=wholedev, 1-15 partition) <br>
| <br>
+-------------------- Logical Volume number</p>

<p style="margin-left:11%; margin-top: 1em">The device
naming scheme is:</p>


<p style="margin-left:11%; margin-top: 1em">/dev/cciss/c0d0
Controller 0, disk 0, whole device <br>
/dev/cciss/c0d0p1 Controller 0, disk 0, partition 1 <br>
/dev/cciss/c0d0p2 Controller 0, disk 0, partition 2 <br>
/dev/cciss/c0d0p3 Controller 0, disk 0, partition 3</p>


<p style="margin-left:11%; margin-top: 1em">/dev/cciss/c1d1
Controller 1, disk 1, whole device <br>
/dev/cciss/c1d1p1 Controller 1, disk 1, partition 1 <br>
/dev/cciss/c1d1p2 Controller 1, disk 1, partition 2 <br>
/dev/cciss/c1d1p3 Controller 1, disk 1, partition 3</p>

<p style="margin-left:11%; margin-top: 1em"><b>Files in
/proc</b> <br>
The files <i>/proc/driver/cciss/cciss[0-9]+</i> contain
information about the configuration of each controller. For
example:</p>

<p style="margin-left:11%; margin-top: 1em">$ <b>cd
/proc/driver/cciss</b> <br>
$ <b>ls -l</b> <br>
total 0 <br>
-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss0 <br>
-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss1 <br>
-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss2 <br>
$ <b>cat cciss2</b> <br>
cciss2: HP Smart Array P800 Controller <br>
Board ID: 0x3223103c <br>
Firmware Version: 7.14 <br>
IRQ: 16 <br>
Logical drives: 1 <br>
Current Q depth: 0 <br>
Current # commands on controller: 0 <br>
Max Q depth since init: 1 <br>
Max # commands on controller since init: 2 <br>
Max SG entries since init: 32 <br>
Sequential access devices: 0</p>

<p style="margin-left:11%; margin-top: 1em">cciss/c2d0:
36.38GB RAID 0</p>

<p style="margin-left:11%; margin-top: 1em"><b>Files in
/sys</b> <i><br>
/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/model</i></p>

<p style="margin-left:22%;">Displays the SCSI INQUIRY page
0 model for logical drive <i>Y</i> of controller
<i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/rev</i></p>

<p style="margin-left:22%;">Displays the SCSI INQUIRY page
0 revision for logical drive <i>Y</i> of controller
<i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/unique_id</i></p>

<p style="margin-left:22%;">Displays the SCSI INQUIRY page
83 serial number for logical drive <i>Y</i> of controller
<i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/vendor</i></p>

<p style="margin-left:22%;">Displays the SCSI INQUIRY page
0 vendor for logical drive <i>Y</i> of controller
<i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/block:cciss!cXdY</i></p>

<p style="margin-left:22%;">A symbolic link to
<i>/sys/block/cciss!cXdY</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/rescan</i></p>

<p style="margin-left:22%;">When this file is written to,
the driver rescans the controller to discover any new,
removed, or modified logical drives.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/resettable</i></p>

<p style="margin-left:22%;">A value of 1 displayed in this
file indicates that the &quot;reset_devices=1&quot; kernel
parameter (used by <b>kdump</b>) is honored by this
controller. A value of 0 indicates that the
&quot;reset_devices=1&quot; kernel parameter will not be
honored. Some models of Smart Array are not able to honor
this parameter.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/lunid</i></p>

<p style="margin-left:22%;">Displays the 8-byte LUN ID used
to address logical drive <i>Y</i> of controller
<i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/raid_level</i></p>

<p style="margin-left:22%;">Displays the RAID level of
logical drive <i>Y</i> of controller <i>X</i>.</p>


<p style="margin-left:11%;"><i>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/usage_count</i></p>

<p style="margin-left:22%;">Displays the usage count
(number of opens) of logical drive <i>Y</i> of controller
<i>X</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SCSI tape
drive and medium changer support</b> <br>
SCSI sequential access devices and medium changer devices
are supported and appropriate device nodes are automatically
created (e.g., <i>/dev/st0</i>, <i>/dev/st1</i>, etc.; see
<b>st</b>(4) for more details.) You must enable &quot;SCSI
tape drive support for Smart Array 5xxx&quot; and &quot;SCSI
support&quot; in your kernel configuration to be able to use
SCSI tape drives with your Smart Array 5xxx controller.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally,
note that the driver will not engage the SCSI core at init
time. The driver must be directed to dynamically engage the
SCSI core via the /proc file-system entry, which the
&quot;block&quot; side of the driver creates as
<i>/proc/driver/cciss/cciss*</i> at run time. This is
because at driver init time, the SCSI core may not yet be
initialized (because the driver is a block driver) and
attempting to register it with the SCSI core in such a case
would cause a hang. This is best done via an initialization
script (typically in <i>/etc/init.d</i>, but could vary
depending on distribution). For example:</p>

<p style="margin-left:11%; margin-top: 1em">for x in
/proc/driver/cciss/cciss[0-9]* <br>
do <br>
echo &quot;engage scsi&quot; &gt; $x <br>
done</p>

<p style="margin-left:11%; margin-top: 1em">Once the SCSI
core is engaged by the driver, it cannot be disengaged
(except by unloading the driver, if it happens to be linked
as a module.)</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
if no sequential access devices or medium changers are
detected, the SCSI core will not be engaged by the action of
the above script.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Hot plug
support for SCSI tape drives</b> <br>
Hot plugging of SCSI tape drives is supported, with some
caveats. The <b>cciss</b> driver must be informed that
changes to the SCSI bus have been made. This may be done via
the /proc file system. For example:</p>

<p style="margin-left:11%; margin-top: 1em">echo
&quot;rescan&quot; &gt; /proc/scsi/cciss0/1</p>

<p style="margin-left:11%; margin-top: 1em">This causes the
driver to:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="74%">


<p>query the adapter about changes to the physical SCSI
buses and/or fibre channel arbitrated loop, and</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="74%">


<p>make note of any new or removed sequential access
devices or medium changers.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The driver will
output messages indicating which devices have been added or
removed and the controller, bus, target and lun used to
address each device. The driver then notifies the SCSI
midlayer of these changes.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
naming convention of the /proc file-system entries contains
a number in addition to the driver name (e.g.,
&quot;cciss0&quot; instead of just &quot;cciss&quot;, which
you might expect).</p>

<p style="margin-left:11%; margin-top: 1em">Note:
<i>Only</i> sequential access devices and medium changers
are presented as SCSI devices to the SCSI midlayer by the
<b>cciss</b> driver. Specifically, physical SCSI disk drives
are <i>not</i> presented to the SCSI midlayer. The only disk
devices that are presented to the kernel are logical drives
that the array controller constructs from regions on the
physical drives. The logical drives are presented to the
block layer (not to the SCSI midlayer). It is important for
the driver to prevent the kernel from accessing the physical
drives directly, since these drives are used by the array
controller to construct the logical drives.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SCSI error
handling for tape drives and medium changers</b> <br>
The Linux SCSI midlayer provides an error-handling protocol
that is initiated whenever a SCSI command fails to complete
within a certain amount of time (which can vary depending on
the command). The <b>cciss</b> driver participates in this
protocol to some extent. The normal protocol is a four-step
process:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="79%">


<p style="margin-top: 1em">First, the device is told to
abort the command.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="79%">


<p>If that doesn&rsquo;t work, the device is reset.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="79%">


<p>If that doesn&rsquo;t work, the SCSI bus is reset.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="79%">


<p>If that doesn&rsquo;t work the host bus adapter is
reset.</p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<b>cciss</b> driver is a block driver as well as a SCSI
driver and only the tape drives and medium changers are
presented to the SCSI midlayer Furthermore, unlike more
straightforward SCSI drivers, disk I/O continues through the
block side during the SCSI error-recovery process Therefore,
the <b>cciss</b> driver implements only the first two of
these actions, aborting the command, and resetting the
device. Note also that most tape drives will not oblige in
aborting commands, and sometimes it appears they will not
even obey a reset command, though in most circumstances they
will. If the command cannot be aborted and the device cannot
be reset, the device will be set offline.</p>

<p style="margin-left:11%; margin-top: 1em">In the event
that the error-handling code is triggered and a tape drive
is successfully reset or the tardy command is successfully
aborted, the tape drive may still not allow I/O to continue
until some command is issued that positions the tape to a
known position. Typically you must rewind the tape (by
issuing <i>mt -f /dev/st0 rewind</i> for example) before I/O
can proceed again to a tape drive that was reset.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>cciss_vol_status</b>(8),
<b>hpsa</b>(4), <b>hpacucli</b>(8), <b>hpacuxe</b>(8), <br>
<a href="http://cciss.sf.net">http://cciss.sf.net</a>, and
<i>Documentation/blockdev/cciss.txt</i> and
<i>Documentation/ABI/testing/sysfs-bus-pci-devices-cciss</i>
in the Linux kernel source tree</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
