<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:58:02 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT&minus;REV&minus;LIST</title>

</head>
<body>

<h1 align="center">GIT&minus;REV&minus;LIST</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#PRETTY FORMATS">PRETTY FORMATS</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-rev-list
&minus; Lists commit objects in reverse chronological
order</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git
rev&minus;list</i> [
&minus;&minus;max&minus;count=&lt;number&gt; ] <br>
[ &minus;&minus;skip=&lt;number&gt; ] <br>
[ &minus;&minus;max&minus;age=&lt;timestamp&gt; ] <br>
[ &minus;&minus;min&minus;age=&lt;timestamp&gt; ] <br>
[ &minus;&minus;sparse ] <br>
[ &minus;&minus;merges ] <br>
[ &minus;&minus;no&minus;merges ] <br>
[ &minus;&minus;min&minus;parents=&lt;number&gt; ] <br>
[ &minus;&minus;no&minus;min&minus;parents ] <br>
[ &minus;&minus;max&minus;parents=&lt;number&gt; ] <br>
[ &minus;&minus;no&minus;max&minus;parents ] <br>
[ &minus;&minus;first&minus;parent ] <br>
[ &minus;&minus;remove&minus;empty ] <br>
[ &minus;&minus;full&minus;history ] <br>
[ &minus;&minus;not ] <br>
[ &minus;&minus;all ] <br>
[ &minus;&minus;branches[=&lt;pattern&gt;] ] <br>
[ &minus;&minus;tags[=&lt;pattern&gt;] ] <br>
[ &minus;&minus;remotes[=&lt;pattern&gt;] ] <br>
[ &minus;&minus;glob=&lt;glob&minus;pattern&gt; ] <br>
[ &minus;&minus;ignore&minus;missing ] <br>
[ &minus;&minus;stdin ] <br>
[ &minus;&minus;quiet ] <br>
[ &minus;&minus;topo&minus;order ] <br>
[ &minus;&minus;parents ] <br>
[ &minus;&minus;timestamp ] <br>
[ &minus;&minus;left&minus;right ] <br>
[ &minus;&minus;left&minus;only ] <br>
[ &minus;&minus;right&minus;only ] <br>
[ &minus;&minus;cherry&minus;mark ] <br>
[ &minus;&minus;cherry&minus;pick ] <br>
[ &minus;&minus;encoding[=&lt;encoding&gt;] ] <br>
[ &minus;&minus;(author|committer|grep)=&lt;pattern&gt; ]
<br>
[ &minus;&minus;regexp&minus;ignore&minus;case | &minus;i ]
<br>
[ &minus;&minus;extended&minus;regexp | &minus;E ] <br>
[ &minus;&minus;fixed&minus;strings | &minus;F ] <br>
[ &minus;&minus;date=(local|relative|default|iso|rfc|short)
] <br>
[ [&minus;&minus;objects | &minus;&minus;objects&minus;edge]
[ &minus;&minus;unpacked ] ] <br>
[ &minus;&minus;pretty | &minus;&minus;header ] <br>
[ &minus;&minus;bisect ] <br>
[ &minus;&minus;bisect&minus;vars ] <br>
[ &minus;&minus;bisect&minus;all ] <br>
[ &minus;&minus;merge ] <br>
[ &minus;&minus;reverse ] <br>
[ &minus;&minus;walk&minus;reflogs ] <br>
[ &minus;&minus;no&minus;walk ] [
&minus;&minus;do&minus;walk ] <br>
&lt;commit&gt;... [ &minus;&minus; &lt;paths&gt;... ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">List commits
that are reachable by following the parent links from the
given commit(s), but exclude commits that are reachable from
the one(s) given with a <i>^</i> in front of them. The
output is given in reverse chronological order by
default.</p>

<p style="margin-left:11%; margin-top: 1em">You can think
of this as a set operation. Commits given on the command
line form a set of commits that are reachable from any of
them, and then commits reachable from any of the ones given
with <i>^</i> in front are subtracted from that set. The
remaining commits are what comes out in the command&rsquo;s
output. Various other options and paths parameters can be
used to further limit the result.</p>

<p style="margin-left:11%; margin-top: 1em">Thus, the
following command:</p>

<p style="margin-left:17%; margin-top: 1em">$ git
rev&minus;list foo bar ^baz</p>

<p style="margin-left:11%; margin-top: 1em">means
&quot;list all the commits which are reachable from
<i>foo</i> or <i>bar</i>, but not from <i>baz</i>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">A special
notation
&quot;<i>&lt;commit1&gt;</i>..<i>&lt;commit2&gt;</i>&quot;
can be used as a short&minus;hand for
&quot;^'&lt;commit1&gt;' <i>&lt;commit2&gt;</i>&quot;. For
example, either of the following may be used
interchangeably:</p>

<p style="margin-left:17%; margin-top: 1em">$ git
rev&minus;list origin..HEAD <br>
$ git rev&minus;list HEAD ^origin</p>

<p style="margin-left:11%; margin-top: 1em">Another special
notation is
&quot;<i>&lt;commit1&gt;</i>...<i>&lt;commit2&gt;</i>&quot;
which is useful for merges. The resulting set of commits is
the symmetric difference between the two operands. The
following two commands are equivalent:</p>

<p style="margin-left:17%; margin-top: 1em">$ git
rev&minus;list A B &minus;&minus;not $(git merge&minus;base
&minus;&minus;all A B) <br>
$ git rev&minus;list A...B</p>


<p style="margin-left:11%; margin-top: 1em"><i>rev&minus;list</i>
is a very essential Git command, since it provides the
ability to build and traverse commit ancestry graphs. For
this reason, it has a lot of different options that enables
it to be used by commands as different as <i>git bisect</i>
and <i>git repack</i>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Commit
Limiting</b> <br>
Besides specifying a range of commits that should be listed
using the special notations explained in the description,
additional commit limiting may be applied.</p>

<p style="margin-left:11%; margin-top: 1em">Using more
options generally further limits the output (e.g.
&minus;&minus;since=&lt;date1&gt; limits to commits newer
than &lt;date1&gt;, and using it with
&minus;&minus;grep=&lt;pattern&gt; further limits to commits
whose log message has a line that matches &lt;pattern&gt;),
unless otherwise noted.</p>

<p style="margin-left:11%; margin-top: 1em">Note that these
are applied before commit ordering and formatting options,
such as &minus;&minus;reverse.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&lt;number&gt;,
&minus;n &lt;number&gt;,
&minus;&minus;max&minus;count=&lt;number&gt;</p>

<p style="margin-left:17%;">Limit the number of commits to
output.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;skip=&lt;number&gt;</p>

<p style="margin-left:17%;">Skip <i>number</i> commits
before starting to show the commit output.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;since=&lt;date&gt;,
&minus;&minus;after=&lt;date&gt;</p>

<p style="margin-left:17%;">Show commits more recent than a
specific date.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;until=&lt;date&gt;,
&minus;&minus;before=&lt;date&gt;</p>

<p style="margin-left:17%;">Show commits older than a
specific date.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;max&minus;age=&lt;timestamp&gt;,
&minus;&minus;min&minus;age=&lt;timestamp&gt;</p>

<p style="margin-left:17%;">Limit the commits output to
specified time range.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;author=&lt;pattern&gt;,
&minus;&minus;committer=&lt;pattern&gt;</p>

<p style="margin-left:17%;">Limit the commits output to
ones with author/committer header lines that match the
specified pattern (regular expression). With more than one
&minus;&minus;author=&lt;pattern&gt;, commits whose author
matches any of the given patterns are chosen (similarly for
multiple &minus;&minus;committer=&lt;pattern&gt;).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;grep&minus;reflog=&lt;pattern&gt;</p>

<p style="margin-left:17%;">Limit the commits output to
ones with reflog entries that match the specified pattern
(regular expression). With more than one
&minus;&minus;grep&minus;reflog, commits whose reflog
message matches any of the given patterns are chosen. It is
an error to use this option unless
&minus;&minus;walk&minus;reflogs is in use.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;grep=&lt;pattern&gt;</p>

<p style="margin-left:17%;">Limit the commits output to
ones with log message that matches the specified pattern
(regular expression). With more than one
&minus;&minus;grep=&lt;pattern&gt;, commits whose message
matches any of the given patterns are chosen (but see
&minus;&minus;all&minus;match).</p>

<p style="margin-left:17%; margin-top: 1em">When
&minus;&minus;show&minus;notes is in effect, the message
from the notes as if it is part of the log message.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;all&minus;match</p>

<p style="margin-left:17%;">Limit the commits output to
ones that match all given &minus;&minus;grep, instead of
ones that match at least one.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;i,
&minus;&minus;regexp&minus;ignore&minus;case</p>

<p style="margin-left:17%;">Match the regexp limiting
patterns without regard to letters case.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;basic&minus;regexp</p>

<p style="margin-left:17%;">Consider the limiting patterns
to be basic regular expressions; this is the default.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;E,
&minus;&minus;extended&minus;regexp</p>

<p style="margin-left:17%;">Consider the limiting patterns
to be extended regular expressions instead of the default
basic regular expressions.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;F,
&minus;&minus;fixed&minus;strings</p>

<p style="margin-left:17%;">Consider the limiting patterns
to be fixed strings (don&rsquo;t interpret pattern as a
regular expression).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;perl&minus;regexp</p>

<p style="margin-left:17%;">Consider the limiting patterns
to be Perl&minus;compatible regexp. Requires libpcre to be
compiled in.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;remove&minus;empty</p>

<p style="margin-left:17%;">Stop when a given path
disappears from the tree.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;merges</p>

<p style="margin-left:17%;">Print only merge commits. This
is exactly the same as
&minus;&minus;min&minus;parents=2.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;merges</p>

<p style="margin-left:17%;">Do not print commits with more
than one parent. This is exactly the same as
&minus;&minus;max&minus;parents=1.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;min&minus;parents=&lt;number&gt;,
&minus;&minus;max&minus;parents=&lt;number&gt;,
&minus;&minus;no&minus;min&minus;parents,
&minus;&minus;no&minus;max&minus;parents</p>

<p style="margin-left:17%;">Show only commits which have at
least (or at most) that many commits. In particular,
&minus;&minus;max&minus;parents=1 is the same as
&minus;&minus;no&minus;merges,
&minus;&minus;min&minus;parents=2 is the same as
&minus;&minus;merges. &minus;&minus;max&minus;parents=0
gives all root commits and &minus;&minus;min&minus;parents=3
all octopus merges.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;no&minus;min&minus;parents
and &minus;&minus;no&minus;max&minus;parents reset these
limits (to no limit) again. Equivalent forms are
&minus;&minus;min&minus;parents=0 (any commit has 0 or more
parents) and &minus;&minus;max&minus;parents=&minus;1
(negative numbers denote no upper limit).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;first&minus;parent</p>

<p style="margin-left:17%;">Follow only the first parent
commit upon seeing a merge commit. This option can give a
better overview when viewing the evolution of a particular
topic branch, because merges into a topic branch tend to be
only about adjusting to updated upstream from time to time,
and this option allows you to ignore the individual commits
brought in to your history by such a merge.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;not</p>

<p style="margin-left:17%;">Reverses the meaning of the
<i>^</i> prefix (or lack thereof) for all following revision
specifiers, up to the next <i>&minus;&minus;not</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;all</p>

<p style="margin-left:17%;">Pretend as if all the refs in
refs/ are listed on the command line as
<i>&lt;commit&gt;</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;branches[=&lt;pattern&gt;]</p>

<p style="margin-left:17%;">Pretend as if all the refs in
refs/heads are listed on the command line as
<i>&lt;commit&gt;</i>. If <i>&lt;pattern&gt;</i> is given,
limit branches to ones matching given shell glob. If pattern
lacks <i>?</i>, <i>*</i>, or <i>[</i>, <i>/*</i> at the end
is implied.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;tags[=&lt;pattern&gt;]</p>

<p style="margin-left:17%;">Pretend as if all the refs in
refs/tags are listed on the command line as
<i>&lt;commit&gt;</i>. If <i>&lt;pattern&gt;</i> is given,
limit tags to ones matching given shell glob. If pattern
lacks <i>?</i>, <i>*</i>, or <i>[</i>, <i>/*</i> at the end
is implied.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;remotes[=&lt;pattern&gt;]</p>

<p style="margin-left:17%;">Pretend as if all the refs in
refs/remotes are listed on the command line as
<i>&lt;commit&gt;</i>. If <i>&lt;pattern&gt;</i> is given,
limit remote&minus;tracking branches to ones matching given
shell glob. If pattern lacks <i>?</i>, <i>*</i>, or
<i>[</i>, <i>/*</i> at the end is implied.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;glob=&lt;glob&minus;pattern&gt;</p>

<p style="margin-left:17%;">Pretend as if all the refs
matching shell glob <i>&lt;glob&minus;pattern&gt;</i> are
listed on the command line as <i>&lt;commit&gt;</i>. Leading
<i>refs/</i>, is automatically prepended if missing. If
pattern lacks <i>?</i>, <i>*</i>, or <i>[</i>, <i>/*</i> at
the end is implied.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;ignore&minus;missing</p>

<p style="margin-left:17%;">Upon seeing an invalid object
name in the input, pretend as if the bad input was not
given.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;stdin</p>

<p style="margin-left:17%;">In addition to the
<i>&lt;commit&gt;</i> listed on the command line, read them
from the standard input. If a <i>&minus;&minus;</i>
separator is seen, stop reading commits and start reading
paths to limit the result.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;quiet</p>

<p style="margin-left:17%;">Don&rsquo;t print anything to
standard output. This form is primarily meant to allow the
caller to test the exit status to see if a range of objects
is fully connected (or not). It is faster than redirecting
stdout to /dev/null as the output does not have to be
formatted.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;cherry&minus;mark</p>

<p style="margin-left:17%;">Like
&minus;&minus;cherry&minus;pick (see below) but mark
equivalent commits with = rather than omitting them, and
inequivalent ones with +.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;cherry&minus;pick</p>

<p style="margin-left:17%;">Omit any commit that introduces
the same change as another commit on the &quot;other
side&quot; when the set of commits are limited with
symmetric difference.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
you have two branches, A and B, a usual way to list all
commits on only one side of them is with
&minus;&minus;left&minus;right (see the example below in the
description of the &minus;&minus;left&minus;right option).
It however shows the commits that were cherry&minus;picked
from the other branch (for example, &quot;3rd on b&quot; may
be cherry&minus;picked from branch A). With this option,
such pairs of commits are excluded from the output.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;left&minus;only,
&minus;&minus;right&minus;only</p>

<p style="margin-left:17%;">List only commits on the
respective side of a symmetric range, i.e. only those which
would be marked &lt; resp. &gt; by
&minus;&minus;left&minus;right.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
&minus;&minus;cherry&minus;pick
&minus;&minus;right&minus;only A...B omits those commits
from B which are in A or are patch&minus;equivalent to a
commit in A. In other words, this lists the + commits from
git cherry A B. More precisely,
&minus;&minus;cherry&minus;pick
&minus;&minus;right&minus;only &minus;&minus;no&minus;merges
gives the exact list.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;cherry</p>

<p style="margin-left:17%;">A synonym for
&minus;&minus;right&minus;only
&minus;&minus;cherry&minus;mark
&minus;&minus;no&minus;merges; useful to limit the output to
the commits on our side and mark those that have been
applied to the other side of a forked history with git log
&minus;&minus;cherry upstream...mybranch, similar to git
cherry upstream mybranch.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;g,
&minus;&minus;walk&minus;reflogs</p>

<p style="margin-left:17%;">Instead of walking the commit
ancestry chain, walk reflog entries from the most recent one
to older ones. When this option is used you cannot specify
commits to exclude (that is, <i>^commit</i>,
<i>commit1..commit2</i>, nor <i>commit1...commit2</i>
notations cannot be used).</p>

<p style="margin-left:17%; margin-top: 1em">With
<i>&minus;&minus;pretty</i> format other than oneline (for
obvious reasons), this causes the output to have two extra
lines of information taken from the reflog. By default,
<i>commit@{Nth}</i> notation is used in the output. When the
starting commit is specified as <i>commit@{now}</i>, output
also uses <i>commit@{timestamp}</i> notation instead. Under
<i>&minus;&minus;pretty=oneline</i>, the commit message is
prefixed with this information on the same line. This option
cannot be combined with <i>&minus;&minus;reverse</i>. See
also <b>git-reflog</b>(1).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;merge</p>

<p style="margin-left:17%;">After a failed merge, show refs
that touch files having a conflict and don&rsquo;t exist on
all heads to merge.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;boundary</p>

<p style="margin-left:17%;">Output uninteresting commits at
the boundary, which are usually not shown.</p>

<p style="margin-left:11%; margin-top: 1em"><b>History
Simplification</b> <br>
Sometimes you are only interested in parts of the history,
for example the commits modifying a particular &lt;path&gt;.
But there are two parts of <i>History Simplification</i>,
one part is selecting the commits and the other is how to do
it, as there are various strategies to simplify the
history.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options select the commits to be shown:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;paths&gt;</p>

<p style="margin-left:17%;">Commits modifying the given
&lt;paths&gt; are selected.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;simplify&minus;by&minus;decoration</p>

<p style="margin-left:17%;">Commits that are referred by
some branch or tag are selected.</p>

<p style="margin-left:11%; margin-top: 1em">Note that extra
commits can be shown to give a meaningful history.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options affect the way the simplification is performed:</p>

<p style="margin-left:11%; margin-top: 1em">Default
mode</p>

<p style="margin-left:17%;">Simplifies the history to the
simplest history explaining the final state of the tree.
Simplest because it prunes some side branches if the end
result is the same (i.e. merging branches with the same
content)</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;full&minus;history</p>

<p style="margin-left:17%;">Same as the default mode, but
does not prune some history.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;dense</p>

<p style="margin-left:17%;">Only the selected commits are
shown, plus some to have a meaningful history.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;sparse</p>

<p style="margin-left:17%;">All commits in the simplified
history are shown.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;simplify&minus;merges</p>

<p style="margin-left:17%;">Additional option to
<i>&minus;&minus;full&minus;history</i> to remove some
needless merges from the resulting history, as there are no
selected commits contributing to this merge.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;ancestry&minus;path</p>

<p style="margin-left:17%;">When given a range of commits
to display (e.g. <i>commit1..commit2</i> or <i>commit2
^commit1</i>), only display commits that exist directly on
the ancestry chain between the <i>commit1</i> and
<i>commit2</i>, i.e. commits that are both descendants of
<i>commit1</i>, and ancestors of <i>commit2</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A more detailed
explanation follows.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose you
specified foo as the &lt;paths&gt;. We shall call commits
that modify foo !TREESAME, and the rest TREESAME. (In a diff
filtered for foo, they look different and equal,
respectively.)</p>

<p style="margin-left:11%; margin-top: 1em">In the
following, we will always refer to the same example history
to illustrate the differences between simplification
settings. We assume that you are filtering for a file foo in
this commit graph:</p>


<p style="margin-left:17%; margin-top: 1em">.&minus;A&minus;&minus;&minus;M&minus;&minus;&minus;N&minus;&minus;&minus;O&minus;&minus;&minus;P
<br>
/ / / / / <br>
I B C D E <br>
\ / / / / <br>

&lsquo;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;'</p>

<p style="margin-left:11%; margin-top: 1em">The horizontal
line of history A&minus;&minus;&minus;P is taken to be the
first parent of each merge. The commits are:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; I is the
initial commit, in which foo exists with contents
&quot;asdf&quot;, and a file quux exists with contents
&quot;quux&quot;. Initial commits are compared to an empty
tree, so I is !TREESAME.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; In A,
foo contains just &quot;foo&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; B
contains the same change as A. Its merge M is trivial and
hence TREESAME to all parents.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; C does
not change foo, but its merge N changes it to
&quot;foobar&quot;, so it is not TREESAME to any parent.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; D sets
foo to &quot;baz&quot;. Its merge O combines the strings
from N and D to &quot;foobarbaz&quot;; i.e., it is not
TREESAME to any parent.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; E
changes quux to &quot;xyzzy&quot;, and its merge P combines
the strings to &quot;quux xyzzy&quot;. Despite appearing
interesting, P is TREESAME to all parents.</p>


<p style="margin-left:11%; margin-top: 1em"><i>rev&minus;list</i>
walks backwards through history, including or excluding
commits based on whether
<i>&minus;&minus;full&minus;history</i> and/or parent
rewriting (via <i>&minus;&minus;parents</i> or
<i>&minus;&minus;children</i>) are used. The following
settings are available.</p>

<p style="margin-left:11%; margin-top: 1em">Default
mode</p>

<p style="margin-left:17%;">Commits are included if they
are not TREESAME to any parent (though this can be changed,
see <i>&minus;&minus;sparse</i> below). If the commit was a
merge, and it was TREESAME to one parent, follow only that
parent. (Even if there are several TREESAME parents, follow
only one of them.) Otherwise, follow all parents.</p>

<p style="margin-left:17%; margin-top: 1em">This results
in:</p>


<p style="margin-left:23%; margin-top: 1em">.&minus;A&minus;&minus;&minus;N&minus;&minus;&minus;O
<br>
/ / / <br>

I&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;D</p>

<p style="margin-left:17%; margin-top: 1em">Note how the
rule to only follow the TREESAME parent, if one is
available, removed B from consideration entirely. C was
considered via N, but is TREESAME. Root commits are compared
to an empty tree, so I is !TREESAME.</p>

<p style="margin-left:17%; margin-top: 1em">Parent/child
relations are only visible with &minus;&minus;parents, but
that does not affect the commits selected in default mode,
so we have shown the parent lines.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;full&minus;history
without parent rewriting</p>

<p style="margin-left:17%;">This mode differs from the
default in one point: always follow all parents of a merge,
even if it is TREESAME to one of them. Even if more than one
side of the merge has commits that are included, this does
not imply that the merge itself is! In the example, we
get</p>

<p style="margin-left:23%; margin-top: 1em">I A B N D O</p>

<p style="margin-left:17%; margin-top: 1em">P and M were
excluded because they are TREESAME to a parent. E, C and B
were all walked, but only B was !TREESAME, so the others do
not appear.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
without parent rewriting, it is not really possible to talk
about the parent/child relationships between the commits, so
we show them disconnected.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;full&minus;history
with parent rewriting</p>

<p style="margin-left:17%;">Ordinary commits are only
included if they are !TREESAME (though this can be changed,
see <i>&minus;&minus;sparse</i> below).</p>

<p style="margin-left:17%; margin-top: 1em">Merges are
always included. However, their parent list is rewritten:
Along each parent, prune away commits that are not included
themselves. This results in</p>


<p style="margin-left:23%; margin-top: 1em">.&minus;A&minus;&minus;&minus;M&minus;&minus;&minus;N&minus;&minus;&minus;O&minus;&minus;&minus;P
<br>
/ / / / / <br>
I B / D / <br>
\ / / / / <br>

&lsquo;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;'</p>

<p style="margin-left:17%; margin-top: 1em">Compare to
<i>&minus;&minus;full&minus;history</i> without rewriting
above. Note that E was pruned away because it is TREESAME,
but the parent list of P was rewritten to contain E's parent
I. The same happened for C and N. Note also that P was
included despite being TREESAME.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the above settings, you can change whether TREESAME affects
inclusion:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;dense</p>

<p style="margin-left:17%;">Commits that are walked are
included if they are not TREESAME to any parent.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;sparse</p>

<p style="margin-left:17%;">All commits that are walked are
included.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
without <i>&minus;&minus;full&minus;history</i>, this still
simplifies merges: if one of the parents is TREESAME, we
follow only that one, so the other sides of the merge are
never walked.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;simplify&minus;merges</p>

<p style="margin-left:17%;">First, build a history graph in
the same way that <i>&minus;&minus;full&minus;history</i>
with parent rewriting does (see above).</p>

<p style="margin-left:17%; margin-top: 1em">Then simplify
each commit C to its replacement C' in the final history
according to the following rules:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Set C'
to C.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Replace
each parent P of C' with its simplification P'. In the
process, drop parents that are ancestors of other parents,
and remove duplicates.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; If after
this parent rewriting, C' is a root or merge commit (has
zero or &gt;1 parents), a boundary commit, or !TREESAME, it
remains. Otherwise, it is replaced with its only parent.</p>

<p style="margin-left:17%; margin-top: 1em">The effect of
this is best shown by way of comparing to
<i>&minus;&minus;full&minus;history</i> with parent
rewriting. The example turns into:</p>


<p style="margin-left:23%; margin-top: 1em">.&minus;A&minus;&minus;&minus;M&minus;&minus;&minus;N&minus;&minus;&minus;O
<br>
/ / / <br>
I B D <br>
\ / / <br>

&lsquo;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;'</p>

<p style="margin-left:17%; margin-top: 1em">Note the major
differences in N and P over
<i>&minus;&minus;full&minus;history</i>:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; N's
parent list had I removed, because it is an ancestor of the
other parent M. Still, N remained because it is
!TREESAME.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; P's
parent list similarly had I removed. P was then removed
completely, because it had one parent and is TREESAME.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, there
is a fifth simplification mode available:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;ancestry&minus;path</p>

<p style="margin-left:17%;">Limit the displayed commits to
those directly on the ancestry chain between the
&quot;from&quot; and &quot;to&quot; commits in the given
commit range. I.e. only display commits that are ancestor of
the &quot;to&quot; commit, and descendants of the
&quot;from&quot; commit.</p>

<p style="margin-left:17%; margin-top: 1em">As an example
use case, consider the following commit history:</p>


<p style="margin-left:23%; margin-top: 1em">D&minus;&minus;&minus;E&minus;&minus;&minus;&minus;&minus;&minus;&minus;F
<br>
/ \ \ <br>

B&minus;&minus;&minus;C&minus;&minus;&minus;G&minus;&minus;&minus;H&minus;&minus;&minus;I&minus;&minus;&minus;J
<br>
/ \ <br>

A&minus;&minus;&minus;&minus;&minus;&minus;&minus;K&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;L&minus;&minus;M</p>

<p style="margin-left:17%; margin-top: 1em">A regular
<i>D..M</i> computes the set of commits that are ancestors
of M, but excludes the ones that are ancestors of D. This is
useful to see what happened to the history leading to M
since D, in the sense that &quot;what does M have that did
not exist in D&quot;. The result in this example would be
all the commits, except A and B (and D itself, of
course).</p>

<p style="margin-left:17%; margin-top: 1em">When we want to
find out what commits in M are contaminated with the bug
introduced by D and need fixing, however, we might want to
view only the subset of <i>D..M</i> that are actually
descendants of D, i.e. excluding C and K. This is exactly
what the <i>&minus;&minus;ancestry&minus;path</i> option
does. Applied to the <i>D..M</i> range, it results in:</p>


<p style="margin-left:23%; margin-top: 1em">E&minus;&minus;&minus;&minus;&minus;&minus;&minus;F
<br>
\ \ <br>

G&minus;&minus;&minus;H&minus;&minus;&minus;I&minus;&minus;&minus;J
<br>
\ <br>
L&minus;&minus;M</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>&minus;&minus;simplify&minus;by&minus;decoration</i>
option allows you to view only the big picture of the
topology of the history, by omitting commits that are not
referenced by tags. Commits are marked as !TREESAME (in
other words, kept after history simplification rules
described above) if (1) they are referenced by tags, or (2)
they change the contents of the paths given on the command
line. All other commits are marked as TREESAME (subject to
be simplified away).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bisection
Helpers</b> <br>
&minus;&minus;bisect</p>

<p style="margin-left:17%;">Limit output to the one commit
object which is roughly halfway between included and
excluded commits. Note that the bad bisection ref
refs/bisect/bad is added to the included commits (if it
exists) and the good bisection refs refs/bisect/good&minus;*
are added to the excluded commits (if they exist). Thus,
supposing there are no refs in refs/bisect/, if</p>

<p style="margin-left:17%; margin-top: 1em">$ git
rev&minus;list &minus;&minus;bisect foo ^bar ^baz</p>

<p style="margin-left:11%; margin-top: 1em">outputs
<i>midpoint</i>, the output of the two commands</p>

<p style="margin-left:17%; margin-top: 1em">$ git
rev&minus;list foo ^midpoint <br>
$ git rev&minus;list midpoint ^bar ^baz</p>

<p style="margin-left:11%; margin-top: 1em">would be of
roughly the same length. Finding the change which introduces
a regression is thus reduced to a binary search: repeatedly
generate and test new 'midpoint&rsquo;s until the commit
chain is of length one.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;bisect&minus;vars</p>

<p style="margin-left:17%;">This calculates the same as
&minus;&minus;bisect, except that refs in refs/bisect/ are
not used, and except that this outputs text ready to be
eval&rsquo;ed by the shell. These lines will assign the name
of the midpoint revision to the variable bisect_rev, and the
expected number of commits to be tested after bisect_rev is
tested to bisect_nr, the expected number of commits to be
tested if bisect_rev turns out to be good to bisect_good,
the expected number of commits to be tested if bisect_rev
turns out to be bad to bisect_bad, and the number of commits
we are bisecting right now to bisect_all.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;bisect&minus;all</p>

<p style="margin-left:17%;">This outputs all the commit
objects between the included and excluded commits, ordered
by their distance to the included and excluded commits. Refs
in refs/bisect/ are not used. The farthest from them is
displayed first. (This is the only one displayed by
&minus;&minus;bisect.)</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
because it makes it easy to choose a good commit to test
when you want to avoid to test some of them for some reason
(they may not compile for example).</p>

<p style="margin-left:17%; margin-top: 1em">This option can
be used along with &minus;&minus;bisect&minus;vars, in this
case, after all the sorted commit objects, there will be the
same text as if &minus;&minus;bisect&minus;vars had been
used alone.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Commit
Ordering</b> <br>
By default, the commits are shown in reverse chronological
order.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;date&minus;order</p>

<p style="margin-left:17%;">Show no parents before all of
its children are shown, but otherwise show commits in the
commit timestamp order.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;topo&minus;order</p>

<p style="margin-left:17%;">Show no parents before all of
its children are shown, and avoid showing commits on
multiple lines of history intermixed.</p>

<p style="margin-left:17%; margin-top: 1em">For example, in
a commit history like this:</p>


<p style="margin-left:23%; margin-top: 1em">&minus;&minus;&minus;1&minus;&minus;&minus;&minus;2&minus;&minus;&minus;&minus;4&minus;&minus;&minus;&minus;7
<br>
\ \ <br>

3&minus;&minus;&minus;&minus;5&minus;&minus;&minus;&minus;6&minus;&minus;&minus;&minus;8&minus;&minus;&minus;</p>

<p style="margin-left:17%; margin-top: 1em">where the
numbers denote the order of commit timestamps, git
rev&minus;list and friends with
&minus;&minus;date&minus;order show the commits in the
timestamp order: 8 7 6 5 4 3 2 1.</p>

<p style="margin-left:17%; margin-top: 1em">With
&minus;&minus;topo&minus;order, they would show 8 6 5 3 7 4
2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown
before newer ones in order to avoid showing the commits from
two parallel development track mixed together.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;reverse</p>

<p style="margin-left:17%;">Output the commits in reverse
order. Cannot be combined with
<i>&minus;&minus;walk&minus;reflogs</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Object
Traversal</b> <br>
These options are mostly targeted for packing of Git
repositories.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;objects</p>

<p style="margin-left:17%;">Print the object IDs of any
object referenced by the listed commits.
<i>&minus;&minus;objects foo ^bar</i> thus means &quot;send
me all object IDs which I need to download if I have the
commit object <i>bar</i>, but not <i>foo</i>&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;objects&minus;edge</p>

<p style="margin-left:17%;">Similar to
<i>&minus;&minus;objects</i>, but also print the IDs of
excluded commits prefixed with a &quot;&minus;&quot;
character. This is used by <b>git-pack-objects</b>(1) to
build &quot;thin&quot; pack, which records objects in
deltified form based on objects contained in these excluded
commits to reduce network traffic.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;unpacked</p>

<p style="margin-left:17%;">Only useful with
<i>&minus;&minus;objects</i>; print the object IDs that are
not in packs.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;walk[=(sorted|unsorted)]</p>

<p style="margin-left:17%;">Only show the given commits,
but do not traverse their ancestors. This has no effect if a
range is specified. If the argument &quot;unsorted&quot; is
given, the commits are show in the order they were given on
the command line. Otherwise (if &quot;sorted&quot; or no
argument was given), the commits are show in reverse
chronological order by commit time.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;do&minus;walk</p>

<p style="margin-left:17%;">Overrides a previous
&minus;&minus;no&minus;walk.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Commit
Formatting</b> <br>
Using these options, <b>git-rev-list</b>(1) will act similar
to the more specialized family of commit log tools:
<b>git-log</b>(1), <b>git-show</b>(1), and
<b>git-whatchanged</b>(1)</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;pretty[=&lt;format&gt;],
&minus;&minus;format=&lt;format&gt;</p>

<p style="margin-left:17%;">Pretty&minus;print the contents
of the commit logs in a given format, where
<i>&lt;format&gt;</i> can be one of <i>oneline</i>,
<i>short</i>, <i>medium</i>, <i>full</i>, <i>fuller</i>,
<i>email</i>, <i>raw</i> and <i>format:&lt;string&gt;</i>.
See the &quot;PRETTY FORMATS&quot; section for some
additional details for each format. When omitted, the format
defaults to <i>medium</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Note: you can
specify the default pretty format in the repository
configuration (see <b>git-config</b>(1)).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;abbrev&minus;commit</p>

<p style="margin-left:17%;">Instead of showing the full
40&minus;byte hexadecimal commit object name, show only a
partial prefix. Non default number of digits can be
specified with &quot;&minus;&minus;abbrev=&lt;n&gt;&quot;
(which also modifies diff output, if it is displayed).</p>

<p style="margin-left:17%; margin-top: 1em">This should
make &quot;&minus;&minus;pretty=oneline&quot; a whole lot
more readable for people using 80&minus;column
terminals.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;abbrev&minus;commit</p>

<p style="margin-left:17%;">Show the full 40&minus;byte
hexadecimal commit object name. This negates
&minus;&minus;abbrev&minus;commit and those options which
imply it such as &quot;&minus;&minus;oneline&quot;. It also
overrides the <i>log.abbrevCommit</i> variable.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;oneline</p>

<p style="margin-left:17%;">This is a shorthand for
&quot;&minus;&minus;pretty=oneline
&minus;&minus;abbrev&minus;commit&quot; used together.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;encoding[=&lt;encoding&gt;]</p>

<p style="margin-left:17%;">The commit objects record the
encoding used for the log message in their encoding header;
this option can be used to tell the command to re&minus;code
the commit log message in the encoding preferred by the
user. For non plumbing commands this defaults to
UTF&minus;8.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;notes[=&lt;ref&gt;]</p>

<p style="margin-left:17%;">Show the notes (see
<b>git-notes</b>(1)) that annotate the commit, when showing
the commit log message. This is the default for git log, git
show and git whatchanged commands when there is no
&minus;&minus;pretty, &minus;&minus;format nor
&minus;&minus;oneline option given on the command line.</p>

<p style="margin-left:17%; margin-top: 1em">By default, the
notes shown are from the notes refs listed in the
<i>core.notesRef</i> and <i>notes.displayRef</i> variables
(or corresponding environment overrides). See
<b>git-config</b>(1) for more details.</p>

<p style="margin-left:17%; margin-top: 1em">With an
optional <i>&lt;ref&gt;</i> argument, show this notes ref
instead of the default notes ref(s). The ref is taken to be
in refs/notes/ if it is not qualified.</p>

<p style="margin-left:17%; margin-top: 1em">Multiple
&minus;&minus;notes options can be combined to control which
notes are being displayed. Examples:
&quot;&minus;&minus;notes=foo&quot; will show only notes
from &quot;refs/notes/foo&quot;;
&quot;&minus;&minus;notes=foo &minus;&minus;notes&quot; will
show both notes from &quot;refs/notes/foo&quot; and from the
default notes ref(s).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;notes</p>

<p style="margin-left:17%;">Do not show notes. This negates
the above &minus;&minus;notes option, by resetting the list
of notes refs from which notes are shown. Options are parsed
in the order given on the command line, so e.g.
&quot;&minus;&minus;notes &minus;&minus;notes=foo
&minus;&minus;no&minus;notes &minus;&minus;notes=bar&quot;
will only show notes from &quot;refs/notes/bar&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;show&minus;notes[=&lt;ref&gt;],
&minus;&minus;[no&minus;]standard&minus;notes</p>

<p style="margin-left:17%;">These options are deprecated.
Use the above
&minus;&minus;notes/&minus;&minus;no&minus;notes options
instead.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;show&minus;signature</p>

<p style="margin-left:17%;">Check the validity of a signed
commit object by passing the signature to gpg
&minus;&minus;verify and show the output.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;relative&minus;date</p>

<p style="margin-left:17%;">Synonym for
&minus;&minus;date=relative.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;date=(relative|local|default|iso|rfc|short|raw)</p>

<p style="margin-left:17%;">Only takes effect for dates
shown in human&minus;readable format, such as when using
&quot;&minus;&minus;pretty&quot;. log.date config variable
sets a default value for log command&rsquo;s
&minus;&minus;date option.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=relative
shows dates relative to the current time, e.g. &quot;2 hours
ago&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=local
shows timestamps in user&rsquo;s local timezone.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=iso
(or &minus;&minus;date=iso8601) shows timestamps in ISO 8601
format.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=rfc
(or &minus;&minus;date=rfc2822) shows timestamps in RFC 2822
format, often found in E&minus;mail messages.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=short
shows only date but not time, in YYYY&minus;MM&minus;DD
format.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=raw
shows the date in the internal raw Git format %s %z
format.</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;date=default
shows timestamps in the original timezone (either
committer&rsquo;s or author&rsquo;s).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;header</p>

<p style="margin-left:17%;">Print the contents of the
commit in raw&minus;format; each record is separated with a
NUL character.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;parents</p>

<p style="margin-left:17%;">Print also the parents of the
commit (in the form &quot;commit parent...&quot;). Also
enables parent rewriting, see <i>History Simplification</i>
below.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;children</p>

<p style="margin-left:17%;">Print also the children of the
commit (in the form &quot;commit child...&quot;). Also
enables parent rewriting, see <i>History Simplification</i>
below.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;timestamp</p>

<p style="margin-left:17%;">Print the raw commit
timestamp.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;left&minus;right</p>

<p style="margin-left:17%;">Mark which side of a symmetric
diff a commit is reachable from. Commits from the left side
are prefixed with &lt; and those from the right with &gt;.
If combined with &minus;&minus;boundary, those commits are
prefixed with &minus;.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
you have this topology:</p>


<p style="margin-left:23%; margin-top: 1em">y&minus;&minus;&minus;b&minus;&minus;&minus;b
branch B <br>
/ \ / <br>
/ . <br>
/ / \ <br>

o&minus;&minus;&minus;x&minus;&minus;&minus;a&minus;&minus;&minus;a
branch A</p>

<p style="margin-left:17%; margin-top: 1em">you would get
an output like this:</p>

<p style="margin-left:23%; margin-top: 1em">$ git
rev&minus;list &minus;&minus;left&minus;right
&minus;&minus;boundary &minus;&minus;pretty=oneline
A...B</p>

<p style="margin-left:23%; margin-top: 1em">&gt;bbbbbbb...
3rd on b <br>
&gt;bbbbbbb... 2nd on b <br>
&lt;aaaaaaa... 3rd on a <br>
&lt;aaaaaaa... 2nd on a <br>
&minus;yyyyyyy... 1st on b <br>
&minus;xxxxxxx... 1st on a</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;graph</p>

<p style="margin-left:17%;">Draw a text&minus;based
graphical representation of the commit history on the left
hand side of the output. This may cause extra lines to be
printed in between commits, in order for the graph history
to be drawn properly.</p>

<p style="margin-left:17%; margin-top: 1em">This enables
parent rewriting, see <i>History Simplification</i>
below.</p>

<p style="margin-left:17%; margin-top: 1em">This implies
the <i>&minus;&minus;topo&minus;order</i> option by default,
but the <i>&minus;&minus;date&minus;order</i> option may
also be specified.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;count</p>

<p style="margin-left:17%;">Print a number stating how many
commits would have been listed, and suppress all other
output. When used together with
<i>&minus;&minus;left&minus;right</i>, instead print the
counts for left and right commits, separated by a tab. When
used together with <i>&minus;&minus;cherry&minus;mark</i>,
omit patch equivalent commits from these counts and print
the count for equivalent commits separated by a tab.</p>

<h2>PRETTY FORMATS
<a name="PRETTY FORMATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the commit
is a merge, and if the pretty&minus;format is not
<i>oneline</i>, <i>email</i> or <i>raw</i>, an additional
line is inserted before the <i>Author:</i> line. This line
begins with &quot;Merge: &quot; and the sha1s of ancestral
commits are printed, separated by spaces. Note that the
listed commits may not necessarily be the list of the
<b>direct</b> parent commits if you have limited your view
of history: for example, if you are only interested in
changes related to a certain directory or file.</p>

<p style="margin-left:11%; margin-top: 1em">There are
several built&minus;in formats, and you can define
additional formats by setting a pretty.&lt;name&gt; config
option to either another format name, or a <i>format:</i>
string, as described below (see <b>git-config</b>(1)). Here
are the details of the built&minus;in formats:</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>oneline</i></p>

<p style="margin-left:23%; margin-top: 1em">&lt;sha1&gt;
&lt;title line&gt;</p>

<p style="margin-left:17%; margin-top: 1em">This is
designed to be as compact as possible.</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>short</i></p>

<p style="margin-left:23%; margin-top: 1em">commit
&lt;sha1&gt; <br>
Author: &lt;author&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;title
line&gt;</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>medium</i></p>

<p style="margin-left:23%; margin-top: 1em">commit
&lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
Date: &lt;author date&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;title
line&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;full commit
message&gt;</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>full</i></p>

<p style="margin-left:23%; margin-top: 1em">commit
&lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
Commit: &lt;committer&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;title
line&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;full commit
message&gt;</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>fuller</i></p>

<p style="margin-left:23%; margin-top: 1em">commit
&lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
AuthorDate: &lt;author date&gt; <br>
Commit: &lt;committer&gt; <br>
CommitDate: &lt;committer date&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;title
line&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;full commit
message&gt;</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>email</i></p>

<p style="margin-left:23%; margin-top: 1em">From
&lt;sha1&gt; &lt;date&gt; <br>
From: &lt;author&gt; <br>
Date: &lt;author date&gt; <br>
Subject: [PATCH] &lt;title line&gt;</p>

<p style="margin-left:23%; margin-top: 1em">&lt;full commit
message&gt;</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>raw</i></p>

<p style="margin-left:17%; margin-top: 1em">The <i>raw</i>
format shows the entire commit exactly as stored in the
commit object. Notably, the SHA&minus;1s are displayed in
full, regardless of whether &minus;&minus;abbrev or
&minus;&minus;no&minus;abbrev are used, and <i>parents</i>
information show the true parent commits, without taking
grafts nor history simplification into account.</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>format:&lt;string&gt;</i></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>format:&lt;string&gt;</i> format allows you to specify
which information you want to show. It works a little bit
like printf format, with the notable exception that you get
a newline with <i>%n</i> instead of <i>\n</i>.</p>

<p style="margin-left:17%; margin-top: 1em">E.g,
<i>format:&quot;The author of %h was %an, %ar%nThe title was
&gt;&gt;%s&lt;&lt;%n&quot;</i> would show something like
this:</p>

<p style="margin-left:23%; margin-top: 1em">The author of
fe6e0ee was Junio C Hamano, 23 hours ago <br>
The title was &gt;&gt;t4119: test autocomputing
&minus;p&lt;n&gt; for traditional diff input.&lt;&lt;</p>

<p style="margin-left:17%; margin-top: 1em">The
placeholders are:</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%H</i>: commit hash</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%h</i>: abbreviated commit hash</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%T</i>: tree hash</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%t</i>: abbreviated tree hash</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%P</i>: parent hashes</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%p</i>: abbreviated parent hashes</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%an</i>: author name</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%aN</i>: author name (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ae</i>: author email</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%aE</i>: author email (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ad</i>: author date (format respects &minus;&minus;date=
option)</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%aD</i>: author date, RFC2822 style</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ar</i>: author date, relative</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%at</i>: author date, UNIX timestamp</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ai</i>: author date, ISO 8601 format</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cn</i>: committer name</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cN</i>: committer name (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ce</i>: committer email</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cE</i>: committer email (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cd</i>: committer date</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cD</i>: committer date, RFC2822 style</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%cr</i>: committer date, relative</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ct</i>: committer date, UNIX timestamp</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ci</i>: committer date, ISO 8601 format</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%d</i>: ref names, like the &minus;&minus;decorate option
of <b>git-log</b>(1)</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%e</i>: encoding</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%s</i>: subject</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%f</i>: sanitized subject line, suitable for a
filename</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%b</i>: body</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%B</i>: raw body (unwrapped subject and body)</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%N</i>: commit notes</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%GG</i>: raw verification message from GPG for a signed
commit</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%G?</i>: show &quot;G&quot; for a Good signature,
&quot;B&quot; for a Bad signature, &quot;U&quot; for a good,
untrusted signature and &quot;N&quot; for no signature</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%GS</i>: show the name of the signer for a signed
commit</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%GK</i>: show the key used to sign a signed commit</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gD</i>: reflog selector, e.g., refs/stash@{1}</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gd</i>: shortened reflog selector, e.g., stash@{1}</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gn</i>: reflog identity name</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gN</i>: reflog identity name (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%ge</i>: reflog identity email</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gE</i>: reflog identity email (respecting .mailmap, see
<b>git-shortlog</b>(1) or <b>git-blame</b>(1))</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%gs</i>: reflog subject</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%Cred</i>: switch color to red</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%Cgreen</i>: switch color to green</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%Cblue</i>: switch color to blue</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%Creset</i>: reset color</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%C(...)</i>: color specification, as described in
color.branch.* config option; adding auto, at the beginning
will emit color only when colors are enabled for log output
(by color.diff, color.ui, or &minus;&minus;color, and
respecting the auto settings of the former if we are going
to a terminal). auto alone (i.e. %C(auto)) will turn on auto
coloring on the next placeholders until the color is
switched again.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%m</i>: left, right or boundary mark</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%n</i>: newline</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%%</i>: a raw <i>%</i></p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%x00</i>: print a byte from a hex code</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]])</i>: switch
line wrapping, like the &minus;w option of
<b>git-shortlog</b>(1).</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%&lt;(&lt;N&gt;[,trunc|ltrunc|mtrunc])</i>: make the next
placeholder take at least N columns, padding spaces on the
right if necessary. Optionally truncate at the beginning
(ltrunc), the middle (mtrunc) or the end (trunc) if the
output is longer than N columns. Note that truncating only
works correctly with N &gt;= 2.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%&lt;|(&lt;N&gt;)</i>: make the next placeholder take at
least until Nth columns, padding spaces on the right if
necessary</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%&gt;(&lt;N&gt;)</i>, <i>%&gt;|(&lt;N&gt;)</i>: similar
to <i>%&lt;(&lt;N&gt;)</i>, <i>%&lt;|(&lt;N&gt;)</i>
respectively, but padding spaces on the left</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%&gt;&gt;(&lt;N&gt;)</i>, <i>%&gt;&gt;|(&lt;N&gt;)</i>:
similar to <i>%&gt;(&lt;N&gt;)</i>, <i>%&gt;|(&lt;N&gt;)</i>
respectively, except that if the next placeholder takes more
spaces than given and there are spaces on its left, use
those spaces</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<i>%&gt;&lt;(&lt;N&gt;)</i>, <i>%&gt;&lt;|(&lt;N&gt;)</i>:
similar to <i>% &lt;(&lt;N&gt;)</i>,
<i>%&lt;|(&lt;N&gt;)</i> respectively, but padding both
sides (i.e. the text is centered)</p>


<p style="margin-left:17%; margin-top: 1em"><b><big>Note</big></b>
<br>
Some placeholders may depend on other options given to the
revision traversal engine. For example, the %g* reflog
options will insert an empty string unless we are traversing
reflog entries (e.g., by git log &minus;g). The %d
placeholder will use the &quot;short&quot; decoration format
if &minus;&minus;decorate was not already provided on the
command line.</p>

<p style="margin-left:11%; margin-top: 1em">If you add a +
(plus sign) after <i>%</i> of a placeholder, a
line&minus;feed is inserted immediately before the expansion
if and only if the placeholder expands to a non&minus;empty
string.</p>

<p style="margin-left:11%; margin-top: 1em">If you add a
&minus; (minus sign) after <i>%</i> of a placeholder,
line&minus;feeds that immediately precede the expansion are
deleted if and only if the placeholder expands to an empty
string.</p>

<p style="margin-left:11%; margin-top: 1em">If you add a
&lsquo; &lsquo; (space) after <i>%</i> of a placeholder, a
space is inserted immediately before the expansion if and
only if the placeholder expands to a non&minus;empty
string.</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>tformat:</i></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>tformat:</i> format works exactly like <i>format:</i>,
except that it provides &quot;terminator&quot; semantics
instead of &quot;separator&quot; semantics. In other words,
each commit has the message terminator character (usually a
newline) appended, rather than a separator placed between
entries. This means that the final entry of a
single&minus;line format will be properly terminated with a
new line, just as the &quot;oneline&quot; format does. For
example:</p>

<p style="margin-left:23%; margin-top: 1em">$ git log
&minus;2 &minus;&minus;pretty=format:%h 4da45bef \ <br>
| perl &minus;pe '$_ .= &quot; &minus;&minus; NO
NEWLINE\n&quot; unless /\n/' <br>
4da45be <br>
7134973 &minus;&minus; NO NEWLINE</p>

<p style="margin-left:23%; margin-top: 1em">$ git log
&minus;2 &minus;&minus;pretty=tformat:%h 4da45bef \ <br>
| perl &minus;pe '$_ .= &quot; &minus;&minus; NO
NEWLINE\n&quot; unless /\n/' <br>
4da45be <br>
7134973</p>

<p style="margin-left:17%; margin-top: 1em">In addition,
any unrecognized string that has a % in it is interpreted as
if it has tformat: in front of it. For example, these two
are equivalent:</p>

<p style="margin-left:23%; margin-top: 1em">$ git log
&minus;2 &minus;&minus;pretty=tformat:%h 4da45bef <br>
$ git log &minus;2 &minus;&minus;pretty=%h 4da45bef</p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>Part of
the <b>git</b>(1) suite</big></p>
<hr>
</body>
</html>
