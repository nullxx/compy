<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_CreateSlave</title>

</head>
<body>

<h1 align="center">Tcl_CreateSlave</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl_IsSafe,
Tcl_MakeSafe, Tcl_CreateSlave, Tcl_GetSlave, Tcl_GetMaster,
Tcl_GetInterpPath, Tcl_CreateAlias, Tcl_CreateAliasObj,
Tcl_GetAlias, Tcl_GetAliasObj, Tcl_ExposeCommand,
Tcl_HideCommand &minus; manage multiple Tcl interpreters,
aliases and hidden commands</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_IsSafe</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_MakeSafe</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Interp *
<b><br>
Tcl_CreateSlave</b>(<i>interp, slaveName, isSafe</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Interp *
<b><br>
Tcl_GetSlave</b>(<i>interp, slaveName</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Interp *
<b><br>
Tcl_GetMaster</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetInterpPath</b>(<i>askingInterp, slaveInterp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_CreateAlias</b>(<i>slaveInterp, slaveCmd, targetInterp,
targetCmd, <br>
argc, argv</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_CreateAliasObj</b>(<i>slaveInterp, slaveCmd,
targetInterp, targetCmd, <br>
objc, objv</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetAlias</b>(<i>interp, slaveCmd, targetInterpPtr,
targetCmdPtr, <br>
argcPtr, argvPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetAliasObj</b>(<i>interp, slaveCmd, targetInterpPtr,
targetCmdPtr, <br>
objcPtr, objvPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_ExposeCommand</b>(<i>interp, hiddenCmdName,
cmdName</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_HideCommand</b>(<i>interp, cmdName,
hiddenCmdName</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p style="margin-top: 1em">Tcl_Interp <i>*interp</i>
(in)</p> </td>
<td width="26%"></td>
<td width="12%">


<p style="margin-top: 1em">Interpreter in which to execute
the specified command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>*slaveName</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Name of slave interpreter to create or manipulate.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>int <i>isSafe</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>If non-zero, a &ldquo;safe&rdquo; slave that is suitable
for running untrusted code is created, otherwise a trusted
slave is created.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>Tcl_Interp <i>*slaveInterp</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Interpreter to use for creating the source command for
an alias (see below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>*slaveCmd</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Name of source command for alias.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>Tcl_Interp <i>*targetInterp</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Interpreter that contains the target command for an
alias.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>*targetCmd</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Name of target command for alias in
<i>targetInterp</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>int <i>argc</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Count of additional arguments to pass to the alias
command.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char *const <i>*argv</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Vector of strings, the additional arguments to pass to
the alias command. This storage is owned by the caller.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>int <i>objc</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Count of additional object arguments to pass to the
alias object command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>Tcl_Obj <i>**objv</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Vector of Tcl_Obj structures, the additional object
arguments to pass to the alias object command. This storage
is owned by the caller.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>Tcl_Interp <i>**targetInterpPtr</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store the address of the
interpreter where a target command is defined for an
alias.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>**targetCmdPtr</i> (out)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store the address of the name of
the target command for an alias.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>int <i>*argcPtr</i> (out)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store count of additional
arguments to be passed to the alias. The location is in
storage owned by the caller.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>***argvPtr</i> (out)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store a vector of strings, the
additional arguments to pass to an alias. The location is in
storage owned by the caller, the vector of strings is owned
by the called function.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>int <i>*objcPtr</i> (out)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store count of additional object
arguments to be passed to the alias. The location is in
storage owned by the caller.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>Tcl_Obj <i>***objvPtr</i> (out)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Pointer to location to store a vector of Tcl_Obj
structures, the additional arguments to pass to an object
alias command. The location is in storage owned by the
caller, the vector of Tcl_Obj structures is owned by the
called function.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>*cmdName</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Name of an exposed command to hide or create.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">


<p>const char <i>*hiddenCmdName</i> (in)</p></td>
<td width="26%"></td>
<td width="12%">


<p>Name under which a hidden command is stored and with
which it can be exposed or invoked.</p></td></tr>
</table>


<p style="margin-left:88%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These
procedures are intended for access to the multiple
interpreter facility from inside C programs. They enable
managing multiple interpreters in a hierarchical
relationship, and the management of aliases, commands that
when invoked in one interpreter execute a command in another
interpreter. The return value for those procedures that
return an <b>int</b> is either <b>TCL_OK</b> or
<b>TCL_ERROR</b>. If <b>TCL_ERROR</b> is returned then the
<b>result</b> field of the interpreter contains an error
message.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateSlave</b>
creates a new interpreter as a slave of <i>interp</i>. It
also creates a slave command named <i>slaveName</i> in
<i>interp</i> which allows <i>interp</i> to manipulate the
new slave. If <i>isSafe</i> is zero, the command creates a
trusted slave in which Tcl code has access to all the Tcl
commands. If it is <b>1</b>, the command creates a
&ldquo;safe&rdquo; slave in which Tcl code has access only
to set of Tcl commands defined as &ldquo;Safe Tcl&rdquo;;
see the manual entry for the Tcl <b>interp</b> command for
details. If the creation of the new slave interpreter
failed, <b>NULL</b> is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_IsSafe</b>
returns <b>1</b> if <i>interp</i> is &ldquo;safe&rdquo; (was
created with the <b>TCL_SAFE_INTERPRETER</b> flag
specified), <b>0</b> otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_MakeSafe</b>
marks <i>interp</i> as &ldquo;safe&rdquo;, so that future
calls to <b>Tcl_IsSafe</b> will return 1. It also removes
all known potentially-unsafe core functionality (both
commands and variables) from <i>interp</i>. However, it
cannot know what parts of an extension or application are
safe and does not make any attempt to remove those parts, so
safety is not guaranteed after calling <b>Tcl_MakeSafe</b>.
Callers will want to take care with their use of
<b>Tcl_MakeSafe</b> to avoid false claims of safety. For
many situations, <b>Tcl_CreateSlave</b> may be a better
choice, since it creates interpreters in a known-safe
state.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetSlave</b>
returns a pointer to a slave interpreter of <i>interp</i>.
The slave interpreter is identified by <i>slaveName</i>. If
no such slave interpreter exists, <b>NULL</b> is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetMaster</b>
returns a pointer to the master interpreter of
<i>interp</i>. If <i>interp</i> has no master (it is a
top-level interpreter) then <b>NULL</b> is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetInterpPath</b>
sets the <i>result</i> field in <i>askingInterp</i> to the
relative path between <i>askingInterp</i> and
<i>slaveInterp</i>; <i>slaveInterp</i> must be a slave of
<i>askingInterp</i>. If the computation of the relative path
succeeds, <b>TCL_OK</b> is returned, else <b>TCL_ERROR</b>
is returned and the <i>result</i> field in
<i>askingInterp</i> contains the error message.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateAlias</b>
creates an object command named <i>slaveCmd</i> in
<i>slaveInterp</i> that when invoked, will cause the command
<i>targetCmd</i> to be invoked in <i>targetInterp</i>. The
arguments specified by the strings contained in <i>argv</i>
are always prepended to any arguments supplied in the
invocation of <i>slaveCmd</i> and passed to
<i>targetCmd</i>. This operation returns <b>TCL_OK</b> if it
succeeds, or <b>TCL_ERROR</b> if it fails; in that case, an
error message is left in the object result of
<i>slaveInterp</i>. Note that there are no restrictions on
the ancestry relationship (as created by
<b>Tcl_CreateSlave</b>) between <i>slaveInterp</i> and
<i>targetInterp</i>. Any two interpreters can be used,
without any restrictions on how they are related.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateAliasObj</b>
is similar to <b>Tcl_CreateAlias</b> except that it takes a
vector of objects to pass as additional arguments instead of
a vector of strings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetAlias</b>
returns information about an alias <i>aliasName</i> in
<i>interp</i>. Any of the result fields can be <b>NULL</b>,
in which case the corresponding datum is not returned. If a
result field is non&minus;<b>NULL</b>, the address indicated
is set to the corresponding datum. For example, if
<i>targetNamePtr</i> is non&minus;<b>NULL</b> it is set to a
pointer to the string containing the name of the target
command.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetAliasObj</b>
is similar to <b>Tcl_GetAlias</b> except that it returns a
pointer to a vector of Tcl_Obj structures instead of a
vector of strings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ExposeCommand</b>
moves the command named <i>hiddenCmdName</i> from the set of
hidden commands to the set of exposed commands, putting it
under the name <i>cmdName</i>. <i>HiddenCmdName</i> must be
the name of an existing hidden command, or the operation
will return <b>TCL_ERROR</b> and leave an error message in
the <i>result</i> field in <i>interp</i>. If an exposed
command named <i>cmdName</i> already exists, the operation
returns <b>TCL_ERROR</b> and leaves an error message in the
object result of <i>interp</i>. If the operation succeeds,
it returns <b>TCL_OK</b>. After executing this command,
attempts to use <i>cmdName</i> in a call to <b>Tcl_Eval</b>
or with the Tcl <b>eval</b> command will again succeed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_HideCommand</b>
moves the command named <i>cmdName</i> from the set of
exposed commands to the set of hidden commands, under the
name <i>hiddenCmdName</i>. <i>CmdName</i> must be the name
of an existing exposed command, or the operation will return
<b>TCL_ERROR</b> and leave an error message in the object
result of <i>interp</i>. Currently both <i>cmdName</i> and
<i>hiddenCmdName</i> must not contain namespace qualifiers,
or the operation will return <b>TCL_ERROR</b> and leave an
error message in the object result of <i>interp</i>. The
<i>CmdName</i> will be looked up in the global namespace,
and not relative to the current namespace, even if the
current namespace is not the global one. If a hidden command
whose name is <i>hiddenCmdName</i> already exists, the
operation also returns <b>TCL_ERROR</b> and the
<i>result</i> field in <i>interp</i> contains an error
message. If the operation succeeds, it returns
<b>TCL_OK</b>. After executing this command, attempts to use
<i>cmdName</i> in a call to <b>Tcl_Eval</b> or with the Tcl
<b>eval</b> command will fail.</p>

<p style="margin-left:11%; margin-top: 1em">For a
description of the Tcl interface to multiple interpreters,
see <i>interp(n)</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">interp</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">alias, command,
exposed commands, hidden commands, interpreter, invoke,
master, slave</p>
<hr>
</body>
</html>
