<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:45 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Unicode::Collate</title>

</head>
<body>

<h1 align="center">Unicode::Collate</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXPORT">EXPORT</a><br>
<a href="#INSTALL">INSTALL</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#AUTHOR, COPYRIGHT AND LICENSE">AUTHOR, COPYRIGHT AND LICENSE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Unicode::Collate
&minus; Unicode Collation Algorithm</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use Unicode::Collate;
  #construct
  $Collator = Unicode::Collate&minus;&gt;new(%tailoring);
  #sort
  @sorted = $Collator&minus;&gt;sort(@not_sorted);
  #compare
  $result = $Collator&minus;&gt;cmp($a, $b); # returns 1, 0, or &minus;1.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
Strings in <tt>@not_sorted</tt>, <tt>$a</tt> and <tt>$b</tt>
are interpreted according to Perl&rsquo;s Unicode support.
See perlunicode, perluniintro, perlunitut, perlunifaq, utf8.
Otherwise you can use <tt>&quot;preprocess&quot;</tt> or
should decode them before.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module is
an implementation of Unicode Technical Standard #10 (a.k.a.
<small>UTS</small> #10) &minus; Unicode Collation Algorithm
(a.k.a. <small>UCA</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constructor
and Tailoring</b> <br>
The <tt>&quot;new&quot;</tt> method returns a collator
object. If <i>new()</i> is called with no parameters, the
collator should do the default collation.</p>

<pre style="margin-left:11%; margin-top: 1em">   $Collator = Unicode::Collate&minus;&gt;new(
      UCA_Version =&gt; $UCA_Version,
      alternate =&gt; $alternate, # alias for 'variable'
      backwards =&gt; $levelNumber, # or \@levelNumbers
      entry =&gt; $element,
      hangul_terminator =&gt; $term_primary_weight,
      ignoreName =&gt; qr/$ignoreName/,
      ignoreChar =&gt; qr/$ignoreChar/,
      ignore_level2 =&gt; $bool,
      katakana_before_hiragana =&gt; $bool,
      level =&gt; $collationLevel,
      normalization  =&gt; $normalization_form,
      overrideCJK =&gt; \&amp;overrideCJK,
      overrideHangul =&gt; \&amp;overrideHangul,
      preprocess =&gt; \&amp;preprocess,
      rearrange =&gt; \@charList,
      rewrite =&gt; \&amp;rewrite,
      suppress =&gt; \@charList,
      table =&gt; $filename,
      undefName =&gt; qr/$undefName/,
      undefChar =&gt; qr/$undefChar/,
      upper_before_lower =&gt; $bool,
      variable =&gt; $variable,
   );</pre>


<p style="margin-left:11%;">UCA_Version</p>

<p style="margin-left:17%;">If the revision (previously
&quot;tracking version&quot;) number of <small>UCA</small>
is given, behavior of that revision is emulated on
collating. If omitted, the return value of
<tt>&quot;UCA_Version()&quot;</tt> is used.</p>

<p style="margin-left:17%; margin-top: 1em">The following
revisions are supported. The default is 24.</p>

<pre style="margin-left:17%; margin-top: 1em">     UCA       Unicode Standard         DUCET (@version)
   &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)
     16              5.0                5.0.0 (5.0.0)
     18             5.1.0               5.1.0 (5.1.0)
     20             5.2.0               5.2.0 (5.2.0)
     22             6.0.0               6.0.0 (6.0.0)
     24             6.1.0               6.1.0 (6.1.0)</pre>


<p style="margin-left:17%; margin-top: 1em">* Noncharacters
(e.g. U+FFFF) are not ignored, and can be overridden since
<tt>&quot;UCA_Version&quot;</tt> 22.</p>

<p style="margin-left:17%; margin-top: 1em">* Fully
ignorable characters were ignored, and would not interrupt
contractions with <tt>&quot;UCA_Version&quot;</tt> 9 and
11.</p>

<p style="margin-left:17%; margin-top: 1em">* Treatment of
ignorables after variables and some behaviors were changed
at <tt>&quot;UCA_Version&quot;</tt> 9.</p>

<p style="margin-left:17%; margin-top: 1em">* Characters
regarded as <small>CJK</small> unified ideographs (cf.
<tt>&quot;overrideCJK&quot;</tt>) depend on
<tt>&quot;UCA_Version&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">* Many hangul
jamo are assigned at <tt>&quot;UCA_Version&quot;</tt> 20,
that will affect <tt>&quot;hangul_terminator&quot;</tt>.</p>

<p style="margin-left:11%;">alternate</p>

<p style="margin-left:17%;">&minus;&minus; see 3.2.2
Alternate Weighting, version 8 of <small>UTS</small> #10</p>

<p style="margin-left:17%; margin-top: 1em">For backward
compatibility, <tt>&quot;alternate&quot;</tt> (old name) can
be used as an alias for <tt>&quot;variable&quot;</tt>.</p>

<p style="margin-left:11%;">backwards</p>

<p style="margin-left:17%;">&minus;&minus; see 3.1.2 French
Accents, <small>UTS</small> #10.</p>

<pre style="margin-left:17%; margin-top: 1em">     backwards =&gt; $levelNumber or \@levelNumbers</pre>


<p style="margin-left:17%; margin-top: 1em">Weights in
reverse order; ex. level 2 (diacritic ordering) in French.
If omitted (or <tt>$levelNumber</tt> is
<tt>&quot;undef&quot;</tt> or
<tt>&quot;\@levelNumbers&quot;</tt> is
<tt>&quot;[]&quot;</tt>), forwards at all the levels.</p>

<p style="margin-left:11%;">entry</p>

<p style="margin-left:17%;">&minus;&minus; see 3.1
Linguistic Features; 3.2.1 File Format, <small>UTS</small>
#10.</p>

<p style="margin-left:17%; margin-top: 1em">If the same
character (or a sequence of characters) exists in the
collation element table through <tt>&quot;table&quot;</tt>,
mapping to collation elements is overridden. If it does not
exist, the mapping is defined additionally.</p>

<pre style="margin-left:17%; margin-top: 1em">    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys&minus;4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
00F1      ; [.0F7B.0020.0002.00F1] # n&minus;tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n&minus;tilde
00D1      ; [.0F7B.0020.0008.00D1] # N&minus;tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N&minus;tilde
ENTRY
    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys&minus;4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as &lt;a&gt;&lt;e&gt;
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as &lt;A&gt;&lt;E&gt;
ENTRY</pre>



<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
The code point in the <small>UCA</small> file format (before
<tt>';'</tt>) <b>must</b> be a Unicode code point (defined
as hexadecimal), but not a native code point. So
<tt>0063</tt> must always denote
<tt>&quot;U+0063&quot;</tt>, but not a character of
<tt>&quot;\x63&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Weighting may
vary depending on collation element table. So ensure the
weights defined in <tt>&quot;entry&quot;</tt> will be
consistent with those in the collation element table loaded
via <tt>&quot;table&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">In
<small>DUCET</small> v4.0.0, primary weight of
<tt>&quot;C&quot;</tt> is <tt>0E60</tt> and that of
<tt>&quot;D&quot;</tt> is <tt>&quot;0E6D&quot;</tt>. So
setting primary weight of <tt>&quot;CH&quot;</tt> to
<tt>&quot;0E6A&quot;</tt> (as a value between <tt>0E60</tt>
and <tt>&quot;0E6D&quot;</tt>) makes ordering as <tt>&quot;C
&lt; CH &lt; D&quot;</tt>. Exactly speaking
<small>DUCET</small> already has some characters between
<tt>&quot;C&quot;</tt> and <tt>&quot;D&quot;</tt>:
<tt>&quot;small capital C&quot;</tt>
(<tt>&quot;U+1D04&quot;</tt>) with primary weight
<tt>0E64</tt>,
<tt>&quot;c&minus;hook/C&minus;hook&quot;</tt>
(<tt>&quot;U+0188/U+0187&quot;</tt>) with <tt>0E65</tt>, and
<tt>&quot;c&minus;curl&quot;</tt>
(<tt>&quot;U+0255&quot;</tt>) with <tt>0E69</tt>. Then
primary weight <tt>&quot;0E6A&quot;</tt> for
<tt>&quot;CH&quot;</tt> makes <tt>&quot;CH&quot;</tt>
ordered between <tt>&quot;c&minus;curl&quot;</tt> and
<tt>&quot;D&quot;</tt>.</p>

<p style="margin-left:11%;">hangul_terminator</p>

<p style="margin-left:17%;">&minus;&minus; see 7.1.4
Trailing Weights, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">If a true value
is given (non-zero but should be positive), it will be added
as a terminator primary weight to the end of every standard
Hangul syllable. Secondary and any higher weights for
terminator are set to zero. If the value is false or
<tt>&quot;hangul_terminator&quot;</tt> key does not exist,
insertion of terminator weights will not be performed.</p>

<p style="margin-left:17%; margin-top: 1em">Boundaries of
Hangul syllables are determined according to conjoining Jamo
behavior in <i>the Unicode Standard</i> and
<i>HangulSyllableType.txt</i>.</p>


<p style="margin-left:17%; margin-top: 1em"><b>Implementation
Note:</b> (1) For expansion mapping (Unicode character
mapped to a sequence of collation elements), a terminator
will not be added between collation elements, even if Hangul
syllable boundary exists there. Addition of terminator is
restricted to the next position to the last collation
element.</p>

<p style="margin-left:17%; margin-top: 1em">(2)
Non-conjoining Hangul letters (Compatibility Jamo, halfwidth
Jamo, and enclosed letters) are not automatically terminated
with a terminator primary weight. These characters may need
terminator included in a collation element table
beforehand.</p>

<p style="margin-left:11%;">ignoreChar <br>
ignoreName</p>

<p style="margin-left:17%;">&minus;&minus; see 3.2.2
Variable Weighting, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">Makes the entry
in the table completely ignorable; i.e. as if the weights
were zero at all level.</p>

<p style="margin-left:17%; margin-top: 1em">Through
<tt>&quot;ignoreChar&quot;</tt>, any character matching
<tt>&quot;qr/$ignoreChar/&quot;</tt> will be ignored.
Through <tt>&quot;ignoreName&quot;</tt>, any character whose
name (given in the <tt>&quot;table&quot;</tt> file as a
comment) matches <tt>&quot;qr/$ignoreName/&quot;</tt> will
be ignored.</p>

<p style="margin-left:17%; margin-top: 1em">E.g. when
&rsquo;a&rsquo; and &rsquo;e&rsquo; are ignorable,
&rsquo;element&rsquo; is equal to &rsquo;lament&rsquo; (or
&rsquo;lmnt&rsquo;).</p>

<p style="margin-left:11%;">ignore_level2</p>

<p style="margin-left:17%;">&minus;&minus; see 5.1
Parametric Tailoring, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
case-sensitive comparison (that is level 3 difference)
won&rsquo;t ignore accents (that is level 2 difference).</p>

<p style="margin-left:17%; margin-top: 1em">If the
parameter is made true, accents (and other primary ignorable
characters) are ignored, even though cases are taken into
account.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: <tt>&quot;level&quot;</tt> should be 3 or greater.</p>

<p style="margin-left:11%;">katakana_before_hiragana</p>

<p style="margin-left:17%;">&minus;&minus; see 7.3.1
Tertiary Weight Table, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
hiragana is before katakana. If the parameter is made true,
this is reversed.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: This parameter simplemindedly assumes that any
hiragana/katakana distinctions must occur in level 3, and
their weights at level 3 must be same as those mentioned in
7.3.1, <small>UTS</small> #10. If you define your collation
elements which violate this requirement, this parameter does
not work validly.</p>

<p style="margin-left:11%;">level</p>

<p style="margin-left:17%;">&minus;&minus; see 4.3 Form
Sort Key, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">Set the maximum
level. Any higher levels than the specified one are
ignored.</p>

<pre style="margin-left:17%; margin-top: 1em">  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie&minus;breaking (e.g. in the case when variable is 'shifted')
  ex.level =&gt; 2,</pre>


<p style="margin-left:17%; margin-top: 1em">If omitted, the
maximum is the 4th.</p>

<p style="margin-left:11%;">normalization</p>

<p style="margin-left:17%;">&minus;&minus; see 4.1
Normalize, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">If specified,
strings are normalized before preparation of sort keys (the
normalization is executed after preprocess).</p>

<p style="margin-left:17%; margin-top: 1em">A form name
<tt>&quot;Unicode::Normalize::normalize()&quot;</tt> accepts
will be applied as <tt>$normalization_form</tt>. Acceptable
names include <tt>'NFD'</tt>, <tt>'NFC'</tt>,
<tt>'NFKD'</tt>, and <tt>'NFKC'</tt>. See
<tt>&quot;Unicode::Normalize::normalize()&quot;</tt> for
detail. If omitted, <tt>'NFD'</tt> is used.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;normalization&quot;</tt>
is performed after <tt>&quot;preprocess&quot;</tt> (if
defined).</p>

<p style="margin-left:17%; margin-top: 1em">Furthermore,
special values, <tt>&quot;undef&quot;</tt> and
<tt>&quot;prenormalized&quot;</tt>, can be used, though they
are not concerned with
<tt>&quot;Unicode::Normalize::normalize()&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;undef&quot;</tt> (not a string
<tt>&quot;undef&quot;</tt>) is passed explicitly as the
value for this key, any normalization is not carried out
(this may make tailoring easier if any normalization is not
desired). Under <tt>&quot;(normalization =&gt;
undef)&quot;</tt>, only contiguous contractions are
resolved; e.g. even if <tt>&quot;A&minus;ring&quot;</tt>
(and <tt>&quot;A&minus;ring&minus;cedilla&quot;</tt>) is
ordered after <tt>&quot;Z&quot;</tt>,
<tt>&quot;A&minus;cedilla&minus;ring&quot;</tt> would be
primary equal to <tt>&quot;A&quot;</tt>. In this point,
<tt>&quot;(normalization =&gt; undef, preprocess =&gt; sub {
NFD(shift) })&quot;</tt> <b>is not</b> equivalent to
<tt>&quot;(normalization =&gt; 'NFD')&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">In the case of
<tt>&quot;(normalization =&gt;
&quot;prenormalized&quot;)&quot;</tt>, any normalization is
not performed, but discontiguous contractions with combining
characters are performed. Therefore <tt>&quot;(normalization
=&gt; 'prenormalized', preprocess =&gt; sub { NFD(shift)
})&quot;</tt> <b>is</b> equivalent to
<tt>&quot;(normalization =&gt; 'NFD')&quot;</tt>. If source
strings are finely prenormalized, <tt>&quot;(normalization
=&gt; 'prenormalized')&quot;</tt> may save time for
normalization.</p>

<p style="margin-left:17%; margin-top: 1em">Except
<tt>&quot;(normalization =&gt; undef)&quot;</tt>,
<b>Unicode::Normalize</b> is required (see also
<b><small>CAVEAT</small></b> ).</p>

<p style="margin-left:11%;">overrideCJK</p>

<p style="margin-left:17%;">&minus;&minus; see 7.1 Derived
Collation Elements, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
<small>CJK</small> unified ideographs are ordered in Unicode
codepoint order, but those in the <small>CJK</small> Unified
Ideographs block are lesser than those in the
<small>CJK</small> Unified Ideographs Extension A etc.</p>

<pre style="margin-left:17%; margin-top: 1em">    In the CJK Unified Ideographs block:
    U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
    U+4E00..U+9FBB if UCA_Version is 14 or 16.
    U+4E00..U+9FC3 if UCA_Version is 18.
    U+4E00..U+9FCB if UCA_Version is 20 or 22.
    U+4E00..U+9FCC if UCA_Version is 24.
    In the CJK Unified Ideographs Extension blocks:
    Ext.A (U+3400..U+4DB5) and Ext.B (U+20000..U+2A6D6) in any UCA_Version.
    Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or greater.
    Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or greater.</pre>


<p style="margin-left:17%; margin-top: 1em">Through
<tt>&quot;overrideCJK&quot;</tt>, ordering of
<small>CJK</small> unified ideographs (including extensions)
can be overridden.</p>

<p style="margin-left:17%; margin-top: 1em">ex.
<small>CJK</small> unified ideographs in the
<small>JIS</small> code point order.</p>

<pre style="margin-left:17%; margin-top: 1em">  overrideCJK =&gt; sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF&minus;16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },</pre>


<p style="margin-left:17%; margin-top: 1em">The return
value may be an arrayref of 1st to 4th weights as shown
above. The return value may be an integer as the primary
weight as shown below. If <tt>&quot;undef&quot;</tt> is
returned, the default derived collation element will be
used.</p>

<pre style="margin-left:17%; margin-top: 1em">  overrideCJK =&gt; sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF&minus;16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      return $n;                 # return the primary weight
  },</pre>


<p style="margin-left:17%; margin-top: 1em">The return
value may be a list containing zero or more of an arrayref,
an integer, or <tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">ex. ignores all
<small>CJK</small> unified ideographs.</p>

<pre style="margin-left:17%; margin-top: 1em">  overrideCJK =&gt; sub {()}, # CODEREF returning empty list
   # where &minus;&gt;eq(&quot;Pe\x{4E00}rl&quot;, &quot;Perl&quot;) is true
   # as U+4E00 is a CJK unified ideograph and to be ignorable.</pre>


<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;undef&quot;</tt> is passed explicitly as the value
for this key, weights for <small>CJK</small> unified
ideographs are treated as undefined. But assignment of
weight for <small>CJK</small> unified ideographs in
<tt>&quot;table&quot;</tt> or <tt>&quot;entry&quot;</tt> is
still valid.</p>

<p style="margin-left:17%; margin-top: 1em"><b>Note:</b> In
addition to them, 12 <small>CJK</small> compatibility
ideographs (<tt>&quot;U+FA0E&quot;</tt>,
<tt>&quot;U+FA0F&quot;</tt>, <tt>&quot;U+FA11&quot;</tt>,
<tt>&quot;U+FA13&quot;</tt>, <tt>&quot;U+FA14&quot;</tt>,
<tt>&quot;U+FA1F&quot;</tt>, <tt>&quot;U+FA21&quot;</tt>,
<tt>&quot;U+FA23&quot;</tt>, <tt>&quot;U+FA24&quot;</tt>,
<tt>&quot;U+FA27&quot;</tt>, <tt>&quot;U+FA28&quot;</tt>,
<tt>&quot;U+FA29&quot;</tt>) are also treated as
<small>CJK</small> unified ideographs. But they can&rsquo;t
be overridden via <tt>&quot;overrideCJK&quot;</tt> when you
use <small>DUCET</small> , as the table includes weights for
them. <tt>&quot;table&quot;</tt> or
<tt>&quot;entry&quot;</tt> has priority over
<tt>&quot;overrideCJK&quot;</tt>.</p>

<p style="margin-left:11%;">overrideHangul</p>

<p style="margin-left:17%;">&minus;&minus; see 7.1 Derived
Collation Elements, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
Hangul syllables are decomposed into Hangul Jamo, even if
<tt>&quot;(normalization =&gt; undef)&quot;</tt>. But the
mapping of Hangul syllables may be overridden.</p>

<p style="margin-left:17%; margin-top: 1em">This parameter
works like <tt>&quot;overrideCJK&quot;</tt>, so see there
for examples.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
override the mapping of Hangul syllables, <small>NFD</small>
and <small>NFKD</small> are not appropriate, since
<small>NFD</small> and <small>NFKD</small> will decompose
Hangul syllables before overriding. <small>FCD</small> may
decompose Hangul syllables as the case may be.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;undef&quot;</tt> is passed explicitly as the value
for this key, weight for Hangul syllables is treated as
undefined without decomposition into Hangul Jamo. But
definition of weight for Hangul syllables in
<tt>&quot;table&quot;</tt> or <tt>&quot;entry&quot;</tt> is
still valid.</p>

<p style="margin-left:11%;">preprocess</p>

<p style="margin-left:17%;">&minus;&minus; see 5.1
Preprocessing, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">If specified,
the coderef is used to preprocess each string before the
formation of sort keys.</p>

<p style="margin-left:17%; margin-top: 1em">ex. dropping
English articles, such as &quot;a&quot; or &quot;the&quot;.
Then, &quot;the pen&quot; is before &quot;a
pencil&quot;.</p>

<pre style="margin-left:17%; margin-top: 1em">     preprocess =&gt; sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           return $str;
        },</pre>



<p style="margin-left:17%; margin-top: 1em">&quot;preprocess&quot;
is performed before <tt>&quot;normalization&quot;</tt> (if
defined).</p>

<p style="margin-left:17%; margin-top: 1em">ex. decoding
strings in a legacy encoding such as shift-jis:</p>

<pre style="margin-left:17%; margin-top: 1em">    $sjis_collator = Unicode::Collate&minus;&gt;new(
        preprocess =&gt; \&amp;your_shiftjis_to_unicode_decoder,
    );
    @result = $sjis_collator&minus;&gt;sort(@shiftjis_strings);</pre>


<p style="margin-left:17%; margin-top: 1em"><b>Note:</b>
Strings returned from the coderef will be interpreted
according to Perl&rsquo;s Unicode support. See perlunicode,
perluniintro, perlunitut, perlunifaq, utf8.</p>

<p style="margin-left:11%;">rearrange</p>

<p style="margin-left:17%;">&minus;&minus; see 3.1.3
Rearrangement, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">Characters that
are not coded in logical order and to be rearranged. If
<tt>&quot;UCA_Version&quot;</tt> is equal to or lesser than
11, default is:</p>

<pre style="margin-left:17%; margin-top: 1em">    rearrange =&gt; [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],</pre>


<p style="margin-left:17%; margin-top: 1em">If you want to
disallow any rearrangement, pass <tt>&quot;undef&quot;</tt>
or <tt>&quot;[]&quot;</tt> (a reference to empty list) as
the value for this key.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;UCA_Version&quot;</tt> is equal to or greater than
14, default is <tt>&quot;[]&quot;</tt> (i.e. no
rearrangement).</p>

<p style="margin-left:17%; margin-top: 1em"><b>According to
the version 9 of <small>UCA</small> , this parameter shall
not be used; but it is not warned at present.</b></p>

<p style="margin-left:11%;">rewrite</p>

<p style="margin-left:17%;">If specified, the coderef is
used to rewrite lines in <tt>&quot;table&quot;</tt> or
<tt>&quot;entry&quot;</tt>. The coderef will get each line,
and then should return a rewritten line according to the
<small>UCA</small> file format. If the coderef returns an
empty line, the line will be skipped.</p>

<p style="margin-left:17%; margin-top: 1em">e.g. any
primary ignorable characters into tertiary ignorable:</p>

<pre style="margin-left:17%; margin-top: 1em">    rewrite =&gt; sub {
        my $line = shift;
        $line =~ s/\[\.0000\..{4}\..{4}\./[.0000.0000.0000./g;
        return $line;
    },</pre>


<p style="margin-left:17%; margin-top: 1em">This example
shows rewriting weights. <tt>&quot;rewrite&quot;</tt> is
allowed to affect code points, weights, and the name.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: <tt>&quot;table&quot;</tt> is available to use another
table file; preparing a modified table once would be more
efficient than rewriting lines on reading an unmodified
table every time.</p>

<p style="margin-left:11%;">suppress</p>

<p style="margin-left:17%;">&minus;&minus; see suppress
contractions in 5.14.11 Special-Purpose Commands,
<small>UTS</small> #35 ( <small>LDML</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">Contractions
beginning with the specified characters are suppressed, even
if those contractions are defined in
<tt>&quot;table&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">An example for
Russian and some languages using the Cyrillic script:</p>

<pre style="margin-left:17%; margin-top: 1em">    suppress =&gt; [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],</pre>


<p style="margin-left:17%; margin-top: 1em">where 0x0400
stands for <tt>&quot;U+0400&quot;</tt>, <small>CYRILLIC
CAPITAL LETTER IE WITH GRAVE</small> .</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: Contractions via <tt>&quot;entry&quot;</tt> are not be
suppressed.</p>

<p style="margin-left:11%;">table</p>

<p style="margin-left:17%;">&minus;&minus; see 3.2 Default
Unicode Collation Element Table, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">You can use
another collation element table if desired.</p>

<p style="margin-left:17%; margin-top: 1em">The table file
should locate in the <i>Unicode/Collate</i> directory on
<tt>@INC</tt>. Say, if the filename is <i>Foo.txt</i>, the
table file is searched as <i>Unicode/Collate/Foo.txt</i> in
<tt>@INC</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
<i>allkeys.txt</i> (as the filename of <small>DUCET</small>
) is used. If you will prepare your own table file, any name
other than <i>allkeys.txt</i> may be better to avoid
namespace conflict.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: When <small>XSUB</small> is used, the <small>DUCET</small>
is compiled on building this module, and it may save time at
the run time. Explicit saying <tt>&quot;table =&gt;
'allkeys.txt'&quot;</tt> (or using another table), or using
<tt>&quot;ignoreChar&quot;</tt>,
<tt>&quot;ignoreName&quot;</tt>,
<tt>&quot;undefChar&quot;</tt>,
<tt>&quot;undefName&quot;</tt> or
<tt>&quot;rewrite&quot;</tt> will prevent this module from
using the compiled <small>DUCET</small> .</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;undef&quot;</tt> is passed explicitly as the value
for this key, no file is read (but you can define collation
elements via <tt>&quot;entry&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">A typical way
to define a collation element table without any file of
table:</p>

<pre style="margin-left:17%; margin-top: 1em">   $onlyABC = Unicode::Collate&minus;&gt;new(
       table =&gt; undef,
       entry =&gt; &lt;&lt; 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );</pre>


<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;ignoreName&quot;</tt> or
<tt>&quot;undefName&quot;</tt> is used, character names
should be specified as a comment (following
<tt>&quot;#&quot;</tt>) on each line.</p>

<p style="margin-left:11%;">undefChar <br>
undefName</p>

<p style="margin-left:17%;">&minus;&minus; see 6.3.4
Reducing the Repertoire, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">Undefines the
collation element as if it were unassigned in the
<tt>&quot;table&quot;</tt>. This reduces the size of the
table. If an unassigned character appears in the string to
be collated, the sort key is made from its codepoint as a
single-character collation element, as it is greater than
any other assigned collation elements (in the codepoint
order among the unassigned characters). But, it&rsquo;d be
better to ignore characters unfamiliar to you and maybe
never used.</p>

<p style="margin-left:17%; margin-top: 1em">Through
<tt>&quot;undefChar&quot;</tt>, any character matching
<tt>&quot;qr/$undefChar/&quot;</tt> will be undefined.
Through <tt>&quot;undefName&quot;</tt>, any character whose
name (given in the <tt>&quot;table&quot;</tt> file as a
comment) matches <tt>&quot;qr/$undefName/&quot;</tt> will be
undefined.</p>

<p style="margin-left:17%; margin-top: 1em">ex. Collation
weights for beyond-BMP characters are not stored in
object:</p>

<pre style="margin-left:17%; margin-top: 1em">    undefChar =&gt; qr/[^\0&minus;\x{fffd}]/,</pre>


<p style="margin-left:11%;">upper_before_lower</p>

<p style="margin-left:17%;">&minus;&minus; see 6.6 Case
Comparisons, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
lowercase is before uppercase. If the parameter is made
true, this is reversed.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
: This parameter simplemindedly assumes that any
lowercase/uppercase distinctions must occur in level 3, and
their weights at level 3 must be same as those mentioned in
7.3.1, <small>UTS</small> #10. If you define your collation
elements which differs from this requirement, this parameter
doesn&rsquo;t work validly.</p>

<p style="margin-left:11%;">variable</p>

<p style="margin-left:17%;">&minus;&minus; see 3.2.2
Variable Weighting, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">This key allows
for variable weighting of variable collation elements, which
are marked with an <small>ASTERISK</small> in the table (
<small>NOTE:</small> Many punctuation marks and symbols are
variable in <i>allkeys.txt</i>).</p>

<pre style="margin-left:17%; margin-top: 1em">   variable =&gt; 'blanked', 'non&minus;ignorable', 'shifted', or 'shift&minus;trimmed'.</pre>


<p style="margin-left:17%; margin-top: 1em">These names are
case-insensitive. By default (if specification is omitted),
&rsquo;shifted&rsquo; is adopted.</p>

<pre style="margin-left:17%; margin-top: 1em">   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.
   'Non&minus;Ignorable'  Variable elements are not reset to ignorable.
   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non&minus;Variable elements is 0xFFFF.
   'Shift&minus;Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Methods for
Collation</b> <br>
&quot;@sorted =
$Collator&minus;&gt;sort(@not_sorted)&quot;</p>

<p style="margin-left:17%;">Sorts a list of strings.</p>

<p style="margin-left:11%;">&quot;$result =
$Collator&minus;&gt;cmp($a, $b)&quot;</p>

<p style="margin-left:17%;">Returns 1 (when <tt>$a</tt> is
greater than <tt>$b</tt>) or 0 (when <tt>$a</tt> is equal to
<tt>$b</tt>) or &minus;1 (when <tt>$a</tt> is lesser than
<tt>$b</tt>).</p>

<p style="margin-left:11%;">&quot;$result =
$Collator&minus;&gt;eq($a, $b)&quot; <br>
&quot;$result = $Collator&minus;&gt;ne($a, $b)&quot; <br>
&quot;$result = $Collator&minus;&gt;lt($a, $b)&quot; <br>
&quot;$result = $Collator&minus;&gt;le($a, $b)&quot; <br>
&quot;$result = $Collator&minus;&gt;gt($a, $b)&quot; <br>
&quot;$result = $Collator&minus;&gt;ge($a, $b)&quot;</p>

<p style="margin-left:17%;">They works like the same name
operators as theirs.</p>

<pre style="margin-left:17%; margin-top: 1em">   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is lesser than $b.
   le : whether $a is lesser than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.</pre>


<p style="margin-left:11%;">&quot;$sortKey =
$Collator&minus;&gt;getSortKey($string)&quot;</p>

<p style="margin-left:17%;">&minus;&minus; see 4.3 Form
Sort Key, <small>UTS</small> #10.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a sort
key.</p>

<p style="margin-left:17%; margin-top: 1em">You compare the
sort keys using a binary comparison and get the result of
the comparison of the strings using <small>UCA</small> .</p>

<pre style="margin-left:17%; margin-top: 1em">   $Collator&minus;&gt;getSortKey($a) cmp $Collator&minus;&gt;getSortKey($b)
      is equivalent to
   $Collator&minus;&gt;cmp($a, $b)</pre>


<p style="margin-left:11%;">&quot;$sortKeyForm =
$Collator&minus;&gt;viewSortKey($string)&quot;</p>

<p style="margin-left:17%;">Converts a sorting key into its
representation form. If <tt>&quot;UCA_Version&quot;</tt> is
8, the output is slightly different.</p>

<pre style="margin-left:17%; margin-top: 1em">   use Unicode::Collate;
   my $c = Unicode::Collate&minus;&gt;new();
   print $c&minus;&gt;viewSortKey(&quot;Perl&quot;),&quot;\n&quot;;
   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Methods for
Searching</b> <br>
The <tt>&quot;match&quot;</tt>, <tt>&quot;gmatch&quot;</tt>,
<tt>&quot;subst&quot;</tt>, <tt>&quot;gsubst&quot;</tt>
methods work like <tt>&quot;m//&quot;</tt>,
<tt>&quot;m//g&quot;</tt>, <tt>&quot;s///&quot;</tt>,
<tt>&quot;s///g&quot;</tt>, respectively, but they are not
aware of any pattern, but only a literal substring.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DISCLAIMER:</small></b>
If <tt>&quot;preprocess&quot;</tt> or
<tt>&quot;normalization&quot;</tt> parameter is true for
<tt>$Collator</tt>, calling these methods
(<tt>&quot;index&quot;</tt>, <tt>&quot;match&quot;</tt>,
<tt>&quot;gmatch&quot;</tt>, <tt>&quot;subst&quot;</tt>,
<tt>&quot;gsubst&quot;</tt>) is croaked, as the position and
the length might differ from those on the specified
string.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;rearrange&quot;</tt>
and <tt>&quot;hangul_terminator&quot;</tt> parameters are
neglected. <tt>&quot;katakana_before_hiragana&quot;</tt> and
<tt>&quot;upper_before_lower&quot;</tt> don&rsquo;t affect
matching and searching, as it doesn&rsquo;t matter whether
greater or lesser. <br>
&quot;$position = $Collator&minus;&gt;index($string,
$substring[, $position])&quot; <br>
&quot;($position, $length) =
$Collator&minus;&gt;index($string, $substring[, <br>
$position])&quot;</p>

<p style="margin-left:17%;">If <tt>$substring</tt> matches
a part of <tt>$string</tt>, returns the position of the
first occurrence of the matching part in scalar context; in
list context, returns a two-element list of the position and
the length of the matching part.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$substring</tt> does not match any part of
<tt>$string</tt>, returns <tt>&quot;&minus;1&quot;</tt> in
scalar context and an empty list in list context.</p>

<p style="margin-left:17%; margin-top: 1em">e.g. you
say</p>

<pre style="margin-left:17%; margin-top: 1em">  my $Collator = Unicode::Collate&minus;&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $str = &quot;Ich muss studieren Perl.&quot;;
  my $sub = &quot;MUeSS&quot;;
  my $match;
  if (my($pos,$len) = $Collator&minus;&gt;index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }</pre>


<p style="margin-left:17%; margin-top: 1em">and get
<tt>&quot;muss&quot;</tt> in <tt>$match</tt> since
<tt>&quot;muss&quot;</tt> is primary equal to
<tt>&quot;MUeSS&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;$match_ref =
$Collator&minus;&gt;match($string, $substring)&quot; <br>
&quot;($match) = $Collator&minus;&gt;match($string,
$substring)&quot;</p>

<p style="margin-left:17%;">If <tt>$substring</tt> matches
a part of <tt>$string</tt>, in scalar context, returns <b>a
reference to</b> the first occurrence of the matching part
(<tt>$match_ref</tt> is always true if matches, since every
reference is <b>true</b>); in list context, returns the
first occurrence of the matching part.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$substring</tt> does not match any part of
<tt>$string</tt>, returns <tt>&quot;undef&quot;</tt> in
scalar context and an empty list in list context.</p>

<p style="margin-left:17%; margin-top: 1em">e.g.</p>

<pre style="margin-left:17%; margin-top: 1em">    if ($match_ref = $Collator&minus;&gt;match($str, $sub)) { # scalar context
        print &quot;matches [$$match_ref].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }
     or
    if (($match) = $Collator&minus;&gt;match($str, $sub)) { # list context
        print &quot;matches [$match].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }</pre>


<p style="margin-left:11%;">&quot;@match =
$Collator&minus;&gt;gmatch($string, $substring)&quot;</p>

<p style="margin-left:17%;">If <tt>$substring</tt> matches
a part of <tt>$string</tt>, returns all the matching parts
(or matching count in scalar context).</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$substring</tt> does not match any part of
<tt>$string</tt>, returns an empty list.</p>

<p style="margin-left:11%;">&quot;$count =
$Collator&minus;&gt;subst($string, $substring,
$replacement)&quot;</p>

<p style="margin-left:17%;">If <tt>$substring</tt> matches
a part of <tt>$string</tt>, the first occurrence of the
matching part is replaced by <tt>$replacement</tt>
(<tt>$string</tt> is modified) and <tt>$count</tt> (always
equals to <tt>1</tt>) is returned.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$replacement</tt>
can be a <tt>&quot;CODEREF&quot;</tt>, taking the matching
part as an argument, and returning a string to replace the
matching part (a bit similar to
<tt>&quot;s/(..)/$coderef&minus;&gt;($1)/e&quot;</tt>).</p>

<p style="margin-left:11%;">&quot;$count =
$Collator&minus;&gt;gsubst($string, $substring,
$replacement)&quot;</p>

<p style="margin-left:17%;">If <tt>$substring</tt> matches
a part of <tt>$string</tt>, all the occurrences of the
matching part are replaced by <tt>$replacement</tt>
(<tt>$string</tt> is modified) and <tt>$count</tt> is
returned.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$replacement</tt>
can be a <tt>&quot;CODEREF&quot;</tt>, taking the matching
part as an argument, and returning a string to replace the
matching part (a bit similar to
<tt>&quot;s/(..)/$coderef&minus;&gt;($1)/eg&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">e.g.</p>

<pre style="margin-left:17%; margin-top: 1em">  my $Collator = Unicode::Collate&minus;&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $str = &quot;Camel donkey zebra came\x{301}l CAMEL horse cam\0e\0l...&quot;;
  $Collator&minus;&gt;gsubst($str, &quot;camel&quot;, sub { &quot;&lt;b&gt;$_[0]&lt;/b&gt;&quot; });
  # now $str is &quot;&lt;b&gt;Camel&lt;/b&gt; donkey zebra &lt;b&gt;came\x{301}l&lt;/b&gt; &lt;b&gt;CAMEL&lt;/b&gt; horse &lt;b&gt;cam\0e\0l&lt;/b&gt;...&quot;;
  # i.e., all the camels are made bold&minus;faced.
   Examples: levels and ignore_level2 &minus; what does camel match?
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
   level  ignore_level2  |  camel  Camel  came\x{301}l  c&minus;a&minus;m&minus;e&minus;l  cam\0e\0l
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;|&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
     1        false      |   yes    yes      yes          yes        yes
     2        false      |   yes    yes      no           yes        yes
     3        false      |   yes    no       no           yes        yes
     4        false      |   yes    no       no           no         yes
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;|&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
     1        true       |   yes    yes      yes          yes        yes
     2        true       |   yes    yes      yes          yes        yes
     3        true       |   yes    no       yes          yes        yes
     4        true       |   yes    no       yes          no         yes
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
   note: if variable =&gt; non&minus;ignorable, camel doesn't match c&minus;a&minus;m&minus;e&minus;l
         at any level.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Other
Methods</b> <br>
&quot;%old_tailoring =
$Collator&minus;&gt;change(%new_tailoring)&quot; <br>
&quot;$modified_collator =
$Collator&minus;&gt;change(%new_tailoring)&quot;</p>

<p style="margin-left:17%;">Changes the value of specified
keys and returns the changed part.</p>

<pre style="margin-left:17%; margin-top: 1em">    $Collator = Unicode::Collate&minus;&gt;new(level =&gt; 4);
    $Collator&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false
    %old = $Collator&minus;&gt;change(level =&gt; 2); # returns (level =&gt; 4).
    $Collator&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true
    $Collator&minus;&gt;change(%old); # returns (level =&gt; 2).
    $Collator&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false</pre>


<p style="margin-left:17%; margin-top: 1em">Not all
<tt>&quot;(key,value)&quot;</tt>s are allowed to be changed.
See also <tt>@Unicode::Collate::ChangeOK</tt> and
<tt>@Unicode::Collate::ChangeNG</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">In the scalar
context, returns the modified collator (but it is <b>not</b>
a clone from the original).</p>

<pre style="margin-left:17%; margin-top: 1em">    $Collator&minus;&gt;change(level =&gt; 2)&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true
    $Collator&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true; now max level is 2nd.
    $Collator&minus;&gt;change(level =&gt; 4)&minus;&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false</pre>


<p style="margin-left:11%;">&quot;$version =
$Collator&minus;&gt;version()&quot;</p>

<p style="margin-left:17%;">Returns the version number (a
string) of the Unicode Standard which the
<tt>&quot;table&quot;</tt> file used by the collator object
is based on. If the table does not include a version line
(starting with <tt>@version</tt>), returns
<tt>&quot;unknown&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;UCA_Version()&quot;</p>

<p style="margin-left:17%;">Returns the revision number of
<small>UTS</small> #10 this module consults, that should
correspond with the <small>DUCET</small> incorporated.</p>


<p style="margin-left:11%;">&quot;Base_Unicode_Version()&quot;</p>

<p style="margin-left:17%;">Returns the version number of
<small>UTS</small> #10 this module consults, that should
correspond with the <small>DUCET</small> incorporated.</p>

<h2>EXPORT
<a name="EXPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No method will
be exported.</p>

<h2>INSTALL
<a name="INSTALL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Though this
module can be used without any <tt>&quot;table&quot;</tt>
file, to use this module easily, it is recommended to
install a table file in the <small>UCA</small> format, by
copying it under the directory &lt;a place in
<tt>@INC</tt>&gt;/Unicode/Collate.</p>

<p style="margin-left:11%; margin-top: 1em">The most
preferable one is &quot;The Default Unicode Collation
Element Table&quot; (aka <small>DUCET</small> ), available
from the Unicode Consortium&rsquo;s website:</p>

<pre style="margin-left:11%; margin-top: 1em">   http://www.unicode.org/Public/UCA/
   http://www.unicode.org/Public/UCA/latest/allkeys.txt (latest version)</pre>


<p style="margin-left:11%; margin-top: 1em">If
<small>DUCET</small> is not installed, it is recommended to
copy the file from
http://www.unicode.org/Public/UCA/latest/allkeys.txt to
&lt;a place in <tt>@INC</tt>&gt;/Unicode/Collate/allkeys.txt
manually.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Normalization</p>

<p style="margin-left:17%;">Use of the
<tt>&quot;normalization&quot;</tt> parameter requires the
<b>Unicode::Normalize</b> module (see
Unicode::Normalize).</p>

<p style="margin-left:17%; margin-top: 1em">If you need not
it (say, in the case when you need not handle any combining
characters), assign <tt>&quot;normalization =&gt;
undef&quot;</tt> explicitly.</p>

<p style="margin-left:17%; margin-top: 1em">&minus;&minus;
see 6.5 Avoiding Normalization, <small>UTS</small> #10.</p>

<p style="margin-left:11%;">Conformance Test</p>

<p style="margin-left:17%;">The Conformance Test for the
<small>UCA</small> is available under
&lt;http://www.unicode.org/Public/UCA/&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">For
<i>CollationTest_SHIFTED.txt</i>, a collator via
<tt>&quot;Unicode::Collate&minus;&gt;new( )&quot;</tt>
should be used; for <i>CollationTest_NON_IGNORABLE.txt</i>,
a collator via
<tt>&quot;Unicode::Collate&minus;&gt;new(variable =&gt;
&quot;non&minus;ignorable&quot;, level =&gt;
3)&quot;</tt>.</p>


<p style="margin-left:17%; margin-top: 1em"><b>Unicode::Normalize
is required to try The Conformance Test.</b></p>

<h2>AUTHOR, COPYRIGHT AND LICENSE
<a name="AUTHOR, COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
Unicode::Collate module for perl was written by
<small>SADAHIRO</small> Tomoyuki, &lt;SADAHIRO@cpan.org&gt;.
This module is Copyright(C) 2001&minus;2012,
<small>SADAHIRO</small> Tomoyuki. Japan. All rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This module is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">The file
Unicode/Collate/allkeys.txt was copied verbatim from
&lt;http://www.unicode.org/Public/UCA/6.1.0/allkeys.txt&gt;.
For this file, Copyright (c) 2001&minus;2011 Unicode, Inc.
Distributed under the Terms of Use in
&lt;http://www.unicode.org/copyright.html&gt;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Unicode
Collation Algorithm &minus; <small>UTS</small> #10</p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/reports/tr10/&gt;</p>

<p style="margin-left:11%;">The Default Unicode Collation
Element Table ( <small>DUCET</small> )</p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&gt;</p>

<p style="margin-left:11%;">The conformance test for the
<small>UCA</small></p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/Public/UCA/latest/CollationTest.html&gt;</p>


<p style="margin-left:17%; margin-top: 1em">&lt;http://www.unicode.org/Public/UCA/latest/CollationTest.zip&gt;</p>

<p style="margin-left:11%;">Hangul Syllable Type</p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt&gt;</p>

<p style="margin-left:11%;">Unicode Normalization Forms
&minus; <small>UAX</small> #15</p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/reports/tr15/&gt;</p>

<p style="margin-left:11%;">Unicode Locale Data Markup
Language ( <small>LDML</small> ) &minus; <small>UTS</small>
#35</p>


<p style="margin-left:17%;">&lt;http://www.unicode.org/reports/tr35/&gt;</p>
<hr>
</body>
</html>
