<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:00:08 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SSH(1) BSD General Commands Manual SSH(1)</p>

<p style="margin-top: 1em"><b>NAME</b></p>

<p style="margin-left:6%;"><b>ssh</b> &mdash; OpenSSH SSH
client (remote login program)</p>

<p style="margin-top: 1em"><b>SYNOPSIS</b></p>

<p style="margin-left:12%;"><b>ssh</b>
[<b>&minus;1246AaCfgKkMNnqsTtVvXxYy</b>]
[<b>&minus;b&nbsp;</b><i>bind_address</i>]
[<b>&minus;c&nbsp;</b><i>cipher_spec</i>]
[<b>&minus;D&nbsp;</b>[</p>

<p><i>bind_address</i>: ]<i>port</i>]
[<b>&minus;E&nbsp;</b><i>log_file</i>]
[<b>&minus;e&nbsp;</b><i>escape_char</i>]
[<b>&minus;F&nbsp;</b><i>configfile</i>]
[<b>&minus;I&nbsp;</b><i>pkcs11</i>]
[<b>&minus;i&nbsp;</b><i>identity_file</i>]
[<b>&minus;L&nbsp;</b>[ <i><br>
bind_address</i>: ]<i>port</i>:<i>host</i>:<i>hostport</i>]
[<b>&minus;l&nbsp;</b><i>login_name</i>]
[<b>&minus;m&nbsp;</b><i>mac_spec</i>]
[<b>&minus;O&nbsp;</b><i>ctl_cmd</i>]
[<b>&minus;o&nbsp;</b><i>option</i>]
[<b>&minus;p&nbsp;</b><i>port</i>]
[<b>&minus;Q&nbsp;cipher&nbsp;</b>|&nbsp;<b>cipher-auth&nbsp;</b>|&nbsp;<b>mac&nbsp;</b>|&nbsp;<b>kex&nbsp;</b>|&nbsp;<b>key</b>]
[<b>&minus;R&nbsp;</b>[ <i><br>
bind_address</i>: ]<i>port</i>:<i>host</i>:<i>hostport</i>]
[<b>&minus;S&nbsp;</b><i>ctl_path</i>]
[<b>&minus;W&nbsp;</b><i>host</i>:<i>port</i>]
[<b>&minus;w&nbsp;</b><i>local_tun</i>[:<i>remote_tun</i>]]
[ <i><br>
user</i>@ ]<i>hostname</i> [<i>command</i>]</p>

<p style="margin-top: 1em"><b>DESCRIPTION</b></p>

<p style="margin-left:6%;"><b>ssh</b> (SSH client) is a
program for logging into a remote machine and for executing
commands on a remote machine. It is intended to replace
rlogin and rsh, and provide secure encrypted communications
between two untrusted hosts over an insecure network. X11
connections and arbitrary TCP ports can also be forwarded
over the secure channel.</p>

<p style="margin-left:6%; margin-top: 1em"><b>ssh</b>
connects and logs into the specified <i>hostname</i> (with
optional <i>user</i> name). The user must prove his/her
identity to the remote machine using one of several methods
depending on the protocol version used (see below).</p>

<p style="margin-left:6%; margin-top: 1em">If
<i>command</i> is specified, it is executed on the remote
host instead of a login shell.</p>

<p style="margin-left:6%; margin-top: 1em">The options are
as follows:</p>

<p style="margin-top: 1em"><b>&minus;1</b></p>

<p style="margin-left:17%; margin-top: 1em">Forces
<b>ssh</b> to try protocol version 1 only.</p>

<p style="margin-top: 1em"><b>&minus;2</b></p>

<p style="margin-left:17%; margin-top: 1em">Forces
<b>ssh</b> to try protocol version 2 only.</p>

<p style="margin-top: 1em"><b>&minus;4</b></p>

<p style="margin-left:17%; margin-top: 1em">Forces
<b>ssh</b> to use IPv4 addresses only.</p>

<p style="margin-top: 1em"><b>&minus;6</b></p>

<p style="margin-left:17%; margin-top: 1em">Forces
<b>ssh</b> to use IPv6 addresses only.</p>

<p style="margin-top: 1em"><b>&minus;A</b></p>

<p style="margin-left:17%; margin-top: 1em">Enables
forwarding of the authentication agent connection. This can
also be specified on a per-host basis in a configuration
file.</p>

<p style="margin-left:17%; margin-top: 1em">Agent
forwarding should be enabled with caution. Users with the
ability to bypass file permissions on the remote host (for
the agent&rsquo;s UNIX-domain socket) can access the local
agent through the forwarded connection. An attacker cannot
obtain key material from the agent, however they can perform
operations on the keys that enable them to authenticate
using the identities loaded into the agent.</p>

<p style="margin-top: 1em"><b>&minus;a</b></p>

<p style="margin-left:17%; margin-top: 1em">Disables
forwarding of the authentication agent connection.</p>

<p style="margin-top: 1em"><b>&minus;b</b>
<i>bind_address</i></p>

<p style="margin-left:17%;">Use <i>bind_address</i> on the
local machine as the source address of the connection. Only
useful on systems with more than one address.</p>

<p style="margin-top: 1em"><b>&minus;C</b></p>

<p style="margin-left:17%; margin-top: 1em">Requests
compression of all data (including stdin, stdout, stderr,
and data for forwarded X11 and TCP connections). The
compression algorithm is the same used by gzip(1), and the
&lsquo;&lsquo;level&rsquo;&rsquo; can be controlled by the
<b>CompressionLevel</b> option for protocol version 1.
Compression is desirable on modem lines and other slow
connections, but will only slow down things on fast
networks. The default value can be set on a host-by-host
basis in the configuration files; see the <b>Compression</b>
option.</p>

<p style="margin-top: 1em"><b>&minus;c</b>
<i>cipher_spec</i></p>

<p style="margin-left:17%;">Selects the cipher
specification for encrypting the session.</p>

<p style="margin-left:17%; margin-top: 1em">Protocol
version 1 allows specification of a single cipher. The
supported values are &lsquo;&lsquo;3des&rsquo;&rsquo;,
&lsquo;&lsquo;blowfish&rsquo;&rsquo;, and
&lsquo;&lsquo;des&rsquo;&rsquo;. <i>3des</i> (triple-des) is
an encrypt-decrypt-encrypt triple with three different keys.
It is believed to be secure. <i>blowfish</i> is a fast block
cipher; it appears very secure and is much faster than
<i>3des</i>. <i>des</i> is only supported in the <b>ssh</b>
client for interoperability with legacy protocol 1
implementations that do not support the <i>3des</i> cipher.
Its use is strongly discouraged due to cryptographic
weaknesses. The default is
&lsquo;&lsquo;3des&rsquo;&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">For protocol
version 2, <i>cipher_spec</i> is a comma-separated list of
ciphers listed in order of preference. See the
<b>Ciphers</b> keyword in ssh_config(5) for more
information.</p>

<p style="margin-top: 1em"><b>&minus;D</b> <br>
[ <i><br>
bind_address</i>:]<i>port</i></p>

<p style="margin-left:17%;">Specifies a local
&lsquo;&lsquo;dynamic&rsquo;&rsquo; application-level port
forwarding. This works by allocating a socket to listen to
<i>port</i> on the local side, optionally bound to the
specified <i>bind_address</i>. Whenever a connection is made
to this port, the connection is forwarded over the secure
channel, and the application protocol is then used to
determine where to connect to from the remote machine.
Currently the SOCKS4 and SOCKS5 protocols are supported, and
<b>ssh</b> will act as a SOCKS server. Only root can forward
privileged ports. Dynamic port forwardings can also be
specified in the configuration file.</p>

<p style="margin-left:17%; margin-top: 1em">IPv6 addresses
can be specified by enclosing the address in square
brackets. Only the superuser can forward privileged ports.
By default, the local port is bound in accordance with the
<b>GatewayPorts</b> setting. However, an explicit
<i>bind_address</i> may be used to bind the connection to a
specific address. The <i>bind_address</i> of
&lsquo;&lsquo;localhost&rsquo;&rsquo; indicates that the
listening port be bound for local use only, while an empty
address or &lsquo;*&rsquo; indicates that the port should be
available from all interfaces.</p>

<p style="margin-top: 1em"><b>&minus;E</b>
<i>log_file</i></p>

<p style="margin-left:17%;">Append debug logs to
<i>log_file</i> instead of standard error.</p>

<p style="margin-top: 1em"><b>&minus;e</b>
<i>escape_char</i></p>

<p style="margin-left:17%;">Sets the escape character for
sessions with a pty (default: &lsquo;~&rsquo;). The escape
character is only recognized at the beginning of a line. The
escape character followed by a dot (&lsquo;.&rsquo;) closes
the connection; followed by control-Z suspends the
connection; and followed by itself sends the escape
character once. Setting the character to
&lsquo;&lsquo;none&rsquo;&rsquo; disables any escapes and
makes the session fully transparent.</p>

<p style="margin-top: 1em"><b>&minus;F</b>
<i>configfile</i></p>

<p style="margin-left:17%;">Specifies an alternative
per-user configuration file. If a configuration file is
given on the command line, the system-wide configuration
file (<i>/etc/ssh/ssh_config</i>) will be ignored. The
default for the per-user configuration file is
<i>~/.ssh/config</i>.</p>

<p style="margin-top: 1em"><b>&minus;f</b></p>

<p style="margin-left:17%; margin-top: 1em">Requests
<b>ssh</b> to go to background just before command
execution. This is useful if <b>ssh</b> is going to ask for
passwords or passphrases, but the user wants it in the
background. This implies <b>&minus;n</b>. The recommended
way to start X11 programs at a remote site is with something
like <b>ssh -f host xterm</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If the
<b>ExitOnForwardFailure</b> configuration option is set to
&lsquo;&lsquo;yes&rsquo;&rsquo;, then a client started with
<b>&minus;f</b> will wait for all remote port forwards to be
successfully established before placing itself in the
background.</p>

<p style="margin-top: 1em"><b>&minus;g</b></p>

<p style="margin-left:17%; margin-top: 1em">Allows remote
hosts to connect to local forwarded ports.</p>

<p style="margin-top: 1em"><b>&minus;I</b>
<i>pkcs11</i></p>

<p style="margin-left:17%;">Specify the PKCS#11 shared
library <b>ssh</b> should use to communicate with a PKCS#11
token providing the user&rsquo;s private RSA key.</p>

<p style="margin-top: 1em"><b>&minus;i</b>
<i>identity_file</i></p>

<p style="margin-left:17%;">Selects a file from which the
identity (private key) for public key authentication is
read. The default is <i>~/.ssh/identity</i> for protocol
version 1, and <i>~/.ssh/id_dsa</i>, <i>~/.ssh/id_ecdsa</i>,
<i>~/.ssh/id_ed25519</i> and <i>~/.ssh/id_rsa</i> for
protocol version 2. Identity files may also be specified on
a per-host basis in the configuration file. It is possible
to have multiple <b>&minus;i</b> options (and multiple
identities specified in configuration files). <b>ssh</b>
will also try to load certificate information from the
filename obtained by appending <i>-cert.pub</i> to identity
filenames.</p>

<p style="margin-top: 1em"><b>&minus;K</b></p>

<p style="margin-left:17%; margin-top: 1em">Enables
GSSAPI-based authentication and forwarding (delegation) of
GSSAPI credentials to the server.</p>

<p style="margin-top: 1em"><b>&minus;k</b></p>

<p style="margin-left:17%; margin-top: 1em">Disables
forwarding (delegation) of GSSAPI credentials to the
server.</p>

<p style="margin-top: 1em"><b>&minus;L</b> <br>
[ <i><br>

bind_address</i>:]<i>port</i>:<i>host</i>:<i>hostport</i></p>

<p style="margin-left:17%;">Specifies that the given port
on the local (client) host is to be forwarded to the given
host and port on the remote side. This works by allocating a
socket to listen to <i>port</i> on the local side,
optionally bound to the specified <i>bind_address</i>.
Whenever a connection is made to this port, the connection
is forwarded over the secure channel, and a connection is
made to <i>host</i> port <i>hostport</i> from the remote
machine. Port forwardings can also be specified in the
configuration file. IPv6 addresses can be specified by
enclosing the address in square brackets. Only the superuser
can forward privileged ports. By default, the local port is
bound in accordance with the <b>GatewayPorts</b> setting.
However, an explicit <i>bind_address</i> may be used to bind
the connection to a specific address. The
<i>bind_address</i> of &lsquo;&lsquo;localhost&rsquo;&rsquo;
indicates that the listening port be bound for local use
only, while an empty address or &lsquo;*&rsquo; indicates
that the port should be available from all interfaces.</p>

<p style="margin-top: 1em"><b>&minus;l</b>
<i>login_name</i></p>

<p style="margin-left:17%;">Specifies the user to log in as
on the remote machine. This also may be specified on a
per-host basis in the configuration file.</p>

<p style="margin-top: 1em"><b>&minus;M</b></p>

<p style="margin-left:17%; margin-top: 1em">Places the
<b>ssh</b> client into &lsquo;&lsquo;master&rsquo;&rsquo;
mode for connection sharing. Multiple <b>&minus;M</b>
options places <b>ssh</b> into
&lsquo;&lsquo;master&rsquo;&rsquo; mode with confirmation
required before slave connections are accepted. Refer to the
description of <b>ControlMaster</b> in ssh_config(5) for
details.</p>

<p style="margin-top: 1em"><b>&minus;m</b>
<i>mac_spec</i></p>

<p style="margin-left:17%;">Additionally, for protocol
version 2 a comma-separated list of MAC (message
authentication code) algorithms can be specified in order of
preference. See the <b>MACs</b> keyword for more
information.</p>

<p style="margin-top: 1em"><b>&minus;N</b></p>

<p style="margin-left:17%; margin-top: 1em">Do not execute
a remote command. This is useful for just forwarding ports
(protocol version 2 only).</p>

<p style="margin-top: 1em"><b>&minus;n</b></p>

<p style="margin-left:17%; margin-top: 1em">Redirects stdin
from <i>/dev/null</i> (actually, prevents reading from
stdin). This must be used when <b>ssh</b> is run in the
background. A common trick is to use this to run X11
programs on a remote machine. For example, <b>ssh -n
shadows.cs.hut.fi emacs &amp;</b> will start an emacs on
shadows.cs.hut.fi, and the X11 connection will be
automatically forwarded over an encrypted channel. The
<b>ssh</b> program will be put in the background. (This does
not work if <b>ssh</b> needs to ask for a password or
passphrase; see also the <b>&minus;f</b> option.)</p>

<p style="margin-top: 1em"><b>&minus;O</b>
<i>ctl_cmd</i></p>

<p style="margin-left:17%;">Control an active connection
multiplexing master process. When the <b>&minus;O</b> option
is specified, the <i>ctl_cmd</i> argument is interpreted and
passed to the master process. Valid commands are:
&lsquo;&lsquo;check&rsquo;&rsquo; (check that the master
process is running), &lsquo;&lsquo;forward&rsquo;&rsquo;
(request forwardings without command execution),
&lsquo;&lsquo;cancel&rsquo;&rsquo; (cancel forwardings),
&lsquo;&lsquo;exit&rsquo;&rsquo; (request the master to
exit), and &lsquo;&lsquo;stop&rsquo;&rsquo; (request the
master to stop accepting further multiplexing requests).</p>

<p style="margin-top: 1em"><b>&minus;o</b>
<i>option</i></p>

<p style="margin-left:17%;">Can be used to give options in
the format used in the configuration file. This is useful
for specifying options for which there is no separate
command-line flag. For full details of the options listed
below, and their possible values, see ssh_config(5).</p>

<p style="margin-top: 1em">AddressFamily <br>
BatchMode <br>
BindAddress <br>
CanonicalDomains <br>
CanonicalizeFallbackLocal <br>
CanonicalizeHostname <br>
CanonicalizeMaxDots <br>
CanonicalizePermittedCNAMEs <br>
ChallengeResponseAuthentication <br>
CheckHostIP <br>
Cipher <br>
Ciphers <br>
ClearAllForwardings <br>
Compression <br>
CompressionLevel <br>
ConnectionAttempts <br>
ConnectTimeout <br>
ControlMaster <br>
ControlPath <br>
ControlPersist <br>
DynamicForward <br>
EscapeChar <br>
ExitOnForwardFailure <br>
ForwardAgent <br>
ForwardX11 <br>
ForwardX11Timeout <br>
ForwardX11Trusted <br>
GatewayPorts <br>
GlobalKnownHostsFile <br>
GSSAPIAuthentication <br>
GSSAPIKeyExchange <br>
GSSAPIClientIdentity <br>
GSSAPIDelegateCredentials <br>
GSSAPIRenewalForcesRekey <br>
GSSAPITrustDns <br>
GSSAPIKexAlgorithms <br>
HashKnownHosts <br>
Host <br>
HostbasedAuthentication <br>
HostKeyAlgorithms <br>
HostKeyAlias <br>
HostName <br>
IdentityFile <br>
IdentitiesOnly <br>
IPQoS <br>
KbdInteractiveAuthentication <br>
KbdInteractiveDevices <br>
KexAlgorithms <br>
LocalCommand <br>
LocalForward <br>
LogLevel <br>
MACs <br>
Match <br>
NoHostAuthenticationForLocalhost <br>
NumberOfPasswordPrompts <br>
PasswordAuthentication <br>
PermitLocalCommand <br>
PKCS11Provider <br>
Port <br>
PreferredAuthentications <br>
Protocol <br>
ProxyCommand <br>
ProxyUseFdpass <br>
PubkeyAuthentication <br>
RekeyLimit <br>
RemoteForward <br>
RequestTTY <br>
RhostsRSAAuthentication <br>
RSAAuthentication <br>
SendEnv <br>
ServerAliveInterval <br>
ServerAliveCountMax <br>
StrictHostKeyChecking <br>
TCPKeepAlive <br>
Tunnel <br>
TunnelDevice <br>
UsePrivilegedPort <br>
User <br>
UserKnownHostsFile <br>
VerifyHostKeyDNS <br>
VisualHostKey <br>
XAuthLocation</p>

<p style="margin-top: 1em"><b>&minus;p</b> <i>port</i></p>

<p style="margin-left:17%;">Port to connect to on the
remote host. This can be specified on a per-host basis in
the configuration file.</p>

<p style="margin-top: 1em"><b>&minus;Q cipher</b> |
<b>cipher-auth</b> | <b>mac</b> | <b>kex</b> |
<b>key</b></p>

<p style="margin-left:17%;">Queries <b>ssh</b> for the
algorithms supported for the specified version 2. The
available features are: <i>cipher</i> (supported symmetric
ciphers), <i>cipher-auth</i> (supported symmetric ciphers
that support authenticated encryption), <i>mac</i>
(supported message integrity codes), <i>kex</i> (key
exchange algorithms), <i>key</i> (key types).</p>

<p style="margin-top: 1em"><b>&minus;q</b></p>

<p style="margin-left:17%; margin-top: 1em">Quiet mode.
Causes most warning and diagnostic messages to be
suppressed.</p>

<p style="margin-top: 1em"><b>&minus;R</b> <br>
[ <i><br>

bind_address</i>:]<i>port</i>:<i>host</i>:<i>hostport</i></p>

<p style="margin-left:17%;">Specifies that the given port
on the remote (server) host is to be forwarded to the given
host and port on the local side. This works by allocating a
socket to listen to <i>port</i> on the remote side, and
whenever a connection is made to this port, the connection
is forwarded over the secure channel, and a connection is
made to <i>host</i> port <i>hostport</i> from the local
machine.</p>

<p style="margin-left:17%; margin-top: 1em">Port
forwardings can also be specified in the configuration file.
Privileged ports can be forwarded only when logging in as
root on the remote machine. IPv6 addresses can be specified
by enclosing the address in square brackets.</p>

<p style="margin-left:17%; margin-top: 1em">By default, the
listening socket on the server will be bound to the loopback
interface only. This may be overridden by specifying a
<i>bind_address</i>. An empty <i>bind_address</i>, or the
address &lsquo;*&rsquo;, indicates that the remote socket
should listen on all interfaces. Specifying a remote
<i>bind_address</i> will only succeed if the server&rsquo;s
<b>GatewayPorts</b> option is enabled (see
sshd_config(5)).</p>

<p style="margin-left:17%; margin-top: 1em">If the
<i>port</i> argument is &lsquo;0&rsquo;, the listen port
will be dynamically allocated on the server and reported to
the client at run time. When used together with <b>-O
forward</b> the allocated port will be printed to the
standard output.</p>

<p style="margin-top: 1em"><b>&minus;S</b>
<i>ctl_path</i></p>

<p style="margin-left:17%;">Specifies the location of a
control socket for connection sharing, or the string
&lsquo;&lsquo;none&rsquo;&rsquo; to disable connection
sharing. Refer to the description of <b>ControlPath</b> and
<b>ControlMaster</b> in ssh_config(5) for details.</p>

<p style="margin-top: 1em"><b>&minus;s</b></p>

<p style="margin-left:17%; margin-top: 1em">May be used to
request invocation of a subsystem on the remote system.
Subsystems are a feature of the SSH2 protocol which
facilitate the use of SSH as a secure transport for other
applications (eg. sftp(1)). The subsystem is specified as
the remote command.</p>

<p style="margin-top: 1em"><b>&minus;T</b></p>

<p style="margin-left:17%; margin-top: 1em">Disable
pseudo-tty allocation.</p>

<p style="margin-top: 1em"><b>&minus;t</b></p>

<p style="margin-left:17%; margin-top: 1em">Force
pseudo-tty allocation. This can be used to execute arbitrary
screen-based programs on a remote machine, which can be very
useful, e.g. when implementing menu services. Multiple
<b>&minus;t</b> options force tty allocation, even if
<b>ssh</b> has no local tty.</p>

<p style="margin-top: 1em"><b>&minus;V</b></p>

<p style="margin-left:17%; margin-top: 1em">Display the
version number and exit.</p>

<p style="margin-top: 1em"><b>&minus;v</b></p>

<p style="margin-left:17%; margin-top: 1em">Verbose mode.
Causes <b>ssh</b> to print debugging messages about its
progress. This is helpful in debugging connection,
authentication, and configuration problems. Multiple
<b>&minus;v</b> options increase the verbosity. The maximum
is 3.</p>

<p style="margin-top: 1em"><b>&minus;W</b>
<i>host</i>:<i>port</i></p>

<p style="margin-left:17%;">Requests that standard input
and output on the client be forwarded to <i>host</i> on
<i>port</i> over the secure channel. Implies
<b>&minus;N</b>, <b>&minus;T</b>,
<b>ExitOnForwardFailure</b> and <b>ClearAllForwardings</b>.
Works with Protocol version 2 only.</p>

<p style="margin-top: 1em"><b>&minus;w</b> <i><br>
local_tun</i>[:<i>remote_tun</i>]</p>

<p style="margin-left:17%;">Requests tunnel device
forwarding with the specified tun(4) devices between the
client (<i>local_tun</i>) and the server
(<i>remote_tun</i>).</p>

<p style="margin-left:17%; margin-top: 1em">The devices may
be specified by numerical ID or the keyword
&lsquo;&lsquo;any&rsquo;&rsquo;, which uses the next
available tunnel device. If <i>remote_tun</i> is not
specified, it defaults to &lsquo;&lsquo;any&rsquo;&rsquo;.
See also the <b>Tunnel</b> and <b>TunnelDevice</b>
directives in ssh_config(5). If the <b>Tunnel</b> directive
is unset, it is set to the default tunnel mode, which is
&lsquo;&lsquo;point-to-point&rsquo;&rsquo;.</p>

<p style="margin-top: 1em"><b>&minus;X</b></p>

<p style="margin-left:17%; margin-top: 1em">Enables X11
forwarding. This can also be specified on a per-host basis
in a configuration file.</p>

<p style="margin-left:17%; margin-top: 1em">X11 forwarding
should be enabled with caution. Users with the ability to
bypass file permissions on the remote host (for the
user&rsquo;s X authorization database) can access the local
X11 display through the forwarded connection. An attacker
may then be able to perform activities such as keystroke
monitoring.</p>

<p style="margin-left:17%; margin-top: 1em">For this
reason, X11 forwarding is subjected to X11 SECURITY
extension restrictions by default. Please refer to the
<b>ssh &minus;Y</b> option and the <b>ForwardX11Trusted</b>
directive in ssh_config(5) for more information.</p>

<p style="margin-top: 1em"><b>&minus;x</b></p>

<p style="margin-left:17%; margin-top: 1em">Disables X11
forwarding.</p>

<p style="margin-top: 1em"><b>&minus;Y</b></p>

<p style="margin-left:17%; margin-top: 1em">Enables trusted
X11 forwarding. Trusted X11 forwardings are not subjected to
the X11 SECURITY extension controls.</p>

<p style="margin-top: 1em"><b>&minus;y</b></p>

<p style="margin-left:17%; margin-top: 1em">Send log
information using the syslog(3) system module. By default
this information is sent to stderr.</p>

<p style="margin-left:6%; margin-top: 1em"><b>ssh</b> may
additionally obtain configuration data from a per-user
configuration file and a system-wide configuration file. The
file format and configuration options are described in
ssh_config(5).</p>

<p style="margin-top: 1em"><b>AUTHENTICATION</b></p>

<p style="margin-left:6%;">The OpenSSH SSH client supports
SSH protocols 1 and 2. The default is to use protocol 2
only, though this can be changed via the <b>Protocol</b>
option in ssh_config(5) or the <b>&minus;1</b> and
<b>&minus;2</b> options (see above). Both protocols support
similar authentication methods, but protocol 2 is the
default since it provides additional mechanisms for
confidentiality (the traffic is encrypted using AES, 3DES,
Blowfish, CAST128, or Arcfour) and integrity (hmac-md5,
hmac-sha1, hmac-sha2-256, hmac-sha2-512, umac-64, umac-128,
hmac-ripemd160). Protocol 1 lacks a strong mechanism for
ensuring the integrity of the connection.</p>

<p style="margin-left:6%; margin-top: 1em">The methods
available for authentication are: GSSAPI-based
authentication, host-based authentication, public key
authentication, challenge-response authentication, and
password authentication. Authentication methods are tried in
the order specified above, though protocol 2 has a
configuration option to change the default order:
<b>PreferredAuthentications</b>.</p>

<p style="margin-left:6%; margin-top: 1em">Host-based
authentication works as follows: If the machine the user
logs in from is listed in <i>/etc/hosts.equiv</i> or
<i>/etc/ssh/shosts.equiv</i> on the remote machine, and the
user names are the same on both sides, or if the files
<i>~/.rhosts</i> or <i>~/.shosts</i> exist in the
user&rsquo;s home directory on the remote machine and
contain a line containing the name of the client machine and
the name of the user on that machine, the user is considered
for login. Additionally, the server <i>must</i> be able to
verify the client&rsquo;s host key (see the description of
<i>/etc/ssh/ssh_known_hosts</i> and
<i>~/.ssh/known_hosts</i>, below) for login to be permitted.
This authentication method closes security holes due to IP
spoofing, DNS spoofing, and routing spoofing. [Note to the
administrator: <i>/etc/hosts.equiv</i>, <i>~/.rhosts</i>,
and the rlogin/rsh protocol in general, are inherently
insecure and should be disabled if security is desired.]</p>

<p style="margin-left:6%; margin-top: 1em">Public key
authentication works as follows: The scheme is based on
public-key cryptography, using cryptosystems where
encryption and decryption are done using separate keys, and
it is unfeasible to derive the decryption key from the
encryption key. The idea is that each user creates a
public/private key pair for authentication purposes. The
server knows the public key, and only the user knows the
private key. <b>ssh</b> implements public key authentication
protocol automatically, using one of the DSA, ECDSA, ED25519
or RSA algorithms. Protocol 1 is restricted to using only
RSA keys, but protocol 2 may use any. The HISTORY section of
ssl(8) contains a brief discussion of the DSA and RSA
algorithms.</p>

<p style="margin-left:6%; margin-top: 1em">The file
<i>~/.ssh/authorized_keys</i> lists the public keys that are
permitted for logging in. When the user logs in, the
<b>ssh</b> program tells the server which key pair it would
like to use for authentication. The client proves that it
has access to the private key and the server checks that the
corresponding public key is authorized to accept the
account.</p>

<p style="margin-left:6%; margin-top: 1em">The user creates
his/her key pair by running ssh-keygen(1). This stores the
private key in <i>~/.ssh/identity</i> (protocol 1),
<i>~/.ssh/id_dsa</i> (protocol 2 DSA),
<i>~/.ssh/id_ecdsa</i> (protocol 2 ECDSA),
<i>~/.ssh/id_ed25519</i> (protocol 2 ED25519), or
<i>~/.ssh/id_rsa</i> (protocol 2 RSA) and stores the public
key in <i>~/.ssh/identity.pub</i> (protocol 1),
<i>~/.ssh/id_dsa.pub</i> (protocol 2 DSA),
<i>~/.ssh/id_ecdsa.pub</i> (protocol 2 ECDSA),
<i>~/.ssh/id_ed25519.pub</i> (protocol 2 ED25519), or
<i>~/.ssh/id_rsa.pub</i> (protocol 2 RSA) in the
user&rsquo;s home directory. The user should then copy the
public key to <i>~/.ssh/authorized_keys</i> in his/her home
directory on the remote machine. The <i>authorized_keys</i>
file corresponds to the conventional <i>~/.rhosts</i> file,
and has one key per line, though the lines can be very long.
After this, the user can log in without giving the
password.</p>

<p style="margin-left:6%; margin-top: 1em">A variation on
public key authentication is available in the form of
certificate authentication: instead of a set of
public/private keys, signed certificates are used. This has
the advantage that a single trusted certification authority
can be used in place of many public/private keys. See the
CERTIFICATES section of ssh-keygen(1) for more
information.</p>

<p style="margin-left:6%; margin-top: 1em">The most
convenient way to use public key or certificate
authentication may be with an authentication agent. See
ssh-agent(1) for more information.</p>


<p style="margin-left:6%; margin-top: 1em">Challenge-response
authentication works as follows: The server sends an
arbitrary &quot;challenge&quot; text, and prompts for a
response. Protocol 2 allows multiple challenges and
responses; protocol 1 is restricted to just one
challenge/response. Examples of challenge-response
authentication include BSD Authentication (see
login.conf(5)) and PAM (some non-OpenBSD systems).</p>

<p style="margin-left:6%; margin-top: 1em">Finally, if
other authentication methods fail, <b>ssh</b> prompts the
user for a password. The password is sent to the remote host
for checking; however, since all communications are
encrypted, the password cannot be seen by someone listening
on the network.</p>

<p style="margin-left:6%; margin-top: 1em"><b>ssh</b>
automatically maintains and checks a database containing
identification for all hosts it has ever been used with.
Host keys are stored in <i>~/.ssh/known_hosts</i> in the
user&rsquo;s home directory. Additionally, the file
<i>/etc/ssh/ssh_known_hosts</i> is automatically checked for
known hosts. Any new hosts are automatically added to the
user&rsquo;s file. If a host&rsquo;s identification ever
changes, <b>ssh</b> warns about this and disables password
authentication to prevent server spoofing or
man-in-the-middle attacks, which could otherwise be used to
circumvent the encryption. The <b>StrictHostKeyChecking</b>
option can be used to control logins to machines whose host
key is not known or has changed.</p>

<p style="margin-left:6%; margin-top: 1em">When the
user&rsquo;s identity has been accepted by the server, the
server either executes the given command, or logs into the
machine and gives the user a normal shell on the remote
machine. All communication with the remote command or shell
will be automatically encrypted.</p>

<p style="margin-left:6%; margin-top: 1em">If a
pseudo-terminal has been allocated (normal login session),
the user may use the escape characters noted below.</p>

<p style="margin-left:6%; margin-top: 1em">If no pseudo-tty
has been allocated, the session is transparent and can be
used to reliably transfer binary data. On most systems,
setting the escape character to
&lsquo;&lsquo;none&rsquo;&rsquo; will also make the session
transparent even if a tty is used.</p>

<p style="margin-left:6%; margin-top: 1em">The session
terminates when the command or shell on the remote machine
exits and all X11 and TCP connections have been closed.</p>

<p style="margin-top: 1em"><b>ESCAPE CHARACTERS</b></p>

<p style="margin-left:6%;">When a pseudo-terminal has been
requested, <b>ssh</b> supports a number of functions through
the use of an escape character.</p>

<p style="margin-left:6%; margin-top: 1em">A single tilde
character can be sent as <b>~~</b> or by following the tilde
by a character other than those described below. The escape
character must always follow a newline to be interpreted as
special. The escape character can be changed in
configuration files using the <b>EscapeChar</b>
configuration directive or on the command line by the
<b>&minus;e</b> option.</p>

<p style="margin-left:6%; margin-top: 1em">The supported
escapes (assuming the default &lsquo;~&rsquo;) are:</p>

<p style="margin-top: 1em"><b>~.</b></p>


<p style="margin-left:17%; margin-top: 1em">Disconnect.</p>

<p style="margin-top: 1em"><b>~^Z</b></p>

<p style="margin-left:17%; margin-top: 1em">Background
<b>ssh</b>.</p>

<p style="margin-top: 1em"><b>~#</b></p>

<p style="margin-left:17%; margin-top: 1em">List forwarded
connections.</p>

<p style="margin-top: 1em"><b>~&amp;</b></p>

<p style="margin-left:17%; margin-top: 1em">Background
<b>ssh</b> at logout when waiting for forwarded connection /
X11 sessions to terminate.</p>

<p style="margin-top: 1em"><b>~?</b></p>

<p style="margin-left:17%; margin-top: 1em">Display a list
of escape characters.</p>

<p style="margin-top: 1em"><b>~B</b></p>

<p style="margin-left:17%; margin-top: 1em">Send a BREAK to
the remote system (only useful for SSH protocol version 2
and if the peer supports it).</p>

<p style="margin-top: 1em"><b>~C</b></p>

<p style="margin-left:17%; margin-top: 1em">Open command
line. Currently this allows the addition of port forwardings
using the <b>&minus;L</b>, <b>&minus;R</b> and
<b>&minus;D</b> options (see above). It also allows the
cancellation of existing port-forwardings with
<b>&minus;KL</b>[</p>

<p><i>bind_address</i>: ]<i>port</i> for local,
<b>&minus;KR</b>[ <i><br>
bind_address</i>: ]<i>port</i> for remote and
<b>&minus;KD</b>[ <i><br>
bind_address</i>: ]<i>port</i> for dynamic port-forwardings.
<b>!</b><i>command</i> allows the user to execute a local
command if the <b>PermitLocalCommand</b> option is enabled
in ssh_config(5). Basic help is available, using the
<b>&minus;h</b> option.</p>

<p style="margin-top: 1em"><b>~R</b></p>

<p style="margin-left:17%; margin-top: 1em">Request
rekeying of the connection (only useful for SSH protocol
version 2 and if the peer supports it).</p>

<p style="margin-top: 1em"><b>~V</b></p>

<p style="margin-left:17%; margin-top: 1em">Decrease the
verbosity (<b>LogLevel</b>) when errors are being written to
stderr.</p>

<p style="margin-top: 1em"><b>~v</b></p>

<p style="margin-left:17%; margin-top: 1em">Increase the
verbosity (<b>LogLevel</b>) when errors are being written to
stderr.</p>

<p style="margin-top: 1em"><b>TCP FORWARDING</b></p>

<p style="margin-left:6%;">Forwarding of arbitrary TCP
connections over the secure channel can be specified either
on the command line or in a configuration file. One possible
application of TCP forwarding is a secure connection to a
mail server; another is going through firewalls.</p>

<p style="margin-left:6%; margin-top: 1em">In the example
below, we look at encrypting communication between an IRC
client and server, even though the IRC server does not
directly support encrypted communications. This works as
follows: the user connects to the remote host using
<b>ssh</b>, specifying a port to be used to forward
connections to the remote server. After that it is possible
to start the service which is to be encrypted on the client
machine, connecting to the same local port, and <b>ssh</b>
will encrypt and forward the connection.</p>

<p style="margin-left:6%; margin-top: 1em">The following
example tunnels an IRC session from client machine
&lsquo;&lsquo;127.0.0.1&rsquo;&rsquo; (localhost) to remote
server &lsquo;&lsquo;server.example.com&rsquo;&rsquo;:</p>

<p style="margin-left:12%; margin-top: 1em">$ ssh -f -L
1234:localhost:6667 server.example.com sleep 10 <br>
$ irc -c &rsquo;#users&rsquo; -p 1234 pinky 127.0.0.1</p>

<p style="margin-left:6%; margin-top: 1em">This tunnels a
connection to IRC server
&lsquo;&lsquo;server.example.com&rsquo;&rsquo;, joining
channel &lsquo;&lsquo;#users&rsquo;&rsquo;, nickname
&lsquo;&lsquo;pinky&rsquo;&rsquo;, using port 1234. It
doesn&rsquo;t matter which port is used, as long as
it&rsquo;s greater than 1023 (remember, only root can open
sockets on privileged ports) and doesn&rsquo;t conflict with
any ports already in use. The connection is forwarded to
port 6667 on the remote server, since that&rsquo;s the
standard port for IRC services.</p>

<p style="margin-left:6%; margin-top: 1em">The
<b>&minus;f</b> option backgrounds <b>ssh</b> and the remote
command &lsquo;&lsquo;sleep 10&rsquo;&rsquo; is specified to
allow an amount of time (10 seconds, in the example) to
start the service which is to be tunnelled. If no
connections are made within the time specified, <b>ssh</b>
will exit.</p>

<p style="margin-top: 1em"><b>X11 FORWARDING</b></p>

<p style="margin-left:6%;">If the <b>ForwardX11</b>
variable is set to &lsquo;&lsquo;yes&rsquo;&rsquo; (or see
the description of the <b>&minus;X</b>, <b>&minus;x</b>, and
<b>&minus;Y</b> options above) and the user is using X11
(the DISPLAY environment variable is set), the connection to
the X11 display is automatically forwarded to the remote
side in such a way that any X11 programs started from the
shell (or command) will go through the encrypted channel,
and the connection to the real X server will be made from
the local machine. The user should not manually set DISPLAY.
Forwarding of X11 connections can be configured on the
command line or in configuration files.</p>

<p style="margin-left:6%; margin-top: 1em">The DISPLAY
value set by <b>ssh</b> will point to the server machine,
but with a display number greater than zero. This is normal,
and happens because <b>ssh</b> creates a
&lsquo;&lsquo;proxy&rsquo;&rsquo; X server on the server
machine for forwarding the connections over the encrypted
channel.</p>

<p style="margin-left:6%; margin-top: 1em"><b>ssh</b> will
also automatically set up Xauthority data on the server
machine. For this purpose, it will generate a random
authorization cookie, store it in Xauthority on the server,
and verify that any forwarded connections carry this cookie
and replace it by the real cookie when the connection is
opened. The real authentication cookie is never sent to the
server machine (and no cookies are sent in the plain).</p>

<p style="margin-left:6%; margin-top: 1em">If the
<b>ForwardAgent</b> variable is set to
&lsquo;&lsquo;yes&rsquo;&rsquo; (or see the description of
the <b>&minus;A</b> and <b>&minus;a</b> options above) and
the user is using an authentication agent, the connection to
the agent is automatically forwarded to the remote side.</p>

<p style="margin-top: 1em"><b>VERIFYING HOST KEYS</b></p>

<p style="margin-left:6%;">When connecting to a server for
the first time, a fingerprint of the server&rsquo;s public
key is presented to the user (unless the option
<b>StrictHostKeyChecking</b> has been disabled).
Fingerprints can be determined using ssh-keygen(1):</p>

<p style="margin-left:14%; margin-top: 1em">$ ssh-keygen -l
-f /etc/ssh/ssh_host_rsa_key</p>

<p style="margin-left:6%; margin-top: 1em">If the
fingerprint is already known, it can be matched and the key
can be accepted or rejected. Because of the difficulty of
comparing host keys just by looking at hex strings, there is
also support to compare host keys visually, using <i>random
art</i>. By setting the <b>VisualHostKey</b> option to
&lsquo;&lsquo;yes&rsquo;&rsquo;, a small ASCII graphic gets
displayed on every login to a server, no matter if the
session itself is interactive or not. By learning the
pattern a known server produces, a user can easily find out
that the host key has changed when a completely different
pattern is displayed. Because these patterns are not
unambiguous however, a pattern that looks similar to the
pattern remembered only gives a good probability that the
host key is the same, not guaranteed proof.</p>

<p style="margin-left:6%; margin-top: 1em">To get a listing
of the fingerprints along with their random art for all
known hosts, the following command line can be used:</p>

<p style="margin-left:14%; margin-top: 1em">$ ssh-keygen
-lv -f ~/.ssh/known_hosts</p>

<p style="margin-left:6%; margin-top: 1em">If the
fingerprint is unknown, an alternative method of
verification is available: SSH fingerprints verified by DNS.
An additional resource record (RR), SSHFP, is added to a
zonefile and the connecting client is able to match the
fingerprint with that of the key presented.</p>

<p style="margin-left:6%; margin-top: 1em">In this example,
we are connecting a client to a server,
&lsquo;&lsquo;host.example.com&rsquo;&rsquo;. The SSHFP
resource records should first be added to the zonefile for
host.example.com:</p>

<p style="margin-left:14%; margin-top: 1em">$ ssh-keygen -r
host.example.com.</p>

<p style="margin-left:6%; margin-top: 1em">The output lines
will have to be added to the zonefile. To check that the
zone is answering fingerprint queries:</p>

<p style="margin-left:14%; margin-top: 1em">$ dig -t SSHFP
host.example.com</p>

<p style="margin-left:6%; margin-top: 1em">Finally the
client connects:</p>

<p style="margin-left:14%; margin-top: 1em">$ ssh -o
&quot;VerifyHostKeyDNS ask&quot; host.example.com <br>
[...] <br>
Matching host key fingerprint found in DNS. <br>
Are you sure you want to continue connecting (yes/no)?</p>

<p style="margin-left:6%; margin-top: 1em">See the
<b>VerifyHostKeyDNS</b> option in ssh_config(5) for more
information.</p>

<p style="margin-top: 1em"><b>SSH-BASED VIRTUAL PRIVATE
NETWORKS</b></p>

<p style="margin-left:6%;"><b>ssh</b> contains support for
Virtual Private Network (VPN) tunnelling using the tun(4)
network pseudo-device, allowing two networks to be joined
securely. The sshd_config(5) configuration option
<b>PermitTunnel</b> controls whether the server supports
this, and at what level (layer 2 or 3 traffic).</p>

<p style="margin-left:6%; margin-top: 1em">The following
example would connect client network 10.0.50.0/24 with
remote network 10.0.99.0/24 using a point-to-point
connection from 10.1.1.1 to 10.1.1.2, provided that the SSH
server running on the gateway to the remote network, at
192.168.1.15, allows it.</p>

<p style="margin-left:6%; margin-top: 1em">On the
client:</p>

<p style="margin-left:14%; margin-top: 1em"># ssh -f -w 0:1
192.168.1.15 true <br>
# ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252
<br>
# route add 10.0.99.0/24 10.1.1.2</p>

<p style="margin-left:6%; margin-top: 1em">On the
server:</p>

<p style="margin-left:14%; margin-top: 1em"># ifconfig tun1
10.1.1.2 10.1.1.1 netmask 255.255.255.252 <br>
# route add 10.0.50.0/24 10.1.1.1</p>

<p style="margin-left:6%; margin-top: 1em">Client access
may be more finely tuned via the
<i>/root/.ssh/authorized_keys</i> file (see below) and the
<b>PermitRootLogin</b> server option. The following entry
would permit connections on tun(4) device 1 from user
&lsquo;&lsquo;jane&rsquo;&rsquo; and on tun device 2 from
user &lsquo;&lsquo;john&rsquo;&rsquo;, if
<b>PermitRootLogin</b> is set to
&lsquo;&lsquo;forced-commands-only&rsquo;&rsquo;:</p>


<p style="margin-left:9%; margin-top: 1em">tunnel=&quot;1&quot;,command=&quot;sh
/etc/netstart tun1&quot; ssh-rsa ... jane <br>
tunnel=&quot;2&quot;,command=&quot;sh /etc/netstart
tun2&quot; ssh-rsa ... john</p>

<p style="margin-left:6%; margin-top: 1em">Since an
SSH-based setup entails a fair amount of overhead, it may be
more suited to temporary setups, such as for wireless VPNs.
More permanent VPNs are better provided by tools such as
ipsecctl(8) and isakmpd(8).</p>

<p style="margin-top: 1em"><b>ENVIRONMENT</b></p>

<p style="margin-left:6%;"><b>ssh</b> will normally set the
following environment variables:</p>

<p style="margin-top: 1em">DISPLAY</p>

<p style="margin-left:35%; margin-top: 1em">The DISPLAY
variable indicates the location of the X11 server. It is
automatically set by <b>ssh</b> to point to a value of the
form &lsquo;&lsquo;hostname:n&rsquo;&rsquo;, where
&lsquo;&lsquo;hostname&rsquo;&rsquo; indicates the host
where the shell runs, and &lsquo;n&rsquo; is an integer &ge;
1. <b>ssh</b> uses this special value to forward X11
connections over the secure channel. The user should
normally not set DISPLAY explicitly, as that will render the
X11 connection insecure (and will require the user to
manually copy any required authorization cookies).</p>

<p style="margin-top: 1em">HOME</p>

<p style="margin-left:35%; margin-top: 1em">Set to the path
of the user&rsquo;s home directory.</p>

<p style="margin-top: 1em">LOGNAME</p>

<p style="margin-left:35%; margin-top: 1em">Synonym for
USER; set for compatibility with systems that use this
variable.</p>

<p style="margin-top: 1em">MAIL</p>

<p style="margin-left:35%; margin-top: 1em">Set to the path
of the user&rsquo;s mailbox.</p>

<p style="margin-top: 1em">PATH</p>

<p style="margin-left:35%; margin-top: 1em">Set to the
default PATH, as specified when compiling <b>ssh</b>.</p>

<p style="margin-top: 1em">SSH_ASKPASS</p>

<p style="margin-left:35%; margin-top: 1em">If <b>ssh</b>
needs a passphrase, it will read the passphrase from the
current terminal if it was run from a terminal. If
<b>ssh</b> does not have a terminal associated with it but
DISPLAY and SSH_ASKPASS are set, it will execute the program
specified by SSH_ASKPASS and open an X11 window to read the
passphrase. This is particularly useful when calling
<b>ssh</b> from a <i>.xsession</i> or related script. (Note
that on some machines it may be necessary to redirect the
input from <i>/dev/null</i> to make this work.)</p>

<p style="margin-top: 1em">SSH_AUTH_SOCK</p>

<p style="margin-left:35%; margin-top: 1em">Identifies the
path of a UNIX-domain socket used to communicate with the
agent.</p>

<p style="margin-top: 1em">SSH_CONNECTION</p>

<p style="margin-left:35%; margin-top: 1em">Identifies the
client and server ends of the connection. The variable
contains four space-separated values: client IP address,
client port number, server IP address, and server port
number.</p>

<p style="margin-top: 1em">SSH_ORIGINAL_COMMAND</p>

<p style="margin-left:35%; margin-top: 1em">This variable
contains the original command line if a forced command is
executed. It can be used to extract the original
arguments.</p>

<p style="margin-top: 1em">SSH_TTY</p>

<p style="margin-left:35%; margin-top: 1em">This is set to
the name of the tty (path to the device) associated with the
current shell or command. If the current session has no tty,
this variable is not set.</p>

<p style="margin-top: 1em">TZ</p>

<p style="margin-left:35%; margin-top: 1em">This variable
is set to indicate the present time zone if it was set when
the daemon was started (i.e. the daemon passes the value on
to new connections).</p>

<p style="margin-top: 1em">USER</p>

<p style="margin-left:35%; margin-top: 1em">Set to the name
of the user logging in.</p>

<p style="margin-left:6%; margin-top: 1em">Additionally,
<b>ssh</b> reads <i>~/.ssh/environment</i>, and adds lines
of the format &lsquo;&lsquo;VARNAME=value&rsquo;&rsquo; to
the environment if the file exists and users are allowed to
change their environment. For more information, see the
<b>PermitUserEnvironment</b> option in sshd_config(5).</p>

<p style="margin-top: 1em"><b>ENVIRONMENT</b> <br>
SSH_USE_STRONG_RNG</p>

<p style="margin-left:17%;">The reseeding of the OpenSSL
random generator is usually done from <b>/dev/urandom</b>.
If the <b>SSH_USE_STRONG_RNG</b> environment variable is set
to value other than <b>0</b> the OpenSSL random generator is
reseeded from <b>/dev/random</b>. The number of bytes read
is defined by the SSH_USE_STRONG_RNG value. Minimum is 14
bytes. This setting is not recommended on the computers
without the hardware random generator because insufficient
entropy causes the connection to be blocked until enough
entropy is available.</p>

<p style="margin-top: 1em"><b>FILES</b> <br>
~/.rhosts</p>

<p style="margin-left:17%;">This file is used for
host-based authentication (see above). On some machines this
file may need to be world-readable if the user&rsquo;s home
directory is on an NFS partition, because sshd(8) reads it
as root. Additionally, this file must be owned by the user,
and must not have write permissions for anyone else. The
recommended permission for most machines is read/write for
the user, and not accessible by others.</p>

<p style="margin-top: 1em">~/.shosts</p>

<p style="margin-left:17%;">This file is used in exactly
the same way as <i>.rhosts</i>, but allows host-based
authentication without permitting login with rlogin/rsh.</p>

<p style="margin-top: 1em">~/.ssh/</p>

<p style="margin-left:17%;">This directory is the default
location for all user-specific configuration and
authentication information. There is no general requirement
to keep the entire contents of this directory secret, but
the recommended permissions are read/write/execute for the
user, and not accessible by others.</p>

<p style="margin-top: 1em">~/.ssh/authorized_keys</p>

<p style="margin-left:17%;">Lists the public keys (DSA,
ECDSA, ED25519, RSA) that can be used for logging in as this
user. The format of this file is described in the sshd(8)
manual page. This file is not highly sensitive, but the
recommended permissions are read/write for the user, and not
accessible by others.</p>

<p style="margin-top: 1em">~/.ssh/config</p>

<p style="margin-left:17%;">This is the per-user
configuration file. The file format and configuration
options are described in ssh_config(5). Because of the
potential for abuse, this file must have strict permissions:
read/write for the user, and not writable by others.</p>

<p style="margin-top: 1em">~/.ssh/environment</p>

<p style="margin-left:17%;">Contains additional definitions
for environment variables; see <i>ENVIRONMENT</i>,
above.</p>

<p style="margin-top: 1em">~/.ssh/identity <br>
~/.ssh/id_dsa <br>
~/.ssh/id_ecdsa <br>
~/.ssh/id_ed25519 <br>
~/.ssh/id_rsa</p>

<p style="margin-left:17%;">Contains the private key for
authentication. These files contain sensitive data and
should be readable by the user but not accessible by others
(read/write/execute). <b>ssh</b> will simply ignore a
private key file if it is accessible by others. It is
possible to specify a passphrase when generating the key
which will be used to encrypt the sensitive part of this
file using 3DES.</p>

<p style="margin-top: 1em">~/.ssh/identity.pub <br>
~/.ssh/id_dsa.pub <br>
~/.ssh/id_ecdsa.pub <br>
~/.ssh/id_ed25519.pub <br>
~/.ssh/id_rsa.pub</p>

<p style="margin-left:17%;">Contains the public key for
authentication. These files are not sensitive and can (but
need not) be readable by anyone.</p>

<p style="margin-top: 1em">~/.ssh/known_hosts</p>

<p style="margin-left:17%;">Contains a list of host keys
for all hosts the user has logged into that are not already
in the systemwide list of known host keys. See sshd(8) for
further details of the format of this file.</p>

<p style="margin-top: 1em">~/.ssh/rc</p>

<p style="margin-left:17%;">Commands in this file are
executed by <b>ssh</b> when the user logs in, just before
the user&rsquo;s shell (or command) is started. See the
sshd(8) manual page for more information.</p>

<p style="margin-top: 1em">/etc/hosts.equiv</p>

<p style="margin-left:17%;">This file is for host-based
authentication (see above). It should only be writable by
root.</p>

<p style="margin-top: 1em">/etc/ssh/shosts.equiv</p>

<p style="margin-left:17%;">This file is used in exactly
the same way as <i>hosts.equiv</i>, but allows host-based
authentication without permitting login with rlogin/rsh.</p>

<p style="margin-top: 1em">/etc/ssh/ssh_config</p>

<p style="margin-left:17%;">Systemwide configuration file.
The file format and configuration options are described in
ssh_config(5).</p>

<p style="margin-top: 1em">/etc/ssh/ssh_host_key <br>
/etc/ssh/ssh_host_dsa_key <br>
/etc/ssh/ssh_host_ecdsa_key <br>
/etc/ssh/ssh_host_ed25519_key <br>
/etc/ssh/ssh_host_rsa_key</p>

<p style="margin-left:17%;">These files contain the private
parts of the host keys and are used for host-based
authentication. If protocol version 1 is used, <b>ssh</b>
must be setuid root, since the host key is readable only by
root. For protocol version 2, <b>ssh</b> uses ssh-keysign(8)
to access the host keys, eliminating the requirement that
<b>ssh</b> be setuid root when host-based authentication is
used. By default <b>ssh</b> is not setuid root.</p>

<p style="margin-top: 1em">/etc/ssh/ssh_known_hosts</p>

<p style="margin-left:17%;">Systemwide list of known host
keys. This file should be prepared by the system
administrator to contain the public host keys of all
machines in the organization. It should be world-readable.
See sshd(8) for further details of the format of this
file.</p>

<p style="margin-top: 1em">/etc/ssh/sshrc</p>

<p style="margin-left:17%;">Commands in this file are
executed by <b>ssh</b> when the user logs in, just before
the user&rsquo;s shell (or command) is started. See the
sshd(8) manual page for more information.</p>

<p style="margin-top: 1em"><b>EXIT STATUS</b></p>

<p style="margin-left:6%;"><b>ssh</b> exits with the exit
status of the remote command or with 255 if an error
occurred.</p>

<p style="margin-top: 1em"><b>IPV6</b></p>

<p style="margin-left:6%;">IPv6 address can be used
everywhere where IPv4 address. In all entries must be the
IPv6 address enclosed in square brackets. Note: The square
brackets are metacharacters for the shell and must be
escaped in shell.</p>

<p style="margin-top: 1em"><b>SEE ALSO</b></p>

<p style="margin-left:6%;">scp(1), sftp(1), ssh-add(1),
ssh-agent(1), ssh-keygen(1), ssh-keyscan(1), tun(4),
hosts.equiv(5), ssh_config(5), ssh-keysign(8), sshd(8)</p>

<p style="margin-top: 1em"><b>STANDARDS</b> <br>
S. Lehtinen</p>

<p style="margin-left:6%;">and</p>

<p>C. Lonvick , <i><br>
The Secure Shell (SSH) Protocol Assigned Numbers</i> , <br>
RFC 4250 , <br>
January 2006 .</p>

<p style="margin-top: 1em">T. Ylonen</p>

<p style="margin-left:6%;">and</p>

<p>C. Lonvick , <i><br>
The Secure Shell (SSH) Protocol Architecture</i> , <br>
RFC 4251 , <br>
January 2006 .</p>

<p style="margin-top: 1em">T. Ylonen</p>

<p style="margin-left:6%;">and</p>

<p>C. Lonvick , <i><br>
The Secure Shell (SSH) Authentication Protocol</i> , <br>
RFC 4252 , <br>
January 2006 .</p>

<p style="margin-top: 1em">T. Ylonen</p>

<p style="margin-left:6%;">and</p>

<p>C. Lonvick , <i><br>
The Secure Shell (SSH) Transport Layer Protocol</i> , <br>
RFC 4253 , <br>
January 2006 .</p>

<p style="margin-top: 1em">T. Ylonen</p>

<p style="margin-left:6%;">and</p>

<p>C. Lonvick , <i><br>
The Secure Shell (SSH) Connection Protocol</i> , <br>
RFC 4254 , <br>
January 2006 .</p>

<p style="margin-top: 1em">J. Schlyter</p>

<p style="margin-left:6%;">and</p>

<p>W. Griffin , <i><br>
Using DNS to Securely Publish Secure Shell (SSH) Key
Fingerprints</i> , <br>
RFC 4255 , <br>
January 2006 .</p>

<p style="margin-top: 1em">F. Cusack</p>

<p style="margin-left:6%;">and</p>

<p>M. Forssen , <i><br>
Generic Message Exchange Authentication for the Secure Shell
Protocol (SSH)</i> , <br>
RFC 4256 , <br>
January 2006 .</p>

<p style="margin-top: 1em">J. Galbraith</p>

<p style="margin-left:6%;">and</p>

<p>P. Remaker , <i><br>
The Secure Shell (SSH) Session Channel Break Extension</i> ,
<br>
RFC 4335 , <br>
January 2006 .</p>

<p style="margin-top: 1em">M. Bellare</p>

<p style="margin-left:6%;">,</p>

<p>T. Kohno , and <br>
C. Namprempre , <i><br>
The Secure Shell (SSH) Transport Layer Encryption Modes</i>
, <br>
RFC 4344 , <br>
January 2006 .</p>

<p style="margin-top: 1em">B. Harris</p>

<p style="margin-left:6%;">,</p>

<p><i>Improved Arcfour Modes for the Secure Shell (SSH)
Transport Layer Protocol</i> , <br>
RFC 4345 , <br>
January 2006 .</p>

<p style="margin-top: 1em">M. Friedl</p>

<p style="margin-left:6%;">,</p>

<p>N. Provos , and <br>
W. Simpson , <i><br>
Diffie-Hellman Group Exchange for the Secure Shell (SSH)
Transport Layer Protocol</i> , <br>
RFC 4419 , <br>
March 2006 .</p>

<p style="margin-top: 1em">J. Galbraith</p>

<p style="margin-left:6%;">and</p>

<p>R. Thayer , <i><br>
The Secure Shell (SSH) Public Key File Format</i> , <br>
RFC 4716 , <br>
November 2006 .</p>

<p style="margin-top: 1em">D. Stebila</p>

<p style="margin-left:6%;">and</p>

<p>J. Green , <i><br>
Elliptic Curve Algorithm Integration in the Secure Shell
Transport Layer</i> , <br>
RFC 5656 , <br>
December 2009 .</p>

<p style="margin-top: 1em">A. Perrig</p>

<p style="margin-left:6%;">and</p>

<p>D. Song , <i><br>
Hash Visualization: a New Technique to improve Real-World
Security</i> , <br>
1999 , <br>
International Workshop on Cryptographic Techniques and
E-Commerce (CrypTEC &rsquo;99) .</p>

<p style="margin-top: 1em"><b>AUTHORS</b></p>

<p style="margin-left:6%;">OpenSSH is a derivative of the
original and free ssh 1.2.12 release by Tatu Ylonen. Aaron
Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo de
Raadt and Dug Song removed many bugs, re-added newer
features and created OpenSSH. Markus Friedl contributed the
support for SSH protocol versions 1.5 and 2.0.</p>

<p style="margin-left:6%; margin-top: 1em">BSD
August&nbsp;18, 2016 BSD</p>
<hr>
</body>
</html>
