<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:04:13 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_SetVar</title>

</head>
<body>

<h1 align="center">Tcl_SetVar</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl_SetVar2Ex,
Tcl_SetVar, Tcl_SetVar2, Tcl_ObjSetVar2, Tcl_GetVar2Ex,
Tcl_GetVar, Tcl_GetVar2, Tcl_ObjGetVar2, Tcl_UnsetVar,
Tcl_UnsetVar2 &minus; manipulate Tcl variables</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_SetVar2Ex</b>(<i>interp, name1, name2, newValuePtr,
flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_SetVar</b>(<i>interp, varName, newValue, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_SetVar2</b>(<i>interp, name1, name2, newValue,
flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_ObjSetVar2</b>(<i>interp, part1Ptr, part2Ptr,
newValuePtr, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_GetVar2Ex</b>(<i>interp, name1, name2, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_GetVar</b>(<i>interp, varName, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_GetVar2</b>(<i>interp, name1, name2, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_ObjGetVar2</b>(<i>interp, part1Ptr, part2Ptr,
flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_UnsetVar</b>(<i>interp, varName, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_UnsetVar2</b>(<i>interp, name1, name2, flags</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p style="margin-top: 1em">Tcl_Interp <i>*interp</i>
(in)</p> </td>
<td width="20%"></td>
<td width="31%">


<p style="margin-top: 1em">Interpreter containing
variable.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>const char <i>*name1</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>Contains the name of an array variable (if <i>name2</i>
is non-NULL) or (if <i>name2</i> is NULL) either the name of
a scalar variable or a complete name including both variable
name and index. May include <b>::</b> namespace qualifiers
to specify a variable in a particular namespace.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>const char <i>*name2</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>If non-NULL, gives name of element within array; in this
case <i>name1</i> must refer to an array variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tcl_Obj <i>*newValuePtr</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>Points to a Tcl object containing the new value for the
variable.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>int <i>flags</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>OR-ed combination of bits providing additional
information. See below for valid values.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>const char <i>*varName</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>Name of variable. May include <b>::</b> namespace
qualifiers to specify a variable in a particular namespace.
May refer to a scalar variable or an element of an
array.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>const char <i>*newValue</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>New value for variable, specified as a null-terminated
string. A copy of this value is stored in the variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tcl_Obj <i>*part1Ptr</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>Points to a Tcl object containing the variable&rsquo;s
name. The name may include a series of <b>::</b> namespace
qualifiers to specify a variable in a particular namespace.
May refer to a scalar variable or an element of an array
variable.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">


<p>Tcl_Obj <i>*part2Ptr</i> (in)</p></td>
<td width="20%"></td>
<td width="31%">


<p>If non-NULL, points to an object containing the name of
an element within an array and <i>part1Ptr</i> must refer to
an array variable.</p></td></tr>
</table>


<p style="margin-left:69%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These
procedures are used to create, modify, read, and delete Tcl
variables from C code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SetVar2Ex</b>,
<b>Tcl_SetVar</b>, <b>Tcl_SetVar2</b>, and
<b>Tcl_ObjSetVar2</b> will create a new variable or modify
an existing one. These procedures set the given variable to
the value given by <i>newValuePtr</i> or <i>newValue</i> and
return a pointer to the variable&rsquo;s new value, which is
stored in Tcl&rsquo;s variable structure.
<b>Tcl_SetVar2Ex</b> and <b>Tcl_ObjSetVar2</b> take the new
value as a Tcl_Obj and return a pointer to a Tcl_Obj.
<b>Tcl_SetVar</b> and <b>Tcl_SetVar2</b> take the new value
as a string and return a string; they are usually less
efficient than <b>Tcl_ObjSetVar2</b>. Note that the return
value may be different than the <i>newValuePtr</i> or
<i>newValue</i> argument, due to modifications made by write
traces. If an error occurs in setting the variable (e.g. an
array variable is referenced without giving an index into
the array) NULL is returned and an error message is left in
<i>interp</i>&rsquo;s result if the <b>TCL_LEAVE_ERR_MSG</b>
<i>flag</i> bit is set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetVar2Ex</b>,
<b>Tcl_GetVar</b>, <b>Tcl_GetVar2</b>, and
<b>Tcl_ObjGetVar2</b> return the current value of a
variable. The arguments to these procedures are treated in
the same way as the arguments to the procedures described
above. Under normal circumstances, the return value is a
pointer to the variable&rsquo;s value. For
<b>Tcl_GetVar2Ex</b> and <b>Tcl_ObjGetVar2</b> the value is
returned as a pointer to a Tcl_Obj. For <b>Tcl_GetVar</b>
and <b>Tcl_GetVar2</b> the value is returned as a string;
this is usually less efficient, so <b>Tcl_GetVar2Ex</b> or
<b>Tcl_ObjGetVar2</b> are preferred. If an error occurs
while reading the variable (e.g. the variable does not exist
or an array element is specified for a scalar variable),
then NULL is returned and an error message is left in
<i>interp</i>&rsquo;s result if the <b>TCL_LEAVE_ERR_MSG</b>
<i>flag</i> bit is set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UnsetVar</b>
and <b>Tcl_UnsetVar2</b> may be used to remove a variable,
so that future attempts to read the variable will return an
error. The arguments to these procedures are treated in the
same way as the arguments to the procedures above. If the
variable is successfully removed then <b>TCL_OK</b> is
returned. If the variable cannot be removed because it does
not exist then <b>TCL_ERROR</b> is returned and an error
message is left in <i>interp</i>&rsquo;s result if the
<b>TCL_LEAVE_ERR_MSG</b> <i>flag</i> bit is set. If an array
element is specified, the given element is removed but the
array remains. If an array name is specified without an
index, then the entire array is removed.</p>

<p style="margin-left:11%; margin-top: 1em">The name of a
variable may be specified to these procedures in four
ways:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">If <b>Tcl_SetVar</b>,
<b>Tcl_GetVar</b>, or <b>Tcl_UnsetVar</b> is invoked, the
variable name is given as a single string, <i>varName</i>.
If <i>varName</i> contains an open parenthesis and ends with
a close parenthesis, then the value between the parentheses
is treated as an index (which can have any string value) and
the characters before the first open parenthesis are treated
as the name of an array variable. If <i>varName</i> does not
have parentheses as described above, then the entire string
is treated as the name of a scalar variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="7%"></td>
<td width="78%">


<p>If the <i>name1</i> and <i>name2</i> arguments are
provided and <i>name2</i> is non-NULL, then an array element
is specified and the array name and index have already been
separated by the caller: <i>name1</i> contains the name and
<i>name2</i> contains the index. An error is generated if
<i>name1</i> contains an open parenthesis and ends with a
close parenthesis (array element) and <i>name2</i> is
non-NULL.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="7%"></td>
<td width="78%">


<p>If <i>name2</i> is NULL, <i>name1</i> is treated just
like <i>varName</i> in case [1] above (it can be either a
scalar or an array element variable name).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> argument may be used to specify any of several
options to the procedures. It consists of an OR-ed
combination of the following bits. <b><br>
TCL_GLOBAL_ONLY</b></p>

<p style="margin-left:22%;">Under normal circumstances the
procedures look up variables as follows. If a procedure call
is active in <i>interp</i>, the variable is looked up at the
current level of procedure call. Otherwise, the variable is
looked up first in the current namespace, then in the global
namespace. However, if this bit is set in <i>flags</i> then
the variable is looked up only in the global namespace even
if there is a procedure call active. If both
<b>TCL_GLOBAL_ONLY</b> and <b>TCL_NAMESPACE_ONLY</b> are
given, <b>TCL_GLOBAL_ONLY</b> is ignored.</p>

<p style="margin-left:11%;"><b>TCL_NAMESPACE_ONLY</b></p>

<p style="margin-left:22%;">If this bit is set in
<i>flags</i> then the variable is looked up only in the
current namespace; if a procedure is active its variables
are ignored, and the global namespace is also ignored unless
it is the current namespace.</p>

<p style="margin-left:11%;"><b>TCL_LEAVE_ERR_MSG</b></p>

<p style="margin-left:22%;">If an error is returned and
this bit is set in <i>flags</i>, then an error message will
be left in the interpreter&rsquo;s result, where it can be
retrieved with <b>Tcl_GetObjResult</b> or
<b>Tcl_GetStringResult</b>. If this flag bit is not set then
no error message is left and the interpreter&rsquo;s result
will not be modified.</p>

<p style="margin-left:11%;"><b>TCL_APPEND_VALUE</b></p>

<p style="margin-left:22%;">If this bit is set then
<i>newValuePtr</i> or <i>newValue</i> is appended to the
current value instead of replacing it. If the variable is
currently undefined, then the bit is ignored. This bit is
only used by the <b>Tcl_Set*</b> procedures.</p>

<p style="margin-left:11%;"><b>TCL_LIST_ELEMENT</b></p>

<p style="margin-left:22%;">If this bit is set, then
<i>newValue</i> is converted to a valid Tcl list element
before setting (or appending to) the variable. A separator
space is appended before the new list element unless the
list element is going to be the first element in a list or
sublist (i.e. the variable&rsquo;s current value is empty,
or contains the single character &ldquo;{&rdquo;, or ends in
&ldquo; }&rdquo;). When appending, the original value of the
variable must also be a valid list, so that the operation is
the appending of a new list element onto a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetVar</b>
and <b>Tcl_GetVar2</b> return the current value of a
variable. The arguments to these procedures are treated in
the same way as the arguments to <b>Tcl_SetVar</b> and
<b>Tcl_SetVar2</b>. Under normal circumstances, the return
value is a pointer to the variable&rsquo;s value (which is
stored in Tcl&rsquo;s variable structure and will not change
before the next call to <b>Tcl_SetVar</b> or
<b>Tcl_SetVar2</b>). <b>Tcl_GetVar</b> and
<b>Tcl_GetVar2</b> use the flag bits <b>TCL_GLOBAL_ONLY</b>
and <b>TCL_LEAVE_ERR_MSG</b>, both of which have the same
meaning as for <b>Tcl_SetVar</b>. If an error occurs in
reading the variable (e.g. the variable does not exist or an
array element is specified for a scalar variable), then NULL
is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UnsetVar</b>
and <b>Tcl_UnsetVar2</b> may be used to remove a variable,
so that future calls to <b>Tcl_GetVar</b> or
<b>Tcl_GetVar2</b> for the variable will return an error.
The arguments to these procedures are treated in the same
way as the arguments to <b>Tcl_GetVar</b> and
<b>Tcl_GetVar2</b>. If the variable is successfully removed
then <b>TCL_OK</b> is returned. If the variable cannot be
removed because it does not exist then <b>TCL_ERROR</b> is
returned. If an array element is specified, the given
element is removed but the array remains. If an array name
is specified without an index, then the entire array is
removed.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_GetObjResult,
Tcl_GetStringResult, Tcl_TraceVar</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">array, get
variable, interpreter, object, scalar, set, unset,
variable</p>
<hr>
</body>
</html>
