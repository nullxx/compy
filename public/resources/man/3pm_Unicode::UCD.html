<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:47 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Unicode::UCD</title>

</head>
<body>

<h1 align="center">Unicode::UCD</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Unicode::UCD
&minus; Unicode character database</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Unicode::UCD 'charinfo';
    my $charinfo   = charinfo($codepoint);
    use Unicode::UCD 'casefold';
    my $casefold = casefold(0xFB00);
    use Unicode::UCD 'casespec';
    my $casespec = casespec(0xFB00);
    use Unicode::UCD 'charblock';
    my $charblock  = charblock($codepoint);
    use Unicode::UCD 'charscript';
    my $charscript = charscript($codepoint);
    use Unicode::UCD 'charblocks';
    my $charblocks = charblocks();
    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();
    use Unicode::UCD qw(charscript charinrange);
    my $range = charscript($script);
    print &quot;looks like $script\n&quot; if charinrange($range, $codepoint);
    use Unicode::UCD qw(general_categories bidi_types);
    my $categories = general_categories();
    my $types = bidi_types();
    use Unicode::UCD 'prop_aliases';
    my @space_names = prop_aliases(&quot;space&quot;);
    use Unicode::UCD 'prop_value_aliases';
    my @gc_punct_names = prop_value_aliases(&quot;Gc&quot;, &quot;Punct&quot;);
    use Unicode::UCD 'prop_invlist';
    my @puncts = prop_invlist(&quot;gc=punctuation&quot;);
    use Unicode::UCD 'prop_invmap';
    my ($list_ref, $map_ref, $format, $missing)
                                      = prop_invmap(&quot;General Category&quot;);
    use Unicode::UCD 'compexcl';
    my $compexcl = compexcl($codepoint);
    use Unicode::UCD 'namedseq';
    my $namedseq = namedseq($named_sequence_name);
    my $unicode_version = Unicode::UCD::UnicodeVersion();
    my $convert_to_numeric =
              Unicode::UCD::num(&quot;\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}&quot;);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
Unicode::UCD module offers a series of functions that
provide a simple interface to the Unicode Character
Database.</p>

<p style="margin-left:11%; margin-top: 1em"><b>code point
argument</b> <br>
Some of the functions are called with a <i>code point
argument</i>, which is either a decimal or a hexadecimal
scalar designating a Unicode code point, or
<tt>&quot;U+&quot;</tt> followed by hexadecimals designating
a Unicode code point. In other words, if you want a code
point to be interpreted as a hexadecimal number, you must
prefix it with either <tt>&quot;0x&quot;</tt> or
<tt>&quot;U+&quot;</tt>, because a string like e.g.
<tt>123</tt> will be interpreted as a decimal code point.
Note that the largest code point in Unicode is U+10FFFF.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charinfo()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'charinfo';
    my $charinfo = charinfo(0x41);</pre>


<p style="margin-left:11%; margin-top: 1em">This returns
information about the input &quot;code point argument&quot;
as a reference to a hash of fields as defined by the Unicode
standard. If the &quot;code point argument&quot; is not
assigned in the standard (i.e., has the general category
<tt>&quot;Cn&quot;</tt> meaning
<tt>&quot;Unassigned&quot;</tt>) or is a non-character
(meaning it is guaranteed to never be assigned in the
standard), <tt>&quot;undef&quot;</tt> is returned.</p>

<p style="margin-left:11%; margin-top: 1em">Fields that
aren&rsquo;t applicable to the particular code point
argument exist in the returned hash, and are empty.</p>

<p style="margin-left:11%; margin-top: 1em">The keys in the
hash with the meanings of their values are: <b><br>
code</b></p>

<p style="margin-left:17%;">the input &quot;code point
argument&quot; expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four
hexdigits</p>

<p style="margin-left:11%;"><b>name</b></p>

<p style="margin-left:17%;">name of <i>code</i>, all
<small>IN UPPER CASE</small> . Some control-type code points
do not have names. This field will be empty for
<tt>&quot;Surrogate&quot;</tt> and <tt>&quot;Private
Use&quot;</tt> code points, and for the others without a
name, it will contain a description enclosed in angle
brackets, like <tt>&quot;&lt;control&gt;&quot;</tt>.</p>

<p style="margin-left:11%;"><b>category</b></p>

<p style="margin-left:17%;">The short name of the general
category of <i>code</i>. This will match one of the keys in
the hash returned by
&quot;<i>general_categories()</i>&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;<i>prop_value_aliases()</i>&quot; function can be used
to get all the synonyms of the category name.</p>

<p style="margin-left:11%;"><b>combining</b></p>

<p style="margin-left:17%;">the combining class number for
<i>code</i> used in the Canonical Ordering Algorithm. For
Unicode 5.1, this is described in Section 3.11
<tt>&quot;Canonical Ordering Behavior&quot;</tt> available
at &lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;<i>prop_value_aliases()</i>&quot; function can be used
to get all the synonyms of the combining class number.</p>

<p style="margin-left:11%;"><b>bidi</b></p>

<p style="margin-left:17%;">bidirectional type of
<i>code</i>. This will match one of the keys in the hash
returned by &quot;<i>bidi_types()</i>&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;<i>prop_value_aliases()</i>&quot; function can be used
to get all the synonyms of the bidi type name.</p>

<p style="margin-left:11%;"><b>decomposition</b></p>

<p style="margin-left:17%;">is empty if <i>code</i> has no
decomposition; or is one or more codes (separated by spaces)
that, taken in order, represent a decomposition for
<i>code</i>. Each has at least four hexdigits. The codes may
be preceded by a word enclosed in angle brackets then a
space, like <tt>&quot;&lt;compat&gt; &quot;</tt>, giving the
type of decomposition</p>

<p style="margin-left:17%; margin-top: 1em">This
decomposition may be an intermediate one whose components
are also decomposable. Use Unicode::Normalize to get the
final decomposition.</p>

<p style="margin-left:11%;"><b>decimal</b></p>

<p style="margin-left:17%;">if <i>code</i> is a decimal
digit this is its integer numeric value</p>

<p style="margin-left:11%;"><b>digit</b></p>

<p style="margin-left:17%;">if <i>code</i> represents some
other digit-like number, this is its integer numeric
value</p>

<p style="margin-left:11%;"><b>numeric</b></p>

<p style="margin-left:17%;">if <i>code</i> represents a
whole or rational number, this is its numeric value.
Rational values are expressed as a string like
<tt>&quot;1/4&quot;</tt>.</p>

<p style="margin-left:11%;"><b>mirrored</b></p>

<p style="margin-left:17%;"><tt>&quot;Y&quot;</tt> or
<tt>&quot;N&quot;</tt> designating if <i>code</i> is
mirrored in bidirectional text</p>

<p style="margin-left:11%;"><b>unicode10</b></p>

<p style="margin-left:17%;">name of <i>code</i> in the
Unicode 1.0 standard if one existed for this code point and
is different from the current name</p>

<p style="margin-left:11%;"><b>comment</b></p>

<p style="margin-left:17%;">As of Unicode 6.0, this is
always empty.</p>

<p style="margin-left:11%;"><b>upper</b></p>

<p style="margin-left:17%;">is empty if there is no single
code point uppercase mapping for <i>code</i> (its uppercase
mapping is itself); otherwise it is that mapping expressed
as at least four hexdigits. (&quot;<i>casespec()</i>&quot;
should be used in addition to <b><i>charinfo()</i></b> for
case mappings when the calling program can cope with
multiple code point mappings.)</p>

<p style="margin-left:11%;"><b>lower</b></p>

<p style="margin-left:17%;">is empty if there is no single
code point lowercase mapping for <i>code</i> (its lowercase
mapping is itself); otherwise it is that mapping expressed
as at least four hexdigits. (&quot;<i>casespec()</i>&quot;
should be used in addition to <b><i>charinfo()</i></b> for
case mappings when the calling program can cope with
multiple code point mappings.)</p>

<p style="margin-left:11%;"><b>title</b></p>

<p style="margin-left:17%;">is empty if there is no single
code point titlecase mapping for <i>code</i> (its titlecase
mapping is itself); otherwise it is that mapping expressed
as at least four hexdigits. (&quot;<i>casespec()</i>&quot;
should be used in addition to <b><i>charinfo()</i></b> for
case mappings when the calling program can cope with
multiple code point mappings.)</p>

<p style="margin-left:11%;"><b>block</b></p>

<p style="margin-left:17%;">the block <i>code</i> belongs
to (used in <tt>&quot;\p{Blk=...}&quot;</tt>). See
&quot;Blocks versus Scripts&quot;.</p>

<p style="margin-left:11%;"><b>script</b></p>

<p style="margin-left:17%;">the script <i>code</i> belongs
to. See &quot;Blocks versus Scripts&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
cannot do (de)composition and casing based solely on the
<i>decomposition</i>, <i>combining</i>, <i>lower</i>,
<i>upper</i>, and <i>title</i> fields; you will need also
the &quot;<i>compexcl()</i>&quot;, and
&quot;<i>casespec()</i>&quot; functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charblock()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'charblock';
    my $charblock = charblock(0x41);
    my $charblock = charblock(1234);
    my $charblock = charblock(0x263a);
    my $charblock = charblock(&quot;U+263a&quot;);
    my $range     = charblock('Armenian');</pre>


<p style="margin-left:11%; margin-top: 1em">With a
&quot;code point argument&quot; <i>charblock()</i> returns
the <i>block</i> the code point belongs to, e.g.
<tt>&quot;Basic Latin&quot;</tt>. The old-style block name
is returned (see &quot;Old-style versus new-style block
names&quot;). If the code point is unassigned, this returns
the block it would belong to if it were assigned.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Blocks versus Scripts&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If supplied
with an argument that can&rsquo;t be a code point,
<i>charblock()</i> tries to do the opposite and interpret
the argument as an old-style block name. The return value is
a <i>range set</i> with one range: an anonymous list with a
single element that consists of another anonymous list whose
first element is the first code point in the block, and
whose second (and final) element is the final code point in
the block. (The extra list consisting of just one element is
so that the same program logic can be used to handle both
this return, and the return from
&quot;<i>charscript()</i>&quot; which can have multiple
ranges.) You can test whether a code point is in a range
using the &quot;<i>charinrange()</i>&quot; function. If the
argument is not a known block, <tt>&quot;undef&quot;</tt> is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charscript()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'charscript';
    my $charscript = charscript(0x41);
    my $charscript = charscript(1234);
    my $charscript = charscript(&quot;U+263a&quot;);
    my $range      = charscript('Thai');</pre>


<p style="margin-left:11%; margin-top: 1em">With a
&quot;code point argument&quot; <i>charscript()</i> returns
the <i>script</i> the code point belongs to, e.g.
<tt>&quot;Latin&quot;</tt>, <tt>&quot;Greek&quot;</tt>,
<tt>&quot;Han&quot;</tt>. If the code point is unassigned,
it returns <tt>&quot;Unknown&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If supplied
with an argument that can&rsquo;t be a code point,
<i>charscript()</i> tries to do the opposite and interpret
the argument as a script name. The return value is a
<i>range set</i>: an anonymous list of lists that contain
<i>start-of-range</i>, <i>end-of-range</i> code point pairs.
You can test whether a code point is in a range set using
the &quot;<i>charinrange()</i>&quot; function. If the
argument is not a known script, <tt>&quot;undef&quot;</tt>
is returned.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Blocks versus Scripts&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charblocks()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'charblocks';
    my $charblocks = charblocks();</pre>



<p style="margin-left:11%; margin-top: 1em"><i>charblocks()</i>
returns a reference to a hash with the known block names as
the keys, and the code point ranges (see
&quot;<i>charblock()</i>&quot;) as the values.</p>

<p style="margin-left:11%; margin-top: 1em">The names are
in the old-style (see &quot;Old-style versus new-style block
names&quot;).</p>


<p style="margin-left:11%; margin-top: 1em">prop_invmap(&quot;block&quot;)
can be used to get this same data in a different type of
data structure.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Blocks versus Scripts&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charscripts()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();</pre>



<p style="margin-left:11%; margin-top: 1em"><i>charscripts()</i>
returns a reference to a hash with the known script names as
the keys, and the code point ranges (see
&quot;<i>charscript()</i>&quot;) as the values.</p>


<p style="margin-left:11%; margin-top: 1em">prop_invmap(&quot;script&quot;)
can be used to get this same data in a different type of
data structure.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Blocks versus Scripts&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>charinrange()</i></b>
<br>
In addition to using the <tt>&quot;\p{Blk=...}&quot;</tt>
and <tt>&quot;\P{Blk=...}&quot;</tt> constructs, you can
also test whether a code point is in the <i>range</i> as
returned by &quot;<i>charblock()</i>&quot; and
&quot;<i>charscript()</i>&quot; or as the values of the hash
returned by &quot;<i>charblocks()</i>&quot; and
&quot;<i>charscripts()</i>&quot; by using
<i>charinrange()</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use Unicode::UCD qw(charscript charinrange);
    $range = charscript('Hiragana');
    print &quot;looks like hiragana\n&quot; if charinrange($range, $codepoint);</pre>



<p style="margin-left:11%; margin-top: 1em"><b><i>general_categories()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'general_categories';
    my $categories = general_categories();</pre>


<p style="margin-left:11%; margin-top: 1em">This returns a
reference to a hash which has short general category names
(such as <tt>&quot;Lu&quot;</tt>, <tt>&quot;Nd&quot;</tt>,
<tt>&quot;Zs&quot;</tt>, <tt>&quot;S&quot;</tt>) as keys and
long names (such as <tt>&quot;UppercaseLetter&quot;</tt>,
<tt>&quot;DecimalNumber&quot;</tt>,
<tt>&quot;SpaceSeparator&quot;</tt>,
<tt>&quot;Symbol&quot;</tt>) as values. The hash is
reversible in case you need to go from the long names to the
short names. The general category is the one returned from
&quot;<i>charinfo()</i>&quot; under the
<tt>&quot;category&quot;</tt> key.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;<i>prop_value_aliases()</i>&quot; function can be used
to get all the synonyms of the category name.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>bidi_types()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'bidi_types';
    my $categories = bidi_types();</pre>


<p style="margin-left:11%; margin-top: 1em">This returns a
reference to a hash which has the short bidi (bidirectional)
type names (such as <tt>&quot;L&quot;</tt>,
<tt>&quot;R&quot;</tt>) as keys and long names (such as
<tt>&quot;Left&minus;to&minus;Right&quot;</tt>,
<tt>&quot;Right&minus;to&minus;Left&quot;</tt>) as values.
The hash is reversible in case you need to go from the long
names to the short names. The bidi type is the one returned
from &quot;<i>charinfo()</i>&quot; under the
<tt>&quot;bidi&quot;</tt> key. For the exact meaning of the
various bidi classes the Unicode <small>TR9</small> is
recommended reading:
&lt;http://www.unicode.org/reports/tr9/&gt; (as of Unicode
5.0.0)</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;<i>prop_value_aliases()</i>&quot; function can be used
to get all the synonyms of the bidi type name.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>compexcl()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'compexcl';
    my $compexcl = compexcl(0x09dc);</pre>


<p style="margin-left:11%; margin-top: 1em">This routine is
included for backwards compatibility, but as of Perl 5.12,
for most purposes it is probably more convenient to use one
of the following instead:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $compexcl = chr(0x09dc) =~ /\p{Comp_Ex};
    my $compexcl = chr(0x09dc) =~ /\p{Full_Composition_Exclusion};</pre>


<p style="margin-left:11%; margin-top: 1em">or even</p>

<pre style="margin-left:11%; margin-top: 1em">    my $compexcl = chr(0x09dc) =~ /\p{CE};
    my $compexcl = chr(0x09dc) =~ /\p{Composition_Exclusion};</pre>


<p style="margin-left:11%; margin-top: 1em">The first two
forms return <b>true</b> if the &quot;code point
argument&quot; should not be produced by composition
normalization. For the final two forms to return
<b>true</b>, it is additionally required that this fact not
otherwise be determinable from the Unicode data base.</p>

<p style="margin-left:11%; margin-top: 1em">This routine
behaves identically to the final two forms. That is, it does
not return <b>true</b> if the code point has a decomposition
consisting of another single code point, nor if its
decomposition starts with a code point whose combining class
is non-zero. Code points that meet either of these
conditions should also not be produced by composition
normalization, which is probably why you should use the
<tt>&quot;Full_Composition_Exclusion&quot;</tt> property
instead, as shown above.</p>

<p style="margin-left:11%; margin-top: 1em">The routine
returns <b>false</b> otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>casefold()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'casefold';
    my $casefold = casefold(0xDF);
    if (defined $casefold) {
        my @full_fold_hex = split / /, $casefold&minus;&gt;{'full'};
        my $full_fold_string =
                    join &quot;&quot;, map {chr(hex($_))} @full_fold_hex;
        my @turkic_fold_hex =
                        split / /, ($casefold&minus;&gt;{'turkic'} ne &quot;&quot;)
                                        ? $casefold&minus;&gt;{'turkic'}
                                        : $casefold&minus;&gt;{'full'};
        my $turkic_fold_string =
                        join &quot;&quot;, map {chr(hex($_))} @turkic_fold_hex;
    }
    if (defined $casefold &amp;&amp; $casefold&minus;&gt;{'simple'} ne &quot;&quot;) {
        my $simple_fold_hex = $casefold&minus;&gt;{'simple'};
        my $simple_fold_string = chr(hex($simple_fold_hex));
    }</pre>


<p style="margin-left:11%; margin-top: 1em">This returns
the (almost) locale-independent case folding of the
character specified by the &quot;code point argument&quot;.
(Starting in Perl v5.16, the core function
<tt>&quot;fc()&quot;</tt> returns the
<tt>&quot;full&quot;</tt> mapping (described below) faster
than this does, and for entire strings.)</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
case folding for the input code point,
<tt>&quot;undef&quot;</tt> is returned.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
case folding for that code point, a reference to a hash with
the following fields is returned: <b><br>
code</b></p>

<p style="margin-left:17%;">the input &quot;code point
argument&quot; expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four
hexdigits</p>

<p style="margin-left:11%;"><b>full</b></p>

<p style="margin-left:17%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
case folding for <i>code</i>. Each has at least four
hexdigits.</p>

<p style="margin-left:11%;"><b>simple</b></p>

<p style="margin-left:17%;">is empty, or is exactly one
code with at least four hexdigits which can be used as an
alternative case folding when the calling program cannot
cope with the fold being a sequence of multiple code points.
If <i>full</i> is just one code point, then <i>simple</i>
equals <i>full</i>. If there is no single code point folding
defined for <i>code</i>, then <i>simple</i> is the empty
string. Otherwise, it is an inferior, but still
better-than-nothing alternative folding to <i>full</i>.</p>

<p style="margin-left:11%;"><b>mapping</b></p>

<p style="margin-left:17%;">is the same as <i>simple</i> if
<i>simple</i> is not empty, and it is the same as
<i>full</i> otherwise. It can be considered to be the
simplest possible folding for <i>code</i>. It is defined
primarily for backwards compatibility.</p>

<p style="margin-left:11%;"><b>status</b></p>

<p style="margin-left:17%;">is <tt>&quot;C&quot;</tt> (for
<tt>&quot;common&quot;</tt>) if the best possible fold is a
single code point (<i>simple</i> equals <i>full</i> equals
<i>mapping</i>). It is <tt>&quot;S&quot;</tt> if there are
distinct folds, <i>simple</i> and <i>full</i>
(<i>mapping</i> equals <i>simple</i>). And it is
<tt>&quot;F&quot;</tt> if there is only a <i>full</i> fold
(<i>mapping</i> equals <i>full</i>; <i>simple</i> is empty).
Note that this describes the contents of <i>mapping</i>. It
is defined primarily for backwards compatibility.</p>

<p style="margin-left:17%; margin-top: 1em">For Unicode
versions between 3.1 and 3.1.1 inclusive, <i>status</i> can
also be <tt>&quot;I&quot;</tt> which is the same as
<tt>&quot;C&quot;</tt> but is a special case for dotted
uppercase I and dotless lowercase i: <b><br>
*</b> If you use this &quot;I&quot; mapping</p>

<p style="margin-left:23%;">the result is case-insensitive,
but dotless and dotted I&rsquo;s are not distinguished</p>

<p style="margin-left:17%;"><b>*</b> If you exclude this
&quot;I&quot; mapping</p>

<p style="margin-left:23%;">the result is not fully
case-insensitive, but dotless and dotted I&rsquo;s are
distinguished</p>

<p style="margin-left:11%;"><b>turkic</b></p>

<p style="margin-left:17%;">contains any special folding
for Turkic languages. For versions of Unicode starting with
3.2, this field is empty unless <i>code</i> has a different
folding in Turkic languages, in which case it is one or more
codes (separated by spaces) that, taken in order, give the
code points for the case folding for <i>code</i> in those
languages. Each code has at least four hexdigits. Note that
this folding does not maintain canonical equivalence without
additional processing.</p>

<p style="margin-left:17%; margin-top: 1em">For Unicode
versions between 3.1 and 3.1.1 inclusive, this field is
empty unless there is a special folding for Turkic
languages, in which case <i>status</i> is
<tt>&quot;I&quot;</tt>, and <i>mapping</i>, <i>full</i>,
<i>simple</i>, and <i>turkic</i> are all equal.</p>

<p style="margin-left:11%; margin-top: 1em">Programs that
want complete generality and the best folding results should
use the folding contained in the <i>full</i> field. But note
that the fold for some code points will be a sequence of
multiple code points.</p>

<p style="margin-left:11%; margin-top: 1em">Programs that
can&rsquo;t cope with the fold mapping being multiple code
points can use the folding contained in the <i>simple</i>
field, with the loss of some generality. In Unicode 5.1,
about 7% of the defined foldings have no single code point
folding.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>mapping</i> and <i>status</i> fields are provided for
backwards compatibility for existing programs. They contain
the same values as in previous versions of this
function.</p>

<p style="margin-left:11%; margin-top: 1em">Locale is not
completely independent. The <i>turkic</i> field contains
results to use when the locale is a Turkic language.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information about case mappings see
&lt;http://www.unicode.org/unicode/reports/tr21&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>casespec()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'casespec';
    my $casespec = casespec(0xFB00);</pre>


<p style="margin-left:11%; margin-top: 1em">This returns
the potentially locale-dependent case mappings of the
&quot;code point argument&quot;. The mappings may be longer
than a single code point (which the basic Unicode case
mappings as returned by &quot;<i>charinfo()</i>&quot; never
are).</p>

<p style="margin-left:11%; margin-top: 1em">If there are no
case mappings for the &quot;code point argument&quot;, or if
all three possible mappings (<i>lower</i>, <i>title</i> and
<i>upper</i>) result in single code points and are locale
independent and unconditional, <tt>&quot;undef&quot;</tt> is
returned (which means that the case mappings, if any, for
the code point are those returned by
&quot;<i>charinfo()</i>&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, a
reference to a hash giving the mappings (or a reference to a
hash of such hashes, explained below) is returned with the
following keys and their meanings:</p>

<p style="margin-left:11%; margin-top: 1em">The keys in the
bottom layer hash with the meanings of their values are:
<b><br>
code</b></p>

<p style="margin-left:17%;">the input &quot;code point
argument&quot; expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four
hexdigits</p>

<p style="margin-left:11%;"><b>lower</b></p>

<p style="margin-left:17%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
lower case of <i>code</i>. Each has at least four
hexdigits.</p>

<p style="margin-left:11%;"><b>title</b></p>

<p style="margin-left:17%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
title case of <i>code</i>. Each has at least four
hexdigits.</p>

<p style="margin-left:11%;"><b>upper</b></p>

<p style="margin-left:17%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
upper case of <i>code</i>. Each has at least four
hexdigits.</p>

<p style="margin-left:11%;"><b>condition</b></p>

<p style="margin-left:17%;">the conditions for the mappings
to be valid. If <tt>&quot;undef&quot;</tt>, the mappings are
always valid. When defined, this field is a list of
conditions, all of which must be true for the mappings to be
valid. The list consists of one or more <i>locales</i> (see
below) and/or <i>contexts</i> (explained in the next
paragraph), separated by spaces. (Other than as used to
separate elements, spaces are to be ignored.) Case
distinctions in the condition list are not significant.
Conditions preceded by &quot; <small>NON_</small> &quot;
represent the negation of the condition.</p>

<p style="margin-left:17%; margin-top: 1em">A
<i>context</i> is one of those defined in the Unicode
standard. For Unicode 5.1, they are defined in Section 3.13
<tt>&quot;Default Case Operations&quot;</tt> available at
&lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;. These
are for context-sensitive casing.</p>

<p style="margin-left:11%; margin-top: 1em">The hash
described above is returned for locale-independent casing,
where at least one of the mappings has length longer than
one. If <tt>&quot;undef&quot;</tt> is returned, the code
point may have mappings, but if so, all are length one, and
are returned by &quot;<i>charinfo()</i>&quot;. Note that
when this function does return a value, it will be for the
complete set of mappings for a code point, even those whose
length is one.</p>

<p style="margin-left:11%; margin-top: 1em">If there are
additional casing rules that apply only in certain locales,
an additional key for each will be defined in the returned
hash. Each such key will be its locale name, defined as a
2&minus;letter <small>ISO</small> 3166 country code,
possibly followed by a &quot;_&quot; and a 2&minus;letter
<small>ISO</small> language code (possibly followed by a
&quot;_&quot; and a variant code). You can find the lists of
all possible locales, see Locale::Country and
Locale::Language. (In Unicode 6.0, the only locales returned
by this function are <tt>&quot;lt&quot;</tt>,
<tt>&quot;tr&quot;</tt>, and <tt>&quot;az&quot;</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">Each locale key
is a reference to a hash that has the form above, and gives
the casing rules for that particular locale, which take
precedence over the locale-independent ones when in that
locale.</p>

<p style="margin-left:11%; margin-top: 1em">If the only
casing for a code point is locale-dependent, then the
returned hash will not have any of the base keys, like
<tt>&quot;code&quot;</tt>, <tt>&quot;upper&quot;</tt>, etc.,
but will contain only locale keys.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information about case mappings see
&lt;http://www.unicode.org/unicode/reports/tr21/&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>namedseq()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'namedseq';
    my $namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);
    my @namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);
    my %namedseq = namedseq();</pre>


<p style="margin-left:11%; margin-top: 1em">If used with a
single argument in a scalar context, returns the string
consisting of the code points of the named sequence, or
<tt>&quot;undef&quot;</tt> if no named sequence by that name
exists. If used with a single argument in a list context, it
returns the list of the ordinals of the code points. If used
with no arguments in a list context, returns a hash with the
names of the named sequences as the keys and the named
sequences as strings as the values. Otherwise, it returns
<tt>&quot;undef&quot;</tt> or an empty list depending on the
context.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only operates on officially approved (not provisional) named
sequences.</p>

<p style="margin-left:11%; margin-top: 1em">Note that as of
Perl 5.14, <tt>&quot;\N{KATAKANA LETTER AINU P}&quot;</tt>
will insert the named sequence into double-quoted strings,
and <tt>&quot;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&quot;</tt> will return the same string
this function does, but will also operate on character names
that aren&rsquo;t named sequences, without you having to
know which are which. See charnames.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>num()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'num';
    my $val = num(&quot;123&quot;);
    my $one_quarter = num(&quot;\N{VULGAR FRACTION 1/4}&quot;);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;num&quot;
returns the numeric value of the input Unicode string; or
<tt>&quot;undef&quot;</tt> if it doesn&rsquo;t think the
entire string has a completely valid, safe numeric
value.</p>

<p style="margin-left:11%; margin-top: 1em">If the string
is just one character in length, the Unicode numeric value
is returned if it has one, or <tt>&quot;undef&quot;</tt>
otherwise. Note that this need not be a whole number.
<tt>&quot;num(&quot;\N{TIBETAN DIGIT HALF
ZERO}&quot;)&quot;</tt>, for example returns &minus;0.5.</p>

<p style="margin-left:11%; margin-top: 1em">If the string
is more than one character, <tt>&quot;undef&quot;</tt> is
returned unless all its characters are decimal digits (that
is, they would match <tt>&quot;\d+&quot;</tt>), from the
same script. For example if you have an <small>ASCII</small>
&rsquo;0&rsquo; and a Bengali &rsquo;3&rsquo;, mixed
together, they aren&rsquo;t considered a valid number, and
<tt>&quot;undef&quot;</tt> is returned. A further
restriction is that the digits all have to be of the same
form. A half-width digit mixed with a full-width one will
return <tt>&quot;undef&quot;</tt>. The Arabic script has two
sets of digits; <tt>&quot;num&quot;</tt> will return
<tt>&quot;undef&quot;</tt> unless all the digits in the
string come from the same set.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;num&quot;</tt>
errs on the side of safety, and there may be valid strings
of decimal digits that it doesn&rsquo;t recognize. Note that
Unicode defines a number of &quot;digit&quot; characters
that aren&rsquo;t &quot;decimal digit&quot; characters.
&quot;Decimal digits&quot; have the property that they have
a positional value, i.e., there is a units position, a
10&rsquo;s position, a 100&rsquo;s, etc, <small>AND</small>
they are arranged in Unicode in blocks of 10 contiguous code
points. The Chinese digits, for example, are not in such a
contiguous block, and so Unicode doesn&rsquo;t view them as
decimal digits, but merely digits, and so
<tt>&quot;\d&quot;</tt> will not match them. A
single-character string containing one of these digits will
have its decimal value returned by <tt>&quot;num&quot;</tt>,
but any longer string containing only these digits will
return <tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Strings of
multiple sub&minus; and superscripts are not recognized as
numbers. You can use either of the compatibility
decompositions in Unicode::Normalize to change these into
digits, and then call <tt>&quot;num&quot;</tt> on the
result.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>prop_aliases()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'prop_aliases';
    my ($short_name, $full_name, @other_names) = prop_aliases(&quot;space&quot;);
    my $same_full_name = prop_aliases(&quot;Space&quot;);     # Scalar context
    my ($same_short_name) = prop_aliases(&quot;Space&quot;);  # gets 0th element
    print &quot;The full name is $full_name\n&quot;;
    print &quot;The short name is $short_name\n&quot;;
    print &quot;The other aliases are: &quot;, join(&quot;, &quot;, @other_names), &quot;\n&quot;;
    prints:
    The full name is White_Space
    The short name is WSpace
    The other aliases are: Space</pre>


<p style="margin-left:11%; margin-top: 1em">Most Unicode
properties have several synonymous names. Typically, there
is at least a short name, convenient to type, and a long
name that more fully describes the property, and hence is
more easily understood.</p>

<p style="margin-left:11%; margin-top: 1em">If you know one
name for a Unicode property, you can use
<tt>&quot;prop_aliases&quot;</tt> to find either the long
name (when called in scalar context), or a list of all of
the names, somewhat ordered so that the short name is in the
0th element, the long name in the next element, and any
other synonyms are in the remaining elements, in no
particular order.</p>

<p style="margin-left:11%; margin-top: 1em">The long name
is returned in a form nicely capitalized, suitable for
printing.</p>

<p style="margin-left:11%; margin-top: 1em">The input
parameter name is loosely matched, which means that white
space, hyphens, and underscores are ignored (except for the
trailing underscore in the old_form grandfathered-in
<tt>&quot;L_&quot;</tt>, which is better written as
<tt>&quot;LC&quot;</tt>, and both of which mean
<tt>&quot;General_Category=Cased Letter&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">If the name is
unknown, <tt>&quot;undef&quot;</tt> is returned (or an empty
list in list context). Note that Perl typically recognizes
property names in regular expressions with an optional
<tt>&quot;&quot;Is_&quot;</tt>&quot; (with or without the
underscore) prefixed to them, such as
<tt>&quot;\p{isgc=punct}&quot;</tt>. This function does not
recognize those in the input, returning
<tt>&quot;undef&quot;</tt>. Nor are they included in the
output as possible synonyms.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;prop_aliases&quot;</tt>
does know about the Perl extensions to Unicode properties,
such as <tt>&quot;Any&quot;</tt> and
<tt>&quot;XPosixAlpha&quot;</tt>, and the single form
equivalents to Unicode properties such as
<tt>&quot;XDigit&quot;</tt>, <tt>&quot;Greek&quot;</tt>,
<tt>&quot;In_Greek&quot;</tt>, and
<tt>&quot;Is_Greek&quot;</tt>. The final example
demonstrates that the <tt>&quot;Is_&quot;</tt> prefix is
recognized for these extensions; it is needed to resolve
ambiguities. For example,
<tt>&quot;prop_aliases('lc')&quot;</tt> returns the list
<tt>&quot;(lc, Lowercase_Mapping)&quot;</tt>, but
<tt>&quot;prop_aliases('islc')&quot;</tt> returns
<tt>&quot;(Is_LC, Cased_Letter)&quot;</tt>. This is because
<tt>&quot;islc&quot;</tt> is a Perl extension which is short
for <tt>&quot;General_Category=Cased Letter&quot;</tt>. The
lists returned for the Perl extensions will not include the
<tt>&quot;Is_&quot;</tt> prefix (whether or not the input
had it) unless needed to resolve ambiguities, as shown in
the <tt>&quot;islc&quot;</tt> example, where the returned
list had one element containing <tt>&quot;Is_&quot;</tt>,
and the other without.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible for the reverse to happen:
<tt>&quot;prop_aliases('isc')&quot;</tt> returns the list
<tt>&quot;(isc, ISO_Comment)&quot;</tt>; whereas
<tt>&quot;prop_aliases('c')&quot;</tt> returns <tt>&quot;(C,
Other)&quot;</tt> (the latter being a Perl extension meaning
<tt>&quot;General_Category=Other&quot;</tt>.
&quot;Properties accessible through Unicode::UCD&quot; in
perluniprops lists the available forms, including which ones
are discouraged from use.</p>

<p style="margin-left:11%; margin-top: 1em">Those
discouraged forms are accepted as input to
<tt>&quot;prop_aliases&quot;</tt>, but are not returned in
the lists. <tt>&quot;prop_aliases('isL&amp;')&quot;</tt> and
<tt>&quot;prop_aliases('isL_')&quot;</tt>, which are old
synonyms for <tt>&quot;Is_LC&quot;</tt> and should not be
used in new code, are examples of this. These both return
<tt>&quot;(Is_LC, Cased_Letter)&quot;</tt>. Thus this
function allows you to take a discourarged form, and find
its acceptable alternatives. The same goes with single-form
Block property equivalences. Only the forms that begin with
<tt>&quot;In_&quot;</tt> are not discouraged; if you pass
<tt>&quot;prop_aliases&quot;</tt> a discouraged form, you
will get back the equivalent ones that begin with
<tt>&quot;In_&quot;</tt>. It will otherwise look like a
new-style block name (see. &quot;Old-style versus new-style
block names&quot;).</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;prop_aliases&quot;</tt>
does not know about any user-defined properties, and will
return <tt>&quot;undef&quot;</tt> if called with one of
those. Likewise for Perl internal properties, with the
exception of &quot;Perl_Decimal_Digit&quot; which it does
know about (and which is documented below in
&quot;<i>prop_invmap()</i>&quot;).</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>prop_value_aliases()</i></b></p>


<pre style="margin-left:11%;">    use Unicode::UCD 'prop_value_aliases';
    my ($short_name, $full_name, @other_names)
                                   = prop_value_aliases(&quot;Gc&quot;, &quot;Punct&quot;);
    my $same_full_name = prop_value_aliases(&quot;Gc&quot;, &quot;P&quot;);   # Scalar cntxt
    my ($same_short_name) = prop_value_aliases(&quot;Gc&quot;, &quot;P&quot;); # gets 0th
                                                           # element
    print &quot;The full name is $full_name\n&quot;;
    print &quot;The short name is $short_name\n&quot;;
    print &quot;The other aliases are: &quot;, join(&quot;, &quot;, @other_names), &quot;\n&quot;;
    prints:
    The full name is Punctuation
    The short name is P
    The other aliases are: Punct</pre>


<p style="margin-left:11%; margin-top: 1em">Some Unicode
properties have a restricted set of legal values. For
example, all binary properties are restricted to just
<tt>&quot;true&quot;</tt> or <tt>&quot;false&quot;</tt>; and
there are only a few dozen possible General Categories.</p>

<p style="margin-left:11%; margin-top: 1em">For such
properties, there are usually several synonyms for each
possible value. For example, in binary properties,
<i>truth</i> can be represented by any of the strings
&quot;Y&quot;, &quot;Yes&quot;, &quot;T&quot;, or
&quot;True&quot;; and the General Category
&quot;Punctuation&quot; by that string, or
&quot;Punct&quot;, or simply &quot;P&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Like property
names, there is typically at least a short name for each
such property-value, and a long name. If you know any name
of the property-value, you can use
<tt>&quot;prop_value_aliases&quot;</tt>() to get the long
name (when called in scalar context), or a list of all the
names, with the short name in the 0th element, the long name
in the next element, and any other synonyms in the remaining
elements, in no particular order, except that any
all-numeric synonyms will be last.</p>

<p style="margin-left:11%; margin-top: 1em">The long name
is returned in a form nicely capitalized, suitable for
printing.</p>

<p style="margin-left:11%; margin-top: 1em">Case, white
space, hyphens, and underscores are ignored in the input
parameters (except for the trailing underscore in the
old-form grandfathered-in general category property value
<tt>&quot;L_&quot;</tt>, which is better written as
<tt>&quot;LC&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">If either name
is unknown, <tt>&quot;undef&quot;</tt> is returned. Note
that Perl typically recognizes property names in regular
expressions with an optional
<tt>&quot;&quot;Is_&quot;</tt>&quot; (with or without the
underscore) prefixed to them, such as
<tt>&quot;\p{isgc=punct}&quot;</tt>. This function does not
recognize those in the property parameter, returning
<tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If called with
a property that doesn&rsquo;t have synonyms for its values,
it returns the input value, possibly normalized with
capitalization and underscores.</p>

<p style="margin-left:11%; margin-top: 1em">For the block
property, new-style block names are returned (see
&quot;Old-style versus new-style block names&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">To find the
synonyms for single-forms, such as
<tt>&quot;\p{Any}&quot;</tt>, use
&quot;<i>prop_aliases()</i>&quot; instead.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;prop_value_aliases&quot;</tt>
does not know about any user-defined properties, and will
return <tt>&quot;undef&quot;</tt> if called with one of
those.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>prop_invlist()</i></b>
<tt><br>
&quot;prop_invlist&quot;</tt> returns an inversion list
(described below) that defines all the code points for the
binary Unicode property (or &quot;property=value&quot; pair)
given by the input parameter string:</p>

<pre style="margin-left:11%; margin-top: 1em"> use feature 'say';
 use Unicode::UCD 'prop_invlist';
 say join &quot;, &quot;, prop_invlist(&quot;Any&quot;);
 prints:
 0, 1114112</pre>


<p style="margin-left:11%; margin-top: 1em">An empty list
is returned if the input is unknown; the number of elements
in the list is returned if called in scalar context.</p>

<p style="margin-left:11%; margin-top: 1em">perluniprops
gives the list of properties that this function accepts, as
well as all the possible forms for them (including with the
optional &quot;Is_&quot; prefixes). (Except this function
doesn&rsquo;t accept any Perl-internal properties, some of
which are listed there.) This function uses the same loose
or tighter matching rules for resolving the input
property&rsquo;s name as is done for regular expressions.
These are also specified in perluniprops. Examples of using
the &quot;property=value&quot; form are:</p>

<pre style="margin-left:11%; margin-top: 1em"> say join &quot;, &quot;, prop_invlist(&quot;Script=Shavian&quot;);
 prints:
 66640, 66688
 say join &quot;, &quot;, prop_invlist(&quot;ASCII_Hex_Digit=No&quot;);
 prints:
 0, 48, 58, 65, 71, 97, 103
 say join &quot;, &quot;, prop_invlist(&quot;ASCII_Hex_Digit=Yes&quot;);
 prints:
 48, 58, 65, 71, 97, 103</pre>


<p style="margin-left:11%; margin-top: 1em">Inversion lists
are a compact way of specifying Unicode property-value
definitions. The 0th item in the list is the lowest code
point that has the property-value. The next item (item [1])
is the lowest code point beyond that one that does
<small>NOT</small> have the property-value. And the next
item beyond that ([2]) is the lowest code point beyond that
one that does have the property-value, and so on. Put
another way, each element in the list gives the beginning of
a range that has the property-value (for even numbered
elements), or doesn&rsquo;t have the property-value (for odd
numbered elements). The name for this data structure stems
from the fact that each element in the list toggles (or
inverts) whether the corresponding range is or isn&rsquo;t
on the list.</p>

<p style="margin-left:11%; margin-top: 1em">In the final
example above, the first <small>ASCII</small> Hex digit is
code point 48, the character &quot;0&quot;, and all code
points from it through 57 (a &quot;9&quot;) are
<small>ASCII</small> hex digits. Code points 58 through 64
aren&rsquo;t, but 65 (an &quot;A&quot;) through 70 (an
&quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102
(&quot;f&quot;). 103 starts a range of code points that
aren&rsquo;t <small>ASCII</small> hex digits. That range
extends to infinity, which on your computer can be found in
the variable <tt>$Unicode::UCD::MAX_CP</tt>. (This variable
is as close to infinity as Perl can get on your platform,
and may be too high for some operations to work; you may
wish to use a smaller number for your purposes.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
inversion lists returned by this function can possibly
include non-Unicode code points, that is anything above
0x10FFFF. This is in contrast to Perl regular expression
matches on those code points, in which a non-Unicode code
point always fails to match. For example, both of these have
the same result:</p>

<pre style="margin-left:11%; margin-top: 1em"> chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Fails!</pre>


<p style="margin-left:11%; margin-top: 1em">And both raise
a warning that a Unicode property is being used on a
non-Unicode code point. It is arguable as to which is the
correct thing to do here. This function has chosen the way
opposite to the Perl regular expression behavior. This
allows you to easily flip to to the Perl regular expression
way (for you to go in the other direction would be far
harder). Simply add 0x110000 at the end of the non-empty
returned list if it isn&rsquo;t already that value; and pop
that value if it is; like:</p>

<pre style="margin-left:11%; margin-top: 1em"> my @list = prop_invlist(&quot;foo&quot;);
 if (@list) {
     if ($list[&minus;1] == 0x110000) {
         pop @list;  # Defeat the turning on for above Unicode
     }
     else {
         push @list, 0x110000; # Turn off for above Unicode
     }
 }</pre>


<p style="margin-left:11%; margin-top: 1em">It is a simple
matter to expand out an inversion list to a full list of all
code points that have the property-value:</p>

<pre style="margin-left:11%; margin-top: 1em"> my @invlist = prop_invlist($property_name);
 die &quot;empty&quot; unless @invlist;
 my @full_list;
 for (my $i = 0; $i &lt; @invlist; $i += 2) {
    my $upper = ($i + 1) &lt; @invlist
                ? $invlist[$i+1] &minus; 1      # In range
                : $Unicode::UCD::MAX_CP;  # To infinity.  You may want
                                          # to stop much much earlier;
                                          # going this high may expose
                                          # perl deficiencies with very
                                          # large numbers.
    for my $j ($invlist[$i] .. $upper) {
        push @full_list, $j;
    }
 }</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;prop_invlist&quot;
does not know about any user-defined nor Perl internal-only
properties, and will return <tt>&quot;undef&quot;</tt> if
called with one of those.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>prop_invmap()</i></b></p>


<pre style="margin-left:11%;"> use Unicode::UCD 'prop_invmap';
 my ($list_ref, $map_ref, $format, $missing)
                                      = prop_invmap(&quot;General Category&quot;);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;prop_invmap&quot;
is used to get the complete mapping definition for a
property, in the form of an inversion map. An inversion map
consists of two parallel arrays. One is an ordered list of
code points that mark range beginnings, and the other gives
the value (or mapping) that all code points in the
corresponding range have.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;prop_invmap&quot;</tt>
is called with the name of the desired property. The name is
loosely matched, meaning that differences in case,
white-space, hyphens, and underscores are not meaningful
(except for the trailing underscore in the old-form
grandfathered-in property <tt>&quot;L_&quot;</tt>, which is
better written as <tt>&quot;LC&quot;</tt>, or even better,
<tt>&quot;Gc=LC&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Many Unicode
properties have more than one name (or alias).
<tt>&quot;prop_invmap&quot;</tt> understands all of these,
including Perl extensions to them. Ambiguities are resolved
as described above for &quot;<i>prop_aliases()</i>&quot;.
The Perl internal property &quot;Perl_Decimal_Digit,
described below, is also accepted.
<tt>&quot;undef&quot;</tt> is returned if the property name
is unknown. See &quot;Properties accessible through
Unicode::UCD&quot; in perluniprops for the properties
acceptable as inputs to this function.</p>

<p style="margin-left:11%; margin-top: 1em">It is a fatal
error to call this function except in list context.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the the two arrays that form the inversion map,
<tt>&quot;prop_invmap&quot;</tt> returns two other values;
one is a scalar that gives some details as to the format of
the entries of the map array; the other is used for
specialized purposes, described at the end of this
section.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
<tt>&quot;prop_invmap&quot;</tt> returns a 4 element list.
For example,</p>

<pre style="margin-left:11%; margin-top: 1em"> my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
                                                 = prop_invmap(&quot;Block&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">In this call,
the two arrays will be populated as shown below (for Unicode
6.0):</p>

<pre style="margin-left:11%; margin-top: 1em"> Index  @blocks_ranges  @blocks_maps
   0        0x0000      Basic Latin
   1        0x0080      Latin&minus;1 Supplement
   2        0x0100      Latin Extended&minus;A
   3        0x0180      Latin Extended&minus;B
   4        0x0250      IPA Extensions
   5        0x02B0      Spacing Modifier Letters
   6        0x0300      Combining Diacritical Marks
   7        0x0370      Greek and Coptic
   8        0x0400      Cyrillic
  ...
 233        0x2B820     No_Block
 234        0x2F800     CJK Compatibility Ideographs Supplement
 235        0x2FA20     No_Block
 236        0xE0000     Tags
 237        0xE0080     No_Block
 238        0xE0100     Variation Selectors Supplement
 239        0xE01F0     No_Block
 240        0xF0000     Supplementary Private Use Area&minus;A
 241        0x100000    Supplementary Private Use Area&minus;B
 242        0x110000    No_Block</pre>


<p style="margin-left:11%; margin-top: 1em">The first line
(with Index [0]) means that the value for code point 0 is
&quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the
<tt>@blocks_ranges</tt> column in the second line means that
the value from the first line, &quot;Basic Latin&quot;,
extends to all code points in the range from 0 up to but not
including 0x0080, that is, through 127. In other words, the
code points from 0 to 127 are all in the &quot;Basic
Latin&quot; block. Similarly, all code points in the range
from 0x0080 up to (but not including) 0x0100 are in the
block named &quot;Latin&minus;1 Supplement&quot;, etc.
(Notice that the return is the old-style block names; see
&quot;Old-style versus new-style block names&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The final line
(with Index [242]) means that the value for all code points
above the legal Unicode maximum code point have the value
&quot;No_Block&quot;, which is the term Unicode uses for a
non-existing block.</p>

<p style="margin-left:11%; margin-top: 1em">The arrays
completely specify the mappings for all possible code
points. The final element in an inversion map returned by
this function will always be for the range that consists of
all the code points that aren&rsquo;t legal Unicode, but
that are expressible on the platform. (That is, it starts
with code point 0x110000, the first code point above the
legal Unicode maximum, and extends to infinity.) The value
for that range will be the same that any typical unassigned
code point has for the specified property. (Certain
unassigned code points are not &quot;typical&quot;; for
example the non-character code points, or those in blocks
that are to be written right-to-left. The above-Unicode
range&rsquo;s value is not based on these atypical code
points.) It could be argued that, instead of treating these
as unassigned Unicode code points, the value for this range
should be <tt>&quot;undef&quot;</tt>. If you wish, you can
change the returned arrays accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">The maps are
almost always simple scalars that should be interpreted
as-is. These values are those given in the Unicode-supplied
data files, which may be inconsistent as to capitalization
and as to which synonym for a property-value is given. The
results may be normalized by using the
&quot;<i>prop_value_aliases()</i>&quot; function.</p>

<p style="margin-left:11%; margin-top: 1em">There are
exceptions to the simple scalar maps. Some properties have
some elements in their map list that are themselves lists of
scalars; and some special strings are returned that are not
to be interpreted as-is. Element [2] (placed into
<tt>$format</tt> in the example above) of the returned four
element list tells you if the map has any of these special
elements or not, as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;s&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>means all the elements of the map array are simple
scalars, with no special elements. Almost all properties are
like this, like the <tt>&quot;block&quot;</tt> example
above.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&quot;sl&quot;</b></p>

<p style="margin-left:17%;">means that some of the map
array elements have the form given by
<tt>&quot;s&quot;</tt>, and the rest are lists of scalars.
For example, here is a portion of the output of calling
<tt>&quot;prop_invmap&quot;</tt>() with the &quot;Script
Extensions&quot; property:</p>

<pre style="margin-left:17%; margin-top: 1em"> @scripts_ranges  @scripts_maps
      ...
      0x0953      Devanagari
      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
      0x0966      Devanagari
      0x0970      Common</pre>


<p style="margin-left:17%; margin-top: 1em">Here, the code
points 0x964 and 0x965 are both used in Bengali, Devanagari,
Gurmukhi, and Oriya, but no other scripts.</p>

<p style="margin-left:17%; margin-top: 1em">The Name_Alias
property is also of this form. But each scalar consists of
two components: 1) the name, and 2) the type of alias this
is. They are separated by a colon and a space. In Unicode
6.1, there are several alias types: <br>
&quot;correction&quot;</p>

<p style="margin-left:23%;">indicates that the name is a
corrected form for the original name (which remains valid)
for the same code point.</p>

<p style="margin-left:17%;">&quot;control&quot;</p>

<p style="margin-left:23%;">adds a new name for a control
character.</p>

<p style="margin-left:17%;">&quot;alternate&quot;</p>

<p style="margin-left:23%;">is an alternate name for a
character</p>

<p style="margin-left:17%;">&quot;figment&quot;</p>

<p style="margin-left:23%;">is a name for a character that
has been documented but was never in any actual
standard.</p>

<p style="margin-left:17%;">&quot;abbreviation&quot;</p>

<p style="margin-left:23%;">is a common abbreviation for a
character</p>

<p style="margin-left:17%; margin-top: 1em">The lists are
ordered (roughly) so the most preferred names come before
less preferred ones.</p>

<p style="margin-left:17%; margin-top: 1em">For
example,</p>

<pre style="margin-left:17%; margin-top: 1em"> @aliases_ranges        @alias_maps
    ...
    0x009E        [ 'PRIVACY MESSAGE: control', 'PM: abbreviation' ]
    0x009F        [ 'APPLICATION PROGRAM COMMAND: control',
                    'APC: abbreviation'
                  ]
    0x00A0        'NBSP: abbreviation'
    0x00A1        &quot;&quot;
    0x00AD        'SHY: abbreviation'
    0x00AE        &quot;&quot;
    0x01A2        'LATIN CAPITAL LETTER GHA: correction'
    0x01A3        'LATIN SMALL LETTER GHA: correction'
    0x01A4        &quot;&quot;
    ...</pre>


<p style="margin-left:17%; margin-top: 1em">A map to the
empty string means that there is no alias defined for the
code point.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;a&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>is like <tt>&quot;s&quot;</tt> in that all the map array
elements are scalars, but here they are restricted to all
being integers, and some have to be adjusted (hence the name
<tt>&quot;a&quot;</tt>) to get the correct result. For
example, in:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> my ($uppers_ranges_ref, $uppers_maps_ref, $format)
                          = prop_invmap(&quot;Simple_Uppercase_Mapping&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">the returned
arrays look like this:</p>

<pre style="margin-left:17%; margin-top: 1em"> @$uppers_ranges_ref    @$uppers_maps_ref   Note
       0                      0
      97                     65          'a' maps to 'A', b =&gt; B ...
     123                      0
     181                    924          MICRO SIGN =&gt; Greek Cap MU
     182                      0
     ...</pre>


<p style="margin-left:17%; margin-top: 1em">Let&rsquo;s
start with the second line. It says that the uppercase of
code point 97 is 65; or
<tt>&quot;uc(&quot;a&quot;)&quot;</tt> == &quot;A&quot;. But
the line is for the entire range of code points 97 through
122. To get the mapping for any code point in a range, you
take the offset it has from the beginning code point of the
range, and add that to the mapping for that first code
point. So, the mapping for 122 (&quot;z&quot;) is derived by
taking the offset of 122 from 97 (=25) and adding that to
65, yielding 90 (&quot;z&quot;). Likewise for everything in
between.</p>

<p style="margin-left:17%; margin-top: 1em">The first line
works the same way. The first map in a range is always the
correct value for its code point (because the adjustment is
0). Thus the <tt>&quot;uc(chr(0))&quot;</tt> is just itself.
Also, <tt>&quot;uc(chr(1))&quot;</tt> is also itself, as the
adjustment is 0+1&minus;0 ..
<tt>&quot;uc(chr(96))&quot;</tt> is 96.</p>

<p style="margin-left:17%; margin-top: 1em">Requiring this
simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10,
speeding up searching through them.</p>

<p style="margin-left:11%;"><b>&quot;al&quot;</b></p>

<p style="margin-left:17%;">means that some of the map
array elements have the form given by
<tt>&quot;a&quot;</tt>, and the rest are ordered lists of
code points. For example, in:</p>

<pre style="margin-left:17%; margin-top: 1em"> my ($uppers_ranges_ref, $uppers_maps_ref, $format)
                                 = prop_invmap(&quot;Uppercase_Mapping&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">the returned
arrays look like this:</p>

<pre style="margin-left:17%; margin-top: 1em"> @$uppers_ranges_ref    @$uppers_maps_ref
       0                      0
      97                     65
     123                      0
     181                    924
     182                      0
     ...
    0x0149              [ 0x02BC 0x004E ]
    0x014A                    0
    0x014B                  330
     ...</pre>


<p style="margin-left:17%; margin-top: 1em">This is the
full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format
<tt>&quot;a&quot;</tt>). The only difference between the two
in the ranges shown is that the code point at 0x0149 (
<small>LATIN SMALL LETTER</small> N <small>PRECEDED BY
APOSTROPHE</small> ) maps to a string of two characters,
0x02BC ( <small>MODIFIER LETTER APOSTROPHE</small> )
followed by 0x004E ( <small>LATIN CAPITAL LETTER</small>
N).</p>

<p style="margin-left:17%; margin-top: 1em">No adjustments
are needed to entries that are references to arrays; each
such entry will have exactly one element in its range, so
the offset is always 0.</p>

<p style="margin-left:11%;"><b>&quot;ae&quot;</b></p>

<p style="margin-left:17%;">This is like
<tt>&quot;a&quot;</tt>, but some elements are the empty
string, and should not be adjusted. The one internal Perl
property accessible by <tt>&quot;prop_invmap&quot;</tt> is
of this type: &quot;Perl_Decimal_Digit&quot; returns an
inversion map which gives the numeric values that are
represented by the Unicode decimal digit characters.
Characters that don&rsquo;t represent decimal digits map to
the empty string, like so:</p>

<pre style="margin-left:17%; margin-top: 1em"> @digits    @values
 0x0000       &quot;&quot;
 0x0030        0
 0x003A:      &quot;&quot;
 0x0660:       0
 0x066A:      &quot;&quot;
 0x06F0:       0
 0x06FA:      &quot;&quot;
 0x07C0:       0
 0x07CA:      &quot;&quot;
 0x0966:       0
 ...</pre>


<p style="margin-left:17%; margin-top: 1em">This means that
the code points from 0 to 0x2F do not represent decimal
digits; the code point 0x30 ( <small>DIGIT ZERO</small> )
represents 0; code point 0x31, ( <small>DIGIT ONE</small> ),
represents 0+1&minus;0 = 1; ... code point 0x39, (
<small>DIGIT NINE</small> ), represents 0+9&minus;0 = 9; ...
code points 0x3A through 0x65F do not represent decimal
digits; 0x660 (ARABIC-INDIC <small>DIGIT ZERO</small> ),
represents 0; ... 0x07C1 ( <small>NKO DIGIT ONE</small> ),
represents 0+1&minus;0 = 1 ...</p>

<p style="margin-left:11%;"><b>&quot;ale&quot;</b></p>

<p style="margin-left:17%;">is a combination of the
<tt>&quot;al&quot;</tt> type and the <tt>&quot;ae&quot;</tt>
type. Some of the map array elements have the forms given by
<tt>&quot;al&quot;</tt>, and the rest are the empty string.
The property <tt>&quot;NFKC_Casefold&quot;</tt> has this
form. An example slice is:</p>

<pre style="margin-left:17%; margin-top: 1em"> @$ranges_ref  @$maps_ref         Note
    ...
   0x00AA       97                FEMININE ORDINAL INDICATOR =&gt; 'a'
   0x00AB        0
   0x00AD                         SOFT HYPHEN =&gt; &quot;&quot;
   0x00AE        0
   0x00AF     [ 0x0020, 0x0304 ]  MACRON =&gt; SPACE . COMBINING MACRON
   0x00B0        0
   ...</pre>


<p style="margin-left:11%;"><b>&quot;ar&quot;</b></p>

<p style="margin-left:17%;">means that all the elements of
the map array are either rational numbers or the string
<tt>&quot;NaN&quot;</tt>, meaning &quot;Not a Number&quot;.
A rational number is either an integer, or two integers
separated by a solidus (<tt>&quot;/&quot;</tt>). The second
integer represents the denominator of the division implied
by the solidus, and is actually always positive, so it is
guaranteed not to be 0 and to not to be signed. When the
element is a plain integer (without the solidus), it may
need to be adjusted to get the correct value by adding the
offset, just as other <tt>&quot;a&quot;</tt> properties. No
adjustment is needed for fractions, as the range is
guaranteed to have just a single element, and so the offset
is always 0.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
convert the returned map to entirely scalar numbers, you can
use something like this:</p>

<pre style="margin-left:17%; margin-top: 1em"> my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
 if ($format &amp;&amp; $format eq &quot;ar&quot;) {
     map { $_ = eval $_ } @$invmap_ref;
 }</pre>


<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s
some entries from the output of the property &quot;Nv&quot;,
which has format <tt>&quot;ar&quot;</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em"> @numerics_ranges  @numerics_maps       Note
        0x00           &quot;NaN&quot;
        0x30             0           DIGIT 0 .. DIGIT 9
        0x3A           &quot;NaN&quot;
        0xB2             2           SUPERSCRIPTs 2 and 3
        0xB4           &quot;NaN&quot;
        0xB9             1           SUPERSCRIPT 1
        0xBA           &quot;NaN&quot;
        0xBC            1/4          VULGAR FRACTION 1/4
        0xBD            1/2          VULGAR FRACTION 1/2
        0xBE            3/4          VULGAR FRACTION 3/4
        0xBF           &quot;NaN&quot;
        0x660            0           ARABIC&minus;INDIC DIGIT ZERO .. NINE
        0x66A          &quot;NaN&quot;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;n&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>means the Name property. All the elements of the map
array are simple scalars, but some of them contain special
strings that require more work to get the actual name.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Entries such
as:</p>

<pre style="margin-left:17%; margin-top: 1em"> CJK UNIFIED IDEOGRAPH&minus;&lt;code point&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">mean that the
name for the code point is &quot; <small>CJK UNIFIED
IDEOGRAPH&minus;</small> &quot; with the code point
(expressed in hexadecimal) appended to it, like &quot;
<small>CJK UNIFIED IDEOGRAPH&minus;3403</small> &quot;
(similarly for
<tt>&quot;CJK&nbsp;COMPATIBILITY&nbsp;IDEOGRAPH&minus;&lt;code&nbsp;point&gt;&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Also, entries
like</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;hangul syllable&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">means that the
name is algorithmically calculated. This is easily done by
the function &quot;charnames::viacode(code)&quot; in
charnames.</p>

<p style="margin-left:17%; margin-top: 1em">Note that for
control characters (<tt>&quot;Gc=cc&quot;</tt>),
Unicode&rsquo;s data files have the string
&quot;<tt>&quot;&lt;control&gt;&quot;</tt>&quot;, but the
real name of each of these characters is the empty string.
This function returns that real name, the empty string.
(There are names for these characters, but they are
considered aliases, not the Name property name, and are
contained in the <tt>&quot;Name_Alias&quot;</tt>
property.)</p>

<p style="margin-left:11%;"><b>&quot;ad&quot;</b></p>

<p style="margin-left:17%;">means the Decomposition_Mapping
property. This property is like <tt>&quot;al&quot;</tt>
properties, except that one of the scalar elements is of the
form:</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;hangul syllable&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">This signifies
that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically
calculated. (All of them are currently in one range and no
others outisde the range are likely to ever be added to
Unicode; the <tt>&quot;n&quot;</tt> format has this same
entry.) These can be generated via the function
<i>Unicode::Normalize::NFD()</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
mapping is the one that is specified in the Unicode data
files, and to get the final decomposition, it may need to be
applied recursively.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
format begins with the letter &quot;a&quot; if and only the
property it is for requires adjustments by adding the
offsets in multi-element ranges. For all these properties,
an entry should be adjusted only if the map is a scalar
which is an integer. That is, it must match the regular
expression:</p>

<pre style="margin-left:11%; margin-top: 1em">    / ^ &minus;? \d+ $ /xa</pre>


<p style="margin-left:11%; margin-top: 1em">Further, the
first element in a range never needs adjustment, as the
adjustment would be just adding 0.</p>

<p style="margin-left:11%; margin-top: 1em">A binary search
can be used to quickly find a code point in the inversion
list, and hence its corresponding mapping.</p>

<p style="margin-left:11%; margin-top: 1em">The final
element (index [3], assigned to <tt>$default</tt> in the
&quot;block&quot; example) in the four element list returned
by this function may be useful for applications that wish to
convert the returned inversion map data structure into some
other, such as a hash. It gives the mapping that most code
points map to under the property. If you establish the
convention that any code point not explicitly listed in your
data structure maps to this value, you can potentially make
your data structure much smaller. As you construct your data
structure from the one returned by this function, simply
ignore those ranges that map to this value, generally called
the &quot;default&quot; value. For example, to convert to
the data structure searchable by
&quot;<i>charinrange()</i>&quot;, you can follow this recipe
for properties that don&rsquo;t require adjustments:</p>

<pre style="margin-left:11%; margin-top: 1em"> my ($list_ref, $map_ref, $format, $missing) = prop_invmap($property);
 my @range_list;
 # Look at each element in the list, but the &minus;2 is needed because we
 # look at $i+1 in the loop, and the final element is guaranteed to map
 # to $missing by prop_invmap(), so we would skip it anyway.
 for my $i (0 .. @$list_ref &minus; 2) {
    next if $map_ref&minus;&gt;[$i] eq $missing;
    push @range_list, [ $list_ref&minus;&gt;[$i],
                        $list_ref&minus;&gt;[$i+1],
                        $map_ref&minus;&gt;[$i]
                      ];
 }
 print charinrange(\@range_list, $code_point), &quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">With this,
<tt>&quot;charinrange()&quot;</tt> will return
<tt>&quot;undef&quot;</tt> if its input code point maps to
<tt>$missing</tt>. You can avoid this by omitting the
<tt>&quot;next&quot;</tt> statement, and adding a line after
the loop to handle the final element of the inversion
map.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, this
recipe can be used for properties that do require
adjustments:</p>

<pre style="margin-left:11%; margin-top: 1em"> for my $i (0 .. @$list_ref &minus; 2) {
    next if $map_ref&minus;&gt;[$i] eq $missing;
    # prop_invmap() guarantees that if the mapping is to an array, the
    # range has just one element, so no need to worry about adjustments.
    if (ref $map_ref&minus;&gt;[$i]) {
        push @range_list,
                   [ $list_ref&minus;&gt;[$i], $list_ref&minus;&gt;[$i], $map_ref&minus;&gt;[$i] ];
    }
    else {  # Otherwise each element is actually mapped to a separate
            # value, so the range has to be split into single code point
            # ranges.
        my $adjustment = 0;
        # For each code point that gets mapped to something...
        for my $j ($list_ref&minus;&gt;[$i] .. $list_ref&minus;&gt;[$i+1] &minus;1 ) {
            # ... add a range consisting of just it mapping to the
            # original plus the adjustment, which is incremented for the
            # next time through the loop, as the offset increases by 1
            # for each element in the range
            push @range_list,
                             [ $j, $j, $map_ref&minus;&gt;[$i] + $adjustment++ ];
        }
    }
 }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
inversion maps returned for the
<tt>&quot;Case_Folding&quot;</tt> and
<tt>&quot;Simple_Case_Folding&quot;</tt> properties do not
include the Turkic-locale mappings. Use
&quot;<i>casefold()</i>&quot; for these.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;prop_invmap&quot;</tt>
does not know about any user-defined properties, and will
return <tt>&quot;undef&quot;</tt> if called with one of
those.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Unicode::UCD::UnicodeVersion</b>
<br>
This returns the version of the Unicode Character Database,
in other words, the version of the Unicode standard the
database implements. The version is a string of numbers
delimited by dots (<tt>'.'</tt>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Blocks
versus Scripts</b> <br>
The difference between a block and a script is that scripts
are closer to the linguistic notion of a set of code points
required to present languages, while block is more of an
artifact of the Unicode code point numbering and separation
into blocks of (mostly) 256 code points.</p>

<p style="margin-left:11%; margin-top: 1em">For example the
Latin <b>script</b> is spread over several <b>blocks</b>,
such as <tt>&quot;Basic Latin&quot;</tt>, <tt>&quot;Latin 1
Supplement&quot;</tt>, <tt>&quot;Latin
Extended&minus;A&quot;</tt>, and <tt>&quot;Latin
Extended&minus;B&quot;</tt>. On the other hand, the Latin
script does not contain all the characters of the
<tt>&quot;Basic Latin&quot;</tt> block (also known as
<small>ASCII</small> ): it includes only the letters, and
not, for example, the digits or the punctuation.</p>

<p style="margin-left:11%; margin-top: 1em">For blocks see
&lt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&gt;</p>

<p style="margin-left:11%; margin-top: 1em">For scripts see
<small>UTR</small> #24:
&lt;http://www.unicode.org/unicode/reports/tr24/&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Matching
Scripts and Blocks</b> <br>
Scripts are matched with the regular-expression construct
<tt>&quot;\p{...}&quot;</tt> (e.g.
<tt>&quot;\p{Tibetan}&quot;</tt> matches characters of the
Tibetan script), while <tt>&quot;\p{Blk=...}&quot;</tt> is
used for blocks (e.g. <tt>&quot;\p{Blk=Tibetan}&quot;</tt>
matches any of the 256 code points in the Tibetan
block).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Old-style
versus new-style block names</b> <br>
Unicode publishes the names of blocks in two different
styles, though the two are equivalent under Unicode&rsquo;s
loose matching rules.</p>

<p style="margin-left:11%; margin-top: 1em">The original
style uses blanks and hyphens in the block names (except for
<tt>&quot;No_Block&quot;</tt>), like so:</p>

<pre style="margin-left:11%; margin-top: 1em"> Miscellaneous Mathematical Symbols&minus;B</pre>


<p style="margin-left:11%; margin-top: 1em">The newer style
replaces these with underscores, like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> Miscellaneous_Mathematical_Symbols_B</pre>


<p style="margin-left:11%; margin-top: 1em">This newer
style is consistent with the values of other Unicode
properties. To preserve backward compatibility, all the
functions in Unicode::UCD that return block names (except
one) return the old-style ones. That one function,
&quot;<i>prop_value_aliases()</i>&quot; can be used to
convert from old-style to new-style:</p>

<pre style="margin-left:11%; margin-top: 1em"> my $new_style = prop_values_aliases(&quot;block&quot;, $old_style);</pre>


<p style="margin-left:11%; margin-top: 1em">Perl also has
single-form extensions that refer to blocks,
<tt>&quot;In_Cyrillic&quot;</tt>, meaning
<tt>&quot;Block=Cyrillic&quot;</tt>. These have always been
written in the new style.</p>

<p style="margin-left:11%; margin-top: 1em">To convert from
new-style to old-style, follow this recipe:</p>

<pre style="margin-left:11%; margin-top: 1em"> $old_style = charblock((prop_invlist(&quot;block=$new_style&quot;))[0]);</pre>


<p style="margin-left:11%; margin-top: 1em">(which finds
the range of code points in the block using
<tt>&quot;prop_invlist&quot;</tt>, gets the lower end of the
range (0th element) and then looks up the old name for its
block using <tt>&quot;charblock&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
starting in Unicode 6.1, many of the block names have
shorter synonyms. These are always given in the new
style.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Does not yet
support <small>EBCDIC</small> platforms.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jarkko
Hietaniemi. Now maintained by perl5 porters.</p>
<hr>
</body>
</html>
