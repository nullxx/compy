<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:43 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Text::Balanced</title>

</head>
<body>

<h1 align="center">Text::Balanced</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#BUGS AND IRRITATIONS">BUGS AND IRRITATIONS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Text::Balanced
&minus; Extract delimited text sequences from strings.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> use Text::Balanced qw (
                        extract_delimited
                        extract_bracketed
                        extract_quotelike
                        extract_codeblock
                        extract_variable
                        extract_tagged
                        extract_multiple
                        gen_delimited_pat
                        gen_extract_tagged
                       );
 # Extract the initial substring of $text that is delimited by
 # two (unescaped) instances of the first character in $delim.
        ($extracted, $remainder) = extract_delimited($text,$delim);
 # Extract the initial substring of $text that is bracketed
 # with a delimiter(s) specified by $delim (where the string
 # in $delim contains one or more of '(){}[]&lt;&gt;').
        ($extracted, $remainder) = extract_bracketed($text,$delim);
 # Extract the initial substring of $text that is bounded by
 # an XML tag.
        ($extracted, $remainder) = extract_tagged($text);
 # Extract the initial substring of $text that is bounded by
 # a C&lt;BEGIN&gt;...C&lt;END&gt; pair. Don't allow nested C&lt;BEGIN&gt; tags
        ($extracted, $remainder) =
                extract_tagged($text,&quot;BEGIN&quot;,&quot;END&quot;,undef,{bad=&gt;[&quot;BEGIN&quot;]});
 # Extract the initial substring of $text that represents a
 # Perl &quot;quote or quote&minus;like operation&quot;
        ($extracted, $remainder) = extract_quotelike($text);
 # Extract the initial substring of $text that represents a block
 # of Perl code, bracketed by any of character(s) specified by $delim
 # (where the string $delim contains one or more of '(){}[]&lt;&gt;').
        ($extracted, $remainder) = extract_codeblock($text,$delim);
 # Extract the initial substrings of $text that would be extracted by
 # one or more sequential applications of the specified functions
 # or regular expressions
        @extracted = extract_multiple($text,
                                      [ \&amp;extract_bracketed,
                                        \&amp;extract_quotelike,
                                        \&amp;some_other_extractor_sub,
                                        qr/[xyz]*/,
                                        'literal',
                                      ]);</pre>


<p style="margin-left:11%; margin-top: 1em"># Create a
string representing an optimized pattern (a la Friedl) #
that matches a substring delimited by any of the specified
characters # (in this case: any type of quote or a
slash)</p>

<pre style="margin-left:11%; margin-top: 1em">        $patstring = gen_delimited_pat(q{'&quot;`/});</pre>


<p style="margin-left:11%; margin-top: 1em"># Generate a
reference to an anonymous sub that is just like
extract_tagged # but pre-compiled and optimized for a
specific pair of tags, and consequently # much faster (i.e.
3 times faster). It uses qr// for better performance on #
repeated calls, so it only works under Perl 5.005 or
later.</p>

<pre style="margin-left:11%; margin-top: 1em">        $extract_head = gen_extract_tagged('&lt;HEAD&gt;','&lt;/HEAD&gt;');
        ($extracted, $remainder) = $extract_head&minus;&gt;($text);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The various
<tt>&quot;extract_...&quot;</tt> subroutines may be used to
extract a delimited substring, possibly after skipping a
specified prefix string. By default, that prefix is optional
whitespace (<tt>&quot;/\s*/&quot;</tt>), but you can change
it to whatever you wish (see below).</p>

<p style="margin-left:11%; margin-top: 1em">The substring
to be extracted must appear at the current
<tt>&quot;pos&quot;</tt> location of the string&rsquo;s
variable (or at index zero, if no <tt>&quot;pos&quot;</tt>
position is defined). In other words, the
<tt>&quot;extract_...&quot;</tt> subroutines
<i>don&rsquo;t</i> extract the first occurrence of a
substring anywhere in a string (like an unanchored regex
would). Rather, they extract an occurrence of the substring
appearing immediately at the current matching position in
the string (like a <tt>&quot;\G&quot;</tt>&minus;anchored
regex would).</p>

<p style="margin-left:11%; margin-top: 1em"><b>General
behaviour in list contexts</b> <br>
In a list context, all the subroutines return a list, the
first three elements of which are always:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[0]</p></td>
<td width="2%"></td>
<td width="83%">


<p>The extracted string, including the specified
delimiters. If the extraction fails
<tt>&quot;undef&quot;</tt> is returned.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>The remainder of the input string (i.e. the characters
after the extracted string). On failure, the entire string
is returned.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>The skipped prefix (i.e. the characters before the
extracted string). On failure, <tt>&quot;undef&quot;</tt> is
returned.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that in a
list context, the contents of the original input text (the
first argument) are not modified in any way.</p>

<p style="margin-left:11%; margin-top: 1em">However, if the
input text was passed in a variable, that variable&rsquo;s
<tt>&quot;pos&quot;</tt> value is updated to point at the
first character after the extracted text. That means that in
a list context the various subroutines can be used much like
regular expressions. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">        while ( $next = (extract_quotelike($text))[0] )
        {
                # process next quote&minus;like (in $next)
        }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>General
behaviour in scalar and void contexts</b> <br>
In a scalar context, the extracted string is returned,
having first been removed from the input text. Thus, the
following code also processes each quote-like operation, but
actually removes them from <tt>$text:</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>while (
$next = extract_quotelike($text) ) <br>
{ <br>
# process next quote&minus;like (in $next) <br>
}</tt></p>

<p style="margin-left:11%; margin-top: 1em">Note that if
the input text is a read-only string (i.e. a literal), no
attempt is made to remove the extracted text.</p>

<p style="margin-left:11%; margin-top: 1em">In a void
context the behaviour of the extraction subroutines is
exactly the same as in a scalar context, except (of course)
that the extracted substring is not returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A note about
prefixes</b> <br>
Prefix patterns are matched without any trailing modifiers
(<tt>&quot;/gimsox&quot;</tt> etc.) This can bite you if
you&rsquo;re expecting a prefix specification like
&rsquo;.*?(?=&lt;H1&gt;)&rsquo; to skip everything up to the
first &lt;H1&gt; tag. Such a prefix pattern will only
succeed if the &lt;H1&gt; tag is on the current line, since
. normally doesn&rsquo;t match newlines.</p>

<p style="margin-left:11%; margin-top: 1em">To overcome
this limitation, you need to turn on /s matching within the
prefix pattern, using the <tt>&quot;(?s)&quot;</tt>
directive: &rsquo;(?s).*?(?=&lt;H1&gt;)&rsquo;</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_delimited&quot;</b>
<br>
The <tt>&quot;extract_delimited&quot;</tt> function
formalizes the common idiom of extracting a
single-character-delimited substring from the start of a
string. For example, to extract a single-quote delimited
string, the following code is typically used:</p>

<pre style="margin-left:11%; margin-top: 1em">        ($remainder = $text) =~ s/\A('(\\.|[^'])*')//s;
        $extracted = $1;</pre>


<p style="margin-left:11%; margin-top: 1em">but with
<tt>&quot;extract_delimited&quot;</tt> it can be simplified
to:</p>

<pre style="margin-left:11%; margin-top: 1em">        ($extracted,$remainder) = extract_delimited($text, &quot;'&quot;);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;extract_delimited&quot;
takes up to four scalars (the input text, the delimiters, a
prefix pattern to be skipped, and any escape characters) and
extracts the initial substring of the text that is
appropriately delimited. If the delimiter string has
multiple characters, the first one encountered in the text
is taken to delimit the substring. The third argument
specifies a prefix pattern that is to be skipped (but must
be present!) before the substring is extracted. The final
argument specifies the escape character to be used for each
delimiter.</p>

<p style="margin-left:11%; margin-top: 1em">All arguments
are optional. If the escape characters are not specified,
every delimiter is escaped with a backslash
(<tt>&quot;\&quot;</tt>). If the prefix is not specified,
the pattern <tt>'\s*'</tt> &minus; optional whitespace
&minus; is used. If the delimiter set is also not specified,
the set <tt>&quot;/[&quot;'`]/&quot;</tt> is used. If the
text to be processed is not specified either, <tt>$_</tt> is
used.</p>

<p style="margin-left:11%; margin-top: 1em">In list
context, <tt>&quot;extract_delimited&quot;</tt> returns a
array of three elements, the extracted substring
(<i>including the surrounding delimiters</i>), the remainder
of the text, and the skipped prefix (if any). If a suitable
delimited substring is not found, the first element of the
array is the empty string, the second is the complete
original text, and the prefix returned in the third element
is an empty string.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context, just the extracted substring is returned. In a void
context, the extracted substring (and any prefix) are simply
removed from the beginning of the first argument.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">        # Remove a single&minus;quoted substring from the very beginning of $text:
                $substring = extract_delimited($text, &quot;'&quot;, '');
        # Remove a single&minus;quoted Pascalish substring (i.e. one in which
        # doubling the quote character escapes it) from the very
        # beginning of $text:
                $substring = extract_delimited($text, &quot;'&quot;, '', &quot;'&quot;);
        # Extract a single&minus; or double&minus; quoted substring from the
        # beginning of $text, optionally after some whitespace
        # (note the list context to protect $text from modification):
                ($substring) = extract_delimited $text, q{&quot;'};
        # Delete the substring delimited by the first '/' in $text:
                $text = join '', (extract_delimited($text,'/','[^/]*')[2,1];</pre>


<p style="margin-left:11%; margin-top: 1em">Note that this
last example is <i>not</i> the same as deleting the first
quote-like pattern. For instance, if <tt>$text</tt>
contained the string:</p>

<pre style="margin-left:11%; margin-top: 1em">        &quot;if ('./cmd' =~ m/$UNIXCMD/s) { $cmd = $1; }&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">then after the
deletion it would contain:</p>

<pre style="margin-left:11%; margin-top: 1em">        &quot;if ('.$UNIXCMD/s) { $cmd = $1; }&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">not:</p>

<pre style="margin-left:11%; margin-top: 1em">        &quot;if ('./cmd' =~ ms) { $cmd = $1; }&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">See
&quot;extract_quotelike&quot; for a (partial) solution to
this problem.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_bracketed&quot;</b>
<br>
Like <tt>&quot;extract_delimited&quot;</tt>, the
<tt>&quot;extract_bracketed&quot;</tt> function takes up to
three optional scalar arguments: a string to extract from, a
delimiter specifier, and a prefix pattern. As before, a
missing prefix defaults to optional whitespace and a missing
text defaults to <tt>$_</tt>. However, a missing delimiter
specifier defaults to <tt>'{}()[]&lt;&gt;'</tt> (see
below).</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;extract_bracketed&quot;</tt>
extracts a balanced-bracket-delimited substring (using any
one (or more) of the user-specified delimiter brackets:
&rsquo;(..)&rsquo;, &rsquo;{..}&rsquo;, &rsquo;[..]&rsquo;,
or &rsquo;&lt;..&gt;&rsquo;). Optionally it will also
respect quoted unbalanced brackets (see below).</p>

<p style="margin-left:11%; margin-top: 1em">A
&quot;delimiter bracket&quot; is a bracket in list of
delimiters passed as
<tt>&quot;extract_bracketed&quot;</tt>&rsquo;s second
argument. Delimiter brackets are specified by giving either
the left or right (or both!) versions of the required
bracket(s). Note that the order in which two or more
delimiter brackets are specified is not significant.</p>

<p style="margin-left:11%; margin-top: 1em">A
&quot;balanced-bracket-delimited substring&quot; is a
substring bounded by matched brackets, such that any other
(left or right) delimiter bracket <i>within</i> the
substring is also matched by an opposite (right or left)
delimiter bracket <i>at the same level of nesting</i>. Any
type of bracket not in the delimiter list is treated as an
ordinary character.</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
each type of bracket specified as a delimiter must be
balanced and correctly nested within the substring, and any
other kind of (&quot;non-delimiter&quot;) bracket in the
substring is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
given the string:</p>

<pre style="margin-left:11%; margin-top: 1em">        $text = &quot;{ an '[irregularly :&minus;(] {} parenthesized &gt;:&minus;)' string }&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">then a call to
<tt>&quot;extract_bracketed&quot;</tt> in a list
context:</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '{}' );</pre>


<p style="margin-left:11%; margin-top: 1em">would
return:</p>

<pre style="margin-left:11%; margin-top: 1em">        ( &quot;{ an '[irregularly :&minus;(] {} parenthesized &gt;:&minus;)' string }&quot; , &quot;&quot; , &quot;&quot; )</pre>


<p style="margin-left:11%; margin-top: 1em">since both sets
of <tt>'{..}'</tt> brackets are properly nested and evenly
balanced. (In a scalar context just the first element of the
array would be returned. In a void context, <tt>$text</tt>
would be replaced by an empty string.)</p>

<p style="margin-left:11%; margin-top: 1em">Likewise the
call in:</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '{[' );</pre>


<p style="margin-left:11%; margin-top: 1em">would return
the same result, since all sets of both types of specified
delimiter brackets are correctly nested and balanced.</p>

<p style="margin-left:11%; margin-top: 1em">However, the
call in:</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '{([&lt;' );</pre>


<p style="margin-left:11%; margin-top: 1em">would fail,
returning:</p>

<pre style="margin-left:11%; margin-top: 1em">        ( undef , &quot;{ an '[irregularly :&minus;(] {} parenthesized &gt;:&minus;)' string }&quot;  );</pre>


<p style="margin-left:11%; margin-top: 1em">because the
embedded pairs of <tt>'(..)'</tt>s and <tt>'[..]'</tt>s are
&quot;cross-nested&quot; and the embedded <tt>'&gt;'</tt> is
unbalanced. (In a scalar context, this call would return an
empty string. In a void context, <tt>$text</tt> would be
unchanged.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
embedded single-quotes in the string don&rsquo;t help in
this case, since they have not been specified as acceptable
delimiters and are therefore treated as non-delimiter
characters (and ignored).</p>

<p style="margin-left:11%; margin-top: 1em">However, if a
particular species of quote character is included in the
delimiter specification, then that type of quote will be
correctly handled. for example, if <tt>$text</tt> is:</p>

<pre style="margin-left:11%; margin-top: 1em">        $text = '&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;';</pre>


<p style="margin-left:11%; margin-top: 1em">then</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '&lt;&quot;&gt;' );</pre>


<p style="margin-left:11%; margin-top: 1em">returns:</p>

<pre style="margin-left:11%; margin-top: 1em">        ( '&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;', 'link&lt;/A&gt;', &quot;&quot; )</pre>


<p style="margin-left:11%; margin-top: 1em">as expected.
Without the specification of <tt>&quot;&quot;&quot;</tt> as
an embedded quoter:</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '&lt;&gt;' );</pre>


<p style="margin-left:11%; margin-top: 1em">the result
would be:</p>

<pre style="margin-left:11%; margin-top: 1em">        ( '&lt;A HREF=&quot;&gt;', '&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;', &quot;&quot; )</pre>


<p style="margin-left:11%; margin-top: 1em">In addition to
the quote delimiters <tt>&quot;'&quot;</tt>,
<tt>&quot;&quot;&quot;</tt>, and <tt>&quot;`&quot;</tt>,
full Perl quote-like quoting (i.e. q{string}, qq{string},
etc) can be specified by including the letter
&rsquo;q&rsquo; as a delimiter. Hence:</p>

<pre style="margin-left:11%; margin-top: 1em">        @result = extract_bracketed( $text, '&lt;q&gt;' );</pre>


<p style="margin-left:11%; margin-top: 1em">would correctly
match something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">        $text = '&lt;leftop: conj /and/ conj&gt;';</pre>


<p style="margin-left:11%; margin-top: 1em">See also:
<tt>&quot;extract_quotelike&quot;</tt> and
<tt>&quot;extract_codeblock&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_variable&quot;</b>
<tt><br>
&quot;extract_variable&quot;</tt> extracts any valid Perl
variable or variable-involved expression, including scalars,
arrays, hashes, array accesses, hash look-ups, method calls
through objects, subroutine calls through subroutine
references, etc.</p>

<p style="margin-left:11%; margin-top: 1em">The subroutine
takes up to two optional arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">A string to be processed
(<tt>$_</tt> if the string is omitted or
<tt>&quot;undef&quot;</tt>)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A string specifying a pattern to be matched as a prefix
(which is to be skipped). If omitted, optional whitespace is
skipped.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">On success in a
list context, an array of 3 elements is returned. The
elements are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[0]</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em">the extracted variable, or
variablish expression</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="74%">


<p>the remainder of the input text,</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="74%">


<p>the prefix substring (if any),</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">On failure, all
of these values (except the remaining text) are
<tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context, <tt>&quot;extract_variable&quot;</tt> returns just
the complete substring that matched a variablish expression.
<tt>&quot;undef&quot;</tt> is returned on failure. In
addition, the original input text has the returned substring
(and any prefix) removed from it.</p>

<p style="margin-left:11%; margin-top: 1em">In a void
context, the input text just has the matched substring (and
any specified prefix) removed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_tagged&quot;</b>
<tt><br>
&quot;extract_tagged&quot;</tt> extracts and segments text
between (balanced) specified tags.</p>

<p style="margin-left:11%; margin-top: 1em">The subroutine
takes up to five optional arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">A string to be processed
(<tt>$_</tt> if the string is omitted or
<tt>&quot;undef&quot;</tt>)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A string specifying a pattern to be matched as the
opening tag. If the pattern string is omitted (or
<tt>&quot;undef&quot;</tt>) then a pattern that matches any
standard <small>XML</small> tag is used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A string specifying a pattern to be matched at the
closing tag. If the pattern string is omitted (or
<tt>&quot;undef&quot;</tt>) then the closing tag is
constructed by inserting a <tt>&quot;/&quot;</tt> after any
leading bracket characters in the actual opening tag that
was matched (<i>not</i> the pattern that matched the tag).
For example, if the opening tag pattern is specified as
<tt>'{{\w+}}'</tt> and actually matched the opening tag
<tt>&quot;{{DATA}}&quot;</tt>, then the constructed closing
tag would be <tt>&quot;{{/DATA}}&quot;</tt>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A string specifying a pattern to be matched as a prefix
(which is to be skipped). If omitted, optional whitespace is
skipped.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A hash reference containing various parsing options (see
below)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The various
options that can be specified are: <br>
&quot;reject =&gt; $listref&quot;</p>

<p style="margin-left:17%;">The list reference contains one
or more strings specifying patterns that must <i>not</i>
appear within the tagged text.</p>

<p style="margin-left:17%; margin-top: 1em">For example, to
extract an <small>HTML</small> link (which should not
contain nested links) use:</p>

<pre style="margin-left:17%; margin-top: 1em">        extract_tagged($text, '&lt;A&gt;', '&lt;/A&gt;', undef, {reject =&gt; ['&lt;A&gt;']} );</pre>


<p style="margin-left:11%;">&quot;ignore =&gt;
$listref&quot;</p>

<p style="margin-left:17%;">The list reference contains one
or more strings specifying patterns that are <i>not</i> be
be treated as nested tags within the tagged text (even if
they would match the start tag pattern).</p>

<p style="margin-left:17%; margin-top: 1em">For example, to
extract an arbitrary <small>XML</small> tag, but ignore
&quot;empty&quot; elements:</p>

<pre style="margin-left:17%; margin-top: 1em">        extract_tagged($text, undef, undef, undef, {ignore =&gt; ['&lt;[^&gt;]*/&gt;']} );</pre>


<p style="margin-left:17%; margin-top: 1em">(also see
&quot;gen_delimited_pat&quot; below).</p>

<p style="margin-left:11%;">&quot;fail =&gt; $str&quot;</p>

<p style="margin-left:17%;">The <tt>&quot;fail&quot;</tt>
option indicates the action to be taken if a matching end
tag is not encountered (i.e. before the end of the string or
some <tt>&quot;reject&quot;</tt> pattern matches). By
default, a failure to match a closing tag causes
<tt>&quot;extract_tagged&quot;</tt> to immediately fail.</p>

<p style="margin-left:17%; margin-top: 1em">However, if the
string value associated with &lt;reject&gt; is &quot;
<small>MAX</small> &quot;, then
<tt>&quot;extract_tagged&quot;</tt> returns the complete
text up to the point of failure. If the string is &quot;
<small>PARA</small> &quot;,
<tt>&quot;extract_tagged&quot;</tt> returns only the first
paragraph after the tag (up to the first line that is either
empty or contains only whitespace characters). If the string
is &quot;&quot;, the the default behaviour (i.e. failure) is
reinstated.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
suppose the start tag &quot;/para&quot; introduces a
paragraph, which then continues until the next
&quot;/endpara&quot; tag or until another &quot;/para&quot;
tag is encountered:</p>

<pre style="margin-left:17%; margin-top: 1em">        $text = &quot;/para line 1\n\nline 3\n/para line 4&quot;;
        extract_tagged($text, '/para', '/endpara', undef,
                                {reject =&gt; '/para', fail =&gt; MAX );
        # EXTRACTED: &quot;/para line 1\n\nline 3\n&quot;</pre>


<p style="margin-left:17%; margin-top: 1em">Suppose
instead, that if no matching &quot;/endpara&quot; tag is
found, the &quot;/para&quot; tag refers only to the
immediately following paragraph:</p>

<pre style="margin-left:17%; margin-top: 1em">        $text = &quot;/para line 1\n\nline 3\n/para line 4&quot;;
        extract_tagged($text, '/para', '/endpara', undef,
                        {reject =&gt; '/para', fail =&gt; MAX );
        # EXTRACTED: &quot;/para line 1\n&quot;</pre>


<p style="margin-left:17%; margin-top: 1em">Note that the
specified <tt>&quot;fail&quot;</tt> behaviour applies to
nested tags as well.</p>

<p style="margin-left:11%; margin-top: 1em">On success in a
list context, an array of 6 elements is returned. The
elements are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[0]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the extracted tagged substring (including the outermost
tags),</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the remainder of the input text,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the prefix substring (if any),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the opening tag</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the text between the opening and closing tags</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the closing tag (or &quot;&quot; if no closing tag was
found)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">On failure, all
of these values (except the remaining text) are
<tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context, <tt>&quot;extract_tagged&quot;</tt> returns just
the complete substring that matched a tagged text (including
the start and end tags). <tt>&quot;undef&quot;</tt> is
returned on failure. In addition, the original input text
has the returned substring (and any prefix) removed from
it.</p>

<p style="margin-left:11%; margin-top: 1em">In a void
context, the input text just has the matched substring (and
any specified prefix) removed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;gen_extract_tagged&quot;</b>
<br>
(Note: This subroutine is only available under
Perl5.005)</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;gen_extract_tagged&quot;</tt>
generates a new anonymous subroutine which extracts text
between (balanced) specified tags. In other words, it
generates a function identical in function to
<tt>&quot;extract_tagged&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The difference
between <tt>&quot;extract_tagged&quot;</tt> and the
anonymous subroutines generated by
<tt>&quot;gen_extract_tagged&quot;</tt>, is that those
generated subroutines:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">do not have to reparse tag
specification or parsing options every time they are called
(whereas <tt>&quot;extract_tagged&quot;</tt> has to
effectively rebuild its tag parser on every call);</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>make use of the new qr// construct to pre-compile the
regexes they use (whereas
<tt>&quot;extract_tagged&quot;</tt> uses standard string
variable interpolation to create tag-matching patterns).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The subroutine
takes up to four optional arguments (the same set as
<tt>&quot;extract_tagged&quot;</tt> except for the string to
be processed). It returns a reference to a subroutine which
in turn takes a single argument (the text to be extracted
from).</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
the implementation of <tt>&quot;extract_tagged&quot;</tt> is
exactly equivalent to:</p>

<pre style="margin-left:11%; margin-top: 1em">        sub extract_tagged
        {
                my $text = shift;
                $extractor = gen_extract_tagged(@_);
                return $extractor&minus;&gt;($text);
        }</pre>


<p style="margin-left:11%; margin-top: 1em">(although
<tt>&quot;extract_tagged&quot;</tt> is not currently
implemented that way, in order to preserve pre&minus;5.005
compatibility).</p>

<p style="margin-left:11%; margin-top: 1em">Using
<tt>&quot;gen_extract_tagged&quot;</tt> to create extraction
functions for specific tags is a good idea if those
functions are going to be called more than once, since their
performance is typically twice as good as the more
general-purpose <tt>&quot;extract_tagged&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_quotelike&quot;</b>
<tt><br>
&quot;extract_quotelike&quot;</tt> attempts to recognize,
extract, and segment any one of the various Perl quotes and
quotelike operators (see <i>perlop</i>(3)) Nested
backslashed delimiters, embedded balanced bracket delimiters
(for the quotelike operators), and trailing modifiers are
all caught. For example, in:</p>

<pre style="margin-left:11%; margin-top: 1em">        extract_quotelike 'q # an octothorpe: \# (not the end of the q!) #'
        extract_quotelike '  &quot;You said, \&quot;Use sed\&quot;.&quot;  '
        extract_quotelike ' s{([A&minus;Z]{1,8}\.[A&minus;Z]{3})} /\L$1\E/; '
        extract_quotelike ' tr/\\\/\\\\/\\\//ds; '</pre>


<p style="margin-left:11%; margin-top: 1em">the full Perl
quotelike operations are all extracted correctly.</p>

<p style="margin-left:11%; margin-top: 1em">Note too that,
when using the /x modifier on a regex, any comment
containing the current pattern delimiter will cause the
regex to be immediately terminated. In other words:</p>

<pre style="margin-left:11%; margin-top: 1em">        'm /
                (?i)            # CASE INSENSITIVE
                [a&minus;z_]          # LEADING ALPHABETIC/UNDERSCORE
                [a&minus;z0&minus;9]*       # FOLLOWED BY ANY NUMBER OF ALPHANUMERICS
           /x'</pre>


<p style="margin-left:11%; margin-top: 1em">will be
extracted as if it were:</p>

<pre style="margin-left:11%; margin-top: 1em">        'm /
                (?i)            # CASE INSENSITIVE
                [a&minus;z_]          # LEADING ALPHABETIC/'</pre>


<p style="margin-left:11%; margin-top: 1em">This behaviour
is identical to that of the actual compiler.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;extract_quotelike&quot;</tt>
takes two arguments: the text to be processed and a prefix
to be matched at the very beginning of the text. If no
prefix is specified, optional whitespace is the default. If
no text is given, <tt>$_</tt> is used.</p>

<p style="margin-left:11%; margin-top: 1em">In a list
context, an array of 11 elements is returned. The elements
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[0]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">the extracted quotelike
substring (including trailing modifiers),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the remainder of the input text,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the prefix substring (if any),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the name of the quotelike operator (if any),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the left delimiter of the first block of the
operation,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the text of the first block of the operation (that is,
the contents of a quote, the regex of a match or
substitution or the target list of a translation),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the right delimiter of the first block of the
operation,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[7]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the left delimiter of the second block of the operation
(that is, if it is a <tt>&quot;s&quot;</tt>,
<tt>&quot;tr&quot;</tt>, or <tt>&quot;y&quot;</tt>),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[8]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the text of the second block of the operation (that is,
the replacement of a substitution or the translation list of
a translation),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[9]</p></td>
<td width="2%"></td>
<td width="83%">


<p>the right delimiter of the second block of the operation
(if any),</p></td></tr>
</table>

<p style="margin-left:11%;">[10]</p>

<p style="margin-left:17%;">the trailing modifiers on the
operation (if any).</p>

<p style="margin-left:11%; margin-top: 1em">For each of the
fields marked &quot;(if any)&quot; the default value on
success is an empty string. On failure, all of these values
(except the remaining text) are
<tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context, <tt>&quot;extract_quotelike&quot;</tt> returns just
the complete substring that matched a quotelike operation
(or <tt>&quot;undef&quot;</tt> on failure). In a scalar or
void context, the input text has the same substring (and any
specified prefix) removed.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">        # Remove the first quotelike literal that appears in text
                $quotelike = extract_quotelike($text,'.*?');
        # Replace one or more leading whitespace&minus;separated quotelike
        # literals in $_ with &quot;&lt;QLL&gt;&quot;
                do { $_ = join '&lt;QLL&gt;', (extract_quotelike)[2,1] } until $@;
        # Isolate the search pattern in a quotelike operation from $text
                ($op,$pat) = (extract_quotelike $text)[3,5];
                if ($op =~ /[ms]/)
                {
                        print &quot;search pattern: $pat\n&quot;;
                }
                else
                {
                        print &quot;$op is not a pattern matching operation\n&quot;;
                }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_quotelike&quot;
and &quot;here documents&quot;</b> <tt><br>
&quot;extract_quotelike&quot;</tt> can successfully extract
&quot;here documents&quot; from an input string, but with an
important caveat in list contexts.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike other
types of quote-like literals, a here document is rarely a
contiguous substring. For example, a typical piece of code
using here document might look like this:</p>

<pre style="margin-left:11%; margin-top: 1em">        &lt;&lt;'EOMSG' || die;
        This is the message.
        EOMSG
        exit;</pre>


<p style="margin-left:11%; margin-top: 1em">Given this as
an input string in a scalar context,
<tt>&quot;extract_quotelike&quot;</tt> would correctly
return the string &quot;&lt;&lt;&rsquo; <small>EOMSG</small>
&rsquo;\nThis is the message.\nEOMSG&quot;, leaving the
string &quot; || die;\nexit;&quot; in the original variable.
In other words, the two separate pieces of the here document
are successfully extracted and concatenated.</p>

<p style="margin-left:11%; margin-top: 1em">In a list
context, <tt>&quot;extract_quotelike&quot;</tt> would return
the list</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[0]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;&lt;&lt;&rsquo; <small>EOMSG</small> &rsquo;\nThis
is the message.\nEOMSG\n&quot; (i.e. the full extracted here
document, including fore and aft delimiters),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot; || die;\nexit;&quot; (i.e. the remainder of the
input text, concatenated),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;&quot; (i.e. the prefix substring -- trivial in
this case),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;&lt;&lt;&quot; (i.e. the &quot;name&quot; of the
quotelike operator)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;&rsquo; <small>EOMSG</small> &rsquo;&quot; (i.e.
the left delimiter of the here document, including any
quotes),</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;This is the message.\n&quot; (i.e. the text of the
here document),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot; <small>EOMSG</small> &quot; (i.e. the right
delimiter of the here document),</p></td></tr>
</table>

<p style="margin-left:11%;">[7..10]</p>

<p style="margin-left:17%;">&quot;&quot; (a here document
has no second left delimiter, second text, second right
delimiter, or trailing modifiers).</p>

<p style="margin-left:11%; margin-top: 1em">However, the
matching position of the input variable would be set to
&quot;exit;&quot; (i.e. <i>after</i> the closing delimiter
of the here document), which would cause the earlier &quot;
|| die;\nexit;&quot; to be skipped in any sequence of code
fragment extractions.</p>

<p style="margin-left:11%; margin-top: 1em">To avoid this
problem, when it encounters a here document whilst
extracting from a modifiable string,
<tt>&quot;extract_quotelike&quot;</tt> silently rearranges
the string to an equivalent piece of Perl:</p>

<pre style="margin-left:11%; margin-top: 1em">        &lt;&lt;'EOMSG'
        This is the message.
        EOMSG
        || die;
        exit;</pre>


<p style="margin-left:11%; margin-top: 1em">in which the
here document <i>is</i> contiguous. It still leaves the
matching position after the here document, but now the rest
of the line on which the here document starts is not
skipped.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent
&lt;extract_quotelike&gt; from mucking about with the input
in this way (this is the only case where a list-context
<tt>&quot;extract_quotelike&quot;</tt> does so), you can
pass the input variable as an interpolated literal:</p>

<pre style="margin-left:11%; margin-top: 1em">        $quotelike = extract_quotelike(&quot;$var&quot;);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_codeblock&quot;</b>
<tt><br>
&quot;extract_codeblock&quot;</tt> attempts to recognize and
extract a balanced bracket delimited substring that may
contain unbalanced brackets inside Perl quotes or quotelike
operations. That is, <tt>&quot;extract_codeblock&quot;</tt>
is like a combination of
<tt>&quot;extract_bracketed&quot;</tt> and
<tt>&quot;extract_quotelike&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;extract_codeblock&quot;</tt>
takes the same initial three parameters as
<tt>&quot;extract_bracketed&quot;</tt>: a text to process, a
set of delimiter brackets to look for, and a prefix to match
first. It also takes an optional fourth parameter, which
allows the outermost delimiter brackets to be specified
separately (see below).</p>

<p style="margin-left:11%; margin-top: 1em">Omitting the
first argument (input text) means process <tt>$_</tt>
instead. Omitting the second argument (delimiter brackets)
indicates that only <tt>'{'</tt> is to be used. Omitting the
third argument (prefix argument) implies optional whitespace
at the start. Omitting the fourth argument (outermost
delimiter brackets) indicates that the value of the second
argument is to be used for the outermost delimiters.</p>

<p style="margin-left:11%; margin-top: 1em">Once the prefix
an dthe outermost opening delimiter bracket have been
recognized, code blocks are extracted by stepping through
the input text and trying the following alternatives in
sequence:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Try and match a closing delimiter bracket. If the
bracket was the same species as the last opening bracket,
return the substring to that point. If the bracket was
mismatched, return an error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Try to match a quote or quotelike operator. If found,
call <tt>&quot;extract_quotelike&quot;</tt> to eat it. If
<tt>&quot;extract_quotelike&quot;</tt> fails, return the
error it returned. Otherwise go back to step 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Try to match an opening delimiter bracket. If found,
call <tt>&quot;extract_codeblock&quot;</tt> recursively to
eat the embedded block. If the recursive call fails, return
an error. Otherwise, go back to step 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Unconditionally match a bareword or any other single
character, and then go back to step 1.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">        # Find a while loop in the text
                if ($text =~ s/.*?while\s*\{/{/)
                {
                        $loop = &quot;while &quot; . extract_codeblock($text);
                }
        # Remove the first round&minus;bracketed list (which may include
        # round&minus; or curly&minus;bracketed code blocks or quotelike operators)
                extract_codeblock $text, &quot;(){}&quot;, '[^(]*';</pre>


<p style="margin-left:11%; margin-top: 1em">The ability to
specify a different outermost delimiter bracket is useful in
some circumstances. For example, in the Parse::RecDescent
module, parser actions which are to be performed only on a
successful parse are specified using a
<tt>&quot;&lt;defer:...&gt;&quot;</tt> directive. For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">        sentence: subject verb object
                        &lt;defer: {$::theVerb = $item{verb}} &gt;</pre>



<p style="margin-left:11%; margin-top: 1em">Parse::RecDescent
uses <tt>&quot;extract_codeblock($text,
'{}&lt;&gt;')&quot;</tt> to extract the code within the
<tt>&quot;&lt;defer:...&gt;&quot;</tt> directive, but
there&rsquo;s a problem.</p>

<p style="margin-left:11%; margin-top: 1em">A deferred
action like this:</p>

<pre style="margin-left:11%; margin-top: 1em">                        &lt;defer: {if ($count&gt;10) {$count&minus;&minus;}} &gt;</pre>


<p style="margin-left:11%; margin-top: 1em">will be
incorrectly parsed as:</p>

<pre style="margin-left:11%; margin-top: 1em">                        &lt;defer: {if ($count&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">because the
&quot;less than&quot; operator is interpreted as a closing
delimiter.</p>

<p style="margin-left:11%; margin-top: 1em">But, by
extracting the directive using
<tt>&quot;extract_codeblock($text,&nbsp;'{}',&nbsp;undef,&nbsp;'&lt;&gt;')&quot;</tt>
the &rsquo;&gt;&rsquo; character is only treated as a
delimited at the outermost level of the code block, so the
directive is parsed correctly.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;extract_multiple&quot;</b>
<br>
The <tt>&quot;extract_multiple&quot;</tt> subroutine takes a
string to be processed and a list of extractors (subroutines
or regular expressions) to apply to that string.</p>

<p style="margin-left:11%; margin-top: 1em">In an array
context <tt>&quot;extract_multiple&quot;</tt> returns an
array of substrings of the original string, as extracted by
the specified extractors. In a scalar context,
<tt>&quot;extract_multiple&quot;</tt> returns the first
substring successfully extracted from the original string.
In both scalar and void contexts the original string has the
first successfully extracted substring removed from it. In
all contexts <tt>&quot;extract_multiple&quot;</tt> starts at
the current <tt>&quot;pos&quot;</tt> of the string, and sets
that <tt>&quot;pos&quot;</tt> appropriately after it
matches.</p>

<p style="margin-left:11%; margin-top: 1em">Hence, the aim
of of a call to <tt>&quot;extract_multiple&quot;</tt> in a
list context is to split the processed string into as many
non-overlapping fields as possible, by repeatedly applying
each of the specified extractors to the remainder of the
string. Thus <tt>&quot;extract_multiple&quot;</tt> is a
generalized form of Perl&rsquo;s <tt>&quot;split&quot;</tt>
subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">The subroutine
takes up to four optional arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">A string to be processed
(<tt>$_</tt> if the string is omitted or
<tt>&quot;undef&quot;</tt>)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A reference to a list of subroutine references and/or
qr// objects and/or literal strings and/or hash references,
specifying the extractors to be used to split the string. If
this argument is omitted (or <tt>&quot;undef&quot;</tt>) the
list:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">        [
                sub { extract_variable($_[0], '') },
                sub { extract_quotelike($_[0],'') },
                sub { extract_codeblock($_[0],'{}','') },
        ]</pre>


<p style="margin-left:17%; margin-top: 1em">is used.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">An number specifying the maximum
number of fields to return. If this argument is omitted (or
<tt>&quot;undef&quot;</tt>), split continues as long as
possible.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If the third
argument is <i>N</i>, then extraction continues until
<i>N</i> fields have been successfully extracted, or until
the string has been completely processed.</p>

<p style="margin-left:17%; margin-top: 1em">Note that in
scalar and void contexts the value of this argument is
automatically reset to 1 (under
<tt>&quot;&minus;w&quot;</tt>, a warning is issued if the
argument has to be reset).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">A value indicating whether
unmatched substrings (see below) within the text should be
skipped or returned as fields. If the value is true, such
substrings are skipped. Otherwise, they are returned.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The extraction
process works by applying each extractor in sequence to the
text string.</p>

<p style="margin-left:11%; margin-top: 1em">If the
extractor is a subroutine it is called in a list context and
is expected to return a list of a single element, namely the
extracted text. It may optionally also return two further
arguments: a string representing the text left after
extraction (like $&rsquo; for a pattern match), and a string
representing any prefix skipped before the extraction (like
$&lsquo; in a pattern match). Note that this is designed to
facilitate the use of other Text::Balanced subroutines with
<tt>&quot;extract_multiple&quot;</tt>. Note too that the
value returned by an extractor subroutine need not bear any
relationship to the corresponding substring of the original
text (see examples below).</p>

<p style="margin-left:11%; margin-top: 1em">If the
extractor is a precompiled regular expression or a string,
it is matched against the text in a scalar context with a
leading &rsquo;\G&rsquo; and the gc modifiers enabled. The
extracted value is either <tt>$1</tt> if that variable is
defined after the match, or else the complete match (i.e.
$&amp;).</p>

<p style="margin-left:11%; margin-top: 1em">If the
extractor is a hash reference, it must contain exactly one
element. The value of that element is one of the above
extractor types (subroutine reference, regular expression,
or string). The key of that element is the name of a class
into which the successful return value of the extractor will
be blessed.</p>

<p style="margin-left:11%; margin-top: 1em">If an extractor
returns a defined value, that value is immediately treated
as the next extracted field and pushed onto the list of
fields. If the extractor was specified in a hash reference,
the field is also blessed into the appropriate class,</p>

<p style="margin-left:11%; margin-top: 1em">If the
extractor fails to match (in the case of a regex extractor),
or returns an empty list or an undefined value (in the case
of a subroutine extractor), it is assumed to have failed to
extract. If none of the extractor subroutines succeeds, then
one character is extracted from the start of the text and
the extraction subroutines reapplied. Characters which are
thus removed are accumulated and eventually become the next
field (unless the fourth argument is true, in which case
they are discarded).</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following extracts substrings that are valid Perl
variables:</p>

<pre style="margin-left:11%; margin-top: 1em">        @fields = extract_multiple($text,
                                   [ sub { extract_variable($_[0]) } ],
                                   undef, 1);</pre>


<p style="margin-left:11%; margin-top: 1em">This example
separates a text into fields which are quote delimited,
curly bracketed, and anything else. The delimited and
bracketed parts are also blessed to identify them (the
&quot;anything else&quot; is unblessed):</p>

<pre style="margin-left:11%; margin-top: 1em">        @fields = extract_multiple($text,
                   [
                        { Delim =&gt; sub { extract_delimited($_[0],q{'&quot;}) } },
                        { Brack =&gt; sub { extract_bracketed($_[0],'{}') } },
                   ]);</pre>


<p style="margin-left:11%; margin-top: 1em">This call
extracts the next single substring that is a valid Perl
quotelike operator (and removes it from <tt>$text</tt>):</p>

<pre style="margin-left:11%; margin-top: 1em">        $quotelike = extract_multiple($text,
                                      [
                                        sub { extract_quotelike($_[0]) },
                                      ], undef, 1);</pre>


<p style="margin-left:11%; margin-top: 1em">Finally, here
is yet another way to do comma-separated value parsing:</p>

<pre style="margin-left:11%; margin-top: 1em">        @fields = extract_multiple($csv_text,
                                  [
                                        sub { extract_delimited($_[0],q{'&quot;}) },
                                        qr/([^,]+)(.*)/,
                                  ],
                                  undef,1);</pre>


<p style="margin-left:11%; margin-top: 1em">The list in the
second argument means: <i>&quot;Try and extract a &rsquo; or
&quot; delimited string, otherwise extract anything up to a
comma...&quot;</i>. The undef third argument means:
<i>&quot;...as many times as possible...&quot;</i>, and the
true value in the fourth argument means
<i>&quot;...discarding anything else that appears (i.e. the
commas)&quot;</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If you wanted
the commas preserved as separate fields (i.e. like split
does if your split pattern has capturing parentheses), you
would just make the last parameter undefined (or remove
it).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;gen_delimited_pat&quot;</b>
<br>
The <tt>&quot;gen_delimited_pat&quot;</tt> subroutine takes
a single (string) argument and <br>
&gt; builds a Friedl-style optimized regex that matches a
string delimited by any one of the characters in the single
argument. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">        gen_delimited_pat(q{'&quot;})</pre>


<p style="margin-left:11%; margin-top: 1em">returns the
regex:</p>

<pre style="margin-left:11%; margin-top: 1em">        (?:\&quot;(?:\\\&quot;|(?!\&quot;).)*\&quot;|\'(?:\\\'|(?!\').)*\')</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
specified delimiters are automatically
quotemeta&rsquo;d.</p>

<p style="margin-left:11%; margin-top: 1em">A typical use
of <tt>&quot;gen_delimited_pat&quot;</tt> would be to build
special purpose tags for
<tt>&quot;extract_tagged&quot;</tt>. For example, to
properly ignore &quot;empty&quot; <small>XML</small>
elements (which might contain quoted strings):</p>

<pre style="margin-left:11%; margin-top: 1em">        my $empty_tag = '&lt;(' . gen_delimited_pat(q{'&quot;}) . '|.)+/&gt;';
        extract_tagged($text, undef, undef, undef, {ignore =&gt; [$empty_tag]} );</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;gen_delimited_pat&quot;
may also be called with an optional second argument, which
specifies the &quot;escape&quot; character(s) to be used for
each delimiter. For example to match a Pascal-style string
(where &rsquo; is the delimiter and &rsquo;&rsquo; is a
literal &rsquo; within the string):</p>

<pre style="margin-left:11%; margin-top: 1em">        gen_delimited_pat(q{'},q{'});</pre>


<p style="margin-left:11%; margin-top: 1em">Different
escape characters can be specified for different delimiters.
For example, to specify that &rsquo;/&rsquo; is the escape
for single quotes and &rsquo;%&rsquo; is the escape for
double quotes:</p>

<pre style="margin-left:11%; margin-top: 1em">        gen_delimited_pat(q{'&quot;},q{/%});</pre>


<p style="margin-left:11%; margin-top: 1em">If more
delimiters than escape chars are specified, the last escape
char is used for the remaining delimiters. If no escape char
is specified for a given specified delimiter,
&rsquo;\&rsquo; is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;delimited_pat&quot;</b>
<br>
Note that <tt>&quot;gen_delimited_pat&quot;</tt> was
previously called <tt>&quot;delimited_pat&quot;</tt>. That
name may still be used, but is now deprecated.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In a list
context, all the functions return
<tt>&quot;(undef,$original_text)&quot;</tt> on failure. In a
scalar context, failure is indicated by returning
<tt>&quot;undef&quot;</tt> (in this case the input text is
not modified in any way).</p>

<p style="margin-left:11%; margin-top: 1em">In addition, on
failure in <i>any</i> context, the <tt>$@</tt> variable is
set. Accessing <tt>&quot;$@&minus;&gt;{error}&quot;</tt>
returns one of the error diagnostics listed below. Accessing
<tt>&quot;$@&minus;&gt;{pos}&quot;</tt> returns the offset
into the original string at which the error was detected
(although not necessarily where it occurred!) Printing
<tt>$@</tt> directly produces the error message, with the
offset appended. On success, the <tt>$@</tt> variable is
guaranteed to be <tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The available
diagnostics are: <br>
&quot;Did not find a suitable bracket:
&quot;%s&quot;&quot;</p>

<p style="margin-left:17%;">The delimiter provided to
<tt>&quot;extract_bracketed&quot;</tt> was not one of
<tt>'()[]&lt;&gt;{}'</tt>.</p>

<p style="margin-left:11%;">&quot;Did not find prefix:
/%s/&quot;</p>

<p style="margin-left:17%;">A non-optional prefix was
specified but wasn&rsquo;t found at the start of the
text.</p>

<p style="margin-left:11%;">&quot;Did not find opening
bracket after prefix: &quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_bracketed&quot;</tt>
or <tt>&quot;extract_codeblock&quot;</tt> was expecting a
particular kind of bracket at the start of the text, and
didn&rsquo;t find it.</p>

<p style="margin-left:11%;">&quot;No quotelike operator
found after prefix: &quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_quotelike&quot;</tt>
didn&rsquo;t find one of the quotelike operators
<tt>&quot;q&quot;</tt>, <tt>&quot;qq&quot;</tt>,
<tt>&quot;qw&quot;</tt>, <tt>&quot;qx&quot;</tt>,
<tt>&quot;s&quot;</tt>, <tt>&quot;tr&quot;</tt> or
<tt>&quot;y&quot;</tt> at the start of the substring it was
extracting.</p>

<p style="margin-left:11%;">&quot;Unmatched closing
bracket: &quot;%c&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_bracketed&quot;</tt>,
<tt>&quot;extract_quotelike&quot;</tt> or
<tt>&quot;extract_codeblock&quot;</tt> encountered a closing
bracket where none was expected.</p>

<p style="margin-left:11%;">&quot;Unmatched opening
bracket(s): &quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_bracketed&quot;</tt>,
<tt>&quot;extract_quotelike&quot;</tt> or
<tt>&quot;extract_codeblock&quot;</tt> ran out of characters
in the text before closing one or more levels of nested
brackets.</p>

<p style="margin-left:11%;">&quot;Unmatched embedded quote
(%s)&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_bracketed&quot;</tt>
attempted to match an embedded quoted substring, but failed
to find a closing quote to match it.</p>

<p style="margin-left:11%;">&quot;Did not find closing
delimiter to match '%s'&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_quotelike&quot;</tt>
was unable to find a closing delimiter to match the one that
opened the quote-like operation.</p>

<p style="margin-left:11%;">&quot;Mismatched closing
bracket: expected &quot;%c&quot; but found
&quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_bracketed&quot;</tt>,
<tt>&quot;extract_quotelike&quot;</tt> or
<tt>&quot;extract_codeblock&quot;</tt> found a valid bracket
delimiter, but it was the wrong species. This usually
indicates a nesting error, but may indicate incorrect
quoting or escaping.</p>

<p style="margin-left:11%;">&quot;No block delimiter found
after quotelike &quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_quotelike&quot;</tt>
or <tt>&quot;extract_codeblock&quot;</tt> found one of the
quotelike operators <tt>&quot;q&quot;</tt>,
<tt>&quot;qq&quot;</tt>, <tt>&quot;qw&quot;</tt>,
<tt>&quot;qx&quot;</tt>, <tt>&quot;s&quot;</tt>,
<tt>&quot;tr&quot;</tt> or <tt>&quot;y&quot;</tt> without a
suitable block after it.</p>

<p style="margin-left:11%;">&quot;Did not find leading
dereferencer&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_variable&quot;</tt>
was expecting one of &rsquo;$&rsquo;, &rsquo;@&rsquo;, or
&rsquo;%&rsquo; at the start of a variable, but didn&rsquo;t
find any of them.</p>

<p style="margin-left:11%;">&quot;Bad identifier after
dereferencer&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_variable&quot;</tt>
found a &rsquo;$&rsquo;, &rsquo;@&rsquo;, or &rsquo;%&rsquo;
indicating a variable, but that character was not followed
by a legal Perl identifier.</p>

<p style="margin-left:11%;">&quot;Did not find expected
opening bracket at %s&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_codeblock&quot;</tt>
failed to find any of the outermost opening brackets that
were specified.</p>

<p style="margin-left:11%;">&quot;Improperly nested
codeblock at %s&quot;</p>

<p style="margin-left:17%;">A nested code block was found
that started with a delimiter that was specified as being
only to be used as an outermost bracket.</p>

<p style="margin-left:11%;">&quot;Missing second block for
quotelike &quot;%s&quot;&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_codeblock&quot;</tt>
or <tt>&quot;extract_quotelike&quot;</tt> found one of the
quotelike operators <tt>&quot;s&quot;</tt>,
<tt>&quot;tr&quot;</tt> or <tt>&quot;y&quot;</tt> followed
by only one block.</p>

<p style="margin-left:11%;">&quot;No match found for
opening bracket&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_codeblock&quot;</tt>
failed to find a closing bracket to match the outermost
opening bracket.</p>

<p style="margin-left:11%;">&quot;Did not find opening tag:
/%s/&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_tagged&quot;</tt>
did not find a suitable opening tag (after any specified
prefix was removed).</p>

<p style="margin-left:11%;">&quot;Unable to construct
closing tag to match: /%s/&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_tagged&quot;</tt>
matched the specified opening tag and tried to modify the
matched text to produce a matching closing tag (because none
was specified). It failed to generate the closing tag,
almost certainly because the opening tag did not start with
a bracket of some kind.</p>

<p style="margin-left:11%;">&quot;Found invalid nested tag:
%s&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_tagged&quot;</tt>
found a nested tag that appeared in the &quot;reject&quot;
list (and the failure mode was not &quot; <small>MAX</small>
&quot; or &quot; <small>PARA</small> &quot;).</p>

<p style="margin-left:11%;">&quot;Found unbalanced nested
tag: %s&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_tagged&quot;</tt>
found a nested opening tag that was not matched by a
corresponding nested closing tag (and the failure mode was
not &quot; <small>MAX</small> &quot; or &quot;
<small>PARA</small> &quot;).</p>

<p style="margin-left:11%;">&quot;Did not find closing
tag&quot;</p>


<p style="margin-left:17%;"><tt>&quot;extract_tagged&quot;</tt>
reached the end of the text without finding a closing tag to
match the original opening tag (and the failure mode was not
&quot; <small>MAX</small> &quot; or &quot;
<small>PARA</small> &quot;).</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Damian Conway
(damian@conway.org)</p>

<h2>BUGS AND IRRITATIONS
<a name="BUGS AND IRRITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
undoubtedly serious bugs lurking somewhere in this code, if
only because parts of it give the impression of
understanding a great deal more about Perl than they really
do.</p>

<p style="margin-left:11%; margin-top: 1em">Bug reports and
other feedback are most welcome.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright 1997
&minus; 2001 Damian Conway. All Rights Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Some (minor)
parts copyright 2009 Adam Kennedy.</p>

<p style="margin-left:11%; margin-top: 1em">This module is
free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
