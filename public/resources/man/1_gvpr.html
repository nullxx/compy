<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:58:18 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GVPR</title>

</head>
<body>

<h1 align="center">GVPR</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#OPERANDS">OPERANDS</a><br>
<a href="#PROGRAMS">PROGRAMS</a><br>
<a href="#BUILT-IN FUNCTIONS">BUILT-IN FUNCTIONS</a><br>
<a href="#BUILT-IN VARIABLES">BUILT-IN VARIABLES</a><br>
<a href="#BUILT-IN CONSTANTS">BUILT-IN CONSTANTS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#BUGS AND WARNINGS">BUGS AND WARNINGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">gvpr &minus;
graph pattern scanning and processing language <br>
( previously known as <b>gpr</b> )</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>gvpr</b>
[<b>&minus;icnqV?</b>] [ <b>&minus;o</b> <i>outfile</i> ] [
<b>&minus;a</b> <i>args</i> ] [ <i>&rsquo;prog&rsquo;</i> |
<b>&minus;f</b> <i>progfile</i> ] [ <i>files</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>gvpr</b> is
a graph stream editor inspired by <b>awk</b>. It copies
input graphs to its output, possibly transforming their
structure and attributes, creating new graphs, or printing
arbitrary information. The graph model is that provided by
<i>libcgraph</i>(3). In particular, <b>gvpr</b> reads and
writes graphs using the dot language.</p>

<p style="margin-left:11%; margin-top: 1em">Basically,
<b>gvpr</b> traverses each input graph, denoted by
<b>$G</b>, visiting each node and edge, matching it with the
predicate-action rules supplied in the input program. The
rules are evaluated in order. For each predicate evaluating
to true, the corresponding action is performed. During the
traversal, the current node or edge being visited is denoted
by <b>$</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For each input
graph, there is a target subgraph, denoted by <b>$T</b>,
initially empty and used to accumulate chosen entities, and
an output graph, <b>$O</b>, used for final processing and
then written to output. By default, the output graph is the
target graph. The output graph can be set in the program or,
in a limited sense, on the command line.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
options are supported: <b><br>
&minus;a</b> <i>args</i></p>

<p style="margin-left:22%;">The string <i>args</i> is split
into whitespace-separated tokens, with the individual tokens
available as strings in the <b>gvpr</b> program as
<b>ARGV[</b><i>0</i><b>],...,ARGV[ARGC&minus;1]</b>.
Whitespace characters within single or double quoted
substrings, or preceded by a backslash, are ignored as
separators. In general, a backslash character turns off any
special meaning of the following character. Note that the
tokens derived from multiple <b>&minus;a</b> flags are
concatenated.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Use the source graph as the output graph.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;i</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Derive the node-induced subgraph extension of the output
graph in the context of its root graph.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;o</b>
<i>outfile</i></p>

<p style="margin-left:22%;">Causes the output stream to be
written to the specified file; by default, output is written
to <b>stdout</b>.</p>

<p style="margin-left:11%;"><b>&minus;f</b>
<i>progfile</i></p>

<p style="margin-left:22%;">Use the contents of the
specified file as the program to execute on the input. If
<i>progfile</i> contains a slash character, the name is
taken as the pathname of the file. Otherwise, <b>gvpr</b>
will use the directories specified in the environment
variable <b>GVPRPATH</b> to look for the file. If
<b>&minus;f</b> is not given, <b>gvpr</b> will use the first
non-option argument as the program.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;q</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Turns off warning messages.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Turns off graph read-ahead. By default, the variable
<b>$NG</b> is set to the next graph to be processed. This
requires a read of the next graph before processing the
current graph, which may block is the next graph is only
generated in response to some action pertaining to the
processing of the current graph.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Causes the program to print version information and
exit.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;?</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Causes the program to print usage information and
exit.</p> </td></tr>
</table>

<h2>OPERANDS
<a name="OPERANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
operand is supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><i>files</i></p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">Names of files containing 1 or
more graphs in the dot language. If no <b>&minus;f</b>
option is given, the first name is removed from the list and
used as the input program. If the list of files is empty,
<b>stdin</b> will be used.</p></td></tr>
</table>

<h2>PROGRAMS
<a name="PROGRAMS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A <b>gvpr</b>
program consists of a list of predicate-action clauses,
having one of the forms:</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN {</b>
<i>action</i> <b>}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>BEG_G {</b>
<i>action</i> <b>}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>N [</b>
<i>predicate</i> <b>] {</b> <i>action</i> <b>}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>E [</b>
<i>predicate</i> <b>] {</b> <i>action</i> <b>}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>END_G {</b>
<i>action</i> <b>}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>END {</b>
<i>action</i> <b>}</b></p>

<p style="margin-left:11%; margin-top: 1em">A program can
contain at most one of each of the <b>BEGIN</b>,
<b>END_G</b> and <b>END</b> clauses. There can be any number
of <b>BEG_G</b>, <b>N</b> and <b>E</b> statements, the first
applied to graphs, the second to nodes, the third to edges.
These are separated into blocks, a block consisting of an
optional <b>BEG_G</b> statement and all <b>N</b> and
<b>E</b> statements up to the next <b>BEG_G</b> statement,
if any. The top-level semantics of a <b>gvpr</b> program
are:</p>

<p style="margin-left:22%; margin-top: 1em">Evaluate the
<b>BEGIN</b> clause, if any. <br>
For each input graph <i>G</i> { <br>
For each block { <br>
Set <i>G</i> as the current graph and current object. <br>
Evaluate the <b>BEG_G</b> clause, if any. <br>
For each node and edge in <i>G</i> { <br>
Set the node or edge as the current object. <br>
Evaluate the <b>N</b> or <b>E</b> clauses, as appropriate.
<br>
} <br>
} <br>
Set <i>G</i> as the current object. <br>
Evaluate the <b>END_G</b> clause, if any. <br>
} <br>
Evaluate the <b>END</b> clause, if any.</p>

<p style="margin-left:11%; margin-top: 1em">The actions of
the <b>BEGIN</b>, <b>BEG_G</b>, <b>END_G</b> and <b>END</b>
clauses are performed when the clauses are evaluated. For
<b>N</b> or <b>E</b> clauses, either the predicate or action
may be omitted. If there is no predicate with an action, the
action is performed on every node or edge, as appropriate.
If there is no action and the predicate evaluates to true,
the associated node or edge is added to the target
graph.</p>

<p style="margin-left:11%; margin-top: 1em">The blocks are
evaluated in the order in which they occur. Within a block,
the <b>N</b> clauses (<b>E</b> clauses, respectively) are
evaluated in the order in which the occur. Note, though,
that within a block, <b>N</b> or <b>E</b> clauses may be
interlaced, depending on the traversal order.</p>

<p style="margin-left:11%; margin-top: 1em">Predicates and
actions are sequences of statements in the C dialect
supported by the <i>expr</i>(3) library. The only difference
between predicates and actions is that the former must have
a type that may interpreted as either true or false. Here
the usual C convention is followed, in which a non-zero
value is considered true. This would include non-empty
strings and non-empty references to nodes, edges, etc.
However, if a string can be converted to an integer, this
value is used.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the usual C base types (<b>void</b>, <b>int</b>,
<b>char</b>, <b>float</b>, <b>long</b>, <b>unsigned</b> and
<b>double</b>), <b>gvpr</b> provides <b>string</b> as a
synonym for <b>char*</b>, and the graph-based types
<b>node_t</b>, <b>edge_t</b>, <b>graph_t</b> and
<b>obj_t</b>. The <b>obj_t</b> type can be viewed as a
supertype of the other 3 concrete types; the correct base
type is maintained dynamically. Besides these base types,
the only other supported type expressions are (associative)
arrays.</p>

<p style="margin-left:11%; margin-top: 1em">Constants
follow C syntax, but strings may be quoted with either
<b>&quot;...&quot;</b> or <b>&rsquo;...&rsquo;</b>.
<b>gvpr</b> accepts C++ comments as well as cpp-type
comments. For the latter, if a line begins with a
&rsquo;#&rsquo; character, the rest of the line is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">A statement can
be a declaration of a function, a variable or an array, or
an executable statement. For declarations, there is a single
scope. Array declarations have the form:</p>

<p style="margin-left:22%; margin-top: 1em"><i>type
array</i> <b>[</b> <i>type0</i> <b>]</b></p>

<p style="margin-left:11%; margin-top: 1em">where
<i>type0</i> is optional. If it is supplied, the parser will
enforce that all array subscripts have the specified type.
If it is not supplied, objects of all types can be used as
subscripts. As in C, variables and arrays must be declared.
In particular, an undeclared variable will be interpreted as
the name of an attribute of a node, edge or graph, depending
on the context.</p>

<p style="margin-left:11%; margin-top: 1em">Executable
statements can be one of the following:</p>

<p style="margin-left:22%;"><b>{</b> [ <i>statement ...</i>
] <b>}</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="15%">


<p><i>expression</i></p></td>
<td width="63%">


<p>// commonly <i>var</i> <b>=</b> <i>expression</i></p></td></tr>
</table>

<p style="margin-left:22%;"><b>if(</b> <i>expression</i>
<b>)</b> <i>statement</i> [ <b>else</b> <i>statement</i> ]
<b><br>
for(</b> <i>expression</i> <b>;</b> <i>expression</i>
<b>;</b> <i>expression</i> <b>)</b> <i>statement</i> <b><br>
for(</b> <i>array</i> <b>[</b> <i>var</i> <b>])</b>
<i>statement</i> <b><br>
forr(</b> <i>array</i> <b>[</b> <i>var</i> <b>])</b>
<i>statement</i> <b><br>
while(</b> <i>expression</i> <b>)</b> <i>statement</i>
<b><br>
switch(</b> <i>expression</i> <b>)</b> <i>case
statements</i> <b><br>
break [</b> <i>expression</i> <b>] <br>
continue [</b> <i>expression</i> <b>] <br>
return [</b> <i>expression</i> <b>]</b></p>

<p style="margin-left:11%;"><small>Items in brackets are
optional.</small></p>

<p style="margin-left:11%; margin-top: 1em">In the second
form of the <b>for</b> statement and the <b>forr</b>
statement, the variable <i>var</i> is set to each value used
as an index in the specified array and then the associated
<i>statement</i> is evaluated. For numeric and string
indices, the indices are returned in increasing (decreasing)
numeric or lexicographic order for <b>for</b> (<b>forr</b>,
respectively). This can be used for sorting.</p>

<p style="margin-left:11%; margin-top: 1em">Function
definitions can only appear in the <b>BEGIN</b> clause.</p>

<p style="margin-left:11%; margin-top: 1em">Expressions
include the usual C expressions. String comparisons using
<b>==</b> and <b>!=</b> treat the right hand operand as a
pattern for the purpose of regular expression matching.
Patterns use <i>ksh</i>(1) file match pattern syntax. (For
simple string equality, use the <b>strcmp</b> function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>gvpr</b>
will attempt to use an expression as a string or numeric
value as appropriate. Both C-like casts and function
templates will cause conversions to be performed, if
possible.</p>

<p style="margin-left:11%; margin-top: 1em">Expressions of
graphical type (i.e., <b>graph_t, node_t, edge_t, obj_t</b>)
may be followed by a field reference in the form of
<b>.</b><i>name</i>. The resulting value is the value of the
attribute named <i>name</i> of the given object. In
addition, in certain contexts an undeclared, unmodified
identifier is taken to be an attribute name. Specifically,
such identifiers denote attributes of the current node or
edge, respectively, in <b>N</b> and <b>E</b> clauses, and
the current graph in <b>BEG_G</b> and <b>END_G</b>
clauses.</p>

<p style="margin-left:11%; margin-top: 1em">As usual in the
<i>libcgraph</i>(3) model, attributes are string-valued. In
addition, <b>gvpr</b> supports certain pseudo-attributes of
graph objects, not necessarily string-valued. These reflect
intrinsic properties of the graph objects and cannot be set
by the user. <b><br>
head</b> : <b>node_t</b></p>

<p style="margin-left:22%;">the head of an edge.</p>

<p style="margin-left:11%;"><b>tail</b> : <b>node_t</b></p>

<p style="margin-left:22%;">the tail of an edge.</p>

<p style="margin-left:11%;"><b>name</b> : <b>string</b></p>

<p style="margin-left:22%;">the name of an edge, node or
graph. The name of an edge has the form
&quot;<i>&lt;tail-name&gt;&lt;edge-op&gt;&lt;head-name&gt;</i><b>[</b><i>&lt;key&gt;</i><b>]</b>&quot;,
where <i>&lt;edge-op&gt;</i> is
&quot;<b>&minus;&gt;</b>&quot; or
&quot;<b>&minus;&minus;</b>&quot; depending on whether the
graph is directed or not. The bracket part
<b>[</b><i>&lt;key&gt;</i><b>]</b> only appears if the edge
has a non-trivial key.</p>

<p style="margin-left:11%;"><b>indegree</b> :
<b>int</b></p>

<p style="margin-left:22%;">the indegree of a node.</p>

<p style="margin-left:11%;"><b>outdegree</b> :
<b>int</b></p>

<p style="margin-left:22%;">the outdegree of a node.</p>

<p style="margin-left:11%;"><b>degree</b> : <b>int</b></p>

<p style="margin-left:22%;">the degree of a node.</p>

<p style="margin-left:11%;"><b>root</b> :
<b>graph_t</b></p>

<p style="margin-left:22%;">the root graph of an object.
The root of a root graph is itself.</p>

<p style="margin-left:11%;"><b>parent</b> :
<b>graph_t</b></p>

<p style="margin-left:22%;">the parent graph of a subgraph.
The parent of a root graph is <b>NULL</b></p>

<p style="margin-left:11%;"><b>n_edges</b> : <b>int</b></p>

<p style="margin-left:22%;">the number of edges in the
graph</p>

<p style="margin-left:11%;"><b>n_nodes</b> : <b>int</b></p>

<p style="margin-left:22%;">the number of nodes in the
graph</p>

<p style="margin-left:11%;"><b>directed</b> :
<b>int</b></p>

<p style="margin-left:22%;">true (non-zero) if the graph is
directed</p>

<p style="margin-left:11%;"><b>strict</b> : <b>int</b></p>

<p style="margin-left:22%;">true (non-zero) if the graph is
strict</p>

<h2>BUILT-IN FUNCTIONS
<a name="BUILT-IN FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions are built into <b>gvpr</b>. Those functions
returning references to graph objects return <b>NULL</b> in
case of failure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Graphs and
subgraph <br>
graph</b>(<i>s</i> : <b>string</b>, <i>t</i> :
<b>string</b>) : <b>graph_t</b></p>

<p style="margin-left:22%;">creates a graph whose name is
<i>s</i> and whose type is specified by the string <i>t</i>.
Ignoring case, the characters <b>U, D, S, N</b> have the
interpretation undirected, directed, strict, and non-strict,
respectively. If <i>t</i> is empty, a directed, non-strict
graph is generated.</p>

<p style="margin-left:11%;"><b>subg</b>(<i>g</i> :
<b>graph_t</b>, <i>s</i> : <b>string</b>) :
<b>graph_t</b></p>

<p style="margin-left:22%;">creates a subgraph in graph
<i>g</i> with name <i>s</i>. If the subgraph already exists,
it is returned.</p>

<p style="margin-left:11%;"><b>isSubg</b>(<i>g</i> :
<b>graph_t</b>, <i>s</i> : <b>string</b>) :
<b>graph_t</b></p>

<p style="margin-left:22%;">returns the subgraph in graph
<i>g</i> with name <i>s</i>, if it exists, or <b>NULL</b>
otherwise.</p>

<p style="margin-left:11%;"><b>fstsubg</b>(<i>g</i> :
<b>graph_t</b>) : <b>graph_t</b></p>

<p style="margin-left:22%;">returns the first subgraph in
graph <i>g</i>, or <b>NULL</b> if none exists.</p>

<p style="margin-left:11%;"><b>nxtsubg</b>(<i>sg</i> :
<b>graph_t</b>) : <b>graph_t</b></p>

<p style="margin-left:22%;">returns the next subgraph after
<i>sg</i>, or <b>NULL</b>.</p>

<p style="margin-left:11%;"><b>isDirect</b>(<i>g</i> :
<b>graph_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns true if and only if
<i>g</i> is directed.</p>

<p style="margin-left:11%;"><b>isStrict</b>(<i>g</i> :
<b>graph_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns true if and only if
<i>g</i> is strict.</p>

<p style="margin-left:11%;"><b>nNodes</b>(<i>g</i> :
<b>graph_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the number of nodes in
<i>g</i>.</p>

<p style="margin-left:11%;"><b>nEdges</b>(<i>g</i> :
<b>graph_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the number of edges in
<i>g</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Nodes <br>
node</b>(<i>sg</i> : <b>graph_t</b>, <i>s</i> :
<b>string</b>) : <b>node_t</b></p>

<p style="margin-left:22%;">creates a node in graph
<i>g</i> of name <i>s</i>. If such a node already exists, it
is returned.</p>

<p style="margin-left:11%;"><b>subnode</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>node_t</b></p>

<p style="margin-left:22%;">inserts the node <i>n</i> into
the subgraph <i>g</i>. Returns the node.</p>

<p style="margin-left:11%;"><b>fstnode</b>(<i>g</i> :
<b>graph_t</b>) : <b>node_t</b></p>

<p style="margin-left:22%;">returns the first node in graph
<i>g</i>, or <b>NULL</b> if none exists.</p>

<p style="margin-left:11%;"><b>nxtnode</b>(<i>n</i> :
<b>node_t</b>) : <b>node_t</b></p>

<p style="margin-left:22%;">returns the next node after
<i>n</i> in the root graph, or <b>NULL</b>.</p>

<p style="margin-left:11%;"><b>nxtnode_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>node_t</b></p>

<p style="margin-left:22%;">returns the next node after
<i>n</i> in <i>sg</i>, or <b>NULL</b>.</p>

<p style="margin-left:11%;"><b>isNode</b>(<i>sg</i> :
<b>graph_t</b>, <i>s</i> : <b>string</b>) :
<b>node_t</b></p>

<p style="margin-left:22%;">looks for a node in (sub)graph
<i>sg</i> of name <i>s</i>. If such a node exists, it is
returned. Otherwise, <b>NULL</b> is returned.</p>

<p style="margin-left:11%;"><b>isSubnode</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns non-zero if node
<i>n</i> is in (sub)graph <i>sg</i>, or zero otherwise.</p>

<p style="margin-left:11%;"><b>indegreeOf</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the indegree of node
<i>n</i> in (sub)graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>outdegreeOf</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the outdegree of node
<i>n</i> in (sub)graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>degreeOf</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the degree of node
<i>n</i> in (sub)graph <i>sg</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Edges <br>
edge</b>(<i>t</i> : <b>node_t</b>, <i>h</i> : <b>node_t</b>,
<i>s</i> : <b>string</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">creates an edge with tail node
<i>t</i>, head node <i>h</i> and name <i>s</i> in the root
graph. If the graph is undirected, the distinction between
head and tail nodes is unimportant. If such an edge already
exists, it is returned.</p>

<p style="margin-left:11%;"><b>edge_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>t</i> : <b>node_t</b>, <i>h</i> :
<b>node_t</b>, <i>s</i> : <b>string</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">creates an edge with tail node
<i>t</i>, head node <i>h</i> and name <i>s</i> in (sub)graph
<i>sg</i> (and all parent graphs). If the graph is
undirected, the distinction between head and tail nodes is
unimportant. If such an edge already exists, it is
returned.</p>

<p style="margin-left:11%;"><b>subedge</b>(<i>g</i> :
<b>graph_t</b>, <i>e</i> : <b>edge_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">inserts the edge <i>e</i> into
the subgraph <i>g</i>. Returns the edge.</p>

<p style="margin-left:11%;"><b>isEdge</b>(<i>t</i> :
<b>node_t</b>, <i>h</i> : <b>node_t</b>, <i>s</i> :
<b>string</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">looks for an edge with tail
node <i>t</i>, head node <i>h</i> and name <i>s</i>. If the
graph is undirected, the distinction between head and tail
nodes is unimportant. If such an edge exists, it is
returned. Otherwise, <b>NULL</b> is returned.</p>

<p style="margin-left:11%;"><b>isEdge_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>t</i> : <b>node_t</b>, <i>h</i> :
<b>node_t</b>, <i>s</i> : <b>string</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">looks for an edge with tail
node <i>t</i>, head node <i>h</i> and name <i>s</i> in
(sub)graph <i>sg</i>. If the graph is undirected, the
distinction between head and tail nodes is unimportant. If
such an edge exists, it is returned. Otherwise, <b>NULL</b>
is returned.</p>

<p style="margin-left:11%;"><b>isSubedge</b>(<i>g</i> :
<b>graph_t</b>, <i>e</i> : <b>edge_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns non-zero if edge
<i>e</i> is in (sub)graph <i>sg</i>, or zero otherwise.</p>

<p style="margin-left:11%;"><b>fstout</b>(<i>n</i> :
<b>node_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the first outedge of
node <i>n</i> in the root graph.</p>

<p style="margin-left:11%;"><b>fstout_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the first outedge of
node <i>n</i> in (sub)graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>nxtout</b>(<i>e</i> :
<b>edge_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the next outedge after
<i>e</i> in the root graph.</p>

<p style="margin-left:11%;"><b>nxtout_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>e</i> : <b>edge_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the next outedge after
<i>e</i> in graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>fstin</b>(<i>n</i> :
<b>node_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the first inedge of
node <i>n</i> in the root graph.</p>

<p style="margin-left:11%;"><b>fstin_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the first inedge of
node <i>n</i> in graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>nxtin</b>(<i>e</i> :
<b>edge_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the next inedge after
<i>e</i> in the root graph.</p>

<p style="margin-left:11%;"><b>nxtin_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>e</i> : <b>edge_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the next inedge after
<i>e</i> in graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>fstedge</b>(<i>n</i> :
<b>node_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the first edge of node
<i>n</i> in the root graph.</p>

<p style="margin-left:11%;"><b>fstedge_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the first edge of node
<i>n</i> in graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>nxtedge</b>(<i>e</i> :
<b>edge_t</b>, <b>node_t</b>) : <b>edge_t</b></p>

<p style="margin-left:22%;">returns the next edge after
<i>e</i> in the root graph.</p>

<p style="margin-left:11%;"><b>nxtedge_sg</b>(<i>sg</i> :
<b>graph_t</b>, <i>e</i> : <b>edge_t</b>, <b>node_t</b>) :
<b>edge_t</b></p>

<p style="margin-left:22%;">returns the next edge after
<i>e</i> in the graph <i>sg</i>.</p>

<p style="margin-left:11%;"><b>opp</b>(<i>e</i> :
<b>edge_t</b>, <b>node_t</b>) : <b>node_t</b></p>

<p style="margin-left:22%;">returns the node on the edge
<i>e</i> not equal to <i>n</i>. Returns NULL if <i>n</i> is
not a node of <i>e</i>. This can be useful when using
<b>fstedge</b> and <b>nxtedge</b> to enumerate the neighbors
of <i>n</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Graph I/O
<br>
write</b>(<i>g</i> : <b>graph_t</b>) : <b>void</b></p>

<p style="margin-left:22%;">prints <i>g</i> in dot format
onto the output stream.</p>

<p style="margin-left:11%;"><b>writeG</b>(<i>g</i> :
<b>graph_t</b>, <i>fname</i> : <b>string</b>) :
<b>void</b></p>

<p style="margin-left:22%;">prints <i>g</i> in dot format
into the file <i>fname</i>.</p>

<p style="margin-left:11%;"><b>fwriteG</b>(<i>g</i> :
<b>graph_t</b>, <i>fd</i> : <b>int</b>) : <b>void</b></p>

<p style="margin-left:22%;">prints <i>g</i> in dot format
onto the open stream denoted by the integer <i>fd</i>.</p>

<p style="margin-left:11%;"><b>readG</b>(<i>fname</i> :
<b>string</b>) : <b>graph_t</b></p>

<p style="margin-left:22%;">returns a graph read from the
file <i>fname</i>. The graph should be in dot format. If no
graph can be read, <b>NULL</b> is returned.</p>

<p style="margin-left:11%;"><b>freadG</b>(<i>fd</i> :
<b>int</b>) : <b>graph_t</b></p>

<p style="margin-left:22%;">returns the next graph read
from the open stream <i>fd</i>. Returns <b>NULL</b> at end
of file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Graph
miscellany <br>
delete</b>(<i>g</i> : <b>graph_t</b>, <i>x</i> :
<b>obj_t</b>) : <b>void</b></p>

<p style="margin-left:22%;">deletes object <i>x</i> from
graph <i>g</i>. If <i>g</i> is <b>NULL</b>, the function
uses the root graph of <i>x</i>. If <i>x</i> is a graph or
subgraph, it is closed unless <i>x</i> is locked.</p>

<p style="margin-left:11%;"><b>isIn</b>(<i>g</i> :
<b>graph_t</b>, <i>x</i> : <b>obj_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns true if <i>x</i> is in
subgraph <i>g</i>.</p>

<p style="margin-left:11%;"><b>cloneG</b>(<i>g</i> :
<b>graph_t</b>, <i>s</i> : <b>string</b>) :
<b>graph_t</b></p>

<p style="margin-left:22%;">creates a clone of graph
<i>g</i> with name of <i>s</i>. If <i>s</i> is &quot;&quot;,
the created graph has the same name as <i>g</i>.</p>

<p style="margin-left:11%;"><b>clone</b>(<i>g</i> :
<b>graph_t</b>, <i>x</i> : <b>obj_t</b>) : <b>obj_t</b></p>

<p style="margin-left:22%;">creates a clone of object
<i>x</i> in graph <i>g</i>. In particular, the new object
has the same name/value attributes and structure as the
original object. If an object with the same key as <i>x</i>
already exists, its attributes are overlaid by those of
<i>x</i> and the object is returned. If an edge is cloned,
both endpoints are implicitly cloned. If a graph is cloned,
all nodes, edges and subgraphs are implicitly cloned. If
<i>x</i> is a graph, <i>g</i> may be <b>NULL</b>, in which
case the cloned object will be a new root graph. In this
case, the call is equivalent to
<b>cloneG(</b><i>x</i><b>,&quot;&quot;)</b>.</p>

<p style="margin-left:11%;"><b>copy</b>(<i>g</i> :
<b>graph_t</b>, <i>x</i> : <b>obj_t</b>) : <b>obj_t</b></p>

<p style="margin-left:22%;">creates a copy of object
<i>x</i> in graph <i>g</i>, where the new object has the
same name/value attributes as the original object. If an
object with the same key as <i>x</i> already exists, its
attributes are overlaid by those of <i>x</i> and the object
is returned. Note that this is a shallow copy. If <i>x</i>
is a graph, none of its nodes, edges or subgraphs are copied
into the new graph. If <i>x</i> is an edge, the endpoints
are created if necessary, but they are not cloned. If
<i>x</i> is a graph, <i>g</i> may be <b>NULL</b>, in which
case the cloned object will be a new root graph.</p>

<p style="margin-left:11%;"><b>copyA</b>(<i>src</i> :
<b>obj_t</b>, <i>tgt</i> : <b>obj_t</b>) : <b>int</b></p>

<p style="margin-left:22%;">copies the attributes of object
<i>src</i> to object <i>tgt</i>, overwriting any attribute
values <i>tgt</i> may initially have.</p>

<p style="margin-left:11%;"><b>induce</b>(<i>g</i> :
<b>graph_t</b>) : <b>void</b></p>

<p style="margin-left:22%;">extends <i>g</i> to its
node-induced subgraph extension in its root graph.</p>

<p style="margin-left:11%;"><b>hasAttr</b>(<i>src</i> :
<b>obj_t</b>, <i>name</i> : <b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns non-zero if object
<i>src</i> has an attribute whose name is <i>name</i>. It
returns 0 otherwise.</p>

<p style="margin-left:11%;"><b>isAttr</b>(<i>g</i> :
<b>graph_t</b>, <i>kind</i> : <b>string</b>, <i>name</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns non-zero if an
attribute <i>name</i> has been defined in <i>g</i> for
objects of the given <i>kind</i>. For nodes, edges, and
graphs, <i>kind</i> should be &quot;N&quot;, &quot;E&quot;,
and &quot;G&quot;, respectively. It returns 0 otherwise.</p>

<p style="margin-left:11%;"><b>aget</b>(<i>src</i> :
<b>obj_t</b>, <i>name</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">returns the value of attribute
<i>name</i> in object <i>src</i>. This is useful for those
cases when <i>name</i> conflicts with one of the keywords
such as &quot;head&quot; or &quot;root&quot;. If the
attribute has not been declared in the graph, the function
will initialize it with a default value of &quot;&quot;. To
avoid this, one should use the <b>hasAttr</b> or
<b>isAttr</b> function to check that the attribute
exists.</p>

<p style="margin-left:11%;"><b>aset</b>(<i>src</i> :
<b>obj_t</b>, <i>name</i> : <b>string</b>, <i>value</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">sets the value of attribute
<i>name</i> in object <i>src</i> to <i>value</i>. Returns 0
on success, non-zero on failure. See <b>aget</b> above.</p>

<p style="margin-left:11%;"><b>getDflt</b>(<i>g</i> :
<b>graph_t</b>, <i>kind</i> : <b>string</b>, <i>name</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the default value of
attribute <i>name</i> in objects in <i>g</i> of the given
<i>kind</i>. For nodes, edges, and graphs, <i>kind</i>
should be &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If the attribute has not been declared in the
graph, the function will initialize it with a default value
of &quot;&quot;. To avoid this, one should use the
<b>isAttr</b> function to check that the attribute
exists.</p>

<p style="margin-left:11%;"><b>setDflt</b>(<i>g</i> :
<b>graph_t</b>, <i>kind</i> : <b>string</b>, <i>name</i> :
<b>string</b>, <i>value</i> : <b>string</b>) : <b><br>
int</b></p>

<p style="margin-left:22%;">sets the default value of
attribute <i>name</i> to <i>value</i> in objects in <i>g</i>
of the given <i>kind</i>. For nodes, edges, and graphs,
<i>kind</i> should be &quot;N&quot;, &quot;E&quot;, and
&quot;G&quot;, respectively. Returns 0 on success, non-zero
on failure. See <b>getDflt</b> above.</p>

<p style="margin-left:11%;"><b>fstAttr</b>(<i>g</i> :
<b>graph_t</b>, <i>kind</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">returns the name of the first
attribute of objects in <i>g</i> of the given <i>kind</i>.
For nodes, edges, and graphs, <i>kind</i> should be
&quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If there are no attributes, the string
&quot;&quot; is returned.</p>

<p style="margin-left:11%;"><b>nxtAttr</b>(<i>g</i> :
<b>graph_t</b>, <i>kind</i> : <b>string</b>, <i>name</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the name of the next
attribute of objects in <i>g</i> of the given <i>kind</i>
after the attribute <i>name</i>. The argument <i>name</i>
must be the name of an existing attribute; it will typically
be the return value of an previous call to <b>fstAttr</b> or
<b>nxtAttr</b>. For nodes, edges, and graphs, <i>kind</i>
should be &quot;N&quot;, &quot;E&quot;, and &quot;G&quot;,
respectively. If there are no attributes left, the string
&quot;&quot; is returned.</p>

<p style="margin-left:11%;"><b>compOf</b>(<i>g</i> :
<b>graph_t</b>, <i>n</i> : <b>node_t</b>) :
<b>graph_t</b></p>

<p style="margin-left:22%;">returns the connected component
of the graph <i>g</i> containing node <i>n</i>, as a
subgraph of <i>g</i>. The subgraph only contains the nodes.
One can use <i>induce</i> to add the edges. The function
fails and returns <b>NULL</b> if <i>n</i> is not in
<i>g</i>. Connectivity is based on the underlying undirected
graph of <i>g</i>.</p>

<p style="margin-left:11%;"><b>kindOf</b>(<i>obj</i> :
<b>obj_t</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns an indication of what
kind of graph object is the argument. For nodes, edges, and
graphs, it returns should be &quot;N&quot;, &quot;E&quot;,
and &quot;G&quot;, respectively.</p>

<p style="margin-left:11%;"><b>lock</b>(<i>g</i> :
<b>graph_t</b>, <i>v</i> : <b>int</b>) : <b>int</b></p>

<p style="margin-left:22%;">implements graph locking on
root graphs. If the integer <i>v</i> is positive, the graph
is set so that future calls to <b>delete</b> have no
immediate effect. If <i>v</i> is zero, the graph is
unlocked. If there has been a call to delete the graph while
it was locked, the graph is closed. If <i>v</i> is negative,
nothing is done. In all cases, the previous lock value is
returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Strings <br>
sprintf</b>(<i>fmt</i> : <b>string</b>, <i>...</i>) :
<b>string</b></p>

<p style="margin-left:22%;">returns the string resulting
from formatting the values of the expressions occurring
after <i>fmt</i> according to the <i>printf</i>(3) format
<i>fmt</i></p>

<p style="margin-left:11%;"><b>gsub</b>(<i>str</i> :
<b>string</b>, <i>pat</i> : <b>string</b>) : <b>string <br>
gsub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
<b>string</b>, <i>repl</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">returns <i>str</i> with all
substrings matching <i>pat</i> deleted or replaced by
<i>repl</i>, respectively.</p>

<p style="margin-left:11%;"><b>sub</b>(<i>str</i> :
<b>string</b>, <i>pat</i> : <b>string</b>) : <b>string <br>
sub</b>(<i>str</i> : <b>string</b>, <i>pat</i> :
<b>string</b>, <i>repl</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">returns <i>str</i> with the
leftmost substring matching <i>pat</i> deleted or replaced
by <i>repl</i>, respectively. The characters &rsquo;^&rsquo;
and &rsquo;$&rsquo; may be used at the beginning and end,
respectively, of <i>pat</i> to anchor the pattern to the
beginning or end of <i>str</i>.</p>

<p style="margin-left:11%;"><b>substr</b>(<i>str</i> :
<b>string</b>, <i>idx</i> : <b>int</b>) : <b>string <br>
substr</b>(<i>str</i> : <b>string</b>, <i>idx</i> :
<b>int</b>, <i>len</i> : <b>int</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the substring of
<i>str</i> starting at position <i>idx</i> to the end of the
string or of length <i>len</i>, respectively. Indexing
starts at 0. If <i>idx</i> is negative or <i>idx</i> is
greater than the length of <i>str</i>, a fatal error occurs.
Similarly, in the second case, if <i>len</i> is negative or
<i>idx</i> + <i>len</i> is greater than the length of
<i>str</i>, a fatal error occurs.</p>

<p style="margin-left:11%;"><b>strcmp</b>(<i>s1</i> :
<b>string</b>, <i>s2</i> : <b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">provides the standard C
function <i>strcmp</i>(3).</p>

<p style="margin-left:11%;"><b>length</b>(<i>s</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the length of string
<i>s</i>.</p>

<p style="margin-left:11%;"><b>index</b>(<i>s</i> :
<b>string</b>, <i>t</i> : <b>string</b>) : <b>int <br>
rindex</b>(<i>s</i> : <b>string</b>, <i>t</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the index of the
character in string <i>s</i> where the leftmost (rightmost)
copy of string <i>t</i> can be found, or &minus;1 if
<i>t</i> is not a substring of <i>s</i>.</p>

<p style="margin-left:11%;"><b>match</b>(<i>s</i> :
<b>string</b>, <i>p</i> : <b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns the index of the
character in string <i>s</i> where the leftmost match of
pattern <i>p</i> can be found, or &minus;1 if no substring
of <i>s</i> matches <i>p</i>.</p>

<p style="margin-left:11%;"><b>toupper</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns a version of <i>s</i>
with the alphabetic characters converted to upper-case.</p>

<p style="margin-left:11%;"><b>tolower</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns a version of <i>s</i>
with the alphabetic characters converted to lower-case.</p>

<p style="margin-left:11%;"><b>canon</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns a version of <i>s</i>
appropriate to be used as an identifier in a dot file.</p>

<p style="margin-left:11%;"><b>html</b>(<i>g</i> :
<b>graph_t</b>, <i>s</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">returns a
&lsquo;&lsquo;magic&rsquo;&rsquo; version of <i>s</i> as an
HTML string. This will typically be used to attach an
HTML-like label to a graph object. Note that the returned
string lives in <i>g</i>. In particular, it will be freed
when <i>g</i> is closed, and to act as an HTML string, it
has to be used with an object of <i>g</i>. In addition, note
that the angle bracket quotes should not be part of
<i>s</i>. These will be added if <i>g</i> is written in
concrete DOT format.</p>

<p style="margin-left:11%;"><b>ishtml</b>(<i>s</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">returns non-zero if and only if
<i>s</i> is an HTML string.</p>

<p style="margin-left:11%;"><b>xOf</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the string
&quot;<i>x</i>&quot; if <i>s</i> has the form
&quot;<i>x</i>,<i>y</i>&quot;, where both <i>x</i> and
<i>y</i> are numeric.</p>

<p style="margin-left:11%;"><b>yOf</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the string
&quot;<i>y</i>&quot; if <i>s</i> has the form
&quot;<i>x</i>,<i>y</i>&quot;, where both <i>x</i> and
<i>y</i> are numeric.</p>

<p style="margin-left:11%;"><b>llOf</b>(<i>s</i> :
<b>string</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the string
&quot;<i>llx</i>,<i>lly</i>&quot; if <i>s</i> has the form
&quot;<i>llx</i>,<i>lly</i>,<i>urx</i>,<i>ury</i>&quot;,
where all of <i>llx</i>, <i>lly</i>, <i>urx</i>, and
<i>ury</i> are numeric.</p>


<p style="margin-left:11%;"><b>urOf(</b><i>s</i><b>)</b></p>

<p style="margin-left:22%;"><b>urOf</b>(<i>s</i> :
<b>string</b>) : <b>string</b> returns the string
&quot;<i>urx</i>,<i>ury</i>&quot; if <i>s</i> has the form
&quot;<i>llx</i>,<i>lly</i>,<i>urx</i>,<i>ury</i>&quot;,
where all of <i>llx</i>, <i>lly</i>, <i>urx</i>, and
<i>ury</i> are numeric.</p>

<p style="margin-left:11%;"><b>sscanf</b>(<i>s</i> :
<b>string</b>, <i>fmt</i> : <b>string</b>, <i>...</i>) :
<b>int</b></p>

<p style="margin-left:22%;">scans the string <i>s</i>,
extracting values according to the <i>sscanf</i>(3) format
<i>fmt</i>. The values are stored in the addresses following
<i>fmt</i>, addresses having the form <b>&amp;</b><i>v</i>,
where <i>v</i> is some declared variable of the correct
type. Returns the number of items successfully scanned.</p>

<p style="margin-left:11%;"><b>split</b>(<i>s</i> :
<b>string</b>, <i>arr</i> : <b>array</b>, <i>seps</i> :
<b>string</b>) : <b>int <br>
split</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
<b>array</b>) : <b>int <br>
tokens</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
<b>array</b>, <i>seps</i> : <b>string</b>) : <b>int <br>
tokens</b>(<i>s</i> : <b>string</b>, <i>arr</i> :
<b>array</b>) : <b>int</b></p>

<p style="margin-left:22%;">The <b>split</b> function
breaks the string <i>s</i> into fields, while the
<b>tokens</b> function breaks the string into tokens. A
field consists of all non-separator characters between two
separator characters or the beginning or end of the string.
Thus, a field may be the empty string. A token is a maximal,
non-empty substring not containing a separator character.
The separator characters are those given in the <i>seps</i>
argument. If <i>seps</i> is not provided, the default value
is &quot; \t\n&quot;. The functions return the number of
fields or tokens.</p>

<p style="margin-left:22%; margin-top: 1em">The fields and
tokens are stored in the argument array. The array must be
<b>string</b>-valued and, if an index type is specified, it
must be <b>int</b>. The entries are indexed by consecutive
integers, starting at 0. Any values already stored in the
array will be either overwritten, or still be present after
the function returns.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I/O <br>
print</b>(<i>...</i>) : <b>void</b></p>

<p style="margin-left:22%;"><b>print(</b>
<i>expr</i><b>,</b> <i>...</i> <b>)</b> prints a string
representation of each argument in turn onto <b>stdout</b>,
followed by a newline.</p>

<p style="margin-left:11%;"><b>printf</b>(<i>fmt</i> :
<b>string</b>, <i>...</i>) : <b>int <br>
printf</b>(<i>fd</i> : <b>int</b>, <i>fmt</i> :
<b>string</b>, <i>...</i>) : <b>int</b></p>

<p style="margin-left:22%;">prints the string resulting
from formatting the values of the expressions following
<i>fmt</i> according to the <i>printf</i>(3) format
<i>fmt</i>. Returns 0 on success. By default, it prints on
<b>stdout</b>. If the optional integer <i>fd</i> is given,
output is written on the open stream associated with
<i>fd</i>.</p>

<p style="margin-left:11%;"><b>scanf</b>(<i>fmt</i> :
<b>string</b>, <i>...</i>) : <b>int <br>
scanf</b>(<i>fd</i> : <b>int</b>, <i>fmt</i> :
<b>string</b>, <i>...</i>) : <b>int</b></p>

<p style="margin-left:22%;">scans in values from an input
stream according to the <i>scanf</i>(3) format <i>fmt</i>.
The values are stored in the addresses following <i>fmt</i>,
addresses having the form <b>&amp;</b><i>v</i>, where
<i>v</i> is some declared variable of the correct type. By
default, it reads from <b>stdin</b>. If the optional integer
<i>fd</i> is given, input is read from the open stream
associated with <i>fd</i>. Returns the number of items
successfully scanned.</p>

<p style="margin-left:11%;"><b>openF</b>(<i>s</i> :
<b>string</b>, <i>t</i> : <b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">opens the file <i>s</i> as an
I/O stream. The string argument <i>t</i> specifies how the
file is opened. The arguments are the same as for the C
function <i>fopen</i>(3). It returns an integer denoting the
stream, or &minus;1 on error.</p>

<p style="margin-left:22%; margin-top: 1em">As usual,
streams 0, 1 and 2 are already open as <b>stdin</b>,
<b>stdout</b>, and <b>stderr</b>, respectively. Since
<b>gvpr</b> may use <b>stdin</b> to read the input graphs,
the user should avoid using this stream.</p>

<p style="margin-left:11%;"><b>closeF</b>(<i>fd</i> :
<b>int</b>) : <b>int</b></p>

<p style="margin-left:22%;">closes the open stream denoted
by the integer <i>fd</i>. Streams 0, 1 and 2 cannot be
closed. Returns 0 on success.</p>

<p style="margin-left:11%;"><b>readL</b>(<i>fd</i> :
<b>int</b>) : <b>string</b></p>

<p style="margin-left:22%;">returns the next line read from
the input stream <i>fd</i>. It returns the empty string
&quot;&quot; on end of file. Note that the newline character
is left in the returned string.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Math <br>
exp</b>(<i>d</i> : <b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns e to the <i>d</i>th
power.</p>

<p style="margin-left:11%;"><b>log</b>(<i>d</i> :
<b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the natural log of
<i>d</i>.</p>

<p style="margin-left:11%;"><b>sqrt</b>(<i>d</i> :
<b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the square root of the
double <i>d</i>.</p>

<p style="margin-left:11%;"><b>pow</b>(<i>d</i> :
<b>double</b>, <i>x</i> : <b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns <i>d</i> raised to the
<i>x</i>th power.</p>

<p style="margin-left:11%;"><b>cos</b>(<i>d</i> :
<b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the cosine of
<i>d</i>.</p>

<p style="margin-left:11%;"><b>sin</b>(<i>d</i> :
<b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the sine of
<i>d</i>.</p>

<p style="margin-left:11%;"><b>atan2</b>(<i>y</i> :
<b>double</b>, <i>x</i> : <b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the arctangent of
<i>y/x</i> in the range &minus;pi to pi.</p>

<p style="margin-left:11%;"><b>MIN</b>(<i>y</i> :
<b>double</b>, <i>x</i> : <b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the minimum of <i>y</i>
and <i>x</i>.</p>

<p style="margin-left:11%;"><b>MAX</b>(<i>y</i> :
<b>double</b>, <i>x</i> : <b>double</b>) : <b>double</b></p>

<p style="margin-left:22%;">returns the maximum of <i>y</i>
and <i>x</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Associative
Arrays <br>
#</b> <i>arr</i> : <b>int</b></p>

<p style="margin-left:22%;">returns the number of elements
in the array <i>arr</i>.</p>

<p style="margin-left:11%;"><i>idx</i> <b>in</b> <i>arr</i>
: <b>int</b></p>

<p style="margin-left:22%;">returns 1 if a value has been
set for index <i>idx</i> in the array <i>arr</i>. It returns
0 otherwise.</p>

<p style="margin-left:11%;"><b>unset</b>(<i>v</i> :
<b>array</b>, <i>idx</i>) : <b>int</b></p>

<p style="margin-left:22%;">removes the item indexed by
<i>idx</i>. It returns 1 if the item existed, 0
otherwise.</p>

<p style="margin-left:11%;"><b>unset</b>(<i>v</i> :
<b>array</b>) : <b>void</b></p>

<p style="margin-left:22%;">re-initializes the array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous
<br>
exit</b>(<i>v</i> : <b>int</b>) : <b>void</b></p>

<p style="margin-left:22%;">causes <b>gvpr</b> to exit with
the exit code <i>v</i>.</p>

<p style="margin-left:11%;"><b>system</b>(<i>cmd</i> :
<b>string</b>) : <b>int</b></p>

<p style="margin-left:22%;">provides the standard C
function <i>system</i>(3). It executes <i>cmd</i> in the
user&rsquo;s shell environment, and returns the exit status
of the shell.</p>

<p style="margin-left:11%;"><b>rand</b>() :
<b>double</b></p>

<p style="margin-left:22%;">returns a pseudo-random double
between 0 and 1.</p>

<p style="margin-left:11%;"><b>srand</b>() : <b>int <br>
srand</b>(<i>v</i> : <b>int</b>) : <b>int</b></p>

<p style="margin-left:22%;">sets a seed for the random
number generator. The optional argument gives the seed; if
it is omitted, the current time is used. The previous seed
value is returned. <b>srand</b> should be called before any
calls to <b>rand</b>.</p>

<p style="margin-left:11%;"><b>colorx</b>(<i>color</i> :
<b>string</b>, <i>fmt</i> : <b>string</b>) :
<b>string</b></p>

<p style="margin-left:22%;">translates a color from one
format to another. The <i>color</i> argument should be a
color in one of the recognized string representations. The
<i>fmt</i> value should be one of &quot;RGB&quot;,
&quot;RGBA&quot;, &quot;HSV&quot;, or &quot;HSVA&quot;. An
empty string is returned on error.</p>

<h2>BUILT-IN VARIABLES
<a name="BUILT-IN VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>gvpr</b>
provides certain special, built-in variables, whose values
are set automatically by <b>gvpr</b> depending on the
context. Except as noted, the user cannot modify their
values. <b><br>
$</b> : <b>obj_t</b></p>

<p style="margin-left:22%;">denotes the current object
(node, edge, graph) depending on the context. It is not
available in <b>BEGIN</b> or <b>END</b> clauses.</p>

<p style="margin-left:11%;"><b>$F</b> : <b>string</b></p>

<p style="margin-left:22%;">is the name of the current
input file.</p>

<p style="margin-left:11%;"><b>$G</b> : <b>graph_t</b></p>

<p style="margin-left:22%;">denotes the current graph being
processed. It is not available in <b>BEGIN</b> or <b>END</b>
clauses.</p>

<p style="margin-left:11%;"><b>$NG</b> : <b>graph_t</b></p>

<p style="margin-left:22%;">denotes the next graph to be
processed. If <b>$NG</b> is NULL, the current graph
<b>$G</b> is the last graph. Note that if the input comes
from stdin, the last graph cannot be determined until the
input pipe is closed. It is not available in <b>BEGIN</b> or
<b>END</b> clauses, or if the <b>-n</b> flag is used.</p>

<p style="margin-left:11%;"><b>$O</b> : <b>graph_t</b></p>

<p style="margin-left:22%;">denotes the output graph.
Before graph traversal, it is initialized to the target
graph. After traversal and any <b>END_G</b> actions, if it
refers to a non-empty graph, that graph is printed onto the
output stream. It is only valid in <b>N</b>, <b>E</b> and
<b>END_G</b> clauses. The output graph may be set by the
user.</p>

<p style="margin-left:11%;"><b>$T</b> : <b>graph_t</b></p>

<p style="margin-left:22%;">denotes the current target
graph. It is a subgraph of <b>$G</b> and is available only
in <b>N</b>, <b>E</b> and <b>END_G</b> clauses.</p>

<p style="margin-left:11%;"><b>$tgtname</b> :
<b>string</b></p>

<p style="margin-left:22%;">denotes the name of the target
graph. By default, it is set to
<b>&quot;gvpr_result&quot;</b>. If used multiple times
during the execution of <b>gvpr</b>, the name will be
appended with an integer. This variable may be set by the
user.</p>

<p style="margin-left:11%;"><b>$tvroot</b> :
<b>node_t</b></p>

<p style="margin-left:22%;">indicates the starting node for
a (directed or undirected) depth-first or breadth-first
traversal of the graph (cf. <b>$tvtype</b> below). The
default value is <b>NULL</b> for each input graph. After the
traversal at the given root, if the value of <b>$tvroot</b>
has changed, a new traversal will begin with the new value
of <b>$tvroot</b>. Also, set <b>$tvnext</b> below.</p>

<p style="margin-left:11%;"><b>$tvnext</b> :
<b>node_t</b></p>

<p style="margin-left:22%;">indicates the next starting
node for a (directed or undirected) depth-first or
breadth-first traversal of the graph (cf. <b>$tvtype</b>
below). If a traversal finishes and the <b>$tvroot</b> but
the <b>$tvnext</b> has been set but not used, this node will
be used as the next choice for <b>$tvroot</b>. The default
value is <b>NULL</b> for each input graph.</p>

<p style="margin-left:11%;"><b>$tvedge</b> :
<b>edge_t</b></p>

<p style="margin-left:22%;">For BFS and DFS traversals,
this is set to the edge used to arrive at the current node
or edge. At the beginning of a traversal, or for other
traversal types, the value is <b>NULL</b>.</p>

<p style="margin-left:11%;"><b>$tvtype</b> :
<b>tvtype_t</b></p>

<p style="margin-left:22%;">indicates how <b>gvpr</b>
traverses a graph. It can only take one of the constant
values with the previx &quot;TV_&quot; described below.
<b>TV_flat</b> is the default.</p>

<p style="margin-left:22%; margin-top: 1em">In the
underlying graph library <i>cgraph</i>(3), edges in
undirected graphs are given an arbitrary direction. This is
used for traversals, such as <b>TV_fwd</b>, requiring
directed edges.</p>

<p style="margin-left:11%;"><b>ARGC</b> : <b>int</b></p>

<p style="margin-left:22%;">denotes the number of arguments
specified by the <b>&minus;a</b> <i>args</i> command-line
argument.</p>

<p style="margin-left:11%;"><b>ARGV</b> : <b>string
array</b></p>

<p style="margin-left:22%;">denotes the array of arguments
specified by the <b>&minus;a</b> <i>args</i> command-line
argument. The <i>i</i>th argument is given by
<b>ARGV[</b><i>i</i><b>]</b>.</p>

<h2>BUILT-IN CONSTANTS
<a name="BUILT-IN CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
several symbolic constants defined by <b>gvpr</b>. <b><br>
NULL</b> : <i>obj_t</i></p>

<p style="margin-left:22%;">a null object reference,
equivalent to 0.</p>

<p style="margin-left:11%;"><b>TV_flat</b> :
<i>tvtype_t</i></p>

<p style="margin-left:22%;">a simple, flat traversal, with
graph objects visited in seemingly arbitrary order.</p>

<p style="margin-left:11%;"><b>TV_ne</b> :
<i>tvtype_t</i></p>

<p style="margin-left:22%;">a traversal which first visits
all of the nodes, then all of the edges.</p>

<p style="margin-left:11%;"><b>TV_en</b> :
<i>tvtype_t</i></p>

<p style="margin-left:22%;">a traversal which first visits
all of the edges, then all of the nodes.</p>

<p style="margin-left:11%;"><b>TV_dfs</b> : <i>tvtype_t</i>
<b><br>
TV_postdfs</b> : <i>tvtype_t</i> <b><br>
TV_prepostdfs</b> : <i>tvtype_t</i></p>

<p style="margin-left:22%;">a traversal of the graph using
a depth-first search on the underlying undirected graph. To
do the traversal, <b>gvpr</b> will check the value of
<b>$tvroot</b>. If this has the same value that it had
previously (at the start, the previous value is initialized
to <b>NULL</b>.), <b>gvpr</b> will simply look for some
unvisited node and traverse its connected component. On the
other hand, if <b>$tvroot</b> has changed, its connected
component will be toured, assuming it has not been
previously visited or, if <b>$tvroot</b> is <b>NULL</b>, the
traversal will stop. Note that using <b>TV_dfs</b> and
<b>$tvroot</b>, it is possible to create an infinite
loop.</p>

<p style="margin-left:22%; margin-top: 1em">By default, the
traversal is done in pre-order. That is, a node is visited
before all of its unvisited edges. For <b>TV_postdfs</b>,
all of a node&rsquo;s unvisited edges are visited before the
node. For <b>TV_prepostdfs</b>, a node is visited twice,
before and after all of its unvisited edges.</p>

<p style="margin-left:11%;"><b>TV_fwd</b> : <i>tvtype_t</i>
<b><br>
TV_postfwd</b> : <i>tvtype_t</i> <b><br>
TV_prepostfwd</b> : <i>tvtype_t</i></p>

<p style="margin-left:22%;">A traversal of the graph using
a depth-first search on the graph following only forward
arcs. The choice of roots for the traversal is the same as
described for <b>TV_dfs</b> above. The different order of
visitation specified by <b>TV_fwd</b>, <b>TV_postfwd</b> and
<b>TV_prepostfwd</b> are the same as those specified by the
analogous traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and
<b>TV_prepostdfs</b>.</p>

<p style="margin-left:11%;"><b>TV_rev</b> : <i>tvtype_t</i>
<b><br>
TV_postrev</b> : <i>tvtype_t</i> <b><br>
TV_prepostrev</b> : <i>tvtype_t</i></p>

<p style="margin-left:22%;">A traversal of the graph using
a depth-first search on the graph following only reverse
arcs. The choice of roots for the traversal is the same as
described for <b>TV_dfs</b> above. The different order of
visitation specified by <b>TV_rev</b>, <b>TV_postrev</b> and
<b>TV_prepostrev</b> are the same as those specified by the
analogous traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and
<b>TV_prepostdfs</b>.</p>

<p style="margin-left:11%;"><b>TV_bfs</b> :
<i>tvtype_t</i></p>

<p style="margin-left:22%;">A traversal of the graph using
a breadth-first search on the graph ignoring edge
directions. See the item on <b>TV_dfs</b> above for the role
of <b>$tvroot</b>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:22%; margin-top: 1em"><b>gvpr
&minus;i &rsquo;N[color==&quot;blue&quot;]&rsquo;
file.gv</b></p>

<p style="margin-left:11%; margin-top: 1em">Generate the
node-induced subgraph of all nodes with color blue.</p>

<p style="margin-left:22%; margin-top: 1em"><b>gvpr
&minus;c &rsquo;N[color==&quot;blue&quot;]{color =
&quot;red&quot;}&rsquo; file.gv</b></p>

<p style="margin-left:11%; margin-top: 1em">Make all blue
nodes red.</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN { int
n, e; int tot_n = 0; int tot_e = 0; } <br>
BEG_G { <br>
n = nNodes($G); <br>
e = nEdges($G); <br>
printf (&quot;%d nodes %d edges %s\n&quot;, n, e, $G.name);
<br>
tot_n += n; <br>
tot_e += e; <br>
} <br>
END { printf (&quot;%d nodes %d edges total\n&quot;, tot_n,
tot_e) }</b></p>

<p style="margin-left:11%; margin-top: 1em">Version of the
program <b>gc</b>.</p>

<p style="margin-left:22%; margin-top: 1em"><b>gvpr
&minus;c &quot;&quot;</b></p>

<p style="margin-left:11%; margin-top: 1em">Equivalent to
<b>nop</b>.</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEG_G {
graph_t g = graph (&quot;merge&quot;, &quot;S&quot;); } <br>
E { <br>
node_t h = clone(g,$.head); <br>
node_t t = clone(g,$.tail); <br>
edge_t e = edge(t,h,&quot;&quot;); <br>
e.weight = e.weight + 1; <br>
} <br>
END_G { $O = g; }</b></p>

<p style="margin-left:11%; margin-top: 1em">Produces a
strict version of the input graph, where the weight
attribute of an edge indicates how many edges from the input
graph the edge represents.</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN
{node_t n; int deg[]} <br>
E{deg[head]++; deg[tail]++; } <br>
END_G { <br>
for (deg[n]) { <br>
printf (&quot;deg[%s] = %d\n&quot;, n.name, deg[n]); <br>
} <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">Computes the
degrees of nodes with edges.</p>

<p style="margin-left:22%; margin-top: 1em"><b>BEGIN { <br>
int i, indent; <br>
int seen[string]; <br>
void prInd (int cnt) { <br>
for (i = 0; i &lt; cnt; i++) printf (&quot; &quot;); <br>
} <br>
} <br>
BEG_G {</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>$tvtype =
TV_prepostfwd; <br>
$tvroot = node($,ARGV[0]); <br>
} <br>
N { <br>
if (seen[$.name]) indent--; <br>
else { <br>
prInd(indent); <br>
print ($.name); <br>
seen[$.name] = 1; <br>
indent++; <br>
} <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">Prints the
depth-first traversal of the graph, starting with the node
whose name is <b>ARGV[0]</b>, as an indented list.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>GVPRPATH</b></p>

<p style="margin-left:22%;">Colon-separated list of
directories to be searched to find the file specified by the
&minus;f option. <b>gvpr</b> has a default list built in. If
<b>GVPRPATH</b> is not defined, the default list is used. If
<b>GVPRPATH</b> starts with colon, the list is formed by
appending <b>GVPRPATH</b> to the default list. If
<b>GVPRPATH</b> ends with colon, the list is formed by
appending the default list to <b>GVPRPATH</b>. Otherwise,
<b>GVPRPATH</b> is used for the list.</p>

<p style="margin-left:11%; margin-top: 1em">On Windows
systems, replace &lsquo;&lsquo;colon&rsquo;&rsquo; with
&lsquo;&lsquo;semicolon&rsquo;&rsquo; in the previous
paragraph.</p>

<h2>BUGS AND WARNINGS
<a name="BUGS AND WARNINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Scripts should
be careful deleting nodes during <b>N{}</b> and <b>E{}</b>
blocks using BFS and DFS traversals as these rely on stacks
and queues of nodes.</p>

<p style="margin-left:11%; margin-top: 1em">When the
program is given as a command line argument, the usual shell
interpretation takes place, which may affect some of the
special names in <b>gvpr</b>. To avoid this, it is best to
wrap the program in single quotes.</p>

<p style="margin-left:11%; margin-top: 1em">If string
constants contain pattern metacharacters that you want to
escape to avoid pattern matching, two backslashes will
probably be necessary, as a single backslash will be lost
when the string is originally scanned. Usually, it is
simpler to use <b>strcmp</b> to avoid pattern matching.</p>

<p style="margin-left:11%; margin-top: 1em">As of 24 April
2008, <b>gvpr</b> switched to using a new, underlying graph
library, which uses the simpler model that there is only one
copy of a node, not one copy for each subgraph logically
containing it. This means that iterators such as
<i>nxtnode</i> cannot traverse a subgraph using just a node
argument. For this reason, subgraph traversal requires new
functions ending in &quot;_sg&quot;, which also take a
subgraph argument. The versions without that suffix will
always traverse the root graph.</p>

<p style="margin-left:11%; margin-top: 1em">There is a
single global scope, except for formal function parameters,
and even these can interfere with the type system. Also, the
extent of all variables is the entire life of the program.
It might be preferable for scope to reflect the natural
nesting of the clauses, or for the program to at least reset
locally declared variables. For now, it is advisable to use
distinct names for all variables.</p>

<p style="margin-left:11%; margin-top: 1em">If a function
ends with a complex statement, such as an IF statement, with
each branch doing a return, type checking may fail.
Functions should use a return at the end.</p>

<p style="margin-left:11%; margin-top: 1em">The expr
library does not support string values of (char*)0. This
means we can&rsquo;t distinguish between &quot;&quot; and
(char*)0 edge keys. For the purposes of looking up and
creating edges, we translate &quot;&quot; to be (char*)0,
since this latter value is necessary in order to look up any
edge with a matching head and tail.</p>

<p style="margin-left:11%; margin-top: 1em">Related to
this, strings converted to integers act like char pointers,
getting the value 0 or 1 depending on whether the string
consists solely of zeroes or not. Thus, the
((int)&quot;2&quot;) evaluates to 1.</p>

<p style="margin-left:11%; margin-top: 1em">The language
inherits the usual C problems such as dangling references
and the confusion between &rsquo;=&rsquo; and
&rsquo;==&rsquo;.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Emden R.
Gansner &lt;erg@research.att.com&gt;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">awk(1), gc(1),
dot(1), nop(1), expr(3), cgraph(3)</p>
<hr>
</body>
</html>
