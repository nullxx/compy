<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:26 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLRE</title>

</head>
<body>

<h1 align="center">PERLRE</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlre &minus;
Perl regular expressions</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page
describes the syntax of regular expressions in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If you
haven&rsquo;t used regular expressions before, a quick-start
introduction is available in perlrequick, and a longer
tutorial introduction is available in perlretut.</p>

<p style="margin-left:11%; margin-top: 1em">For reference
on how regular expressions are used in matching operations,
plus various examples of the same, see discussions of
<tt>&quot;m//&quot;</tt>, <tt>&quot;s///&quot;</tt>,
<tt>&quot;qr//&quot;</tt> and <tt>&quot;??&quot;</tt> in
&quot;Regexp Quote-Like Operators&quot; in perlop.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Modifiers</b>
<br>
Matching operations can have various modifiers. Modifiers
that relate to the interpretation of the regular expression
inside are listed below. Modifiers that alter the way a
regular expression is used by Perl are detailed in
&quot;Regexp Quote-Like Operators&quot; in perlop and
&quot;Gory details of parsing quoted constructs&quot; in
perlop.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>m</p></td>
<td width="5%"></td>
<td width="83%">


<p>Treat string as multiple lines. That is, change
&quot;^&quot; and &quot;$&quot; from matching the start or
end of the string to matching the start or end of any line
anywhere within the string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>s</p></td>
<td width="5%"></td>
<td width="83%">


<p>Treat string as single line. That is, change
&quot;.&quot; to match any character whatsoever, even a
newline, which normally it would not match.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Used together,
as <tt>&quot;/ms&quot;</tt>, they let the &quot;.&quot;
match any character whatsoever, while still allowing
&quot;^&quot; and &quot;$&quot; to match, respectively, just
after and just before newlines within the string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">i</p></td>
<td width="5%"></td>
<td width="57%">


<p style="margin-top: 1em">Do case-insensitive pattern
matching.</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If locale
matching rules are in effect, the case map is taken from the
current locale for code points less than 255, and from
Unicode rules for larger code points. However, matches that
would cross the Unicode rules/non&minus;Unicode rules
boundary (ords 255/256) will not succeed. See
perllocale.</p>

<p style="margin-left:17%; margin-top: 1em">There are a
number of Unicode characters that match multiple characters
under <tt>&quot;/i&quot;</tt>. For example, <tt>&quot;LATIN
SMALL LIGATURE FI&quot;</tt> should match the sequence
<tt>&quot;fi&quot;</tt>. Perl is not currently able to do
this when the multiple characters are in the pattern and are
split between groupings, or when one or more are quantified.
Thus</p>

<pre style="margin-left:17%; margin-top: 1em"> &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi/i;          # Matches
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i;    # Doesn't match!
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i;         # Doesn't match!
 # The below doesn't match, and it isn't clear what $1 and $2 would
 # be even if it did!!
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i;      # Doesn't match!</pre>


<p style="margin-left:17%; margin-top: 1em">Perl
doesn&rsquo;t match multiple characters in an inverted
bracketed character class, which otherwise could be highly
confusing. See &quot;Negation&quot; in perlrecharclass.</p>

<p style="margin-left:17%; margin-top: 1em">Another bug
involves character classes that match both a sequence of
multiple characters, and an initial sub-string of that
sequence. For example,</p>

<pre style="margin-left:17%; margin-top: 1em"> /[s\xDF]/i</pre>


<p style="margin-left:17%; margin-top: 1em">should match
both a single and a double &quot;s&quot;, since
<tt>&quot;\xDF&quot;</tt> (on <small>ASCII</small>
platforms) matches &quot;ss&quot;. However, this bug ([perl
#89774]
&lt;https://rt.perl.org/rt3/Ticket/Display.html?id=89774&gt;)
causes it to only match a single &quot;s&quot;, even if the
final larger match fails, and matching the double
&quot;ss&quot; would have succeeded.</p>

<p style="margin-left:17%; margin-top: 1em">Also, Perl
matching doesn&rsquo;t fully conform to the current Unicode
<tt>&quot;/i&quot;</tt> recommendations, which ask that the
matching be made upon the <small>NFD</small> (Normalization
Form Decomposed) of the text. However, Unicode is in the
process of reconsidering and revising their
recommendations.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">x</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Extend your pattern&rsquo;s
legibility by permitting whitespace and comments. Details in
&quot;/x&quot;</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>p</p></td>
<td width="5%"></td>
<td width="83%">


<p>Preserve the string matched such that ${^PREMATCH},
${^MATCH}, and ${^POSTMATCH} are available for use after
matching.</p> </td></tr>
</table>

<p style="margin-left:11%;">g and c</p>

<p style="margin-left:17%;">Global matching, and keep the
Current position after failed matching. Unlike i, m, s and
x, these two flags affect the way the regex is used rather
than the regex itself. See &quot;Using regular expressions
in Perl&quot; in perlretut for further explanation of the g
and c modifiers.</p>

<p style="margin-left:11%;">a, d, l and u</p>

<p style="margin-left:17%;">These modifiers, all new in
5.14, affect which character-set semantics (Unicode, etc.)
are used, as described below in &quot;Character set
modifiers&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expression modifiers are usually written in documentation as
e.g., &quot;the <tt>&quot;/x&quot;</tt> modifier&quot;, even
though the delimiter in question might not really be a
slash. The modifiers <tt>&quot;/imsxadlup&quot;</tt> may
also be embedded within the regular expression itself using
the <tt>&quot;(?...)&quot;</tt> construct, see
&quot;Extended Patterns&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em"><i>/x</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;/x&quot;</tt>
tells the regular expression parser to ignore most
whitespace that is neither backslashed nor within a
character class. You can use this to break up your regular
expression into (slightly) more readable parts. The
<tt>&quot;#&quot;</tt> character is also treated as a
metacharacter introducing a comment, just as in ordinary
Perl code. This also means that if you want real whitespace
or <tt>&quot;#&quot;</tt> characters in the pattern (outside
a character class, where they are unaffected by
<tt>&quot;/x&quot;</tt>), then you&rsquo;ll either have to
escape them (using backslashes or
<tt>&quot;\Q...\E&quot;</tt>) or encode them using octal,
hex, or <tt>&quot;\N{}&quot;</tt> escapes. Taken together,
these features go a long way towards making Perl&rsquo;s
regular expressions more readable. Note that you have to be
careful not to include the pattern delimiter in the
comment--perl has no way of knowing you did not intend to
close the pattern early. See the C&minus;comment deletion
code in perlop. Also note that anything inside a
<tt>&quot;\Q...\E&quot;</tt> stays unaffected by
<tt>&quot;/x&quot;</tt>. And note that
<tt>&quot;/x&quot;</tt> doesn&rsquo;t affect space
interpretation within a single multi-character construct.
For example in <tt>&quot;\x{...}&quot;</tt>, regardless of
the <tt>&quot;/x&quot;</tt> modifier, there can be no
spaces. Same for a quantifier such as
<tt>&quot;{3}&quot;</tt> or <tt>&quot;{5,}&quot;</tt>.
Similarly, <tt>&quot;(?:...)&quot;</tt> can&rsquo;t have a
space between the <tt>&quot;?&quot;</tt> and
<tt>&quot;:&quot;</tt>, but can between the
<tt>&quot;(&quot;</tt> and <tt>&quot;?&quot;</tt>. Within
any delimiters for such a construct, allowed spaces are not
affected by <tt>&quot;/x&quot;</tt>, and depend on the
construct. For example, <tt>&quot;\x{...}&quot;</tt>
can&rsquo;t have spaces because hexadecimal numbers
don&rsquo;t have spaces in them. But, Unicode properties can
have spaces, so in <tt>&quot;\p{...}&quot;</tt> there can be
spaces that follow the Unicode rules, for which see
&quot;Properties accessible through \p{} and \P{}&quot; in
perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Character
set modifiers</i></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;/d&quot;</tt>,
<tt>&quot;/u&quot;</tt>, <tt>&quot;/a&quot;</tt>, and
<tt>&quot;/l&quot;</tt>, available starting in 5.14, are
called the character set modifiers; they affect the
character set semantics used for the regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;/d&quot;</tt>, <tt>&quot;/u&quot;</tt>, and
<tt>&quot;/l&quot;</tt> modifiers are not likely to be of
much use to you, and so you need not worry about them very
much. They exist for Perl&rsquo;s internal use, so that
complex regular expression data structures can be
automatically serialized and later exactly reconstituted,
including all their nuances. But, since Perl can&rsquo;t
keep a secret, and there may be rare instances where they
are useful, they are documented here.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;/a&quot;</tt> modifier, on the other hand, may be
useful. Its purpose is to allow code that is to work mostly
on <small>ASCII</small> data to not have to concern itself
with Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">Briefly,
<tt>&quot;/l&quot;</tt> sets the character set to that of
whatever <b>L</b>ocale is in effect at the time of the
execution of the pattern match.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;/u&quot;</tt>
sets the character set to <b>U</b>nicode.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;/a&quot;</tt>
also sets the character set to Unicode, <small>BUT</small>
adds several restrictions for <b>A</b>SCII-safe
matching.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;/d&quot;</tt>
is the old, problematic, pre&minus;5.14 <b>D</b>efault
character set behavior. Its only use is to force that old
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">At any given
time, exactly one of these modifiers is in effect. Their
existence allows Perl to keep the originally compiled
behavior of a regular expression, regardless of what rules
are in effect when it is actually executed. And if it is
interpolated into a larger regex, the original&rsquo;s rules
continue to apply to it, and only it.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;/l&quot;</tt> and <tt>&quot;/u&quot;</tt>
modifiers are automatically selected for regular expressions
compiled within the scope of various pragmas, and we
recommend that in general, you use those pragmas instead of
specifying these modifiers explicitly. For one thing, the
modifiers affect only pattern matching, and do not extend to
even any replacement done, whereas using the pragmas give
consistent results for all appropriate operations within
their scopes. For example,</p>

<pre style="margin-left:11%; margin-top: 1em"> s/foo/\Ubar/il</pre>


<p style="margin-left:11%; margin-top: 1em">will match
&quot;foo&quot; using the locale&rsquo;s rules for
case-insensitive matching, but the <tt>&quot;/l&quot;</tt>
does not affect how the <tt>&quot;\U&quot;</tt> operates.
Most likely you want both of them to use locale rules. To do
this, instead compile the regular expression within the
scope of <tt>&quot;use locale&quot;</tt>. This both
implicitly adds the <tt>&quot;/l&quot;</tt> and applies
locale rules to the <tt>&quot;\U&quot;</tt>. The lesson is
to <tt>&quot;use locale&quot;</tt> and not
<tt>&quot;/l&quot;</tt> explicitly.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, it
would be better to use <tt>&quot;use feature
'unicode_strings'&quot;</tt> instead of,</p>

<pre style="margin-left:11%; margin-top: 1em"> s/foo/\Lbar/iu</pre>


<p style="margin-left:11%; margin-top: 1em">to get Unicode
rules, as the <tt>&quot;\L&quot;</tt> in the former (but not
necessarily the latter) would also use Unicode rules.</p>

<p style="margin-left:11%; margin-top: 1em">More detail on
each of the modifiers follows. Most likely you don&rsquo;t
need to know this detail for <tt>&quot;/l&quot;</tt>,
<tt>&quot;/u&quot;</tt>, and <tt>&quot;/d&quot;</tt>, and
can skip ahead to /a.</p>

<p style="margin-left:11%; margin-top: 1em">/l</p>

<p style="margin-left:11%; margin-top: 1em">means to use
the current locale&rsquo;s rules (see perllocale) when
pattern matching. For example, <tt>&quot;\w&quot;</tt> will
match the &quot;word&quot; characters of that locale, and
<tt>&quot;/i&quot;</tt> case-insensitive matching will match
according to the locale&rsquo;s case folding rules. The
locale used will be the one in effect at the time of
execution of the pattern match. This may not be the same as
the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
<i>setlocale()</i> function.</p>

<p style="margin-left:11%; margin-top: 1em">Perl only
supports single-byte locales. This means that code points
above 255 are treated as Unicode no matter what locale is in
effect. Under Unicode rules, there are a few
case-insensitive matches that cross the 255/256 boundary.
These are disallowed under <tt>&quot;/l&quot;</tt>. For
example, 0xFF (on <small>ASCII</small> platforms) does not
caselessly match the character at 0x178, <tt>&quot;LATIN
CAPITAL LETTER Y WITH DIAERESIS&quot;</tt>, because 0xFF may
not be <tt>&quot;LATIN SMALL LETTER Y WITH
DIAERESIS&quot;</tt> in the current locale, and Perl has no
way of knowing if that character even exists in the locale,
much less what code point it is.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by <tt>&quot;use
locale&quot;</tt>, but see &quot;Which character set
modifier is in effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">/u</p>

<p style="margin-left:11%; margin-top: 1em">means to use
Unicode rules when pattern matching. On <small>ASCII</small>
platforms, this means that the code points between 128 and
255 take on their Latin&minus;1 (
<small>ISO&minus;8859&minus;1</small> ) meanings (which are
the same as Unicode&rsquo;s). (Otherwise Perl considers
their meanings to be undefined.) Thus, under this modifier,
the <small>ASCII</small> platform effectively becomes a
Unicode platform; and hence, for example,
<tt>&quot;\w&quot;</tt> will match any of the more than
100_000 word characters in Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike most
locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters
<i>somewhere</i> in the world as <tt>&quot;\w&quot;</tt>.
For example, your locale might not think that
<tt>&quot;LATIN SMALL LETTER ETH&quot;</tt> is a letter
(unless you happen to speak Icelandic), but Unicode does.
Similarly, all the characters that are decimal digits
somewhere in the world will match <tt>&quot;\d&quot;</tt>;
this is hundreds, not 10, possible matches. And some of
those digits look like some of the 10 <small>ASCII</small>
digits, but mean a different number, so a human could easily
think a number is a different quantity than it really is.
For example, <tt>&quot;BENGALI DIGIT FOUR&quot;</tt>
(U+09EA) looks very much like an <tt>&quot;ASCII DIGIT
EIGHT&quot;</tt> (U+0038). And, <tt>&quot;\d+&quot;</tt>,
may match strings of digits that are a mixture from
different writing systems, creating a security issue.
&quot;<i>num()</i>&quot; in Unicode::UCD can be used to sort
this out. Or the <tt>&quot;/a&quot;</tt> modifier can be
used to force <tt>&quot;\d&quot;</tt> to match just the
<small>ASCII</small> 0 through 9.</p>

<p style="margin-left:11%; margin-top: 1em">Also, under
this modifier, case-insensitive matching works on the full
set of Unicode characters. The <tt>&quot;KELVIN
SIGN&quot;</tt>, for example matches the letters
&quot;k&quot; and &quot;K&quot;; and <tt>&quot;LATIN SMALL
LIGATURE FF&quot;</tt> matches the sequence &quot;ff&quot;,
which, if you&rsquo;re not prepared, might make it look like
a hexadecimal constant, presenting another potential
security issue. See &lt;http://unicode.org/reports/tr36&gt;
for a detailed discussion of Unicode security issues.</p>

<p style="margin-left:11%; margin-top: 1em">On the
<small>EBCDIC</small> platforms that Perl handles, the
native character set is equivalent to Latin&minus;1. Thus
this modifier changes behavior only when the
<tt>&quot;/i&quot;</tt> modifier is also specified, and it
turns out it affects only two characters, giving them full
Unicode semantics: the <tt>&quot;MICRO SIGN&quot;</tt> will
match the Greek capital and small letters
<tt>&quot;MU&quot;</tt>, otherwise not; and the
<tt>&quot;LATIN CAPITAL LETTER SHARP S&quot;</tt> will match
any of <tt>&quot;SS&quot;</tt>, <tt>&quot;Ss&quot;</tt>,
<tt>&quot;sS&quot;</tt>, and <tt>&quot;ss&quot;</tt>,
otherwise not.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by <tt>&quot;use feature
'unicode_strings&quot;</tt>, <tt>&quot;use locale
':not_characters'&quot;</tt>, or <tt>&quot;use
5.012&quot;</tt> (or higher), but see &quot;Which character
set modifier is in effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">/d</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
means to use the &quot;Default&quot; native rules of the
platform except when there is cause to use Unicode rules
instead, as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the target string is encoded in
<small>UTF&minus;8</small> ; or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern is encoded in <small>UTF&minus;8</small> ;
or</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern explicitly mentions a code point that is
above 255 (say by <tt>&quot;\x{100}&quot;</tt>); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses a Unicode name
(<tt>&quot;\N{...}&quot;</tt>); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses a Unicode property
(<tt>&quot;\p{...}&quot;</tt>)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Another
mnemonic for this modifier is &quot;Depends&quot;, as the
rules actually used depend on various things, and as a
result you can get unexpected results. See &quot;The
&quot;Unicode Bug&quot;&quot; in perlunicode. The Unicode
Bug has become rather infamous, leading to yet another
(printable) name for this modifier, &quot;Dodgy&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">On
<small>ASCII</small> platforms, the native rules are
<small>ASCII</small> , and on <small>EBCDIC</small>
platforms (at least the ones that Perl handles), they are
Latin&minus;1.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples of how that works on an <small>ASCII</small>
platform:</p>

<pre style="margin-left:11%; margin-top: 1em"> $str =  &quot;\xDF&quot;;      # $str is not in UTF&minus;8 format.
 $str =~ /^\w/;       # No match, as $str isn't in UTF&minus;8 format.
 $str .= &quot;\x{0e0b}&quot;;  # Now $str is in UTF&minus;8 format.
 $str =~ /^\w/;       # Match! $str is now in UTF&minus;8 format.
 chop $str;
 $str =~ /^\w/;       # Still a match! $str remains in UTF&minus;8 format.</pre>


<p style="margin-left:11%; margin-top: 1em">This modifier
is automatically selected by default when none of the others
are, so yet another name for it is &quot;Default&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Because of the
unexpected behaviors associated with this modifier, you
probably should only use it to maintain weird backward
compatibilities.</p>

<p style="margin-left:11%; margin-top: 1em">/a (and
/aa)</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
stands for ASCII-restrict (or ASCII-safe). This modifier,
unlike the others, may be doubled-up to increase its
effect.</p>

<p style="margin-left:11%; margin-top: 1em">When it appears
singly, it causes the sequences <tt>&quot;\d&quot;</tt>,
<tt>&quot;\s&quot;</tt>, <tt>&quot;\w&quot;</tt>, and the
Posix character classes to match only in the
<small>ASCII</small> range. They thus revert to their
pre&minus;5.6, pre-Unicode meanings. Under
<tt>&quot;/a&quot;</tt>, <tt>&quot;\d&quot;</tt> always
means precisely the digits <tt>&quot;0&quot;</tt> to
<tt>&quot;9&quot;</tt>; <tt>&quot;\s&quot;</tt> means the
five characters <tt>&quot;[ \f\n\r\t]&quot;</tt>;
<tt>&quot;\w&quot;</tt> means the 63 characters
<tt>&quot;[A&minus;Za&minus;z0&minus;9_]&quot;</tt>; and
likewise, all the Posix classes such as
<tt>&quot;[[:print:]]&quot;</tt> match only the appropriate
ASCII-range characters.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
is useful for people who only incidentally use Unicode, and
who do not wish to be burdened with its complexities and
security concerns.</p>

<p style="margin-left:11%; margin-top: 1em">With
<tt>&quot;/a&quot;</tt>, one can write
<tt>&quot;\d&quot;</tt> with confidence that it will only
match <small>ASCII</small> characters, and should the need
arise to match beyond <small>ASCII</small> , you can instead
use <tt>&quot;\p{Digit}&quot;</tt> (or
<tt>&quot;\p{Word}&quot;</tt> for <tt>&quot;\w&quot;</tt>).
There are similar <tt>&quot;\p{...}&quot;</tt> constructs
that can match beyond <small>ASCII</small> both white space
(see &quot;Whitespace&quot; in perlrecharclass), and Posix
classes (see &quot; <small>POSIX</small> Character
Classes&quot; in perlrecharclass). Thus, this modifier
doesn&rsquo;t mean you can&rsquo;t use Unicode, it means
that to get Unicode matching you must explicitly use a
construct (<tt>&quot;\p{}&quot;</tt>,
<tt>&quot;\P{}&quot;</tt>) that signals Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">As you would
expect, this modifier causes, for example,
<tt>&quot;\D&quot;</tt> to mean the same thing as
<tt>&quot;[^0&minus;9]&quot;</tt>; in fact, all non-ASCII
characters match <tt>&quot;\D&quot;</tt>,
<tt>&quot;\S&quot;</tt>, and <tt>&quot;\W&quot;</tt>.
<tt>&quot;\b&quot;</tt> still means to match at the boundary
between <tt>&quot;\w&quot;</tt> and <tt>&quot;\W&quot;</tt>,
using the <tt>&quot;/a&quot;</tt> definitions of them
(similarly for <tt>&quot;\B&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise,
<tt>&quot;/a&quot;</tt> behaves like the
<tt>&quot;/u&quot;</tt> modifier, in that case-insensitive
matching uses Unicode semantics; for example, &quot;k&quot;
will match the Unicode <tt>&quot;\N{KELVIN SIGN}&quot;</tt>
under <tt>&quot;/i&quot;</tt> matching, and code points in
the Latin1 range, above <small>ASCII</small> will have
Unicode rules when it comes to case-insensitive
matching.</p>

<p style="margin-left:11%; margin-top: 1em">To forbid
ASCII/non&minus;ASCII matches (like &quot;k&quot; with
<tt>&quot;\N{KELVIN SIGN}&quot;</tt>), specify the
&quot;a&quot; twice, for example <tt>&quot;/aai&quot;</tt>
or <tt>&quot;/aia&quot;</tt>. (The first occurrence of
&quot;a&quot; restricts the <tt>&quot;\d&quot;</tt>, etc.,
and the second occurrence adds the <tt>&quot;/i&quot;</tt>
restrictions.) But, note that code points outside the
<small>ASCII</small> range will use Unicode rules for
<tt>&quot;/i&quot;</tt> matching, so the modifier
doesn&rsquo;t really restrict things to just
<small>ASCII</small> ; it just forbids the intermixing of
<small>ASCII</small> and non-ASCII.</p>

<p style="margin-left:11%; margin-top: 1em">To summarize,
this modifier provides protection for applications that
don&rsquo;t wish to be exposed to all of Unicode. Specifying
it twice gives added protection.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by <tt>&quot;use re
'/a'&quot;</tt> or <tt>&quot;use re '/aa'&quot;</tt>. If you
do so, you may actually have occasion to use the
<tt>&quot;/u&quot;</tt> modifier explictly if there are a
few regular expressions where you do want full Unicode rules
(but even here, it&rsquo;s best if everything were under
feature <tt>&quot;unicode_strings&quot;</tt>, along with the
<tt>&quot;use re '/aa'&quot;</tt>). Also see &quot;Which
character set modifier is in effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Which character
set modifier is in effect?</p>

<p style="margin-left:11%; margin-top: 1em">Which of these
modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.
These have been designed so that in general you don&rsquo;t
have to worry about it, but this section gives the gory
details. As explained below in &quot;Extended Patterns&quot;
it is possible to explicitly specify modifiers that apply
only to portions of a regular expression. The innermost
always has priority over any outer ones, and one applying to
the whole expression has priority over any of the default
settings that are described in the remainder of this
section.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;use re '/foo'&quot;</tt> pragma can be used to set
default modifiers (including these) for regular expressions
compiled within its scope. This pragma has precedence over
the other pragmas listed below that also change the
defaults.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise,
<tt>&quot;use locale&quot;</tt> sets the default modifier to
<tt>&quot;/l&quot;</tt>; and <tt>&quot;use feature
'unicode_strings&quot;</tt>, or <tt>&quot;use
5.012&quot;</tt> (or higher) set the default to
<tt>&quot;/u&quot;</tt> when not in the same scope as either
<tt>&quot;use locale&quot;</tt> or <tt>&quot;use
bytes&quot;</tt>. (<tt>&quot;use locale
':not_characters'&quot;</tt> also sets the default to
<tt>&quot;/u&quot;</tt>, overriding any plain <tt>&quot;use
locale&quot;</tt>.) Unlike the mechanisms mentioned above,
these affect operations besides regular expressions pattern
matching, and so give more consistent results with other
operators, including using <tt>&quot;\U&quot;</tt>,
<tt>&quot;\l&quot;</tt>, etc. in substitution
replacements.</p>

<p style="margin-left:11%; margin-top: 1em">If none of the
above apply, for backwards compatibility reasons, the
<tt>&quot;/d&quot;</tt> modifier is the one in effect by
default. As this can lead to unexpected results, it is best
to specify which other rule set should be used.</p>

<p style="margin-left:11%; margin-top: 1em">Character set
modifier behavior prior to Perl 5.14</p>

<p style="margin-left:11%; margin-top: 1em">Prior to 5.14,
there were no explicit modifiers, but
<tt>&quot;/l&quot;</tt> was implied for regexes compiled
within the scope of <tt>&quot;use locale&quot;</tt>, and
<tt>&quot;/d&quot;</tt> was implied otherwise. However,
interpolating a regex into a larger regex would ignore the
original compilation in favor of whatever was in effect at
the time of the second compilation. There were a number of
inconsistencies (bugs) with the <tt>&quot;/d&quot;</tt>
modifier, where Unicode rules would be used when
inappropriate, and vice versa. <tt>&quot;\p{}&quot;</tt> did
not imply Unicode rules, and neither did all occurrences of
<tt>&quot;\N{}&quot;</tt>, until 5.12.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Regular
Expressions</b> <i><br>
Metacharacters</i></p>

<p style="margin-left:11%; margin-top: 1em">The patterns
used in Perl pattern matching evolved from those supplied in
the Version 8 regex routines. (The routines are derived
(distantly) from Henry Spencer&rsquo;s freely
redistributable reimplementation of the V8 routines.) See
&quot;Version 8 Regular Expressions&quot; for details.</p>

<p style="margin-left:11%; margin-top: 1em">In particular
the following metacharacters have their standard
<i>egrep</i>&minus;ish meanings:</p>

<pre style="margin-left:11%; margin-top: 1em">    \        Quote the next metacharacter
    ^        Match the beginning of the line
    .        Match any character (except newline)
    $        Match the end of the line (or before newline at the end)
    |        Alternation
    ()       Grouping
    []       Bracketed Character class</pre>


<p style="margin-left:11%; margin-top: 1em">By default, the
&quot;^&quot; character is guaranteed to match only the
beginning of the string, the &quot;$&quot; character only
the end (or before the newline at the end), and Perl does
certain optimizations with the assumption that the string
contains only one line. Embedded newlines will not be
matched by &quot;^&quot; or &quot;$&quot;. You may, however,
wish to treat a string as a multi-line buffer, such that the
&quot;^&quot; will match after any newline within the string
(except if the newline is the last character in the string),
and &quot;$&quot; will match before any newline. At the cost
of a little more overhead, you can do this by using the /m
modifier on the pattern match operator. (Older programs did
this by setting <tt>$*</tt>, but this option was removed in
perl 5.9.)</p>

<p style="margin-left:11%; margin-top: 1em">To simplify
multi-line substitutions, the &quot;.&quot; character never
matches a newline unless you use the <tt>&quot;/s&quot;</tt>
modifier, which in effect tells Perl to pretend the string
is a single line--even if it isn&rsquo;t.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Quantifiers</i></p>

<p style="margin-left:11%; margin-top: 1em">The following
standard quantifiers are recognized:</p>

<pre style="margin-left:11%; margin-top: 1em">    *           Match 0 or more times
    +           Match 1 or more times
    ?           Match 1 or 0 times
    {n}         Match exactly n times
    {n,}        Match at least n times
    {n,m}       Match at least n but not more than m times</pre>


<p style="margin-left:11%; margin-top: 1em">(If a curly
bracket occurs in any other context and does not form part
of a backslashed sequence like <tt>&quot;\x{...}&quot;</tt>,
it is treated as a regular character. In particular, the
lower quantifier bound is not optional. However, in Perl
v5.18, it is planned to issue a deprecation warning for all
such occurrences, and in Perl v5.20 to require literal uses
of a curly bracket to be escaped, say by preceding them with
a backslash or enclosing them within square brackets,
(<tt>&quot;\{&quot;</tt> or <tt>&quot;[{]&quot;</tt>). This
change will allow for future syntax extensions (like making
the lower bound of a quantifier optional), and better error
checking of quantifiers. Now, a typo in a quantifier
silently causes it to be treated as the literal characters.
For example,</p>

<pre style="margin-left:11%; margin-top: 1em">    /o{4,3}/</pre>


<p style="margin-left:11%; margin-top: 1em">looks like a
quantifier that matches 0 times, since 4 is greater than 3,
but it really means to match the sequence of six characters
<tt>&quot;o&nbsp;{&nbsp;4&nbsp;,&nbsp;3&nbsp;}&quot;</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;*&quot; quantifier is equivalent to
<tt>&quot;{0,}&quot;</tt>, the &quot;+&quot; quantifier to
<tt>&quot;{1,}&quot;</tt>, and the &quot;?&quot; quantifier
to <tt>&quot;{0,1}&quot;</tt>. n and m are limited to
non-negative integral values less than a preset limit
defined when perl is built. This is usually 32766 on the
most common platforms. The actual limit can be seen in the
error message generated by code such as this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ **= $_ , / {$_} / for 2 .. 42;</pre>


<p style="margin-left:11%; margin-top: 1em">By default, a
quantified subpattern is &quot;greedy&quot;, that is, it
will match as many times as possible (given a particular
starting location) while still allowing the rest of the
pattern to match. If you want it to match the minimum number
of times possible, follow the quantifier with a
&quot;?&quot;. Note that the meanings don&rsquo;t change,
just the &quot;greediness&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em">    *?        Match 0 or more times, not greedily
    +?        Match 1 or more times, not greedily
    ??        Match 0 or 1 time, not greedily
    {n}?      Match exactly n times, not greedily (redundant)
    {n,}?     Match at least n times, not greedily
    {n,m}?    Match at least n but not more than m times, not greedily</pre>


<p style="margin-left:11%; margin-top: 1em">By default,
when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this
behaviour is sometimes undesirable. Thus Perl provides the
&quot;possessive&quot; quantifier form as well.</p>

<pre style="margin-left:11%; margin-top: 1em"> *+     Match 0 or more times and give nothing back
 ++     Match 1 or more times and give nothing back
 ?+     Match 0 or 1 time and give nothing back
 {n}+   Match exactly n times and give nothing back (redundant)
 {n,}+  Match at least n times and give nothing back
 {n,m}+ Match at least n but not more than m times and give nothing back</pre>


<p style="margin-left:11%; margin-top: 1em">For
instance,</p>

<pre style="margin-left:11%; margin-top: 1em">   'aaaa' =~ /a++a/</pre>


<p style="margin-left:11%; margin-top: 1em">will never
match, as the <tt>&quot;a++&quot;</tt> will gobble up all
the <tt>&quot;a&quot;</tt>&rsquo;s in the string and
won&rsquo;t leave any for the remaining part of the pattern.
This feature can be extremely useful to give perl hints
about where it shouldn&rsquo;t backtrack. For instance, the
typical &quot;match a double-quoted string&quot; problem can
be most efficiently performed when written as:</p>

<pre style="margin-left:11%; margin-top: 1em">   /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</pre>


<p style="margin-left:11%; margin-top: 1em">as we know that
if the final quote does not match, backtracking will not
help. See the independent subexpression
&quot;<tt>&quot;(?&gt;pattern)&quot;</tt>&quot; for more
details; possessive quantifiers are just syntactic sugar for
that construct. For instance the above example could also be
written as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">   /&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Escape
sequences</i></p>

<p style="margin-left:11%; margin-top: 1em">Because
patterns are processed as double-quoted strings, the
following also work:</p>

<pre style="margin-left:11%; margin-top: 1em"> \t          tab                   (HT, TAB)
 \n          newline               (LF, NL)
 \r          return                (CR)
 \f          form feed             (FF)
 \a          alarm (bell)          (BEL)
 \e          escape (think troff)  (ESC)
 \cK         control char          (example: VT)
 \x{}, \x00  character whose ordinal is the given hexadecimal number
 \N{name}    named Unicode character or character sequence
 \N{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
 \o{}, \000  character whose ordinal is the given octal number
 \l          lowercase next char (think vi)
 \u          uppercase next char (think vi)
 \L          lowercase till \E (think vi)
 \U          uppercase till \E (think vi)
 \Q          quote (disable) pattern metacharacters till \E
 \E          end either case modification or quoted section, think vi</pre>


<p style="margin-left:11%; margin-top: 1em">Details are in
&quot;Quote and Quote-like Operators&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Character
Classes and other Special Escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">In addition,
Perl defines the following:</p>

<pre style="margin-left:11%; margin-top: 1em"> Sequence   Note    Description
  [...]     [1]  Match a character according to the rules of the
                   bracketed character class defined by the &quot;...&quot;.
                   Example: [a&minus;z] matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot; ... or &quot;z&quot;
  [[:...:]] [2]  Match a character according to the rules of the POSIX
                   character class &quot;...&quot; within the outer bracketed
                   character class.  Example: [[:upper:]] matches any
                   uppercase character.
  \w        [3]  Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;, plus
                   other connector punctuation chars plus Unicode
                   marks)
  \W        [3]  Match a non&minus;&quot;word&quot; character
  \s        [3]  Match a whitespace character
  \S        [3]  Match a non&minus;whitespace character
  \d        [3]  Match a decimal digit character
  \D        [3]  Match a non&minus;digit character
  \pP       [3]  Match P, named property.  Use \p{Prop} for longer names
  \PP       [3]  Match non&minus;P
  \X        [4]  Match Unicode &quot;eXtended grapheme cluster&quot;
  \C             Match a single C&minus;language char (octet) even if that is
                   part of a larger UTF&minus;8 character.  Thus it breaks up
                   characters into their UTF&minus;8 bytes, so you may end up
                   with malformed pieces of UTF&minus;8.  Unsupported in
                   lookbehind.
  \1        [5]  Backreference to a specific capture group or buffer.
                   '1' may actually be any positive integer.
  \g1       [5]  Backreference to a specific or previous group,
  \g{&minus;1}    [5]  The number may be negative indicating a relative
                   previous group and may optionally be wrapped in
                   curly brackets for safer parsing.
  \g{name}  [5]  Named backreference
  \k&lt;name&gt;  [5]  Named backreference
  \K        [6]  Keep the stuff left of the \K, don't include it in $&amp;
  \N        [7]  Any character but \n (experimental).  Not affected by
                   /s modifier
  \v        [3]  Vertical whitespace
  \V        [3]  Not vertical whitespace
  \h        [3]  Horizontal whitespace
  \H        [3]  Not horizontal whitespace
  \R        [4]  Linebreak</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">See &quot;Bracketed Character
Classes&quot; in perlrecharclass for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot; <small>POSIX</small> Character Classes&quot;
in perlrecharclass for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Backslash sequences&quot; in perlrecharclass
for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Misc&quot; in perlrebackslash for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Capture groups&quot; below for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Extended Patterns&quot; below for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[7]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Note that <tt>&quot;\N&quot;</tt> has two meanings. When
of the form <tt>&quot;\N{NAME}&quot;</tt>, it matches the
character or character sequence whose name is
<tt>&quot;NAME&quot;</tt>; and similarly when of the form
<tt>&quot;\N{U+</tt><i>hex</i><tt>}&quot;</tt>, it matches
the character whose Unicode code point is <i>hex</i>.
Otherwise it matches any character but
<tt>&quot;\n&quot;</tt>.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i>Assertions</i></p>

<p style="margin-left:11%; margin-top: 1em">Perl defines
the following zero-width assertions:</p>

<pre style="margin-left:11%; margin-top: 1em">    \b  Match a word boundary
    \B  Match except at a word boundary
    \A  Match only at beginning of string
    \Z  Match only at end of string, or before newline at the end
    \z  Match only at end of string
    \G  Match only at pos() (e.g. at the end&minus;of&minus;match position
        of prior m//g)</pre>


<p style="margin-left:11%; margin-top: 1em">A word boundary
(<tt>&quot;\b&quot;</tt>) is a spot between two characters
that has a <tt>&quot;\w&quot;</tt> on one side of it and a
<tt>&quot;\W&quot;</tt> on the other side of it (in either
order), counting the imaginary characters off the beginning
and end of the string as matching a <tt>&quot;\W&quot;</tt>.
(Within character classes <tt>&quot;\b&quot;</tt> represents
backspace rather than a word boundary, just as it normally
does in any double-quoted string.) The
<tt>&quot;\A&quot;</tt> and <tt>&quot;\Z&quot;</tt> are just
like &quot;^&quot; and &quot;$&quot;, except that they
won&rsquo;t match multiple times when the
<tt>&quot;/m&quot;</tt> modifier is used, while
&quot;^&quot; and &quot;$&quot; will match at every internal
line boundary. To match the actual end of the string and not
ignore an optional trailing newline, use
<tt>&quot;\z&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\G&quot;</tt> assertion can be used to chain
global matches (using <tt>&quot;m//g&quot;</tt>), as
described in &quot;Regexp Quote-Like Operators&quot; in
perlop. It is also useful when writing
<tt>&quot;lex&quot;</tt>&minus;like scanners, when you have
several patterns that you want to match against consequent
substrings of your string; see the previous reference. The
actual location where <tt>&quot;\G&quot;</tt> will match can
also be influenced by using <tt>&quot;pos()&quot;</tt> as an
lvalue: see &quot;pos&quot; in perlfunc. Note that the rule
for zero-length matches (see &quot;Repeated Patterns
Matching a Zero-length Substring&quot;) is modified
somewhat, in that contents to the left of
<tt>&quot;\G&quot;</tt> are not counted when determining the
length of the match. Thus the following will not match
forever:</p>

<pre style="margin-left:11%; margin-top: 1em">     my $string = 'ABC';
     pos($string) = 1;
     while ($string =~ /(.\G)/g) {
         print $1;
     }</pre>


<p style="margin-left:11%; margin-top: 1em">It will print
&rsquo;A&rsquo; and then terminate, as it considers the
match to be zero-width, and thus will not match at the same
position twice in a row.</p>

<p style="margin-left:11%; margin-top: 1em">It is worth
noting that <tt>&quot;\G&quot;</tt> improperly used can
result in an infinite loop. Take care when using patterns
that include <tt>&quot;\G&quot;</tt> in an alternation.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Capture
groups</i></p>

<p style="margin-left:11%; margin-top: 1em">The bracketing
construct <tt>&quot;( ... )&quot;</tt> creates capture
groups (also referred to as capture buffers). To refer to
the current contents of a group later on, within the same
pattern, use <tt>&quot;\g1&quot;</tt> (or
<tt>&quot;\g{1}&quot;</tt>) for the first,
<tt>&quot;\g2&quot;</tt> (or <tt>&quot;\g{2}&quot;</tt>) for
the second, and so on. This is called a
<i>backreference</i>.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being
number 1, etc. If a group did not match, the associated
backreference won&rsquo;t match either. (This can happen if
the group is optional, or in a different branch of an
alternation.) You can omit the <tt>&quot;g&quot;</tt>, and
write <tt>&quot;\1&quot;</tt>, etc, but there are some
issues with this form, described below.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
refer to capture groups relatively, by using a negative
number, so that <tt>&quot;\g&minus;1&quot;</tt> and
<tt>&quot;\g{&minus;1}&quot;</tt> both refer to the
immediately preceding capture group, and
<tt>&quot;\g&minus;2&quot;</tt> and
<tt>&quot;\g{&minus;2}&quot;</tt> both refer to the group
before it. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">        /
         (Y)            # group 1
         (              # group 2
            (X)         # group 3
            \g{&minus;1}      # backref to group 3
            \g{&minus;3}      # backref to group 1
         )
        /x</pre>


<p style="margin-left:11%; margin-top: 1em">would match the
same as <tt>&quot;/(Y) ( (X) \g3 \g1 )/x&quot;</tt>. This
allows you to interpolate regexes into larger regexes and
not have to worry about the capture groups being
renumbered.</p>

<p style="margin-left:11%; margin-top: 1em">You can
dispense with numbers altogether and create named capture
groups. The notation is
<tt>&quot;(?&lt;</tt><i>name</i><tt>&gt;...)&quot;</tt> to
declare and <tt>&quot;\g{</tt><i>name</i><tt>}&quot;</tt> to
reference. (To be compatible with .Net regular expressions,
<tt>&quot;\g{</tt><i>name</i><tt>}&quot;</tt> may also be
written as <tt>&quot;\k{</tt><i>name</i><tt>}&quot;</tt>,
<tt>&quot;\k&lt;</tt><i>name</i><tt>&gt;&quot;</tt> or
<tt>&quot;\k'</tt><i>name</i><tt>'&quot;</tt>.) <i>name</i>
must not begin with a number, nor contain hyphens. When
different groups within the same pattern have the same name,
any reference to that name assumes the leftmost defined
group. Named groups count in absolute and relative
numbering, and so can also be referred to by those numbers.
(It&rsquo;s possible to do things with named capture groups
that would otherwise require
<tt>&quot;(??{})&quot;</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">Capture group
contents are dynamically scoped and available to you outside
the pattern until the end of the enclosing block or until
the next successful match, whichever comes first. (See
&quot;Compound Statements&quot; in perlsyn.) You can refer
to them by absolute number (using <tt>&quot;$1&quot;</tt>
instead of <tt>&quot;\g1&quot;</tt>, etc); or by name via
the <tt>&quot;%+&quot;</tt> hash, using
<tt>&quot;$+{</tt><i>name</i><tt>}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Braces are
required in referring to named capture groups, but are
optional for absolute or relative numbered ones. Braces are
safer when creating a regex by concatenating smaller
strings. For example if you have
<tt>&quot;qr/$a$b/&quot;</tt>, and <tt>$a</tt> contained
<tt>&quot;\g1&quot;</tt>, and <tt>$b</tt> contained
<tt>&quot;37&quot;</tt>, you would get
<tt>&quot;/\g137/&quot;</tt> which is probably not what you
intended.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\g&quot;</tt> and <tt>&quot;\k&quot;</tt>
notations were introduced in Perl 5.10.0. Prior to that
there were no named nor relative numbered capture groups.
Absolute numbered groups were referred to using
<tt>&quot;\1&quot;</tt>, <tt>&quot;\2&quot;</tt>, etc., and
this notation is still accepted (and likely always will be).
But it leads to some ambiguities if there are more than 9
capture groups, as <tt>&quot;\10&quot;</tt> could mean
either the tenth capture group, or the character whose
ordinal in octal is 010 (a backspace in <small>ASCII</small>
). Perl resolves this ambiguity by interpreting
<tt>&quot;\10&quot;</tt> as a backreference only if at least
10 left parentheses have opened before it. Likewise
<tt>&quot;\11&quot;</tt> is a backreference only if at least
11 left parentheses have opened before it. And so on.
<tt>&quot;\1&quot;</tt> through <tt>&quot;\9&quot;</tt> are
always interpreted as backreferences. There are several
examples below that illustrate these perils. You can avoid
the ambiguity by always using <tt>&quot;\g{}&quot;</tt> or
<tt>&quot;\g&quot;</tt> if you mean capturing groups; and
for octal constants always using <tt>&quot;\o{}&quot;</tt>,
or for <tt>&quot;\077&quot;</tt> and below, using 3 digits
padded with leading zeros, since a leading zero implies an
octal constant.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\</tt><i>digit</i><tt>&quot;</tt> notation also
works in certain circumstances outside the pattern. See
&quot;Warning on \1 Instead of <tt>$1</tt>&quot; below for
details.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
    /(.)\g1/                        # find first doubled char
         and print &quot;'$1' is the first doubled character\n&quot;;
    /(?&lt;char&gt;.)\k&lt;char&gt;/            # ... a different way
         and print &quot;'$+{char}' is the first doubled character\n&quot;;
    /(?'char'.)\g1/                 # ... mix and match
         and print &quot;'$1' is the first doubled character\n&quot;;
    if (/Time: (..):(..):(..)/) {   # parse out values
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 is a backreference
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 is octal
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 is a backreference
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal
    $a = '(.)\1';        # Creates problems when concatenated.
    $b = '(.)\g{1}';     # Avoids the problems.
    &quot;aa&quot; =~ /${a}/;      # True
    &quot;aa&quot; =~ /${b}/;      # True
    &quot;aa0&quot; =~ /${a}0/;    # False!
    &quot;aa0&quot; =~ /${b}0/;    # True
    &quot;aa\x08&quot; =~ /${a}0/;  # True!
    &quot;aa\x08&quot; =~ /${b}0/;  # False</pre>


<p style="margin-left:11%; margin-top: 1em">Several special
variables also refer back to portions of the previous match.
<tt>$+</tt> returns whatever the last bracket match matched.
<tt>$&amp;</tt> returns the entire matched string. (At one
point <tt>$0</tt> did also, but now it returns the name of
the program.) <tt>&quot;$`&quot;</tt> returns everything
before the matched string. <tt>&quot;$'&quot;</tt> returns
everything after the matched string. And <tt>$^N</tt>
contains whatever was matched by the most-recently closed
group (submatch). <tt>$^N</tt> can be used in extended
patterns (see below), for example to assign a submatch to a
variable.</p>

<p style="margin-left:11%; margin-top: 1em">These special
variables, like the <tt>&quot;%+&quot;</tt> hash and the
numbered match variables (<tt>$1</tt>, <tt>$2</tt>,
<tt>$3</tt>, etc.) are dynamically scoped until the end of
the enclosing block or until the next successful match,
whichever comes first. (See &quot;Compound Statements&quot;
in perlsyn.)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series
of more specific cases and remembers the best match.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: Once Perl sees that you need one of <tt>$&amp;</tt>,
<tt>&quot;$`&quot;</tt>, or <tt>&quot;$'&quot;</tt> anywhere
in the program, it has to provide them for every pattern
match. This may substantially slow your program. Perl uses
the same mechanism to produce <tt>$1</tt>, <tt>$2</tt>, etc,
so you also pay a price for each pattern that contains
capturing parentheses. (To avoid this cost while retaining
the grouping behaviour, use the extended regular expression
<tt>&quot;(?: ... )&quot;</tt> instead.) But if you never
use <tt>$&amp;</tt>, <tt>&quot;$`&quot;</tt> or
<tt>&quot;$'&quot;</tt>, then patterns <i>without</i>
capturing parentheses will not be penalized. So avoid
<tt>$&amp;</tt>, <tt>&quot;$'&quot;</tt>, and
<tt>&quot;$`&quot;</tt> if you can, but if you can&rsquo;t
(and some algorithms really appreciate them), once
you&rsquo;ve used them once, use them at will, because
you&rsquo;ve already paid the price. As of 5.005,
<tt>$&amp;</tt> is not so costly as the other two.</p>

<p style="margin-left:11%; margin-top: 1em">As a workaround
for this problem, Perl 5.10.0 introduces
<tt>&quot;${^PREMATCH}&quot;</tt>,
<tt>&quot;${^MATCH}&quot;</tt> and
<tt>&quot;${^POSTMATCH}&quot;</tt>, which are equivalent to
<tt>&quot;$`&quot;</tt>, <tt>$&amp;</tt> and
<tt>&quot;$'&quot;</tt>, <b>except</b> that they are only
guaranteed to be defined after a successful match that was
executed with the <tt>&quot;/p&quot;</tt> (preserve)
modifier. The use of these variables incurs no global
performance penalty, unlike their punctuation char
equivalents, however at the trade-off that you have to tell
perl when you want to use them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Quoting
metacharacters</b> <br>
Backslashed metacharacters in Perl are alphanumeric, such as
<tt>&quot;\b&quot;</tt>, <tt>&quot;\w&quot;</tt>,
<tt>&quot;\n&quot;</tt>. Unlike some other regular
expression languages, there are no backslashed symbols that
aren&rsquo;t alphanumeric. So anything that looks like \\,
\(, \), \&lt;, \&gt;, \{, or \} is always interpreted as a
literal character, not a metacharacter. This was once used
in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you
want to use for a pattern. Simply quote all
non&minus;&quot;word&quot; characters:</p>

<pre style="margin-left:11%; margin-top: 1em">    $pattern =~ s/(\W)/\\$1/g;</pre>


<p style="margin-left:11%; margin-top: 1em">(If
<tt>&quot;use locale&quot;</tt> is set, then this depends on
the current locale.) Today it is more common to use the
<i>quotemeta()</i> function or the <tt>&quot;\Q&quot;</tt>
metaquoting escape sequence to disable all
metacharacters&rsquo; special meanings like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    /$unquoted\Q$quoted\E$unquoted/</pre>


<p style="margin-left:11%; margin-top: 1em">Beware that if
you put literal backslashes (those not inside interpolated
variables) between <tt>&quot;\Q&quot;</tt> and
<tt>&quot;\E&quot;</tt>, double-quotish backslash
interpolation may lead to confusing results. If you
<i>need</i> to use literal backslashes within
<tt>&quot;\Q...\E&quot;</tt>, consult &quot;Gory details of
parsing quoted constructs&quot; in perlop.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;quotemeta()&quot;</tt>
and <tt>&quot;\Q&quot;</tt> are fully described in
&quot;quotemeta&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extended
Patterns</b> <br>
Perl also defines a consistent extension syntax for features
not found in standard tools like <b>awk</b> and <b>lex</b>.
The syntax for most of these is a pair of parentheses with a
question mark as the first thing within the parentheses. The
character after the question mark indicates the
extension.</p>

<p style="margin-left:11%; margin-top: 1em">The stability
of these extensions varies widely. Some have been part of
the core language for many years. Others are experimental
and may change without warning or be completely removed.
Check the documentation on an individual feature to verify
its current status.</p>

<p style="margin-left:11%; margin-top: 1em">A question mark
was chosen for this and for the minimal-matching construct
because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop
and &quot;question&quot; exactly what is going on.
That&rsquo;s psychology.... <br>
&quot;(?#text)&quot;</p>

<p style="margin-left:17%;">A comment. The text is ignored.
If the <tt>&quot;/x&quot;</tt> modifier enables whitespace
formatting, a simple <tt>&quot;#&quot;</tt> will suffice.
Note that Perl closes the comment as soon as it sees a
<tt>&quot;)&quot;</tt>, so there is no way to put a literal
<tt>&quot;)&quot;</tt> in the comment.</p>


<p style="margin-left:11%;">&quot;(?adlupimsx&minus;imsx)&quot;
<br>
&quot;(?^alupimsx)&quot;</p>

<p style="margin-left:17%;">One or more embedded
pattern-match modifiers, to be turned on (or turned off, if
preceded by <tt>&quot;&minus;&quot;</tt>) for the remainder
of the pattern or the remainder of the enclosing pattern
group (if any).</p>

<p style="margin-left:17%; margin-top: 1em">This is
particularly useful for dynamic patterns, such as those read
in from a configuration file, taken from an argument, or
specified in a table somewhere. Consider the case where some
patterns want to be case-sensitive and some do not: The
case-insensitive ones merely need to include
<tt>&quot;(?i)&quot;</tt> at the front of the pattern. For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">    $pattern = &quot;foobar&quot;;
    if ( /$pattern/i ) { }
    # more flexible:
    $pattern = &quot;(?i)foobar&quot;;
    if ( /$pattern/ ) { }</pre>


<p style="margin-left:17%; margin-top: 1em">These modifiers
are restored at the end of the enclosing group. For
example,</p>

<pre style="margin-left:17%; margin-top: 1em">    ( (?i) blah ) \s+ \g1</pre>


<p style="margin-left:17%; margin-top: 1em">will match
<tt>&quot;blah&quot;</tt> in any case, some spaces, and an
exact (<i>including the case</i>!) repetition of the
previous word, assuming the <tt>&quot;/x&quot;</tt>
modifier, and no <tt>&quot;/i&quot;</tt> modifier outside
this group.</p>

<p style="margin-left:17%; margin-top: 1em">These modifiers
do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as
<tt>&quot;((?i)(?&amp;NAME))&quot;</tt> does not change the
case-sensitivity of the &quot; <small>NAME</small> &quot;
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">Any of these
modifiers can be set to apply globally to all regular
expressions compiled within the scope of a <tt>&quot;use
re&quot;</tt>. See &quot;&rsquo;/flags&rsquo; mode&quot; in
re.</p>

<p style="margin-left:17%; margin-top: 1em">Starting in
Perl 5.14, a <tt>&quot;^&quot;</tt> (caret or circumflex
accent) immediately after the <tt>&quot;?&quot;</tt> is a
shorthand equivalent to <tt>&quot;d&minus;imsx&quot;</tt>.
Flags (except <tt>&quot;d&quot;</tt>) may follow the caret
to override it. But a minus sign is not legal with it.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
<tt>&quot;a&quot;</tt>, <tt>&quot;d&quot;</tt>,
<tt>&quot;l&quot;</tt>, <tt>&quot;p&quot;</tt>, and
<tt>&quot;u&quot;</tt> modifiers are special in that they
can only be enabled, not disabled, and the
<tt>&quot;a&quot;</tt>, <tt>&quot;d&quot;</tt>,
<tt>&quot;l&quot;</tt>, and <tt>&quot;u&quot;</tt> modifiers
are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two
<tt>&quot;a&quot;</tt>&rsquo;s) may appear in the construct.
Thus, for example, <tt>&quot;(?&minus;p)&quot;</tt> will
warn when compiled under <tt>&quot;use warnings&quot;</tt>;
<tt>&quot;(?&minus;d:...)&quot;</tt> and
<tt>&quot;(?dl:...)&quot;</tt> are fatal errors.</p>

<p style="margin-left:17%; margin-top: 1em">Note also that
the <tt>&quot;p&quot;</tt> modifier is special in that its
presence anywhere in a pattern has a global effect.</p>

<p style="margin-left:11%;">&quot;(?:pattern)&quot; <br>
&quot;(?adluimsx&minus;imsx:pattern)&quot; <br>
&quot;(?^aluimsx:pattern)&quot;</p>

<p style="margin-left:17%;">This is for clustering, not
capturing; it groups subexpressions like &quot;()&quot;, but
doesn&rsquo;t make backreferences as &quot;()&quot; does.
So</p>

<pre style="margin-left:17%; margin-top: 1em">    @fields = split(/\b(?:a|b|c)\b/)</pre>


<p style="margin-left:17%; margin-top: 1em">is like</p>

<pre style="margin-left:17%; margin-top: 1em">    @fields = split(/\b(a|b|c)\b/)</pre>


<p style="margin-left:17%; margin-top: 1em">but
doesn&rsquo;t spit out extra fields. It&rsquo;s also cheaper
not to capture characters if you don&rsquo;t need to.</p>

<p style="margin-left:17%; margin-top: 1em">Any letters
between <tt>&quot;?&quot;</tt> and <tt>&quot;:&quot;</tt>
act as flags modifiers as with
<tt>&quot;(?adluimsx&minus;imsx)&quot;</tt>. For
example,</p>

<pre style="margin-left:17%; margin-top: 1em">    /(?s&minus;i:more.*than).*million/i</pre>


<p style="margin-left:17%; margin-top: 1em">is equivalent
to the more verbose</p>

<pre style="margin-left:17%; margin-top: 1em">    /(?:(?s&minus;i)more.*than).*million/i</pre>


<p style="margin-left:17%; margin-top: 1em">Starting in
Perl 5.14, a <tt>&quot;^&quot;</tt> (caret or circumflex
accent) immediately after the <tt>&quot;?&quot;</tt> is a
shorthand equivalent to <tt>&quot;d&minus;imsx&quot;</tt>.
Any positive flags (except <tt>&quot;d&quot;</tt>) may
follow the caret, so</p>

<pre style="margin-left:17%; margin-top: 1em">    (?^x:foo)</pre>


<p style="margin-left:17%; margin-top: 1em">is equivalent
to</p>

<pre style="margin-left:17%; margin-top: 1em">    (?x&minus;ims:foo)</pre>


<p style="margin-left:17%; margin-top: 1em">The caret tells
Perl that this cluster doesn&rsquo;t inherit the flags of
any surrounding pattern, but uses the system defaults
(<tt>&quot;d&minus;imsx&quot;</tt>), modified by any flags
specified.</p>

<p style="margin-left:17%; margin-top: 1em">The caret
allows for simpler stringification of compiled regular
expressions. These look like</p>

<pre style="margin-left:17%; margin-top: 1em">    (?^:pattern)</pre>


<p style="margin-left:17%; margin-top: 1em">with any
non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn&rsquo;t
need to have the system default flags hard-coded in it, just
the caret. If new flags are added to Perl, the meaning of
the caret&rsquo;s expansion will change to include the
default for those flags, so the test will still work,
unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">Specifying a
negative flag after the caret is an error, as the flag is
redundant.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic for
<tt>&quot;(?^...)&quot;</tt>: A fresh beginning since the
usual use of a caret is to match at the beginning.</p>

<p style="margin-left:11%;">&quot;(?|pattern)&quot;</p>

<p style="margin-left:17%;">This is the &quot;branch
reset&quot; pattern, which has the special property that the
capture groups are numbered from the same starting point in
each alternation branch. It is available starting from perl
5.10.0.</p>

<p style="margin-left:17%; margin-top: 1em">Capture groups
are numbered from left to right, but inside this construct
the numbering is restarted for each branch.</p>

<p style="margin-left:17%; margin-top: 1em">The numbering
within each branch will be as normal, and any groups
following this construct will be numbered as though the
construct contained only one branch, that being the one with
the most capture groups in it.</p>

<p style="margin-left:17%; margin-top: 1em">This construct
is useful when you want to capture one of a number of
alternative matches.</p>

<p style="margin-left:17%; margin-top: 1em">Consider the
following pattern. The numbers underneath show in which
group the captured content will be stored.</p>

<pre style="margin-left:17%; margin-top: 1em">    # before  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;branch&minus;reset&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus; after
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4</pre>


<p style="margin-left:17%; margin-top: 1em">Be careful when
using the branch reset pattern in combination with named
captures. Named captures are implemented as being aliases to
numbered groups holding the captures, and that interferes
with the implementation of the branch reset pattern. If you
are using named captures in a branch reset pattern,
it&rsquo;s best to use the same names, in the same order, in
each of the alternations:</p>

<pre style="margin-left:17%; margin-top: 1em">   /(?|  (?&lt;a&gt; x ) (?&lt;b&gt; y )
      |  (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x</pre>


<p style="margin-left:17%; margin-top: 1em">Not doing so
may lead to surprises:</p>

<pre style="margin-left:17%; margin-top: 1em">  &quot;12&quot; =~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x;
  say $+ {a};   # Prints '12'
  say $+ {b};   # *Also* prints '12'.</pre>


<p style="margin-left:17%; margin-top: 1em">The problem
here is that both the group named <tt>&quot;a&quot;</tt> and
the group named <tt>&quot;b&quot;</tt> are aliases for the
group belonging to <tt>$1</tt>.</p>

<p style="margin-left:11%;">Look-Around Assertions</p>

<p style="margin-left:17%;">Look-around assertions are
zero-width patterns which match a specific pattern without
including it in <tt>$&amp;</tt>. Positive assertions match
when their subpattern matches, negative assertions match
when their subpattern fails. Look-behind matches text up to
the current match position, look-ahead matches text
following the current match position. <br>
&quot;(?=pattern)&quot;</p>

<p style="margin-left:23%;">A zero-width positive
look-ahead assertion. For example,
<tt>&quot;/\w+(?=\t)/&quot;</tt> matches a word followed by
a tab, without including the tab in <tt>$&amp;</tt>.</p>

<p style="margin-left:17%;">&quot;(?!pattern)&quot;</p>

<p style="margin-left:23%;">A zero-width negative
look-ahead assertion. For example
<tt>&quot;/foo(?!bar)/&quot;</tt> matches any occurrence of
&quot;foo&quot; that isn&rsquo;t followed by
&quot;bar&quot;. Note however that look-ahead and
look-behind are <small>NOT</small> the same thing. You
cannot use this for look-behind.</p>

<p style="margin-left:23%; margin-top: 1em">If you are
looking for a &quot;bar&quot; that isn&rsquo;t preceded by a
&quot;foo&quot;, <tt>&quot;/(?!foo)bar/&quot;</tt> will not
do what you want. That&rsquo;s because the
<tt>&quot;(?!foo)&quot;</tt> is just saying that the next
thing cannot be &quot;foo&quot;&minus;&minus;and it&rsquo;s
not, it&rsquo;s a &quot;bar&quot;, so &quot;foobar&quot;
will match. Use look-behind instead (see below).</p>

<p style="margin-left:17%;">&quot;(?&lt;=pattern)&quot;
&quot;\K&quot;</p>

<p style="margin-left:23%;">A zero-width positive
look-behind assertion. For example,
<tt>&quot;/(?&lt;=\t)\w+/&quot;</tt> matches a word that
follows a tab, without including the tab in <tt>$&amp;</tt>.
Works only for fixed-width look-behind.</p>

<p style="margin-left:23%; margin-top: 1em">There is a
special form of this construct, called
<tt>&quot;\K&quot;</tt>, which causes the regex engine to
&quot;keep&quot; everything it had matched prior to the
<tt>&quot;\K&quot;</tt> and not include it in
<tt>$&amp;</tt>. This effectively provides variable-length
look-behind. The use of <tt>&quot;\K&quot;</tt> inside of
another look-around assertion is allowed, but the behaviour
is currently not well defined.</p>

<p style="margin-left:23%; margin-top: 1em">For various
reasons <tt>&quot;\K&quot;</tt> may be significantly more
efficient than the equivalent
<tt>&quot;(?&lt;=...)&quot;</tt> construct, and it is
especially useful in situations where you want to
efficiently remove something following something else in a
string. For instance</p>

<pre style="margin-left:23%; margin-top: 1em">  s/(foo)bar/$1/g;</pre>


<p style="margin-left:23%; margin-top: 1em">can be
rewritten as the much more efficient</p>

<pre style="margin-left:23%; margin-top: 1em">  s/foo\Kbar//g;</pre>



<p style="margin-left:17%;">&quot;(?&lt;!pattern)&quot;</p>

<p style="margin-left:23%;">A zero-width negative
look-behind assertion. For example
<tt>&quot;/(?&lt;!bar)foo/&quot;</tt> matches any occurrence
of &quot;foo&quot; that does not follow &quot;bar&quot;.
Works only for fixed-width look-behind.</p>

<p style="margin-left:11%;">&quot;(?'NAME'pattern)&quot;
<br>
&quot;(?&lt;NAME&gt;pattern)&quot;</p>

<p style="margin-left:17%;">A named capture group.
Identical in every respect to normal capturing parentheses
<tt>&quot;()&quot;</tt> but for the additional fact that the
group can be referred to by name in various regular
expression constructs (like <tt>&quot;\g{NAME}&quot;</tt>)
and can be accessed by name after a successful match via
<tt>&quot;%+&quot;</tt> or <tt>&quot;%&minus;&quot;</tt>.
See perlvar for more details on the <tt>&quot;%+&quot;</tt>
and <tt>&quot;%&minus;&quot;</tt> hashes.</p>

<p style="margin-left:17%; margin-top: 1em">If multiple
distinct capture groups have the same name then the $+{
<small>NAME</small> } will refer to the leftmost defined
group in the match.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
<tt>&quot;(?'NAME'pattern)&quot;</tt> and
<tt>&quot;(?&lt;NAME&gt;pattern)&quot;</tt> are
equivalent.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
While the notation of this construct is the same as the
similar function in .NET regexes, the behavior is not. In
Perl the groups are numbered sequentially regardless of
being named or not. Thus in the pattern</p>

<pre style="margin-left:17%; margin-top: 1em">  /(x)(?&lt;foo&gt;y)(z)/</pre>


<p style="margin-left:17%; margin-top: 1em">$+{foo} will be
the same as <tt>$2</tt>, and <tt>$3</tt> will contain
&rsquo;z&rsquo; instead of the opposite which is what a .NET
regex hacker might expect.</p>

<p style="margin-left:17%; margin-top: 1em">Currently
<small>NAME</small> is restricted to simple identifiers
only. In other words, it must match
<tt>&quot;/^[_A&minus;Za&minus;z][_A&minus;Za&minus;z0&minus;9]*\z/&quot;</tt>
or its Unicode extension (see utf8), though it isn&rsquo;t
extended by the locale (see perllocale).</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines, the pattern
<tt>&quot;(?P&lt;NAME&gt;pattern)&quot;</tt> may be used
instead of <tt>&quot;(?&lt;NAME&gt;pattern)&quot;</tt>;
however this form does not support the use of single quotes
as a delimiter for the name.</p>

<p style="margin-left:11%;">&quot;\k&lt;NAME&gt;&quot; <br>
&quot;\k'NAME'&quot;</p>

<p style="margin-left:17%;">Named backreference. Similar to
numeric backreferences, except that the group is designated
by name and not number. If multiple groups have the same
name then it refers to the leftmost defined group in the
current match.</p>

<p style="margin-left:17%; margin-top: 1em">It is an error
to refer to a name not defined by a
<tt>&quot;(?&lt;NAME&gt;)&quot;</tt> earlier in the
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">Both forms are
equivalent.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines, the pattern <tt>&quot;(?P=NAME)&quot;</tt> may be
used instead of <tt>&quot;\k&lt;NAME&gt;&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;(?{ code })&quot;</p>

<p style="margin-left:17%;"><b><small>WARNING</small></b> :
This extended regular expression feature is considered
experimental, and may be changed without notice. Code
executed that has side effects may not perform identically
from version to version due to the effect of future
optimisations in the regex engine.</p>

<p style="margin-left:17%; margin-top: 1em">This zero-width
assertion evaluates any embedded Perl code. It always
succeeds, and its <tt>&quot;code&quot;</tt> is not
interpolated. Currently, the rules to determine where the
<tt>&quot;code&quot;</tt> ends are somewhat convoluted.</p>

<p style="margin-left:17%; margin-top: 1em">This feature
can be used together with the special variable <tt>$^N</tt>
to capture the results of submatches in variables without
having to keep track of the number of nested parentheses.
For example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $_ = &quot;The brown fox jumps over the lazy dog&quot;;
  /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;
  print &quot;color = $color, animal = $animal\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">Inside the
<tt>&quot;(?{...})&quot;</tt> block, <tt>$_</tt> refers to
the string the regular expression is matching against. You
can also use <tt>&quot;pos()&quot;</tt> to know what is the
current position of matching within this string.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;code&quot;</tt> is properly scoped in the
following sense: If the assertion is backtracked (compare
&quot;Backtracking&quot;), all changes introduced after
<tt>&quot;local&quot;</tt>ization are undone, so that</p>

<pre style="margin-left:17%; margin-top: 1em">  $_ = 'a' x 8;
  m&lt;
     (?{ $cnt = 0 })               # Initialize $cnt.
     (
       a
       (?{
           local $cnt = $cnt + 1;  # Update $cnt,
                                   # backtracking&minus;safe.
       })
     )*
     aaaa
     (?{ $res = $cnt })            # On success copy to
                                   # non&minus;localized location.
   &gt;x;</pre>


<p style="margin-left:17%; margin-top: 1em">will set
<tt>&quot;$res = 4&quot;</tt>. Note that after the match,
<tt>$cnt</tt> returns to the globally introduced value,
because the scopes that restrict <tt>&quot;local&quot;</tt>
operators are unwound.</p>

<p style="margin-left:17%; margin-top: 1em">This assertion
may be used as a
<tt>&quot;(?(condition)yes&minus;pattern|no&minus;pattern)&quot;</tt>
switch. If <i>not</i> used in this way, the result of
evaluation of <tt>&quot;code&quot;</tt> is put into the
special variable <tt>$^R</tt>. This happens immediately, so
<tt>$^R</tt> can be used from other <tt>&quot;(?{ code
})&quot;</tt> assertions inside the same regular
expression.</p>

<p style="margin-left:17%; margin-top: 1em">The assignment
to <tt>$^R</tt> above is properly localized, so the old
value of <tt>$^R</tt> is restored if the assertion is
backtracked; compare &quot;Backtracking&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For reasons of
security, this construct is forbidden if the regular
expression involves run-time interpolation of variables,
unless the perilous <tt>&quot;use re 'eval'&quot;</tt>
pragma has been used (see re), or the variables contain
results of the <tt>&quot;qr//&quot;</tt> operator (see
&quot;qr/STRING/msixpodual&quot; in perlop).</p>

<p style="margin-left:17%; margin-top: 1em">This
restriction is due to the wide-spread and remarkably
convenient custom of using run-time determined strings as
patterns. For example:</p>

<pre style="margin-left:17%; margin-top: 1em">    $re = &lt;&gt;;
    chomp $re;
    $string =~ /$re/;</pre>


<p style="margin-left:17%; margin-top: 1em">Before Perl
knew how to execute interpolated code within a pattern, this
operation was completely safe from a security point of view,
although it could raise an exception from an illegal
pattern. If you turn on the <tt>&quot;use re
'eval'&quot;</tt>, though, it is no longer secure, so you
should only do so if you are also using taint checking.
Better yet, use the carefully constrained evaluation within
a Safe compartment. See perlsec for details about both these
mechanisms.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: Use of lexical (<tt>&quot;my&quot;</tt>) variables in
these blocks is broken. The result is unpredictable and will
make perl unstable. The workaround is to use global
(<tt>&quot;our&quot;</tt>) variables.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: In perl 5.12.x and earlier, the regex engine was not
re-entrant, so interpolated code could not safely invoke the
regex engine either directly with <tt>&quot;m//&quot;</tt>
or <tt>&quot;s///&quot;</tt>), or indirectly with functions
such as <tt>&quot;split&quot;</tt>. Invoking the regex
engine in these blocks would make perl unstable.</p>

<p style="margin-left:11%;">&quot;(??{ code })&quot;</p>

<p style="margin-left:17%;"><b><small>WARNING</small></b> :
This extended regular expression feature is considered
experimental, and may be changed without notice. Code
executed that has side effects may not perform identically
from version to version due to the effect of future
optimisations in the regex engine.</p>

<p style="margin-left:17%; margin-top: 1em">This is a
&quot;postponed&quot; regular subexpression. The
<tt>&quot;code&quot;</tt> is evaluated at run time, at the
moment this subexpression may match. The result of
evaluation is considered a regular expression and matched as
if it were inserted instead of this construct. Note that
this means that the contents of capture groups defined
inside an eval&rsquo;ed pattern are not available outside of
the pattern, and vice versa, there is no way for the inner
pattern returned from the code block to refer to a capture
group defined outside. (The code block itself can use
<tt>$1</tt>, etc., to refer to the enclosing pattern&rsquo;s
capture groups.) Thus,</p>

<pre style="margin-left:17%; margin-top: 1em">    ('a' x 100)=~/(??{'(.)' x 100})/</pre>


<p style="margin-left:17%; margin-top: 1em"><b>will</b>
match, it will <b>not</b> set <tt>$1</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;code&quot;</tt> is not interpolated. As before,
the rules to determine where the <tt>&quot;code&quot;</tt>
ends are currently somewhat convoluted.</p>

<p style="margin-left:17%; margin-top: 1em">The following
pattern matches a parenthesized group:</p>

<pre style="margin-left:17%; margin-top: 1em"> $re = qr{
            \(
            (?:
               (?&gt; [^()]+ )  # Non&minus;parens without backtracking
             |
               (??{ $re })   # Group with matching parens
            )*
            \)
         }x;</pre>


<p style="margin-left:17%; margin-top: 1em">See also
<tt>&quot;(?PARNO)&quot;</tt> for a different, more
efficient way to accomplish the same task.</p>

<p style="margin-left:17%; margin-top: 1em">For reasons of
security, this construct is forbidden if the regular
expression involves run-time interpolation of variables,
unless the perilous <tt>&quot;use re 'eval'&quot;</tt>
pragma has been used (see re), or the variables contain
results of the <tt>&quot;qr//&quot;</tt> operator (see
&quot;qr/STRING/msixpodual&quot; in perlop).</p>

<p style="margin-left:17%; margin-top: 1em">In perl 5.12.x
and earlier, because the regex engine was not re-entrant,
delayed code could not safely invoke the regex engine either
directly with <tt>&quot;m//&quot;</tt> or
<tt>&quot;s///&quot;</tt>), or indirectly with functions
such as <tt>&quot;split&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Recursing
deeper than 50 times without consuming any input string will
result in a fatal error. The maximum depth is compiled into
perl, so changing it requires a custom build.</p>

<p style="margin-left:11%;">&quot;(?PARNO)&quot;
&quot;(?&minus;PARNO)&quot; &quot;(?+PARNO)&quot;
&quot;(?R)&quot; &quot;(?0)&quot;</p>

<p style="margin-left:17%;">Similar to <tt>&quot;(??{ code
})&quot;</tt> except it does not involve compiling any code,
instead it treats the contents of a capture group as an
independent pattern that must match at the current position.
Capture groups contained by the pattern will have the value
as determined by the outermost recursion.</p>


<p style="margin-left:17%; margin-top: 1em"><small>PARNO</small>
is a sequence of digits (not starting with 0) whose value
reflects the paren-number of the capture group to recurse
to. <tt>&quot;(?R)&quot;</tt> recurses to the beginning of
the whole pattern. <tt>&quot;(?0)&quot;</tt> is an alternate
syntax for <tt>&quot;(?R)&quot;</tt>. If
<small>PARNO</small> is preceded by a plus or minus sign
then it is assumed to be relative, with negative numbers
indicating preceding capture groups and positive ones
following. Thus <tt>&quot;(?&minus;1)&quot;</tt> refers to
the most recently declared group, and
<tt>&quot;(?+1)&quot;</tt> indicates the next group to be
declared. Note that the counting for relative recursion
differs from that of relative backreferences, in that with
recursion unclosed groups <b>are</b> included.</p>

<p style="margin-left:17%; margin-top: 1em">The following
pattern matches a function <i>foo()</i> which may contain
balanced parentheses as the argument.</p>

<pre style="margin-left:17%; margin-top: 1em">  $re = qr{ (                   # paren group 1 (full function)
              foo
              (                 # paren group 2 (parens)
                \(
                  (             # paren group 3 (contents of parens)
                  (?:
                   (?&gt; [^()]+ ) # Non&minus;parens without backtracking
                  |
                   (?2)         # Recurse to start of paren group 2
                  )*
                  )
                \)
              )
            )
          }x;</pre>


<p style="margin-left:17%; margin-top: 1em">If the pattern
was used as follows</p>

<pre style="margin-left:17%; margin-top: 1em">    'foo(bar(baz)+baz(bop))'=~/$re/
        and print &quot;\$1 = $1\n&quot;,
                  &quot;\$2 = $2\n&quot;,
                  &quot;\$3 = $3\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">the output
produced should be the following:</p>

<pre style="margin-left:17%; margin-top: 1em">    $1 = foo(bar(baz)+baz(bop))
    $2 = (bar(baz)+baz(bop))
    $3 = bar(baz)+baz(bop)</pre>


<p style="margin-left:17%; margin-top: 1em">If there is no
corresponding capture group defined, then it is a fatal
error. Recursing deeper than 50 times without consuming any
input string will also result in a fatal error. The maximum
depth is compiled into perl, so changing it requires a
custom build.</p>

<p style="margin-left:17%; margin-top: 1em">The following
shows how using negative indexing can make it easier to
embed recursive patterns inside of a
<tt>&quot;qr//&quot;</tt> construct for later use:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $parens = qr/(\((?:[^()]++|(?&minus;1))*+\))/;
    if (/foo $parens \s+ + \s+ bar $parens/x) {
       # do something here...
    }</pre>


<p style="margin-left:17%; margin-top: 1em"><b>Note</b>
that this pattern does not behave the same way as the
equivalent <small>PCRE</small> or Python construct of the
same form. In Perl you can backtrack into a recursed group,
in <small>PCRE</small> and Python the recursed into group is
treated as atomic. Also, modifiers are resolved at compile
time, so constructs like (?i:(?1)) or (?:(?i)(?1)) do not
affect how the sub-pattern will be processed.</p>

<p style="margin-left:11%;">&quot;(?&amp;NAME)&quot;</p>

<p style="margin-left:17%;">Recurse to a named subpattern.
Identical to <tt>&quot;(?PARNO)&quot;</tt> except that the
parenthesis to recurse to is determined by name. If multiple
parentheses have the same name, then it recurses to the
leftmost.</p>

<p style="margin-left:17%; margin-top: 1em">It is an error
to refer to a name that is not declared somewhere in the
pattern.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines the pattern <tt>&quot;(?P&gt;NAME)&quot;</tt> may be
used instead of <tt>&quot;(?&amp;NAME)&quot;</tt>.</p>


<p style="margin-left:11%;">&quot;(?(condition)yes&minus;pattern|no&minus;pattern)&quot;
<br>
&quot;(?(condition)yes&minus;pattern)&quot;</p>

<p style="margin-left:17%;">Conditional expression. Matches
<tt>&quot;yes&minus;pattern&quot;</tt> if
<tt>&quot;condition&quot;</tt> yields a true value, matches
<tt>&quot;no&minus;pattern&quot;</tt> otherwise. A missing
pattern always matches.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;(condition)&quot;</tt>
should be either an integer in parentheses (which is valid
if the corresponding pair of parentheses matched), a
look&minus;ahead/look&minus;behind/evaluate zero-width
assertion, a name in angle brackets or single quotes (which
is valid if a group with the given name matched), or the
special symbol (R) (true when evaluated inside of recursion
or eval). Additionally the R may be followed by a number,
(which will be true when evaluated when recursing inside of
the appropriate group), or by <tt>&amp;NAME</tt>, in which
case it will be true only when evaluated during recursion in
the named group.</p>

<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s a
summary of the possible predicates: <br>
(1) (2) ...</p>

<p style="margin-left:23%;">Checks if the numbered
capturing group has matched something.</p>

<p style="margin-left:17%;">(&lt; <small>NAME</small> &gt;)
(&rsquo; <small>NAME</small> &rsquo;)</p>

<p style="margin-left:23%;">Checks if a group with the
given name has matched something.</p>

<p style="margin-left:17%;">(?=...) (?!...) (?&lt;=...)
(?&lt;!...)</p>

<p style="margin-left:23%;">Checks whether the pattern
matches (or does not match, for the &rsquo;!&rsquo;
variants).</p>

<p style="margin-left:17%;">(?{ <small>CODE</small> })</p>

<p style="margin-left:23%;">Treats the return value of the
code block as the condition.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>(R)</p></td>
<td width="1%"></td>
<td width="77%">


<p>Checks if the expression has been evaluated inside of
recursion.</p> </td></tr>
</table>

<p style="margin-left:17%;">(R1) (R2) ...</p>

<p style="margin-left:23%;">Checks if the expression has
been evaluated while executing directly inside of the
n&minus;th capture group. This check is the regex equivalent
of</p>

<pre style="margin-left:23%; margin-top: 1em">  if ((caller(0))[3] eq 'subname') { ... }</pre>


<p style="margin-left:23%; margin-top: 1em">In other words,
it does not check the full recursion stack.</p>

<p style="margin-left:17%;">(R&amp;NAME)</p>

<p style="margin-left:23%;">Similar to
<tt>&quot;(R1)&quot;</tt>, this predicate checks to see if
we&rsquo;re executing directly inside of the leftmost group
with a given name (this is the same logic used by
<tt>&quot;(?&amp;NAME)&quot;</tt> to disambiguate). It does
not check the full stack, but only the name of the innermost
active recursion.</p>

<p style="margin-left:17%;">( <small>DEFINE</small> )</p>

<p style="margin-left:23%;">In this case, the yes-pattern
is never directly executed, and no no-pattern is allowed.
Similar in spirit to <tt>&quot;(?{0})&quot;</tt> but more
efficient. See below for details.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">    m{ ( \( )?
       [^()]+
       (?(1) \) )
     }x</pre>


<p style="margin-left:17%; margin-top: 1em">matches a chunk
of non-parentheses, possibly included in parentheses
themselves.</p>

<p style="margin-left:17%; margin-top: 1em">A special form
is the <tt>&quot;(DEFINE)&quot;</tt> predicate, which never
executes its yes-pattern directly, and does not allow a
no-pattern. This allows one to define subpatterns which will
be executed only by the recursion mechanism. This way, you
can define a set of regular expression rules that can be
bundled into any pattern you choose.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended that for this usage you put the
<small>DEFINE</small> block at the end of the pattern, and
that you name any subpatterns defined within it.</p>

<p style="margin-left:17%; margin-top: 1em">Also,
it&rsquo;s worth noting that patterns defined this way
probably will not be as efficient, as the optimiser is not
very clever about handling them.</p>

<p style="margin-left:17%; margin-top: 1em">An example of
how this might be used is as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">  /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
   (?(DEFINE)
     (?&lt;NAME_PAT&gt;....)
     (?&lt;ADRESS_PAT&gt;....)
   )/x</pre>


<p style="margin-left:17%; margin-top: 1em">Note that
capture groups matched inside of recursion are not
accessible after the recursion returns, so the extra layer
of capturing groups is necessary. Thus <tt>$+{NAME_PAT}</tt>
would not be defined even though <tt>$+{NAME}</tt> would
be.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, keep
in mind that subpatterns created inside a
<small>DEFINE</small> block count towards the absolute and
relative number of captures, so this:</p>

<pre style="margin-left:17%; margin-top: 1em">    my @captures = &quot;a&quot; =~ /(.)                  # First capture
                           (?(DEFINE)
                               (?&lt;EXAMPLE&gt; 1 )  # Second capture
                           )/x;
    say scalar @captures;</pre>


<p style="margin-left:17%; margin-top: 1em">Will output 2,
not 1. This is particularly important if you intend to
compile the definitions with the <tt>&quot;qr//&quot;</tt>
operator, and later interpolate them in another pattern.</p>

<p style="margin-left:11%;">&quot;(?&gt;pattern)&quot;</p>

<p style="margin-left:17%;">An &quot;independent&quot;
subexpression, one which matches the substring that a
<i>standalone</i> <tt>&quot;pattern&quot;</tt> would match
if anchored at the given position, and it matches <i>nothing
other than this substring</i>. This construct is useful for
optimizations of what would otherwise be &quot;eternal&quot;
matches, because it will not backtrack (see
&quot;Backtracking&quot;). It may also be useful in places
where the &quot;grab all you can, and do not give anything
back&quot; semantic is desirable.</p>

<p style="margin-left:17%; margin-top: 1em">For example:
<tt>&quot;^(?&gt;a*)ab&quot;</tt> will never match, since
<tt>&quot;(?&gt;a*)&quot;</tt> (anchored at the beginning of
string, as above) will match <i>all</i> characters
<tt>&quot;a&quot;</tt> at the beginning of string, leaving
no <tt>&quot;a&quot;</tt> for <tt>&quot;ab&quot;</tt> to
match. In contrast, <tt>&quot;a*ab&quot;</tt> will match the
same as <tt>&quot;a+b&quot;</tt>, since the match of the
subgroup <tt>&quot;a*&quot;</tt> is influenced by the
following group <tt>&quot;ab&quot;</tt> (see
&quot;Backtracking&quot;). In particular,
<tt>&quot;a*&quot;</tt> inside <tt>&quot;a*ab&quot;</tt>
will match fewer characters than a standalone
<tt>&quot;a*&quot;</tt>, since this makes the tail
match.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;(?&gt;pattern)&quot;</tt>
does not disable backtracking altogether once it has
matched. It is still possible to backtrack past the
construct, but not into it. So
<tt>&quot;((?&gt;a*)|(?&gt;b*))ar&quot;</tt> will still
match &quot;bar&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">An effect
similar to <tt>&quot;(?&gt;pattern)&quot;</tt> may be
achieved by writing
<tt>&quot;(?=(pattern))\g{&minus;1}&quot;</tt>. This matches
the same substring as a standalone <tt>&quot;a+&quot;</tt>,
and the following <tt>&quot;\g{&minus;1}&quot;</tt> eats the
matched string; it therefore makes a zero-length assertion
into an analogue of <tt>&quot;(?&gt;...)&quot;</tt>. (The
difference between these two constructs is that the second
one uses a capturing group, thus shifting ordinals of
backreferences in the rest of a regular expression.)</p>

<p style="margin-left:17%; margin-top: 1em">Consider this
pattern:</p>

<pre style="margin-left:17%; margin-top: 1em">    m{ \(
          (
            [^()]+           # x+
          |
            \( [^()]* \)
          )+
       \)
     }x</pre>


<p style="margin-left:17%; margin-top: 1em">That will
efficiently match a nonempty group with matching parentheses
two levels deep or less. However, if there is no such group,
it will take virtually forever on a long string.
That&rsquo;s because there are so many different ways to
split a long string into several substrings. This is what
<tt>&quot;(.+)+&quot;</tt> is doing, and
<tt>&quot;(.+)+&quot;</tt> is similar to a subpattern of the
above pattern. Consider how the pattern above detects
no-match on <tt>&quot;((()aaaaaaaaaaaaaaaaaa&quot;</tt> in
several seconds, but that each extra letter doubles this
time. This exponential performance will make it appear that
your program has hung. However, a tiny change to this
pattern</p>

<pre style="margin-left:17%; margin-top: 1em">    m{ \(
          (
            (?&gt; [^()]+ )        # change x+ above to (?&gt; x+ )
          |
            \( [^()]* \)
          )+
       \)
     }x</pre>


<p style="margin-left:17%; margin-top: 1em">which uses
<tt>&quot;(?&gt;...)&quot;</tt> matches exactly when the one
above does (verifying this yourself would be a productive
exercise), but finishes in a fourth the time when used on a
similar string with 1000000 <tt>&quot;a&quot;</tt>s. Be
aware, however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the <tt>&quot;use warnings&quot;</tt> pragma or
<b>&minus;w</b> switch saying it <tt>&quot;matches null
string many times in regex&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">On simple
groups, such as the pattern <tt>&quot;(?&gt; [^()]+
)&quot;</tt>, a comparable effect may be achieved by
negative look-ahead, as in <tt>&quot;[^()]+ (?! [^()]
)&quot;</tt>. This was only 4 times slower on a string with
1000000 <tt>&quot;a&quot;</tt>s.</p>

<p style="margin-left:17%; margin-top: 1em">The &quot;grab
all you can, and do not give anything back&quot; semantic is
desirable in many situations where on the first sight a
simple <tt>&quot;()*&quot;</tt> looks like the correct
solution. Suppose we parse text with comments being
delimited by <tt>&quot;#&quot;</tt> followed by some
optional (horizontal) whitespace. Contrary to its
appearance, <tt>&quot;#[ \t]*&quot;</tt> <i>is not</i> the
correct subexpression to match the comment delimiter,
because it may &quot;give up&quot; some whitespace if the
remainder of the pattern can be made to match that way. The
correct answer is either one of these:</p>

<pre style="margin-left:17%; margin-top: 1em">    (?&gt;#[ \t]*)
    #[ \t]*(?![ \t])</pre>


<p style="margin-left:17%; margin-top: 1em">For example, to
grab non-empty comments into <tt>$1</tt>, one should use
either one of these:</p>

<pre style="margin-left:17%; margin-top: 1em">    / (?&gt; \# [ \t]* ) (        .+ ) /x;
    /     \# [ \t]*   ( [^ \t] .* ) /x;</pre>


<p style="margin-left:17%; margin-top: 1em">Which one you
pick depends on which of these expressions better reflects
the above specification of comments.</p>

<p style="margin-left:17%; margin-top: 1em">In some
literature this construct is called &quot;atomic
matching&quot; or &quot;possessive matching&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Possessive
quantifiers are equivalent to putting the item they are
applied to inside of one of these constructs. The following
equivalences apply:</p>

<pre style="margin-left:17%; margin-top: 1em">    Quantifier Form     Bracketing Form
    &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;     &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
    PAT*+               (?&gt;PAT*)
    PAT++               (?&gt;PAT+)
    PAT?+               (?&gt;PAT?)
    PAT{min,max}+       (?&gt;PAT{min,max})</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Special
Backtracking Control Verbs <small><br>
WARNING:</small></b> These patterns are experimental and
subject to change or removal in a future version of Perl.
Their usage in production code should be noted to avoid
problems during upgrades.</p>

<p style="margin-left:11%; margin-top: 1em">These special
patterns are generally of the form
<tt>&quot;(*VERB:ARG)&quot;</tt>. Unless otherwise stated
the <small>ARG</small> argument is optional; in some cases,
it is forbidden.</p>

<p style="margin-left:11%; margin-top: 1em">Any pattern
containing a special backtracking verb that allows an
argument has the special behaviour that when executed it
sets the current package&rsquo;s <tt>$REGERROR</tt> and
<tt>$REGMARK</tt> variables. When doing so the following
rules apply:</p>

<p style="margin-left:11%; margin-top: 1em">On failure, the
<tt>$REGERROR</tt> variable will be set to the
<small>ARG</small> value of the verb pattern, if the verb
was involved in the failure of the match. If the
<small>ARG</small> part of the pattern was omitted, then
<tt>$REGERROR</tt> will be set to the name of the last
<tt>&quot;(*MARK:NAME)&quot;</tt> pattern executed, or to
<small>TRUE</small> if there was none. Also, the
<tt>$REGMARK</tt> variable will be set to
<small>FALSE</small> .</p>

<p style="margin-left:11%; margin-top: 1em">On a successful
match, the <tt>$REGERROR</tt> variable will be set to
<small>FALSE</small> , and the <tt>$REGMARK</tt> variable
will be set to the name of the last
<tt>&quot;(*MARK:NAME)&quot;</tt> pattern executed. See the
explanation for the <tt>&quot;(*MARK:NAME)&quot;</tt> verb
below for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
<tt>$REGERROR</tt> and <tt>$REGMARK</tt> are not magic
variables like <tt>$1</tt> and most other regex-related
variables. They are not local to a scope, nor readonly, but
instead are volatile package variables similar to
<tt>$AUTOLOAD</tt>. Use <tt>&quot;local&quot;</tt> to
localize changes to them to a specific scope if
necessary.</p>

<p style="margin-left:11%; margin-top: 1em">If a pattern
does not contain a special backtracking verb that allows an
argument, then <tt>$REGERROR</tt> and <tt>$REGMARK</tt> are
not touched at all. <br>
Verbs that take an argument</p>

<p style="margin-left:15%;">&quot;(*PRUNE)&quot;
&quot;(*PRUNE:NAME)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern prunes
the backtracking tree at the current point when backtracked
into on failure. Consider the pattern <tt>&quot;A (*PRUNE)
B&quot;</tt>, where A and B are complex patterns. Until the
<tt>&quot;(*PRUNE)&quot;</tt> verb is reached, A may
backtrack as necessary to match. Once it is reached,
matching continues in B, which may also backtrack as
necessary; however, should B not match, then no further
backtracking will take place, and the pattern will fail
outright at the current starting position.</p>

<p style="margin-left:22%; margin-top: 1em">The following
example counts all the possible matching strings in a
pattern (without actually matching any of them).</p>

<pre style="margin-left:22%; margin-top: 1em">    'aaab' =~ /a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    print &quot;Count=$count\n&quot;;</pre>


<p style="margin-left:22%; margin-top: 1em">which
produces:</p>

<pre style="margin-left:22%; margin-top: 1em">    aaab
    aaa
    aa
    a
    aab
    aa
    a
    ab
    a
    Count=9</pre>


<p style="margin-left:22%; margin-top: 1em">If we add a
<tt>&quot;(*PRUNE)&quot;</tt> before the count like the
following</p>

<pre style="margin-left:22%; margin-top: 1em">    'aaab' =~ /a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    print &quot;Count=$count\n&quot;;</pre>


<p style="margin-left:22%; margin-top: 1em">we prevent
backtracking and find the count of the longest matching
string at each matching starting point like so:</p>

<pre style="margin-left:22%; margin-top: 1em">    aaab
    aab
    ab
    Count=3</pre>


<p style="margin-left:22%; margin-top: 1em">Any number of
<tt>&quot;(*PRUNE)&quot;</tt> assertions may be used in a
pattern.</p>

<p style="margin-left:22%; margin-top: 1em">See also
<tt>&quot;(?&gt;pattern)&quot;</tt> and possessive
quantifiers for other ways to control backtracking. In some
cases, the use of <tt>&quot;(*PRUNE)&quot;</tt> can be
replaced with a <tt>&quot;(?&gt;pattern)&quot;</tt> with no
functional difference; however,
<tt>&quot;(*PRUNE)&quot;</tt> can be used to handle cases
that cannot be expressed using a
<tt>&quot;(?&gt;pattern)&quot;</tt> alone.</p>

<p style="margin-left:15%;">&quot;(*SKIP)&quot;
&quot;(*SKIP:NAME)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern is
similar to <tt>&quot;(*PRUNE)&quot;</tt>, except that on
failure it also signifies that whatever text that was
matched leading up to the <tt>&quot;(*SKIP)&quot;</tt>
pattern being executed cannot be part of <i>any</i> match of
this pattern. This effectively means that the regex engine
&quot;skips&quot; forward to this position on failure and
tries to match again, (assuming that there is sufficient
room to match).</p>

<p style="margin-left:22%; margin-top: 1em">The name of the
<tt>&quot;(*SKIP:NAME)&quot;</tt> pattern has special
significance. If a <tt>&quot;(*MARK:NAME)&quot;</tt> was
encountered while matching, then it is that position which
is used as the &quot;skip point&quot;. If no
<tt>&quot;(*MARK)&quot;</tt> of that name was encountered,
then the <tt>&quot;(*SKIP)&quot;</tt> operator has no
effect. When used without a name the &quot;skip point&quot;
is where the match point was when executing the (*SKIP)
pattern.</p>

<p style="margin-left:22%; margin-top: 1em">Compare the
following to the examples in <tt>&quot;(*PRUNE)&quot;</tt>;
note the string is twice as long:</p>

<pre style="margin-left:22%; margin-top: 1em"> 'aaabaaab' =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
 print &quot;Count=$count\n&quot;;</pre>


<p style="margin-left:22%; margin-top: 1em">outputs</p>

<pre style="margin-left:22%; margin-top: 1em">    aaab
    aaab
    Count=2</pre>


<p style="margin-left:22%; margin-top: 1em">Once the
&rsquo;aaab&rsquo; at the start of the string has matched,
and the <tt>&quot;(*SKIP)&quot;</tt> executed, the next
starting point will be where the cursor was when the
<tt>&quot;(*SKIP)&quot;</tt> was executed.</p>

<p style="margin-left:15%;">&quot;(*MARK:NAME)&quot;
&quot;(*:NAME)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern can be
used to mark the point reached in a string when a certain
part of the pattern has been successfully matched. This mark
may be given a name. A later <tt>&quot;(*SKIP)&quot;</tt>
pattern will then skip forward to that point if backtracked
into on failure. Any number of <tt>&quot;(*MARK)&quot;</tt>
patterns are allowed, and the <small>NAME</small> portion
may be duplicated.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
interacting with the <tt>&quot;(*SKIP)&quot;</tt> pattern,
<tt>&quot;(*MARK:NAME)&quot;</tt> can be used to
&quot;label&quot; a pattern branch, so that after matching,
the program can determine which branches of the pattern were
involved in the match.</p>

<p style="margin-left:22%; margin-top: 1em">When a match is
successful, the <tt>$REGMARK</tt> variable will be set to
the name of the most recently executed
<tt>&quot;(*MARK:NAME)&quot;</tt> that was involved in the
match.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
used to determine which branch of a pattern was matched
without using a separate capture group for each branch,
which in turn can result in a performance improvement, as
perl cannot optimize <tt>&quot;/(?:(x)|(y)|(z))/&quot;</tt>
as efficiently as something like
<tt>&quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;</tt>.</p>

<p style="margin-left:22%; margin-top: 1em">When a match
has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the
<tt>$REGERROR</tt> variable will be set to the name of the
most recently executed
<tt>&quot;(*MARK:NAME)&quot;</tt>.</p>

<p style="margin-left:22%; margin-top: 1em">See
&quot;(*SKIP)&quot; for more details.</p>

<p style="margin-left:22%; margin-top: 1em">As a shortcut
<tt>&quot;(*MARK:NAME)&quot;</tt> can be written
<tt>&quot;(*:NAME)&quot;</tt>.</p>

<p style="margin-left:15%;">&quot;(*THEN)&quot;
&quot;(*THEN:NAME)&quot;</p>

<p style="margin-left:22%;">This is similar to the
&quot;cut group&quot; operator <tt>&quot;::&quot;</tt> from
Perl 6. Like <tt>&quot;(*PRUNE)&quot;</tt>, this verb always
matches, and when backtracked into on failure, it causes the
regex engine to try the next alternation in the innermost
enclosing group (capturing or otherwise) that has
alternations. The two branches of a
<tt>&quot;(?(condition)yes&minus;pattern|no&minus;pattern)&quot;</tt>
do not count as an alternation, as far as
<tt>&quot;(*THEN)&quot;</tt> is concerned.</p>

<p style="margin-left:22%; margin-top: 1em">Its name comes
from the observation that this operation combined with the
alternation operator (<tt>&quot;|&quot;</tt>) can be used to
create what is essentially a pattern-based if/then/else
block:</p>

<pre style="margin-left:22%; margin-top: 1em">  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )</pre>


<p style="margin-left:22%; margin-top: 1em">Note that if
this operator is used and <small>NOT</small> inside of an
alternation then it acts exactly like the
<tt>&quot;(*PRUNE)&quot;</tt> operator.</p>

<pre style="margin-left:22%; margin-top: 1em">  / A (*PRUNE) B /</pre>


<p style="margin-left:22%; margin-top: 1em">is the same
as</p>

<pre style="margin-left:22%; margin-top: 1em">  / A (*THEN) B /</pre>


<p style="margin-left:22%; margin-top: 1em">but</p>

<pre style="margin-left:22%; margin-top: 1em">  / ( A (*THEN) B | C (*THEN) D ) /</pre>


<p style="margin-left:22%; margin-top: 1em">is not the same
as</p>

<pre style="margin-left:22%; margin-top: 1em">  / ( A (*PRUNE) B | C (*PRUNE) D ) /</pre>


<p style="margin-left:22%; margin-top: 1em">as after
matching the A but failing on the B the
<tt>&quot;(*THEN)&quot;</tt> verb will backtrack and try C;
but the <tt>&quot;(*PRUNE)&quot;</tt> verb will simply
fail.</p>

<p style="margin-left:11%;">Verbs without an argument</p>

<p style="margin-left:15%;">&quot;(*COMMIT)&quot;</p>

<p style="margin-left:22%;">This is the Perl 6 &quot;commit
pattern&quot; <tt>&quot;&lt;commit&gt;&quot;</tt> or
<tt>&quot;:::&quot;</tt>. It&rsquo;s a zero-width pattern
similar to <tt>&quot;(*SKIP)&quot;</tt>, except that when
backtracked into on failure it causes the match to fail
outright. No further attempts to find a valid match by
advancing the start pointer will occur again. For
example,</p>

<pre style="margin-left:22%; margin-top: 1em"> 'aaabaaab' =~ /a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
 print &quot;Count=$count\n&quot;;</pre>


<p style="margin-left:22%; margin-top: 1em">outputs</p>

<pre style="margin-left:22%; margin-top: 1em">    aaab
    Count=1</pre>


<p style="margin-left:22%; margin-top: 1em">In other words,
once the <tt>&quot;(*COMMIT)&quot;</tt> has been entered,
and if the pattern does not match, the regex engine will not
try any further matching on the rest of the string.</p>

<p style="margin-left:15%;">&quot;(*FAIL)&quot;
&quot;(*F)&quot;</p>

<p style="margin-left:22%;">This pattern matches nothing
and always fails. It can be used to force the engine to
backtrack. It is equivalent to <tt>&quot;(?!)&quot;</tt>,
but easier to read. In fact, <tt>&quot;(?!)&quot;</tt> gets
optimised into <tt>&quot;(*FAIL)&quot;</tt> internally.</p>

<p style="margin-left:22%; margin-top: 1em">It is probably
useful only when combined with <tt>&quot;(?{})&quot;</tt> or
<tt>&quot;(??{})&quot;</tt>.</p>

<p style="margin-left:15%;">&quot;(*ACCEPT)&quot;</p>

<p style="margin-left:22%;"><b><small>WARNING:</small></b>
This feature is highly experimental. It is not recommended
for production code.</p>

<p style="margin-left:22%; margin-top: 1em">This pattern
matches nothing and causes the end of successful matching at
the point at which the <tt>&quot;(*ACCEPT)&quot;</tt>
pattern was encountered, regardless of whether there is
actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern
dynamically generated via <tt>&quot;(??{})&quot;</tt>, only
the innermost pattern is ended immediately.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<tt>&quot;(*ACCEPT)&quot;</tt> is inside of capturing groups
then the groups are marked as ended at the point at which
the <tt>&quot;(*ACCEPT)&quot;</tt> was encountered. For
instance:</p>

<pre style="margin-left:22%; margin-top: 1em">  'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;</pre>


<p style="margin-left:22%; margin-top: 1em">will match, and
<tt>$1</tt> will be <tt>&quot;AB&quot;</tt> and <tt>$2</tt>
will be <tt>&quot;B&quot;</tt>, <tt>$3</tt> will not be set.
If another branch in the inner parentheses was matched, such
as in the string &rsquo; <small>ACDE</small> &rsquo;, then
the <tt>&quot;D&quot;</tt> and <tt>&quot;E&quot;</tt> would
have to be matched as well.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Backtracking</b>
<small><br>
NOTE:</small> This section presents an abstract
approximation of regular expression behavior. For a more
rigorous (and complicated) view of the rules involved in
selecting a match among possible alternatives, see
&quot;Combining <small>RE</small> Pieces&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">A fundamental
feature of regular expression matching involves the notion
called <i>backtracking</i>, which is currently used (when
needed) by all regular non-possessive expression
quantifiers, namely <tt>&quot;*&quot;</tt>,
<tt>&quot;*?&quot;</tt>, <tt>&quot;+&quot;</tt>,
<tt>&quot;+?&quot;</tt>, <tt>&quot;{n,m}&quot;</tt>, and
<tt>&quot;{n,m}?&quot;</tt>. Backtracking is often optimized
internally, but the general principle outlined here is
valid.</p>

<p style="margin-left:11%; margin-top: 1em">For a regular
expression to match, the <i>entire</i> regular expression
must match, not just part of it. So if the beginning of a
pattern containing a quantifier succeeds in a way that
causes later parts in the pattern to fail, the matching
engine backs up and recalculates the beginning
part--that&rsquo;s why it&rsquo;s called backtracking.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of backtracking: Let&rsquo;s say you want to find
the word following &quot;foo&quot; in the string &quot;Food
is on the foo table.&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = &quot;Food is on the foo table.&quot;;
    if ( /\b(foo)\s+(\w+)/i ) {
        print &quot;$2 follows $1.\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">When the match
runs, the first part of the regular expression
(<tt>&quot;\b(foo)&quot;</tt>) finds a possible match right
at the beginning of the string, and loads up <tt>$1</tt>
with &quot;Foo&quot;. However, as soon as the matching
engine sees that there&rsquo;s no whitespace following the
&quot;Foo&quot; that it had saved in <tt>$1</tt>, it
realizes its mistake and starts over again one character
after where it had the tentative match. This time it goes
all the way until the next occurrence of &quot;foo&quot;.
The complete regular expression matches this time, and you
get the expected output of &quot;table follows
foo.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes
minimal matching can help a lot. Imagine you&rsquo;d like to
match everything between &quot;foo&quot; and
&quot;bar&quot;. Initially, you write something like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ =  &quot;The food is under the bar in the barn.&quot;;
    if ( /foo(.*)bar/ ) {
        print &quot;got &lt;$1&gt;\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Which perhaps
unexpectedly yields:</p>

<pre style="margin-left:11%; margin-top: 1em">  got &lt;d is under the bar in the &gt;</pre>


<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
because <tt>&quot;.*&quot;</tt> was greedy, so you get
everything between the <i>first</i> &quot;foo&quot; and the
<i>last</i> &quot;bar&quot;. Here it&rsquo;s more effective
to use minimal matching to make sure you get the text
between a &quot;foo&quot; and the first &quot;bar&quot;
thereafter.</p>

<pre style="margin-left:11%; margin-top: 1em">    if ( /foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;\n&quot; }
  got &lt;d is under the &gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
another example. Let&rsquo;s say you&rsquo;d like to match a
number at the end of a string, and you also want to keep the
preceding part of the match. So you write this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = &quot;I have 2 numbers: 53147&quot;;
    if ( /(.*)(\d*)/ ) {                                # Wrong!
        print &quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">That
won&rsquo;t work at all, because <tt>&quot;.*&quot;</tt> was
greedy and gobbled up the whole string. As
<tt>&quot;\d*&quot;</tt> can match on an empty string the
complete regular expression matched successfully.</p>

<pre style="margin-left:11%; margin-top: 1em">    Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.</pre>


<p style="margin-left:11%; margin-top: 1em">Here are some
variants, most of which don&rsquo;t work:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = &quot;I have 2 numbers: 53147&quot;;
    @pats = qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    };
    for $pat (@pats) {
        printf &quot;%&minus;12s &quot;, $pat;
        if ( /$pat/ ) {
            print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;
        } else {
            print &quot;FAIL\n&quot;;
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">That will print
out:</p>

<pre style="margin-left:11%; margin-top: 1em">    (.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;
    (.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d*)   &lt;&gt; &lt;&gt;
    (.*?)(\d+)   &lt;I have &gt; &lt;2&gt;
    (.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">As you see,
this can be a bit tricky. It&rsquo;s important to realize
that a regular expression is merely a set of assertions that
gives a definition of success. There may be 0, 1, or several
different ways that the definition might succeed against a
particular string. And if there are multiple ways it might
succeed, you need to understand backtracking to know which
variety of success you will achieve.</p>

<p style="margin-left:11%; margin-top: 1em">When using
look-ahead assertions and negations, this can all get even
trickier. Imagine you&rsquo;d like to find a sequence of
non-digits not followed by &quot;123&quot;. You might try to
write that as</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = &quot;ABC123&quot;;
    if ( /^\D*(?!123)/ ) {                # Wrong!
        print &quot;Yup, no 123 in $_\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">But that
isn&rsquo;t going to match; at least, not the way
you&rsquo;re hoping. It claims that there is no 123 in the
string. Here&rsquo;s a clearer picture of why that pattern
matches, contrary to popular expectations:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = 'ABC123';
    $y = 'ABC445';
    print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/;
    print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/;
    print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/;
    print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/;</pre>


<p style="margin-left:11%; margin-top: 1em">This prints</p>

<pre style="margin-left:11%; margin-top: 1em">    2: got ABC
    3: got AB
    4: got ABC</pre>


<p style="margin-left:11%; margin-top: 1em">You might have
expected test 3 to fail because it seems to a more general
purpose version of test 1. The important difference between
them is that test 3 contains a quantifier
(<tt>&quot;\D*&quot;</tt>) and so can use backtracking,
whereas test 1 will not. What&rsquo;s happening is that
you&rsquo;ve asked &quot;Is it true that at the start of
<tt>$x</tt>, following 0 or more non-digits, you have
something that&rsquo;s not 123?&quot; If the pattern matcher
had let <tt>&quot;\D*&quot;</tt> expand to &quot;
<small>ABC</small> &quot;, this would have caused the whole
pattern to fail.</p>

<p style="margin-left:11%; margin-top: 1em">The search
engine will initially match <tt>&quot;\D*&quot;</tt> with
&quot; <small>ABC</small> &quot;. Then it will try to match
<tt>&quot;(?!123)&quot;</tt> with &quot;123&quot;, which
fails. But because a quantifier (<tt>&quot;\D*&quot;</tt>)
has been used in the regular expression, the search engine
can backtrack and retry the match differently in the hope of
matching the complete regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">The pattern
really, <i>really</i> wants to succeed, so it uses the
standard pattern back-off-and-retry and lets
<tt>&quot;\D*&quot;</tt> expand to just &quot;
<small>AB</small> &quot; this time. Now there&rsquo;s indeed
something following &quot; <small>AB</small> &quot; that is
not &quot;123&quot;. It&rsquo;s &quot;C123&quot;, which
suffices.</p>

<p style="margin-left:11%; margin-top: 1em">We can deal
with this by using both an assertion and a negation.
We&rsquo;ll say that the first part in <tt>$1</tt> must be
followed both by a digit and by something that&rsquo;s not
&quot;123&quot;. Remember that the look-aheads are
zero-width expressions--they only look, but don&rsquo;t
consume any of the string in their match. So rewriting this
way produces what you&rsquo;d expect; that is, case 5 will
fail, but case 6 succeeds:</p>

<pre style="margin-left:11%; margin-top: 1em">    print &quot;5: got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/;
    print &quot;6: got $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/;
    6: got ABC</pre>


<p style="margin-left:11%; margin-top: 1em">In other words,
the two zero-width assertions next to each other work as
though they&rsquo;re ANDed together, just as you&rsquo;d use
any built-in assertions: <tt>&quot;/^$/&quot;</tt> matches
only if you&rsquo;re at the beginning of the line
<small>AND</small> the end of the line simultaneously. The
deeper underlying truth is that juxtaposition in regular
expressions always means <small>AND</small> , except when
you write an explicit <small>OR</small> using the vertical
bar. <tt>&quot;/ab/&quot;</tt> means match &quot;a&quot;
<small>AND</small> (then) match &quot;b&quot;, although the
attempted matches are made at different positions because
&quot;a&quot; is not a zero-width assertion, but a one-width
assertion.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of
possible ways they can use backtracking to try for a match.
For example, without internal optimizations done by the
regular expression engine, this will take a painfully long
time to run:</p>

<pre style="margin-left:11%; margin-top: 1em">    'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/</pre>


<p style="margin-left:11%; margin-top: 1em">And if you used
<tt>&quot;*&quot;</tt>&rsquo;s in the internal groups
instead of limiting them to 0 through 5 matches, then it
would take forever--or until you ran out of stack space.
Moreover, these internal optimizations are not always
applicable. For example, if you put
<tt>&quot;{0,5}&quot;</tt> instead of <tt>&quot;*&quot;</tt>
on the external group, no current optimization is
applicable, and the match takes a long time to finish.</p>

<p style="margin-left:11%; margin-top: 1em">A powerful tool
for optimizing such beasts is what is known as an
&quot;independent group&quot;, which does not backtrack (see
&quot;<tt>&quot;(?&gt;pattern)&quot;</tt>&quot;). Note also
that zero-length look&minus;ahead/look&minus;behind
assertions will not backtrack to make the tail match, since
they are in &quot;logical&quot; context: only whether they
match is considered relevant. For an example where
side-effects of look-ahead <i>might</i> have influenced the
following match, see
&quot;<tt>&quot;(?&gt;pattern)&quot;</tt>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Version 8
Regular Expressions</b> <br>
In case you&rsquo;re not familiar with the
&quot;regular&quot; Version 8 regex routines, here are the
pattern-matching rules not described above.</p>

<p style="margin-left:11%; margin-top: 1em">Any single
character matches itself, unless it is a
<i>metacharacter</i> with a special meaning described here
or above. You can cause characters that normally function as
metacharacters to be interpreted literally by prefixing them
with a &quot;\&quot; (e.g., &quot;\.&quot; matches a
&quot;.&quot;, not any character; &quot;\\&quot; matches a
&quot;\&quot;). This escape mechanism is also required for
the character used as the pattern delimiter.</p>

<p style="margin-left:11%; margin-top: 1em">A series of
characters matches that series of characters in the target
string, so the pattern <tt>&quot;blurfl&quot;</tt> would
match &quot;blurfl&quot; in the target string.</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
a character class, by enclosing a list of characters in
<tt>&quot;[]&quot;</tt>, which will match any character from
the list. If the first character after the &quot;[&quot; is
&quot;^&quot;, the class matches any character not in the
list. Within a list, the &quot;&minus;&quot; character
specifies a range, so that <tt>&quot;a&minus;z&quot;</tt>
represents all characters between &quot;a&quot; and
&quot;z&quot;, inclusive. If you want either
&quot;&minus;&quot; or &quot;]&quot; itself to be a member
of a class, put it at the start of the list (possibly after
a &quot;^&quot;), or escape it with a backslash.
&quot;&minus;&quot; is also taken literally when it is at
the end of the list, just before the closing &quot;]&quot;.
(The following all specify the same class of three
characters: <tt>&quot;[&minus;az]&quot;</tt>,
<tt>&quot;[az&minus;]&quot;</tt>, and
<tt>&quot;[a\&minus;z]&quot;</tt>. All are different from
<tt>&quot;[a&minus;z]&quot;</tt>, which specifies a class
containing twenty-six characters, even on EBCDIC-based
character sets.) Also, if you try to use the character
classes <tt>&quot;\w&quot;</tt>, <tt>&quot;\W&quot;</tt>,
<tt>&quot;\s&quot;</tt>, <tt>&quot;\S&quot;</tt>,
<tt>&quot;\d&quot;</tt>, or <tt>&quot;\D&quot;</tt> as
endpoints of a range, the &quot;&minus;&quot; is understood
literally.</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
the whole range idea is rather unportable between character
sets--and even within character sets they may cause results
you probably didn&rsquo;t expect. A sound principle is to
use only ranges that begin from and end at either
alphabetics of equal case ([a&minus;e], [A&minus;E]), or
digits ([0&minus;9]). Anything else is unsafe. If in doubt,
spell out the character sets in full.</p>

<p style="margin-left:11%; margin-top: 1em">Characters may
be specified using a metacharacter syntax much like that
used in C: &quot;\n&quot; matches a newline, &quot;\t&quot;
a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a
form feed, etc. More generally, \<i>nnn</i>, where
<i>nnn</i> is a string of three octal digits, matches the
character whose coded character set value is <i>nnn</i>.
Similarly, \x<i>nn</i>, where <i>nn</i> are hexadecimal
digits, matches the character whose ordinal is <i>nn</i>.
The expression \c<i>x</i> matches the character
control&minus;<i>x</i>. Finally, the &quot;.&quot;
metacharacter matches any character except &quot;\n&quot;
(unless you use <tt>&quot;/s&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
a series of alternatives for a pattern using &quot;|&quot;
to separate them, so that <tt>&quot;fee|fie|foe&quot;</tt>
will match any of &quot;fee&quot;, &quot;fie&quot;, or
&quot;foe&quot; in the target string (as would
<tt>&quot;f(e|i|o)e&quot;</tt>). The first alternative
includes everything from the last pattern delimiter
(&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of
the pattern) up to the first &quot;|&quot;, and the last
alternative contains everything from the last &quot;|&quot;
to the next closing pattern delimiter. That&rsquo;s why
it&rsquo;s common practice to include alternatives in
parentheses: to minimize confusion about where they start
and end.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatives
are tried from left to right, so the first alternative found
for which the entire expression matches, is the one that is
chosen. This means that alternatives are not necessarily
greedy. For example: when matching
<tt>&quot;foo|foot&quot;</tt> against &quot;barefoot&quot;,
only the &quot;foo&quot; part will match, as that is the
first alternative tried, and it successfully matches the
target string. (This might not seem important, but it is
important when you are capturing matched text using
parentheses.)</p>

<p style="margin-left:11%; margin-top: 1em">Also remember
that &quot;|&quot; is interpreted as a literal within square
brackets, so if you write <tt>&quot;[fee|fie|foe]&quot;</tt>
you&rsquo;re really only matching
<tt>&quot;[feio|]&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Within a
pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to
the <i>n</i>th subpattern later in the pattern using the
metacharacter \<i>n</i> or \g<i>n</i>. Subpatterns are
numbered based on the left to right order of their opening
parenthesis. A backreference matches whatever actually
matched the subpattern in the string being examined, not the
rules for that subpattern. Therefore,
<tt>&quot;(0|0x)\d*\s\g1\d*&quot;</tt> will match
&quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;,
because subpattern 1 matched &quot;0x&quot;, even though the
rule <tt>&quot;0|0x&quot;</tt> could potentially match the
leading 0 in the second number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Warning on
\1 Instead of $1</b> <br>
Some people get too used to writing things like:</p>

<pre style="margin-left:11%; margin-top: 1em">    $pattern =~ s/(\W)/\\\1/g;</pre>


<p style="margin-left:11%; margin-top: 1em">This is
grandfathered (for \1 to \9) for the <small>RHS</small> of a
substitute to avoid shocking the <b>sed</b> addicts, but
it&rsquo;s a dirty habit to get into. That&rsquo;s because
in PerlThink, the righthand side of an
<tt>&quot;s///&quot;</tt> is a double-quoted string.
<tt>&quot;\1&quot;</tt> in the usual double-quoted string
means a control-A. The customary Unix meaning of
<tt>&quot;\1&quot;</tt> is kludged in for
<tt>&quot;s///&quot;</tt>. However, if you get into the
habit of doing that, you get yourself into trouble if you
then add an <tt>&quot;/e&quot;</tt> modifier.</p>

<pre style="margin-left:11%; margin-top: 1em">    s/(\d+)/ \1 + 1 /eg;            # causes warning under &minus;w</pre>


<p style="margin-left:11%; margin-top: 1em">Or if you try
to do</p>

<pre style="margin-left:11%; margin-top: 1em">    s/(\d+)/\1000/;</pre>


<p style="margin-left:11%; margin-top: 1em">You can&rsquo;t
disambiguate that by saying <tt>&quot;\{1}000&quot;</tt>,
whereas you can fix it with <tt>&quot;${1}000&quot;</tt>.
The operation of interpolation should not be confused with
the operation of matching a backreference. Certainly they
mean two different things on the <i>left</i> side of the
<tt>&quot;s///&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Repeated
Patterns Matching a Zero-length Substring <small><br>
WARNING</small></b> : Difficult material (and prose) ahead.
This section needs a rewrite.</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expressions provide a terse and powerful programming
language. As with most other power tools, power comes
together with the ability to wreak havoc.</p>

<p style="margin-left:11%; margin-top: 1em">A common abuse
of this power stems from the ability to make infinite loops
using regular expressions, with something as innocuous
as:</p>

<pre style="margin-left:11%; margin-top: 1em">    'foo' =~ m{ ( o? )* }x;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;o?&quot;</tt> matches at the beginning of
<tt>'foo'</tt>, and since the position in the string is not
moved by the match, <tt>&quot;o?&quot;</tt> would match
again and again because of the <tt>&quot;*&quot;</tt>
quantifier. Another common way to create a similar cycle is
with the looping modifier <tt>&quot;//g&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    @matches = ( 'foo' =~ m{ o? }xg );</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:11%; margin-top: 1em">    print &quot;match: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o? }xg;</pre>


<p style="margin-left:11%; margin-top: 1em">or the loop
implied by <i>split()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">However, long
experience has shown that many programming tasks may be
significantly simplified by using repeated subexpressions
that may match zero-length substrings. Here&rsquo;s a simple
example being:</p>

<pre style="margin-left:11%; margin-top: 1em">    @chars = split //, $string;           # // is not magic in split
    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /</pre>


<p style="margin-left:11%; margin-top: 1em">Thus Perl
allows such constructs, by <i>forcefully breaking the
infinite loop</i>. The rules for this are different for
lower-level loops given by the greedy quantifiers
<tt>&quot;*+{}&quot;</tt>, and for higher-level ones like
the <tt>&quot;/g&quot;</tt> modifier or <i>split()</i>
operator.</p>

<p style="margin-left:11%; margin-top: 1em">The lower-level
loops are <i>interrupted</i> (that is, the loop is broken)
when Perl detects that a repeated expression matched a
zero-length substring. Thus</p>

<pre style="margin-left:11%; margin-top: 1em">   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;</pre>


<p style="margin-left:11%; margin-top: 1em">is made
equivalent to</p>

<pre style="margin-left:11%; margin-top: 1em">   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;</pre>


<p style="margin-left:11%; margin-top: 1em">For example,
this program</p>

<pre style="margin-left:11%; margin-top: 1em">   #!perl &minus;l
   &quot;aaaaab&quot; =~ /
     (?:
        a                 # non&minus;zero
        |                 # or
       (?{print &quot;hello&quot;}) # print hello whenever this
                          #    branch is tried
       (?=(b))            # zero&minus;width assertion
     )*  # any number of times
    /x;
   print $&amp;;
   print $1;</pre>


<p style="margin-left:11%; margin-top: 1em">prints</p>

<pre style="margin-left:11%; margin-top: 1em">   hello
   aaaaa
   b</pre>


<p style="margin-left:11%; margin-top: 1em">Notice that
&quot;hello&quot; is only printed once, as when Perl sees
that the sixth iteration of the outermost
<tt>&quot;(?:)*&quot;</tt> matches a zero-length string, it
stops the <tt>&quot;*&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
higher-level loops preserve an additional state between
iterations: whether the last match was zero-length. To break
the loop, the following match after a zero-length match is
prohibited to have a length of zero. This prohibition
interacts with backtracking (see &quot;Backtracking&quot;),
and so the <i>second best</i> match is chosen if the
<i>best</i> match is of zero length.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = 'bar';
    s/\w??/&lt;$&amp;&gt;/g;</pre>


<p style="margin-left:11%; margin-top: 1em">results in
<tt>&quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;</tt>.
At each position of the string the best match given by
non-greedy <tt>&quot;??&quot;</tt> is the zero-length match,
and the <i>second best</i> match is what is matched by
<tt>&quot;\w&quot;</tt>. Thus zero-length matches alternate
with one-character-long matches.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, for
repeated <tt>&quot;m/()/g&quot;</tt> the second-best match
is the match at the position one notch further in the
string.</p>

<p style="margin-left:11%; margin-top: 1em">The additional
state of being <i>matched with zero-length</i> is associated
with the matched string, and is reset by each assignment to
<i>pos()</i>. Zero-length matches at the end of the previous
match are ignored during <tt>&quot;split&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Combining
<small>RE</small> Pieces</b> <br>
Each of the elementary pieces of regular expressions which
were described before (such as <tt>&quot;ab&quot;</tt> or
<tt>&quot;\Z&quot;</tt>) could match at most one substring
at the given position of the input string. However, in a
typical regular expression these elementary pieces are
combined into more complicated patterns using combining
operators <tt>&quot;ST&quot;</tt>, <tt>&quot;S|T&quot;</tt>,
<tt>&quot;S*&quot;</tt> etc. (in these examples
<tt>&quot;S&quot;</tt> and <tt>&quot;T&quot;</tt> are
regular subexpressions).</p>

<p style="margin-left:11%; margin-top: 1em">Such
combinations can include alternatives, leading to a problem
of choice: if we match a regular expression
<tt>&quot;a|ab&quot;</tt> against <tt>&quot;abc&quot;</tt>,
will it match substring <tt>&quot;a&quot;</tt> or
<tt>&quot;ab&quot;</tt>? One way to describe which substring
is actually matched is the concept of backtracking (see
&quot;Backtracking&quot;). However, this description is too
low-level and makes you think in terms of a particular
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Another
description starts with notions of
&quot;better&quot;/&quot;worse&quot;. All the substrings
which may be matched by the given regular expression can be
sorted from the &quot;best&quot; match to the
&quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen. This substitutes the question of
&quot;what is chosen?&quot; by the question of &quot;which
matches are better, and which are worse?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Again, for
elementary pieces there is no such question, since at most
one match at a given position is possible. This section
describes the notion of better/worse for combining
operators. In the description below <tt>&quot;S&quot;</tt>
and <tt>&quot;T&quot;</tt> are regular subexpressions. <br>
&quot;ST&quot;</p>

<p style="margin-left:17%;">Consider two possible matches,
<tt>&quot;AB&quot;</tt> and <tt>&quot;A'B'&quot;</tt>,
<tt>&quot;A&quot;</tt> and <tt>&quot;A'&quot;</tt> are
substrings which can be matched by <tt>&quot;S&quot;</tt>,
<tt>&quot;B&quot;</tt> and <tt>&quot;B'&quot;</tt> are
substrings which can be matched by
<tt>&quot;T&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;A&quot;</tt> is a better match for
<tt>&quot;S&quot;</tt> than <tt>&quot;A'&quot;</tt>,
<tt>&quot;AB&quot;</tt> is a better match than
<tt>&quot;A'B'&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;A&quot;</tt> and <tt>&quot;A'&quot;</tt> coincide:
<tt>&quot;AB&quot;</tt> is a better match than
<tt>&quot;AB'&quot;</tt> if <tt>&quot;B&quot;</tt> is a
better match for <tt>&quot;T&quot;</tt> than
<tt>&quot;B'&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;S|T&quot;</p>

<p style="margin-left:17%;">When <tt>&quot;S&quot;</tt> can
match, it is a better match than when only
<tt>&quot;T&quot;</tt> can match.</p>

<p style="margin-left:17%; margin-top: 1em">Ordering of two
matches for <tt>&quot;S&quot;</tt> is the same as for
<tt>&quot;S&quot;</tt>. Similar for two matches for
<tt>&quot;T&quot;</tt>.</p>


<p style="margin-left:11%;">&quot;S{REPEAT_COUNT}&quot;</p>

<p style="margin-left:17%;">Matches as
<tt>&quot;SSS...S&quot;</tt> (repeated as many times as
necessary).</p>

<p style="margin-left:11%;">&quot;S{min,max}&quot;</p>

<p style="margin-left:17%;">Matches as
<tt>&quot;S{max}|S{max&minus;1}|...|S{min+1}|S{min}&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;S{min,max}?&quot;</p>

<p style="margin-left:17%;">Matches as
<tt>&quot;S{min}|S{min+1}|...|S{max&minus;1}|S{max}&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;S?&quot;, &quot;S*&quot;,
&quot;S+&quot;</p>

<p style="margin-left:17%;">Same as
<tt>&quot;S{0,1}&quot;</tt>,
<tt>&quot;S{0,BIG_NUMBER}&quot;</tt>,
<tt>&quot;S{1,BIG_NUMBER}&quot;</tt> respectively.</p>

<p style="margin-left:11%;">&quot;S??&quot;,
&quot;S*?&quot;, &quot;S+?&quot;</p>

<p style="margin-left:17%;">Same as
<tt>&quot;S{0,1}?&quot;</tt>,
<tt>&quot;S{0,BIG_NUMBER}?&quot;</tt>,
<tt>&quot;S{1,BIG_NUMBER}?&quot;</tt> respectively.</p>

<p style="margin-left:11%;">&quot;(?&gt;S)&quot;</p>

<p style="margin-left:17%;">Matches the best match for
<tt>&quot;S&quot;</tt> and only that.</p>

<p style="margin-left:11%;">&quot;(?=S)&quot;,
&quot;(?&lt;=S)&quot;</p>

<p style="margin-left:17%;">Only the best match for
<tt>&quot;S&quot;</tt> is considered. (This is important
only if <tt>&quot;S&quot;</tt> has capturing parentheses,
and backreferences are used somewhere else in the whole
regular expression.)</p>

<p style="margin-left:11%;">&quot;(?!S)&quot;,
&quot;(?&lt;!S)&quot;</p>

<p style="margin-left:17%;">For this grouping operator
there is no need to describe the ordering, since only
whether or not <tt>&quot;S&quot;</tt> can match is
important.</p>

<p style="margin-left:11%;">&quot;(??{ EXPR })&quot;,
&quot;(?PARNO)&quot;</p>

<p style="margin-left:17%;">The ordering is the same as for
the regular expression which is the result of
<small>EXPR</small> , or the pattern contained by capture
group <small>PARNO</small> .</p>


<p style="margin-left:11%;">&quot;(?(condition)yes&minus;pattern|no&minus;pattern)&quot;</p>

<p style="margin-left:17%;">Recall that which of
<tt>&quot;yes&minus;pattern&quot;</tt> or
<tt>&quot;no&minus;pattern&quot;</tt> actually matches is
already determined. The ordering of the matches is the same
as for the chosen subexpression.</p>

<p style="margin-left:11%; margin-top: 1em">The above
recipes describe the ordering of matches <i>at a given
position</i>. One more rule is needed to understand how a
match is determined for the whole regular expression: a
match at an earlier position is always better than a match
at a later position.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating
Custom <small>RE</small> Engines</b> <br>
As of Perl 5.10.0, one can create custom regular expression
engines. This is not for the faint of heart, as they have to
plug in at the C level. See perlreapi for more details.</p>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, overloaded constants (see overload) provide a
simple way to extend the functionality of the
<small>RE</small> engine, by substituting one pattern for
another.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose that we
want to enable a new <small>RE</small> escape-sequence
<tt>&quot;\Y|&quot;</tt> which matches at a boundary between
whitespace characters and non-whitespace characters. Note
that <tt>&quot;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&quot;</tt>
matches exactly at these positions, so we want to have each
<tt>&quot;\Y|&quot;</tt> in the place of the more
complicated version. We can create a module
<tt>&quot;customre&quot;</tt> to do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    package customre;
    use overload;
    sub import {
      shift;
      die &quot;No argument to customre::import allowed&quot; if @_;
      overload::constant 'qr' =&gt; \&amp;convert;
    }
    sub invalid { die &quot;/$_[0]/: invalid escape '\\$_[1]'&quot;}
    # We must also take care of not escaping the legitimate \\Y|
    # sequence, hence the presence of '\\' in the conversion rules.
    my %rules = ( '\\' =&gt; '\\\\',
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );
    sub convert {
      my $re = shift;
      $re =~ s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex;
      return $re;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Now
<tt>&quot;use customre&quot;</tt> enables the new escape in
constant regular expressions, i.e., those without any
runtime variable interpolations. As documented in overload,
this conversion will work only over literal parts of regular
expressions. For <tt>&quot;\Y|$re\Y|&quot;</tt> the variable
part of this regular expression needs to be converted
explicitly (but only if the special meaning of
<tt>&quot;\Y|&quot;</tt> should be enabled inside
<tt>$re</tt>):</p>

<pre style="margin-left:11%; margin-top: 1em">    use customre;
    $re = &lt;&gt;;
    chomp $re;
    $re = customre::convert $re;
    /\Y|$re\Y|/;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>PCRE/Python
Support</b> <br>
As of Perl 5.10.0, Perl supports several
Python/PCRE&minus;specific extensions to the regex syntax.
While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted: <br>
&quot;(?P&lt;NAME&gt;pattern)&quot;</p>

<p style="margin-left:17%;">Define a named capture group.
Equivalent to
<tt>&quot;(?&lt;NAME&gt;pattern)&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;(?P=NAME)&quot;</p>

<p style="margin-left:17%;">Backreference to a named
capture group. Equivalent to
<tt>&quot;\g{NAME}&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;(?P&gt;NAME)&quot;</p>

<p style="margin-left:17%;">Subroutine call to a named
capture group. Equivalent to
<tt>&quot;(?&amp;NAME)&quot;</tt>.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many regular
expression constructs don&rsquo;t work on
<small>EBCDIC</small> platforms.</p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of issues with regard to case-insensitive matching in
Unicode rules. See <tt>&quot;i&quot;</tt> under
&quot;Modifiers&quot; above.</p>

<p style="margin-left:11%; margin-top: 1em">This document
varies from difficult to understand to completely and
utterly opaque. The wandering prose riddled with jargon is
hard to fathom in several places.</p>

<p style="margin-left:11%; margin-top: 1em">This document
needs a rewrite that separates the tutorial content from the
reference content.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">perlrequick.</p>

<p style="margin-left:11%; margin-top: 1em">perlretut.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Regexp
Quote-Like Operators&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Gory
details of parsing quoted constructs&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em">perlfaq6.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;pos&quot;
in perlfunc.</p>


<p style="margin-left:11%; margin-top: 1em">perllocale.</p>


<p style="margin-left:11%; margin-top: 1em">perlebcdic.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Mastering
Regular Expressions</i> by Jeffrey Friedl, published by
O&rsquo;Reilly and Associates.</p>
<hr>
</body>
</html>
