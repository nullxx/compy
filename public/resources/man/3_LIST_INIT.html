<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:02:52 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>QUEUE</title>

</head>
<body>

<h1 align="center">QUEUE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">LIST_ENTRY,
LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD,
LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT,
TAILQ_INSERT_AFTER, TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL,
TAILQ_REMOVE, CIRCLEQ_ENTRY, CIRCLEQ_HEAD, CIRCLEQ_INIT,
CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE,
CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE
&minus; implementations of lists, tail queues, and circular
queues</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/queue.h&gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>LIST_ENTRY(</b><i>TYPE</i><b>);
<br>
LIST_HEAD(</b><i>HEADNAME</i><b>,</b> <i>TYPE</i><b>); <br>
LIST_INIT(LIST_HEAD *</b><i>head</i><b>); <br>
LIST_INSERT_AFTER(LIST_ENTRY *</b><i>listelm</i><b>, <br>
TYPE *</b><i>elm</i><b>, LIST_ENTRY</b> <i>NAME</i><b>);
<br>
LIST_INSERT_HEAD(LIST_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, LIST_ENTRY</b> <i>NAME</i><b>);
<br>
LIST_REMOVE(TYPE *</b><i>elm</i><b>, LIST_ENTRY</b>
<i>NAME</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>TAILQ_ENTRY(</b><i>TYPE</i><b>);
<br>
TAILQ_HEAD(</b><i>HEADNAME</i><b>,</b> <i>TYPE</i><b>); <br>
TAILQ_INIT(TAILQ_HEAD *</b><i>head</i><b>); <br>
TAILQ_INSERT_AFTER(TAILQ_HEAD *</b><i>head</i><b>, TYPE
*</b><i>listelm</i><b>, <br>
TYPE *</b><i>elm</i><b>, TAILQ_ENTRY</b> <i>NAME</i><b>);
<br>
TAILQ_INSERT_HEAD(TAILQ_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, TAILQ_ENTRY</b> <i>NAME</i><b>);
<br>
TAILQ_INSERT_TAIL(TAILQ_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, TAILQ_ENTRY</b> <i>NAME</i><b>);
<br>
TAILQ_REMOVE(TAILQ_HEAD *</b><i>head</i><b>, TYPE
*</b><i>elm</i><b>, TAILQ_ENTRY</b> <i>NAME</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>CIRCLEQ_ENTRY(</b><i>TYPE</i><b>);
<br>
CIRCLEQ_HEAD(</b><i>HEADNAME</i><b>,</b> <i>TYPE</i><b>);
<br>
CIRCLEQ_INIT(CIRCLEQ_HEAD *</b><i>head</i><b>); <br>
CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *</b><i>head</i><b>, TYPE
*</b><i>listelm</i><b>, <br>
TYPE *</b><i>elm</i><b>, CIRCLEQ_ENTRY</b> <i>NAME</i><b>);
<br>
CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *</b><i>head</i><b>, TYPE
*</b><i>listelm</i><b>, <br>
TYPE *</b><i>elm</i><b>, CIRCLEQ_ENTRY</b> <i>NAME</i><b>);
<br>
CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, CIRCLEQ_ENTRY</b> <i>NAME</i><b>);
<br>
CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, CIRCLEQ_ENTRY</b> <i>NAME</i><b>);
<br>
CIRCLEQ_REMOVE(CIRCLEQ_HEAD *</b><i>head</i><b>, <br>
TYPE *</b><i>elm</i><b>, CIRCLEQ_ENTRY</b>
<i>NAME</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These macros
define and operate on three types of data structures: lists,
tail queues, and circular queues. All three structures
support the following functionality:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>Insertion of a new entry at the head of the list.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>Insertion of a new entry after any element in the
list.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>Removal of any entry in the list.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>Forward traversal through the list.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Lists are the
simplest of the three data structures and support only the
above functionality.</p>

<p style="margin-left:11%; margin-top: 1em">Tail queues add
the following functionality:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="5%"></td>
<td width="65%">


<p style="margin-top: 1em">Entries can be added at the end
of a list.</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">However:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">All list insertions and removals
must specify the head of the list.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="77%">


<p>Each head entry requires two pointers rather than
one.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="77%">


<p>Code size is about 15% greater and operations run about
20% slower than lists.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Circular queues
add the following functionality:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">Entries can be added at the end
of a list.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>Entries can be added before another entry.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="5%"></td>
<td width="77%">


<p>They may be traversed backward, from tail to head.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">However:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">All list insertions and removals
must specify the head of the list.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="77%">


<p>Each head entry requires two pointers rather than
one.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="77%">


<p>The termination condition for traversal is more
complex.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="77%">


<p>Code size is about 40% greater and operations run about
45% slower than lists.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the macro
definitions, <i>TYPE</i> is the name of a user-defined
structure, that must contain a field of type
<b>LIST_ENTRY</b>, <b>TAILQ_ENTRY</b>, or
<b>CIRCLEQ_ENTRY</b>, named <i>NAME</i>. The argument
<i>HEADNAME</i> is the name of a user-defined structure that
must be declared using the macros <b>LIST_HEAD</b>,
<b>TAILQ_HEAD</b>, or <b>CIRCLEQ_HEAD</b>. See the examples
below for further explanation of how these macros are
used.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Lists</b>
<br>
A list is headed by a structure defined by the
<b>LIST_HEAD</b> macro. This structure contains a single
pointer to the first element on the list. The elements are
doubly linked so that an arbitrary element can be removed
without traversing the list. New elements can be added to
the list after an existing element or at the head of the
list. A <b>LIST_HEAD</b> structure is declared as
follows:</p>


<p style="margin-left:17%; margin-top: 1em">LIST_HEAD(HEADNAME,
TYPE) head;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>HEADNAME</i> is the name of the structure to be defined,
and <i>TYPE</i> is the type of the elements to be linked
into the list. A pointer to the head of the list can later
be declared as:</p>

<p style="margin-left:17%; margin-top: 1em">struct HEADNAME
*headp;</p>

<p style="margin-left:11%; margin-top: 1em">(The names
<i>head</i> and <i>headp</i> are user selectable.)</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>LIST_ENTRY</b> declares a structure that connects the
elements in the list.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>LIST_INIT</b> initializes the list referenced by
<i>head</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>LIST_INSERT_HEAD</b> inserts the new element <i>elm</i>
at the head of the list.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>LIST_INSERT_AFTER</b> inserts the new element <i>elm</i>
after the element <i>listelm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>LIST_REMOVE</b> removes the element <i>elm</i> from the
list.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List
example</b> <br>
LIST_HEAD(listhead, entry) head; <br>
struct listhead *headp; /* List head. */ <br>
struct entry { <br>
... <br>
LIST_ENTRY(entry) entries; /* List. */ <br>
... <br>
} *n1, *n2, *np;</p>


<p style="margin-left:11%; margin-top: 1em">LIST_INIT(&amp;head);
/* Initialize the list. */</p>

<p style="margin-left:11%; margin-top: 1em">n1 =
malloc(sizeof(struct entry)); /* Insert at the head. */ <br>
LIST_INSERT_HEAD(&amp;head, n1, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n2 =
malloc(sizeof(struct entry)); /* Insert after. */ <br>
LIST_INSERT_AFTER(n1, n2, entries); <br>
/* Forward traversal. */ <br>
for (np = head.lh_first; np != NULL; np =
np&minus;&gt;entries.le_next) <br>
np&minus;&gt; ...</p>

<p style="margin-left:11%; margin-top: 1em">while
(head.lh_first != NULL) /* Delete. */ <br>
LIST_REMOVE(head.lh_first, entries);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tail
queues</b> <br>
A tail queue is headed by a structure defined by the
<b>TAILQ_HEAD</b> macro. This structure contains a pair of
pointers, one to the first element in the tail queue and the
other to the last element in the tail queue. The elements
are doubly linked so that an arbitrary element can be
removed without traversing the tail queue. New elements can
be added to the tail queue after an existing element, at the
head of the tail queue, or at the end of the tail queue. A
<b>TAILQ_HEAD</b> structure is declared as follows:</p>


<p style="margin-left:17%; margin-top: 1em">TAILQ_HEAD(HEADNAME,
TYPE) head;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>HEADNAME</i> is the name of the structure to be defined,
and <i>TYPE</i> is the type of the elements to be linked
into the tail queue. A pointer to the head of the tail queue
can later be declared as:</p>

<p style="margin-left:17%; margin-top: 1em">struct HEADNAME
*headp;</p>

<p style="margin-left:11%; margin-top: 1em">(The names
<i>head</i> and <i>headp</i> are user selectable.)</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_ENTRY</b> declares a structure that connects the
elements in the tail queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_INIT</b> initializes the tail queue referenced by
<i>head</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_INSERT_HEAD</b> inserts the new element <i>elm</i>
at the head of the tail queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_INSERT_TAIL</b> inserts the new element <i>elm</i>
at the end of the tail queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_INSERT_AFTER</b> inserts the new element <i>elm</i>
after the element <i>listelm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>TAILQ_REMOVE</b> removes the element <i>elm</i> from the
tail queue.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tail queue
example</b> <br>
TAILQ_HEAD(tailhead, entry) head; <br>
struct tailhead *headp; /* Tail queue head. */ <br>
struct entry { <br>
... <br>
TAILQ_ENTRY(entry) entries; /* Tail queue. */ <br>
... <br>
} *n1, *n2, *np;</p>


<p style="margin-left:11%; margin-top: 1em">TAILQ_INIT(&amp;head);
/* Initialize the queue. */</p>

<p style="margin-left:11%; margin-top: 1em">n1 =
malloc(sizeof(struct entry)); /* Insert at the head. */ <br>
TAILQ_INSERT_HEAD(&amp;head, n1, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n1 =
malloc(sizeof(struct entry)); /* Insert at the tail. */ <br>
TAILQ_INSERT_TAIL(&amp;head, n1, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n2 =
malloc(sizeof(struct entry)); /* Insert after. */ <br>
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); <br>
/* Forward traversal. */ <br>
for (np = head.tqh_first; np != NULL; np =
np&minus;&gt;entries.tqe_next) <br>
np&minus;&gt; ... <br>
/* Delete. */ <br>
while (head.tqh_first != NULL) <br>
TAILQ_REMOVE(&amp;head, head.tqh_first, entries);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Circular
queues</b> <br>
A circular queue is headed by a structure defined by the
<b>CIRCLEQ_HEAD</b> macro. This structure contains a pair of
pointers, one to the first element in the circular queue and
the other to the last element in the circular queue. The
elements are doubly linked so that an arbitrary element can
be removed without traversing the queue. New elements can be
added to the queue after an existing element, before an
existing element, at the head of the queue, or at the end of
the queue. A <b>CIRCLEQ_HEAD</b> structure is declared as
follows:</p>


<p style="margin-left:17%; margin-top: 1em">CIRCLEQ_HEAD(HEADNAME,
TYPE) head;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>HEADNAME</i> is the name of the structure to be defined,
and <i>TYPE</i> is the type of the elements to be linked
into the circular queue. A pointer to the head of the
circular queue can later be declared as:</p>

<p style="margin-left:17%; margin-top: 1em">struct HEADNAME
*headp;</p>

<p style="margin-left:11%; margin-top: 1em">(The names
<i>head</i> and <i>headp</i> are user selectable.)</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_ENTRY</b> declares a structure that connects the
elements in the circular queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_INIT</b> initializes the circular queue
referenced by <i>head</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_INSERT_HEAD</b> inserts the new element
<i>elm</i> at the head of the circular queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_INSERT_TAIL</b> inserts the new element
<i>elm</i> at the end of the circular queue.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_INSERT_AFTER</b> inserts the new element
<i>elm</i> after the element <i>listelm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_INSERT_BEFORE</b> inserts the new element
<i>elm</i> before the element <i>listelm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The macro
<b>CIRCLEQ_REMOVE</b> removes the element <i>elm</i> from
the circular queue.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Circular
queue example</b> <br>
CIRCLEQ_HEAD(circleq, entry) head; <br>
struct circleq *headp; /* Circular queue head. */ <br>
struct entry { <br>
... <br>
CIRCLEQ_ENTRY(entry) entries; /* Circular queue. */ <br>
... <br>
} *n1, *n2, *np;</p>


<p style="margin-left:11%; margin-top: 1em">CIRCLEQ_INIT(&amp;head);
/* Initialize the circular queue. */</p>

<p style="margin-left:11%; margin-top: 1em">n1 =
malloc(sizeof(struct entry)); /* Insert at the head. */ <br>
CIRCLEQ_INSERT_HEAD(&amp;head, n1, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n1 =
malloc(sizeof(struct entry)); /* Insert at the tail. */ <br>
CIRCLEQ_INSERT_TAIL(&amp;head, n1, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n2 =
malloc(sizeof(struct entry)); /* Insert after. */ <br>
CIRCLEQ_INSERT_AFTER(&amp;head, n1, n2, entries);</p>

<p style="margin-left:11%; margin-top: 1em">n2 =
malloc(sizeof(struct entry)); /* Insert before. */ <br>
CIRCLEQ_INSERT_BEFORE(&amp;head, n1, n2, entries); <br>
/* Forward traversal. */ <br>
for (np = head.cqh_first; np != (void *)&amp;head; <br>
np = np&minus;&gt;entries.cqe_next) <br>
np&minus;&gt; ... <br>
/* Reverse traversal. */ <br>
for (np = head.cqh_last; np != (void *)&amp;head; np =
np&minus;&gt;entries.cqe_prev) <br>
np&minus;&gt; ... <br>
/* Delete. */ <br>
while (head.cqh_first != (void *)&amp;head) <br>
CIRCLEQ_REMOVE(&amp;head, head.cqh_first, entries);</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Not in
POSIX.1-2001. Present on the BSDs. The queue functions first
appeared in 4.4BSD.</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
