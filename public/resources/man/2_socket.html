<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:02:11 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SOCKET</title>

</head>
<body>

<h1 align="center">SOCKET</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">socket &minus;
create an endpoint for communication</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/types.h&gt;</b> /* See NOTES */ <b><br>
#include &lt;sys/socket.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
socket(int</b> <i>domain</i><b>, int</b> <i>type</i><b>,
int</b> <i>protocol</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>socket</b>()
creates an endpoint for communication and returns a
descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>domain</i> argument specifies a communication domain;
this selects the protocol family which will be used for
communication. These families are defined in
<i>&lt;sys/socket.h&gt;</i>. The currently understood
formats include:</p>

<p style="margin-left:11%; margin-top: 1em">The socket has
the indicated <i>type</i>, which specifies the communication
semantics. Currently defined types are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_STREAM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides sequenced, reliable, two-way, connection-based
byte streams. An out-of-band data transmission mechanism may
be supported.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_DGRAM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Supports datagrams (connectionless, unreliable messages
of a fixed maximum length).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_SEQPACKET</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides a sequenced, reliable, two-way connection-based
data transmission path for datagrams of fixed maximum
length; a consumer is required to read an entire packet with
each input system call.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_RAW</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides raw network protocol access.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_RDM</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Provides a reliable datagram layer that does not
guarantee ordering.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p><b>SOCK_PACKET</b></p></td>
<td width="3%"></td>
<td width="65%">


<p>Obsolete and should not be used in new programs; see
<b>packet</b>(7).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Some socket
types may not be implemented by all protocol families; for
example, <b>SOCK_SEQPACKET</b> is not implemented for
<b>AF_INET</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
2.6.27, the <i>type</i> argument serves a second purpose: in
addition to specifying a socket type, it may include the
bitwise OR of any of the following values, to modify the
behavior of <b>socket</b>():</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>SOCK_NONBLOCK</b></p></td>
<td width="4%"></td>
<td width="65%">


<p style="margin-top: 1em">Set the <b>O_NONBLOCK</b> file
status flag on the new open file description. Using this
flag saves extra calls to <b>fcntl</b>(2) to achieve the
same result.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>SOCK_CLOEXEC</b></p></td>
<td width="4%"></td>
<td width="65%">


<p>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the
new file descriptor. See the description of the
<b>O_CLOEXEC</b> flag in <b>open</b>(2) for reasons why this
may be useful.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>protocol</i> specifies a particular protocol to be used
with the socket. Normally only a single protocol exists to
support a particular socket type within a given protocol
family, in which case <i>protocol</i> can be specified as 0.
However, it is possible that many protocols may exist, in
which case a particular protocol must be specified in this
manner. The protocol number to use is specific to the
&ldquo;communication domain&rdquo; in which communication is
to take place; see <b>protocols</b>(5). See
<b>getprotoent</b>(3) on how to map protocol name strings to
protocol numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Sockets of type
<b>SOCK_STREAM</b> are full-duplex byte streams, similar to
pipes. They do not preserve record boundaries. A stream
socket must be in a <i>connected</i> state before any data
may be sent or received on it. A connection to another
socket is created with a <b>connect</b>(2) call. Once
connected, data may be transferred using <b>read</b>(2) and
<b>write</b>(2) calls or some variant of the <b>send</b>(2)
and <b>recv</b>(2) calls. When a session has been completed
a <b>close</b>(2) may be performed. Out-of-band data may
also be transmitted as described in <b>send</b>(2) and
received as described in <b>recv</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The
communications protocols which implement a
<b>SOCK_STREAM</b> ensure that data is not lost or
duplicated. If a piece of data for which the peer protocol
has buffer space cannot be successfully transmitted within a
reasonable length of time, then the connection is considered
to be dead. When <b>SO_KEEPALIVE</b> is enabled on the
socket the protocol checks in a protocol-specific manner if
the other end is still alive. A <b>SIGPIPE</b> signal is
raised if a process sends or receives on a broken stream;
this causes naive processes, which do not handle the signal,
to exit. <b>SOCK_SEQPACKET</b> sockets employ the same
system calls as <b>SOCK_STREAM</b> sockets. The only
difference is that <b>read</b>(2) calls will return only the
amount of data requested, and any data remaining in the
arriving packet will be discarded. Also all message
boundaries in incoming datagrams are preserved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SOCK_DGRAM</b>
and <b>SOCK_RAW</b> sockets allow sending of datagrams to
correspondents named in <b>sendto</b>(2) calls. Datagrams
are generally received with <b>recvfrom</b>(2), which
returns the next datagram along with the address of its
sender.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SOCK_PACKET</b>
is an obsolete socket type to receive raw packets directly
from the device driver. Use <b>packet</b>(7) instead.</p>

<p style="margin-left:11%; margin-top: 1em">An
<b>fcntl</b>(2) <b>F_SETOWN</b> operation can be used to
specify a process or process group to receive a
<b>SIGURG</b> signal when the out-of-band data arrives or
<b>SIGPIPE</b> signal when a <b>SOCK_STREAM</b> connection
breaks unexpectedly. This operation may also be used to set
the process or process group that receives the I/O and
asynchronous notification of I/O events via <b>SIGIO</b>.
Using <b>F_SETOWN</b> is equivalent to an <b>ioctl</b>(2)
call with the <b>FIOSETOWN</b> or <b>SIOCSPGRP</b>
argument.</p>

<p style="margin-left:11%; margin-top: 1em">When the
network signals an error condition to the protocol module
(e.g., using a ICMP message for IP) the pending error flag
is set for the socket. The next operation on this socket
will return the error code of the pending error. For some
protocols it is possible to enable a per-socket error queue
to retrieve detailed information about the error; see
<b>IP_RECVERR</b> in <b>ip</b>(7).</p>

<p style="margin-left:11%; margin-top: 1em">The operation
of sockets is controlled by socket level <i>options</i>.
These options are defined in <i>&lt;sys/socket.h&gt;</i>.
The functions <b>setsockopt</b>(2) and <b>getsockopt</b>(2)
are used to set and get options, respectively.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success, a
file descriptor for the new socket is returned. On error,
&minus;1 is returned, and <i>errno</i> is set
appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Permission to create a socket of
the specified type and/or protocol is denied.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EAFNOSUPPORT</b></p>

<p style="margin-left:22%;">The implementation does not
support the specified address family.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Unknown protocol, or protocol family not available.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Invalid flags in <i>type</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Process file table overflow.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system limit on the total number of open files has
been reached.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENOBUFS</b> or
<b>ENOMEM</b></p>

<p style="margin-left:22%;">Insufficient memory is
available. The socket cannot be created until sufficient
resources are freed.</p>

<p style="margin-left:11%;"><b>EPROTONOSUPPORT</b></p>

<p style="margin-left:22%;">The protocol type or the
specified protocol is not supported within this domain.</p>

<p style="margin-left:11%; margin-top: 1em">Other errors
may be generated by the underlying protocol modules.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">4.4BSD,
POSIX.1-2001.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SOCK_NONBLOCK</b> and <b>SOCK_CLOEXEC</b> flags are
Linux-specific.</p>


<p style="margin-left:11%; margin-top: 1em"><b>socket</b>()
appeared in 4.2BSD. It is generally portable to/from non-BSD
systems supporting clones of the BSD socket layer (including
System V variants).</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001
does not require the inclusion of
<i>&lt;sys/types.h&gt;</i>, and this header file is not
required on Linux. However, some historical (BSD)
implementations required this header file, and portable
applications are probably wise to include it.</p>

<p style="margin-left:11%; margin-top: 1em">The manifest
constants used under 4.x BSD for protocol families are
<b>PF_UNIX</b>, <b>PF_INET</b>, and so on, while
<b>AF_UNIX</b>, <b>AF_INET</b>, and so on are used for
address families. However, already the BSD man page
promises: &quot;The protocol family generally is the same as
the address family&quot;, and subsequent standards use AF_*
everywhere.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An example of
the use of <b>socket</b>() is shown in
<b>getaddrinfo</b>(3).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>accept</b>(2),
<b>bind</b>(2), <b>connect</b>(2), <b>fcntl</b>(2),
<b>getpeername</b>(2), <b>getsockname</b>(2),
<b>getsockopt</b>(2), <b>ioctl</b>(2), <b>listen</b>(2),
<b>read</b>(2), <b>recv</b>(2), <b>select</b>(2),
<b>send</b>(2), <b>shutdown</b>(2), <b>socketpair</b>(2),
<b>write</b>(2), <b>getprotoent</b>(3), <b>ip</b>(7),
<b>socket</b>(7), <b>tcp</b>(7), <b>udp</b>(7),
<b>unix</b>(7)</p>

<p style="margin-left:11%; margin-top: 1em">&ldquo;An
Introductory 4.3BSD Interprocess Communication
Tutorial&rdquo; and &ldquo;BSD Interprocess Communication
Tutorial&rdquo;, reprinted in <i>UNIX Programmer&rsquo;s
Supplementary Documents Volume 1.</i></p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
