<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:57:54 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT&minus;FAST&minus;IMPORT</title>

</head>
<body>

<h1 align="center">GIT&minus;FAST&minus;IMPORT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#PERFORMANCE">PERFORMANCE</a><br>
<a href="#DEVELOPMENT COST">DEVELOPMENT COST</a><br>
<a href="#PARALLEL OPERATION">PARALLEL OPERATION</a><br>
<a href="#TECHNICAL DISCUSSION">TECHNICAL DISCUSSION</a><br>
<a href="#INPUT FORMAT">INPUT FORMAT</a><br>
<a href="#RESPONSES TO COMMANDS">RESPONSES TO COMMANDS</a><br>
<a href="#CRASH REPORTS">CRASH REPORTS</a><br>
<a href="#TIPS AND TRICKS">TIPS AND TRICKS</a><br>
<a href="#PACKFILE OPTIMIZATION">PACKFILE OPTIMIZATION</a><br>
<a href="#MEMORY UTILIZATION">MEMORY UTILIZATION</a><br>
<a href="#SIGNALS">SIGNALS</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">git-fast-import
&minus; Backend for fast Git data importers</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">frontend |
<i>git fast&minus;import</i> [options]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
usually not what the end user wants to run directly. Most
end users want to use one of the existing frontend programs,
which parses a specific type of foreign source and feeds the
contents stored there to <i>git fast&minus;import</i>.</p>


<p style="margin-left:11%; margin-top: 1em">fast&minus;import
reads a mixed command/data stream from standard input and
writes one or more packfiles directly into the current
repository. When EOF is received on standard input, fast
import writes out updated branch and tag refs, fully
updating the current repository with the newly imported
data.</p>

<p style="margin-left:11%; margin-top: 1em">The
fast&minus;import backend itself can import into an empty
repository (one that has already been initialized by <i>git
init</i>) or incrementally update an existing populated
repository. Whether or not incremental imports are supported
from a particular foreign source depends on the frontend
program in use.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&minus;&minus;force</p>

<p style="margin-left:17%;">Force updating modified
existing branches, even if doing so would cause commits to
be lost (as the new commit does not contain the old
commit).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;quiet</p>

<p style="margin-left:17%;">Disable all non&minus;fatal
output, making fast&minus;import silent when it is
successful. This option disables the output shown by
&minus;&minus;stats.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;stats</p>

<p style="margin-left:17%;">Display some basic statistics
about the objects fast&minus;import has created, the
packfiles they were stored into, and the memory used by
fast&minus;import during this run. Showing this output is
currently the default, but can be disabled with
&minus;&minus;quiet.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options for
Frontends</b> <br>
&minus;&minus;cat&minus;blob&minus;fd=&lt;fd&gt;</p>

<p style="margin-left:17%;">Write responses to
cat&minus;blob and ls queries to the file descriptor
&lt;fd&gt; instead of stdout. Allows progress output
intended for the end&minus;user to be separated from other
output.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;date&minus;format=&lt;fmt&gt;</p>

<p style="margin-left:17%;">Specify the type of dates the
frontend will supply to fast&minus;import within author,
committer and tagger commands. See &ldquo;Date
Formats&rdquo; below for details about which formats are
supported, and their syntax.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;done</p>

<p style="margin-left:17%;">Terminate with error if there
is no done command at the end of the stream. This option
might be useful for detecting errors that cause the frontend
to terminate before it has started to write a stream.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Locations of
Marks Files</b> <br>
&minus;&minus;export&minus;marks=&lt;file&gt;</p>

<p style="margin-left:17%;">Dumps the internal marks table
to &lt;file&gt; when complete. Marks are written one per
line as :markid SHA&minus;1. Frontends can use this file to
validate imports after they have been completed, or to save
the marks table across incremental runs. As &lt;file&gt; is
only opened and truncated at checkpoint (or completion) the
same path can also be safely given to
&minus;&minus;import&minus;marks.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;import&minus;marks=&lt;file&gt;</p>

<p style="margin-left:17%;">Before processing any input,
load the marks specified in &lt;file&gt;. The input file
must exist, must be readable, and must use the same format
as produced by &minus;&minus;export&minus;marks. Multiple
options may be supplied to import more than one set of
marks. If a mark is defined to different values, the last
file wins.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;import&minus;marks&minus;if&minus;exists=&lt;file&gt;</p>

<p style="margin-left:17%;">Like
&minus;&minus;import&minus;marks but instead of erroring
out, silently skips the file if it does not exist.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;[no&minus;]relative&minus;marks</p>

<p style="margin-left:17%;">After specifying
&minus;&minus;relative&minus;marks the paths specified with
&minus;&minus;import&minus;marks= and
&minus;&minus;export&minus;marks= are relative to an
internal directory in the current repository. In
git&minus;fast&minus;import this means that the paths are
relative to the .git/info/fast&minus;import directory.
However, other importers may use a different location.</p>

<p style="margin-left:17%; margin-top: 1em">Relative and
non&minus;relative marks may be combined by interweaving
&minus;&minus;(no&minus;)&minus;relative&minus;marks with
the &minus;&minus;(import|export)&minus;marks= options.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Performance
and Compression Tuning</b> <br>
&minus;&minus;active&minus;branches=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum number of branches to
maintain active at once. See &ldquo;Memory
Utilization&rdquo; below for details. Default is 5.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;big&minus;file&minus;threshold=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum size of a blob that
fast&minus;import will attempt to create a delta for,
expressed in bytes. The default is 512m (512 MiB). Some
importers may wish to lower this on systems with constrained
memory.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;depth=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum delta depth, for blob
and tree deltification. Default is 10.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;export&minus;pack&minus;edges=&lt;file&gt;</p>

<p style="margin-left:17%;">After creating a packfile,
print a line of data to &lt;file&gt; listing the filename of
the packfile and the last commit on each branch that was
written to that packfile. This information may be useful
after importing projects whose total object set exceeds the
4 GiB packfile limit, as these commits can be used as edge
points during calls to <i>git pack&minus;objects</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;max&minus;pack&minus;size=&lt;n&gt;</p>

<p style="margin-left:17%;">Maximum size of each output
packfile. The default is unlimited.</p>

<h2>PERFORMANCE
<a name="PERFORMANCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The design of
fast&minus;import allows it to import large projects in a
minimum amount of memory usage and processing time. Assuming
the frontend is able to keep up with fast&minus;import and
feed it a constant stream of data, import times for projects
holding 10+ years of history and containing 100,000+
individual commits are generally completed in just 1&minus;2
hours on quite modest (~$2,000 USD) hardware.</p>

<p style="margin-left:11%; margin-top: 1em">Most
bottlenecks appear to be in foreign source data access (the
source just cannot extract revisions fast enough) or disk IO
(fast&minus;import writes as fast as the disk will take the
data). Imports will run faster if the source data is stored
on a different drive than the destination Git repository
(due to less IO contention).</p>

<h2>DEVELOPMENT COST
<a name="DEVELOPMENT COST"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A typical
frontend for fast&minus;import tends to weigh in at
approximately 200 lines of Perl/Python/Ruby code. Most
developers have been able to create working importers in
just a couple of hours, even though it is their first
exposure to fast&minus;import, and sometimes even to Git.
This is an ideal situation, given that most conversion tools
are throw&minus;away (use once, and never look back).</p>

<h2>PARALLEL OPERATION
<a name="PARALLEL OPERATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Like <i>git
push</i> or <i>git fetch</i>, imports handled by
fast&minus;import are safe to run alongside parallel git
repack &minus;a &minus;d or git gc invocations, or any other
Git operation (including <i>git prune</i>, as loose objects
are never used by fast&minus;import).</p>


<p style="margin-left:11%; margin-top: 1em">fast&minus;import
does not lock the branch or tag refs it is actively
importing. After the import, during its ref update phase,
fast&minus;import tests each existing branch ref to verify
the update will be a fast&minus;forward update (the commit
stored in the ref is contained in the new history of the
commit to be written). If the update is not a
fast&minus;forward update, fast&minus;import will skip
updating that ref and instead prints a warning message.
fast&minus;import will always attempt to update all branch
refs, and does not stop on the first failure.</p>

<p style="margin-left:11%; margin-top: 1em">Branch updates
can be forced with &minus;&minus;force, but it&rsquo;s
recommended that this only be used on an otherwise quiet
repository. Using &minus;&minus;force is not necessary for
an initial import into an empty repository.</p>

<h2>TECHNICAL DISCUSSION
<a name="TECHNICAL DISCUSSION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">fast&minus;import
tracks a set of branches in memory. Any branch can be
created or modified at any point during the import process
by sending a commit command on the input stream. This design
allows a frontend program to process an unlimited number of
branches simultaneously, generating commits in the order
they are available from the source data. It also simplifies
the frontend programs considerably.</p>


<p style="margin-left:11%; margin-top: 1em">fast&minus;import
does not use or alter the current working directory, or any
file within it. (It does however update the current Git
repository, as referenced by GIT_DIR.) Therefore an import
frontend may use the working directory for its own purposes,
such as extracting file revisions from the foreign source.
This ignorance of the working directory also allows
fast&minus;import to run very quickly, as it does not need
to perform any costly file update operations when switching
between branches.</p>

<h2>INPUT FORMAT
<a name="INPUT FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">With the
exception of raw file data (which Git does not interpret)
the fast&minus;import input format is text (ASCII) based.
This text based format simplifies development and debugging
of frontend programs, especially when a higher level
language such as Perl, Python or Ruby is being used.</p>


<p style="margin-left:11%; margin-top: 1em">fast&minus;import
is very strict about its input. Where we say SP below we
mean <b>exactly</b> one space. Likewise LF means one (and
only one) linefeed and HT one (and only one) horizontal tab.
Supplying additional whitespace characters will cause
unexpected results, such as branch names or file names with
leading or trailing spaces in their name, or early
termination of fast&minus;import when it encounters
unexpected input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Stream
Comments</b> <br>
To aid in debugging frontends fast&minus;import ignores any
line that begins with # (ASCII pound/hash) up to and
including the line ending LF. A comment line may contain any
sequence of bytes that does not contain an LF and therefore
may be used to include any detailed debugging information
that might be specific to the frontend and useful when
inspecting a fast&minus;import data stream.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Date
Formats</b> <br>
The following date formats are supported. A frontend should
select the format it will use for this import by passing the
format name in the
&minus;&minus;date&minus;format=&lt;fmt&gt; command line
option.</p>

<p style="margin-left:11%; margin-top: 1em">raw</p>

<p style="margin-left:17%;">This is the Git native format
and is &lt;time&gt; SP &lt;offutc&gt;. It is also
fast&minus;import&rsquo;s default format, if
&minus;&minus;date&minus;format was not specified.</p>

<p style="margin-left:17%; margin-top: 1em">The time of the
event is specified by &lt;time&gt; as the number of seconds
since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is
written as an ASCII decimal integer.</p>

<p style="margin-left:17%; margin-top: 1em">The local
offset is specified by &lt;offutc&gt; as a positive or
negative offset from UTC. For example EST (which is 5 hours
behind UTC) would be expressed in &lt;tz&gt; by
&ldquo;&minus;0500&rdquo; while UTC is &ldquo;+0000&rdquo;.
The local offset does not affect &lt;time&gt;; it is used
only as an advisement to help formatting routines display
the timestamp.</p>

<p style="margin-left:17%; margin-top: 1em">If the local
offset is not available in the source material, use
&ldquo;+0000&rdquo;, or the most common local offset. For
example many organizations have a CVS repository which has
only ever been accessed by users who are located in the same
location and timezone. In this case a reasonable offset from
UTC could be assumed.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike the
rfc2822 format, this format is very strict. Any variation in
formatting will cause fast&minus;import to reject the
value.</p>

<p style="margin-left:11%; margin-top: 1em">rfc2822</p>

<p style="margin-left:17%;">This is the standard email
format as described by RFC 2822.</p>

<p style="margin-left:17%; margin-top: 1em">An example
value is &ldquo;Tue Feb 6 11:22:18 2007 &minus;0500&rdquo;.
The Git parser is accurate, but a little on the lenient
side. It is the same parser used by <i>git am</i> when
applying patches received from email.</p>

<p style="margin-left:17%; margin-top: 1em">Some malformed
strings may be accepted as valid dates. In some of these
cases Git will still be able to obtain the correct date from
the malformed string. There are also some types of malformed
strings which Git will parse wrong, and yet consider valid.
Seriously malformed strings will be rejected.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike the raw
format above, the timezone/UTC offset information contained
in an RFC 2822 date string is used to adjust the date value
to UTC prior to storage. Therefore it is important that this
information be as accurate as possible.</p>

<p style="margin-left:17%; margin-top: 1em">If the source
material uses RFC 2822 style dates, the frontend should let
fast&minus;import handle the parsing and conversion (rather
than attempting to do it itself) as the Git parser has been
well tested in the wild.</p>

<p style="margin-left:17%; margin-top: 1em">Frontends
should prefer the raw format if the source material already
uses UNIX&minus;epoch format, can be coaxed to give dates in
that format, or its format is easily convertible to it, as
there is no ambiguity in parsing.</p>

<p style="margin-left:11%; margin-top: 1em">now</p>

<p style="margin-left:17%;">Always use the current time and
timezone. The literal now must always be supplied for
&lt;when&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">This is a toy
format. The current time and timezone of this system is
always copied into the identity string at the time it is
being created by fast&minus;import. There is no way to
specify a different time or timezone.</p>

<p style="margin-left:17%; margin-top: 1em">This particular
format is supplied as it&rsquo;s short to implement and may
be useful to a process that wants to create a new commit
right now, without needing to use a working directory or
<i>git update&minus;index</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If separate
author and committer commands are used in a commit the
timestamps may not match, as the system clock will be polled
twice (once for each command). The only way to ensure that
both author and committer identity information has the same
timestamp is to omit author (thus copying from committer) or
to use a date format other than now.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Commands</b>
<br>
fast&minus;import accepts several commands to update the
current repository and control the current import process.
More detailed discussion (with examples) of each command
follows later.</p>

<p style="margin-left:11%; margin-top: 1em">commit</p>

<p style="margin-left:17%;">Creates a new branch or updates
an existing branch by creating a new commit and updating the
branch to point at the newly created commit.</p>

<p style="margin-left:11%; margin-top: 1em">tag</p>

<p style="margin-left:17%;">Creates an annotated tag object
from an existing commit or branch. Lightweight tags are not
supported by this command, as they are not recommended for
recording meaningful points in time.</p>

<p style="margin-left:11%; margin-top: 1em">reset</p>

<p style="margin-left:17%;">Reset an existing branch (or a
new branch) to a specific revision. This command must be
used to change a branch to a specific revision without
making a commit on it.</p>

<p style="margin-left:11%; margin-top: 1em">blob</p>

<p style="margin-left:17%;">Convert raw file data into a
blob, for future use in a commit command. This command is
optional and is not needed to perform an import.</p>

<p style="margin-left:11%; margin-top: 1em">checkpoint</p>

<p style="margin-left:17%;">Forces fast&minus;import to
close the current packfile, generate its unique SHA&minus;1
checksum and index, and start a new packfile. This command
is optional and is not needed to perform an import.</p>

<p style="margin-left:11%; margin-top: 1em">progress</p>

<p style="margin-left:17%;">Causes fast&minus;import to
echo the entire line to its own standard output. This
command is optional and is not needed to perform an
import.</p>

<p style="margin-left:11%; margin-top: 1em">done</p>

<p style="margin-left:17%;">Marks the end of the stream.
This command is optional unless the done feature was
requested using the &minus;&minus;done command line option
or feature done command.</p>


<p style="margin-left:11%; margin-top: 1em">cat&minus;blob</p>

<p style="margin-left:17%;">Causes fast&minus;import to
print a blob in <i>cat&minus;file &minus;&minus;batch</i>
format to the file descriptor set with
&minus;&minus;cat&minus;blob&minus;fd or stdout if
unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">ls</p>

<p style="margin-left:17%;">Causes fast&minus;import to
print a line describing a directory entry in
<i>ls&minus;tree</i> format to the file descriptor set with
&minus;&minus;cat&minus;blob&minus;fd or stdout if
unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">feature</p>

<p style="margin-left:17%;">Require that fast&minus;import
supports the specified feature, or abort if it does not.</p>

<p style="margin-left:11%; margin-top: 1em">option</p>

<p style="margin-left:17%;">Specify any of the options
listed under OPTIONS that do not change stream semantic to
suit the frontend&rsquo;s needs. This command is optional
and is not needed to perform an import.</p>

<p style="margin-left:11%; margin-top: 1em"><b>commit</b>
<br>
Create or update a branch with a new commit, recording one
logical change to the project.</p>

<p style="margin-left:17%; margin-top: 1em">'commit' SP
&lt;ref&gt; LF <br>
mark? <br>
('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF)? <br>
'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF <br>
data <br>
('from' SP &lt;committish&gt; LF)? <br>
('merge' SP &lt;committish&gt; LF)? <br>
(filemodify | filedelete | filecopy | filerename |
filedeleteall | notemodify)* <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">where
&lt;ref&gt; is the name of the branch to make the commit on.
Typically branch names are prefixed with refs/heads/ in Git,
so importing the CVS branch symbol RELENG&minus;1_0 would
use refs/heads/RELENG&minus;1_0 for the value of
&lt;ref&gt;. The value of &lt;ref&gt; must be a valid
refname in Git. As LF is not valid in a Git refname, no
quoting or escaping syntax is supported here.</p>

<p style="margin-left:11%; margin-top: 1em">A mark command
may optionally appear, requesting fast&minus;import to save
a reference to the newly created commit for future use by
the frontend (see below for format). It is very common for
frontends to mark every commit they create, thereby allowing
future branch creation from any imported commit.</p>

<p style="margin-left:11%; margin-top: 1em">The data
command following committer must supply the commit message
(see below for data command syntax). To import an empty
commit message use a 0 length data. Commit messages are
free&minus;form and are not interpreted by Git. Currently
they must be encoded in UTF&minus;8, as fast&minus;import
does not permit other encodings to be specified.</p>

<p style="margin-left:11%; margin-top: 1em">Zero or more
filemodify, filedelete, filecopy, filerename, filedeleteall
and notemodify commands may be included to update the
contents of the branch prior to creating the commit. These
commands may be supplied in any order. However it is
recommended that a filedeleteall command precede all
filemodify, filecopy, filerename and notemodify commands in
the same commit, as filedeleteall wipes the branch clean
(see below).</p>

<p style="margin-left:11%; margin-top: 1em">The LF after
the command is optional (it used to be required).</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>author</big></b></p>

<p style="margin-left:17%;">An author command may
optionally appear, if the author information might differ
from the committer information. If author is omitted then
fast&minus;import will automatically use the
committer&rsquo;s information for the author portion of the
commit. See below for a description of the fields in author,
as they are identical to committer.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>committer</big></b></p>

<p style="margin-left:17%;">The committer command indicates
who made this commit, and when they made it.</p>

<p style="margin-left:17%; margin-top: 1em">Here
&lt;name&gt; is the person&rsquo;s display name (for example
&ldquo;Com M Itter&rdquo;) and &lt;email&gt; is the
person&rsquo;s email address (&ldquo;cm@example.com&rdquo;).
LT and GT are the literal less&minus;than (\x3c) and
greater&minus;than (\x3e) symbols. These are required to
delimit the email address from the other fields in the line.
Note that &lt;name&gt; and &lt;email&gt; are free&minus;form
and may contain any sequence of bytes, except LT, GT and LF.
&lt;name&gt; is typically UTF&minus;8 encoded.</p>

<p style="margin-left:17%; margin-top: 1em">The time of the
change is specified by &lt;when&gt; using the date format
that was selected by the
&minus;&minus;date&minus;format=&lt;fmt&gt; command line
option. See &ldquo;Date Formats&rdquo; above for the set of
supported formats, and their syntax.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>from</big></b></p>

<p style="margin-left:17%;">The from command is used to
specify the commit to initialize this branch from. This
revision will be the first ancestor of the new commit. The
state of the tree built at this commit will begin with the
state at the from commit, and be altered by the content
modifications in this commit.</p>

<p style="margin-left:17%; margin-top: 1em">Omitting the
from command in the first commit of a new branch will cause
fast&minus;import to create that commit with no ancestor.
This tends to be desired only for the initial commit of a
project. If the frontend creates all files from scratch when
making a new branch, a merge command may be used instead of
from to start the commit with an empty tree. Omitting the
from command on existing branches is usually desired, as the
current commit on that branch is automatically assumed to be
the first ancestor of the new commit.</p>

<p style="margin-left:17%; margin-top: 1em">As LF is not
valid in a Git refname or SHA&minus;1 expression, no quoting
or escaping syntax is supported within
&lt;committish&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">Here
&lt;committish&gt; is any of the following:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The name
of an existing branch already in fast&minus;import&rsquo;s
internal branch table. If fast&minus;import doesn&rsquo;t
know the name, it&rsquo;s treated as a SHA&minus;1
expression.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; A mark
reference, :&lt;idnum&gt;, where &lt;idnum&gt; is the mark
number.</p>

<p style="margin-left:23%; margin-top: 1em">The reason
fast&minus;import uses : to denote a mark reference is this
character is not legal in a Git branch name. The leading :
makes it easy to distinguish between the mark 42 (:42) and
the branch 42 (42 or refs/heads/42), or an abbreviated
SHA&minus;1 which happened to consist only of base&minus;10
digits.</p>

<p style="margin-left:23%; margin-top: 1em">Marks must be
declared (via mark) before they can be used.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; A
complete 40 byte or abbreviated commit SHA&minus;1 in
hex.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Any
valid Git SHA&minus;1 expression that resolves to a commit.
See &ldquo;SPECIFYING REVISIONS&rdquo; in
<b>gitrevisions</b>(7) for details.</p>

<p style="margin-left:17%; margin-top: 1em">The special
case of restarting an incremental import from the current
branch value should be written as:</p>

<p style="margin-left:23%; margin-top: 1em">from
refs/heads/branch^0</p>

<p style="margin-left:17%; margin-top: 1em">The ^0 suffix
is necessary as fast&minus;import does not permit a branch
to start from itself, and the branch is created in memory
before the from command is even read from the input. Adding
^0 will force fast&minus;import to resolve the commit
through Git&rsquo;s revision parsing library, rather than
its internal branch table, thereby loading in the existing
value of the branch.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>merge</big></b></p>

<p style="margin-left:17%;">Includes one additional
ancestor commit. The additional ancestry link does not
change the way the tree state is built at this commit. If
the from command is omitted when creating a new branch, the
first merge commit will be the first ancestor of the current
commit, and the branch will start out with no files. An
unlimited number of merge commands per commit are permitted
by fast&minus;import, thereby establishing an n&minus;way
merge. However Git&rsquo;s other tools never create commits
with more than 15 additional ancestors (forming a
16&minus;way merge). For this reason it is suggested that
frontends do not use more than 15 merge commands per commit;
16, if starting a new, empty branch.</p>

<p style="margin-left:17%; margin-top: 1em">Here
&lt;committish&gt; is any of the commit specification
expressions also accepted by from (see above).</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filemodify</big></b></p>

<p style="margin-left:17%;">Included in a commit command to
add a new file or change the content of an existing file.
This command has two different means of specifying the
content of the file.</p>

<p style="margin-left:17%; margin-top: 1em">External data
format</p>

<p style="margin-left:23%;">The data content for the file
was already supplied by a prior blob command. The frontend
just needs to connect it.</p>

<p style="margin-left:29%; margin-top: 1em">'M' SP
&lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:23%; margin-top: 1em">Here usually
&lt;dataref&gt; must be either a mark reference
(:&lt;idnum&gt;) set by a prior blob command, or a full
40&minus;byte SHA&minus;1 of an existing Git blob object. If
&lt;mode&gt; is 040000&lsquo; then &lt;dataref&gt; must be
the full 40&minus;byte SHA&minus;1 of an existing Git tree
object or a mark reference set with
&minus;&minus;import&minus;marks.</p>

<p style="margin-left:17%; margin-top: 1em">Inline data
format</p>

<p style="margin-left:23%;">The data content for the file
has not been supplied yet. The frontend wants to supply it
as part of this modify command.</p>

<p style="margin-left:29%; margin-top: 1em">'M' SP
&lt;mode&gt; SP 'inline' SP &lt;path&gt; LF <br>
data</p>

<p style="margin-left:23%; margin-top: 1em">See below for a
detailed description of the data command.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
&lt;mode&gt; is the type of file entry, specified in octal.
Git only supports the following modes:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; 100644
or 644: A normal (not&minus;executable) file. The majority
of files in most projects use this mode. If in doubt, this
is what you want.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; 100755
or 755: A normal, but executable, file.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; 120000:
A symlink, the content of the file will be the link
target.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; 160000:
A gitlink, SHA&minus;1 of the object refers to a commit in
another repository. Git links can only be specified by SHA
or through a commit mark. They are used to implement
submodules.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; 040000:
A subdirectory. Subdirectories can only be specified by SHA
or through a tree mark set with
&minus;&minus;import&minus;marks.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
&lt;path&gt; is the complete path of the file to be added
(if not already existing) or modified (if already
existing).</p>

<p style="margin-left:17%; margin-top: 1em">A &lt;path&gt;
string must use UNIX&minus;style directory separators
(forward slash /), may contain any byte other than LF, and
must not start with double quote (&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">A path can use
C&minus;style string quoting; this is accepted in all cases
and mandatory if the filename starts with double quote or
contains LF. In C&minus;style quoting, the complete name
should be surrounded with double quotes, and any LF,
backslash, or double quote characters must be escaped by
preceding them with a backslash (e.g., &quot;path/with\n, \\
and \&quot; in it&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">The value of
&lt;path&gt; must be in canonical form. That is it must
not:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; contain
an empty directory component (e.g. foo//bar is invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; end with
a directory separator (e.g. foo/ is invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; start
with a directory separator (e.g. /foo is invalid),</p>

<p style="margin-left:23%; margin-top: 1em">&bull; contain
the special component . or .. (e.g. foo/./bar and foo/../bar
are invalid).</p>

<p style="margin-left:17%; margin-top: 1em">The root of the
tree can be represented by an empty string as
&lt;path&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended that &lt;path&gt; always be encoded using
UTF&minus;8.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filedelete</big></b></p>

<p style="margin-left:17%;">Included in a commit command to
remove a file or recursively delete an entire directory from
the branch. If the file or directory removal makes its
parent directory empty, the parent directory will be
automatically removed too. This cascades up the tree until
the first non&minus;empty directory or the root is
reached.</p>

<p style="margin-left:23%; margin-top: 1em">'D' SP
&lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here
&lt;path&gt; is the complete path of the file or
subdirectory to be removed from the branch. See filemodify
above for a detailed description of &lt;path&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filecopy</big></b></p>

<p style="margin-left:17%;">Recursively copies an existing
file or subdirectory to a different location within the
branch. The existing file or directory must exist. If the
destination exists it will be completely replaced by the
content copied from the source.</p>

<p style="margin-left:23%; margin-top: 1em">'C' SP
&lt;path&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here the first
&lt;path&gt; is the source location and the second
&lt;path&gt; is the destination. See filemodify above for a
detailed description of what &lt;path&gt; may look like. To
use a source path that contains SP the path must be
quoted.</p>

<p style="margin-left:17%; margin-top: 1em">A filecopy
command takes effect immediately. Once the source location
has been copied to the destination any future commands
applied to the source location will not impact the
destination of the copy.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filerename</big></b></p>

<p style="margin-left:17%;">Renames an existing file or
subdirectory to a different location within the branch. The
existing file or directory must exist. If the destination
exists it will be replaced by the source directory.</p>

<p style="margin-left:23%; margin-top: 1em">'R' SP
&lt;path&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:17%; margin-top: 1em">here the first
&lt;path&gt; is the source location and the second
&lt;path&gt; is the destination. See filemodify above for a
detailed description of what &lt;path&gt; may look like. To
use a source path that contains SP the path must be
quoted.</p>

<p style="margin-left:17%; margin-top: 1em">A filerename
command takes effect immediately. Once the source location
has been renamed to the destination any future commands
applied to the source location will create new files there
and not impact the destination of the rename.</p>

<p style="margin-left:17%; margin-top: 1em">Note that a
filerename is the same as a filecopy followed by a
filedelete of the source location. There is a slight
performance advantage to using filerename, but the advantage
is so small that it is never worth trying to convert a
delete/add pair in source material into a rename for
fast&minus;import. This filerename command is provided just
to simplify frontends that already have rename information
and don&rsquo;t want bother with decomposing it into a
filecopy followed by a filedelete.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>filedeleteall</big></b></p>

<p style="margin-left:17%;">Included in a commit command to
remove all files (and also all directories) from the branch.
This command resets the internal branch structure to have no
files in it, allowing the frontend to subsequently add all
interesting files from scratch.</p>

<p style="margin-left:23%; margin-top: 1em">'deleteall'
LF</p>

<p style="margin-left:17%; margin-top: 1em">This command is
extremely useful if the frontend does not know (or does not
care to know) what files are currently on the branch, and
therefore cannot generate the proper filedelete commands to
update the content.</p>

<p style="margin-left:17%; margin-top: 1em">Issuing a
filedeleteall followed by the needed filemodify commands to
set the correct content will produce the same results as
sending only the needed filemodify and filedelete commands.
The filedeleteall approach may however require
fast&minus;import to use slightly more memory per active
branch (less than 1 MiB for even most large projects); so
frontends that can easily obtain only the affected paths for
a commit are encouraged to do so.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>notemodify</big></b></p>

<p style="margin-left:17%;">Included in a commit
&lt;notes_ref&gt; command to add a new note annotating a
&lt;committish&gt; or change this annotation contents.
Internally it is similar to filemodify 100644 on
&lt;committish&gt; path (maybe split into subdirectories).
It&rsquo;s not advised to use any other commands to write to
the &lt;notes_ref&gt; tree except filedeleteall to delete
all existing notes in this tree. This command has two
different means of specifying the content of the note.</p>

<p style="margin-left:17%; margin-top: 1em">External data
format</p>

<p style="margin-left:23%;">The data content for the note
was already supplied by a prior blob command. The frontend
just needs to connect it to the commit that is to be
annotated.</p>

<p style="margin-left:29%; margin-top: 1em">'N' SP
&lt;dataref&gt; SP &lt;committish&gt; LF</p>

<p style="margin-left:23%; margin-top: 1em">Here
&lt;dataref&gt; can be either a mark reference
(:&lt;idnum&gt;) set by a prior blob command, or a full
40&minus;byte SHA&minus;1 of an existing Git blob
object.</p>

<p style="margin-left:17%; margin-top: 1em">Inline data
format</p>

<p style="margin-left:23%;">The data content for the note
has not been supplied yet. The frontend wants to supply it
as part of this modify command.</p>

<p style="margin-left:29%; margin-top: 1em">'N' SP 'inline'
SP &lt;committish&gt; LF <br>
data</p>

<p style="margin-left:23%; margin-top: 1em">See below for a
detailed description of the data command.</p>

<p style="margin-left:17%; margin-top: 1em">In both formats
&lt;committish&gt; is any of the commit specification
expressions also accepted by from (see above).</p>

<p style="margin-left:11%; margin-top: 1em"><b>mark</b>
<br>
Arranges for fast&minus;import to save a reference to the
current object, allowing the frontend to recall this object
at a future point in time, without knowing its SHA&minus;1.
Here the current object is the object creation command the
mark command appears within. This can be commit, tag, and
blob, but commit is the most common usage.</p>

<p style="margin-left:17%; margin-top: 1em">'mark' SP ':'
&lt;idnum&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">where
&lt;idnum&gt; is the number assigned by the frontend to this
mark. The value of &lt;idnum&gt; is expressed as an ASCII
decimal integer. The value 0 is reserved and cannot be used
as a mark. Only values greater than or equal to 1 may be
used as marks.</p>

<p style="margin-left:11%; margin-top: 1em">New marks are
created automatically. Existing marks can be moved to
another object simply by reusing the same &lt;idnum&gt; in
another mark command.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tag</b> <br>
Creates an annotated tag referring to a specific commit. To
create lightweight (non&minus;annotated) tags see the reset
command below.</p>

<p style="margin-left:17%; margin-top: 1em">'tag' SP
&lt;name&gt; LF <br>
'from' SP &lt;committish&gt; LF <br>
'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP
&lt;when&gt; LF <br>
data</p>

<p style="margin-left:11%; margin-top: 1em">where
&lt;name&gt; is the name of the tag to create.</p>

<p style="margin-left:11%; margin-top: 1em">Tag names are
automatically prefixed with refs/tags/ when stored in Git,
so importing the CVS branch symbol
RELENG&minus;1_0&minus;FINAL would use just
RELENG&minus;1_0&minus;FINAL for &lt;name&gt;, and
fast&minus;import will write the corresponding ref as
refs/tags/RELENG&minus;1_0&minus;FINAL.</p>

<p style="margin-left:11%; margin-top: 1em">The value of
&lt;name&gt; must be a valid refname in Git and therefore
may contain forward slashes. As LF is not valid in a Git
refname, no quoting or escaping syntax is supported
here.</p>

<p style="margin-left:11%; margin-top: 1em">The from
command is the same as in the commit command; see above for
details.</p>

<p style="margin-left:11%; margin-top: 1em">The tagger
command uses the same format as committer within commit;
again see above for details.</p>

<p style="margin-left:11%; margin-top: 1em">The data
command following tagger must supply the annotated tag
message (see below for data command syntax). To import an
empty tag message use a 0 length data. Tag messages are
free&minus;form and are not interpreted by Git. Currently
they must be encoded in UTF&minus;8, as fast&minus;import
does not permit other encodings to be specified.</p>

<p style="margin-left:11%; margin-top: 1em">Signing
annotated tags during import from within fast&minus;import
is not supported. Trying to include your own PGP/GPG
signature is not recommended, as the frontend does not
(easily) have access to the complete set of bytes which
normally goes into such a signature. If signing is required,
create lightweight tags from within fast&minus;import with
reset, then create the annotated versions of those tags
offline with the standard <i>git tag</i> process.</p>

<p style="margin-left:11%; margin-top: 1em"><b>reset</b>
<br>
Creates (or recreates) the named branch, optionally starting
from a specific revision. The reset command allows a
frontend to issue a new from command for an existing branch,
or to create a new branch from an existing commit without
creating a new commit.</p>

<p style="margin-left:17%; margin-top: 1em">'reset' SP
&lt;ref&gt; LF <br>
('from' SP &lt;committish&gt; LF)? <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">For a detailed
description of &lt;ref&gt; and &lt;committish&gt; see above
under commit and from.</p>

<p style="margin-left:11%; margin-top: 1em">The LF after
the command is optional (it used to be required).</p>

<p style="margin-left:11%; margin-top: 1em">The reset
command can also be used to create lightweight
(non&minus;annotated) tags. For example:</p>

<p style="margin-left:17%; margin-top: 1em">reset
refs/tags/938 <br>
from :938</p>

<p style="margin-left:11%; margin-top: 1em">would create
the lightweight tag refs/tags/938 referring to whatever
commit mark :938 references.</p>

<p style="margin-left:11%; margin-top: 1em"><b>blob</b>
<br>
Requests writing one file revision to the packfile. The
revision is not connected to any commit; this connection
must be formed in a subsequent commit command by referencing
the blob through an assigned mark.</p>

<p style="margin-left:17%; margin-top: 1em">'blob' LF <br>
mark? <br>
data</p>

<p style="margin-left:11%; margin-top: 1em">The mark
command is optional here as some frontends have chosen to
generate the Git SHA&minus;1 for the blob on their own, and
feed that directly to commit. This is typically more work
than it&rsquo;s worth however, as marks are inexpensive to
store and easy to use.</p>

<p style="margin-left:11%; margin-top: 1em"><b>data</b>
<br>
Supplies raw data (for use as blob/file content, commit
messages, or annotated tag messages) to fast&minus;import.
Data can be supplied using an exact byte count or delimited
with a terminating line. Real frontends intended for
production&minus;quality conversions should always use the
exact byte count format, as it is more robust and performs
better. The delimited format is intended primarily for
testing fast&minus;import.</p>

<p style="margin-left:11%; margin-top: 1em">Comment lines
appearing within the &lt;raw&gt; part of data commands are
always taken to be part of the body of the data and are
therefore never ignored by fast&minus;import. This makes it
safe to import any file/message content whose lines might
start with #.</p>

<p style="margin-left:11%; margin-top: 1em">Exact byte
count format</p>

<p style="margin-left:17%;">The frontend must specify the
number of bytes of data.</p>

<p style="margin-left:23%; margin-top: 1em">'data' SP
&lt;count&gt; LF <br>
&lt;raw&gt; LF?</p>

<p style="margin-left:17%; margin-top: 1em">where
&lt;count&gt; is the exact number of bytes appearing within
&lt;raw&gt;. The value of &lt;count&gt; is expressed as an
ASCII decimal integer. The LF on either side of &lt;raw&gt;
is not included in &lt;count&gt; and will not be included in
the imported data.</p>

<p style="margin-left:17%; margin-top: 1em">The LF after
&lt;raw&gt; is optional (it used to be required) but
recommended. Always including it makes debugging a
fast&minus;import stream easier as the next command always
starts in column 0 of the next line, even if &lt;raw&gt; did
not end with an LF.</p>

<p style="margin-left:11%; margin-top: 1em">Delimited
format</p>

<p style="margin-left:17%;">A delimiter string is used to
mark the end of the data. fast&minus;import will compute the
length by searching for the delimiter. This format is
primarily useful for testing and is not recommended for real
data.</p>

<p style="margin-left:23%; margin-top: 1em">'data' SP
'&lt;&lt;' &lt;delim&gt; LF <br>
&lt;raw&gt; LF <br>
&lt;delim&gt; LF <br>
LF?</p>

<p style="margin-left:17%; margin-top: 1em">where
&lt;delim&gt; is the chosen delimiter string. The string
&lt;delim&gt; must not appear on a line by itself within
&lt;raw&gt;, as otherwise fast&minus;import will think the
data ends earlier than it really does. The LF immediately
trailing &lt;raw&gt; is part of &lt;raw&gt;. This is one of
the limitations of the delimited format, it is impossible to
supply a data chunk which does not have an LF as its last
byte.</p>

<p style="margin-left:17%; margin-top: 1em">The LF after
&lt;delim&gt; LF is optional (it used to be required).</p>


<p style="margin-left:11%; margin-top: 1em"><b>checkpoint</b>
<br>
Forces fast&minus;import to close the current packfile,
start a new one, and to save out all current branch refs,
tags and marks.</p>

<p style="margin-left:17%; margin-top: 1em">'checkpoint' LF
<br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">Note that
fast&minus;import automatically switches packfiles when the
current packfile reaches
&minus;&minus;max&minus;pack&minus;size, or 4 GiB, whichever
limit is smaller. During an automatic packfile switch
fast&minus;import does not update the branch refs, tags or
marks.</p>

<p style="margin-left:11%; margin-top: 1em">As a checkpoint
can require a significant amount of CPU time and disk IO (to
compute the overall pack SHA&minus;1 checksum, generate the
corresponding index file, and update the refs) it can easily
take several minutes for a single checkpoint command to
complete.</p>

<p style="margin-left:11%; margin-top: 1em">Frontends may
choose to issue checkpoints during extremely large and long
running imports, or when they need to allow another Git
process access to a branch. However given that a 30 GiB
Subversion repository can be loaded into Git through
fast&minus;import in about 3 hours, explicit checkpointing
may not be necessary.</p>

<p style="margin-left:11%; margin-top: 1em">The LF after
the command is optional (it used to be required).</p>


<p style="margin-left:11%; margin-top: 1em"><b>progress</b>
<br>
Causes fast&minus;import to print the entire progress line
unmodified to its standard output channel (file descriptor
1) when the command is processed from the input stream. The
command otherwise has no impact on the current import, or on
any of fast&minus;import&rsquo;s internal state.</p>

<p style="margin-left:17%; margin-top: 1em">'progress' SP
&lt;any&gt; LF <br>
LF?</p>

<p style="margin-left:11%; margin-top: 1em">The &lt;any&gt;
part of the command may contain any sequence of bytes that
does not contain LF. The LF after the command is optional.
Callers may wish to process the output through a tool such
as sed to remove the leading part of the line, for
example:</p>

<p style="margin-left:17%; margin-top: 1em">frontend | git
fast&minus;import | sed 's/^progress //'</p>

<p style="margin-left:11%; margin-top: 1em">Placing a
progress command immediately after a checkpoint will inform
the reader when the checkpoint has been completed and it can
safely access the refs that fast&minus;import updated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cat&minus;blob</b>
<br>
Causes fast&minus;import to print a blob to a file
descriptor previously arranged with the
&minus;&minus;cat&minus;blob&minus;fd argument. The command
otherwise has no impact on the current import; its main
purpose is to retrieve blobs that may be in
fast&minus;import&rsquo;s memory but not accessible from the
target repository.</p>


<p style="margin-left:17%; margin-top: 1em">'cat&minus;blob'
SP &lt;dataref&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;dataref&gt; can be either a mark reference
(:&lt;idnum&gt;) set previously or a full 40&minus;byte
SHA&minus;1 of a Git blob, preexisting or ready to be
written.</p>

<p style="margin-left:11%; margin-top: 1em">Output uses the
same format as git cat&minus;file &minus;&minus;batch:</p>

<p style="margin-left:17%; margin-top: 1em">&lt;sha1&gt; SP
'blob' SP &lt;size&gt; LF <br>
&lt;contents&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">This command
can be used anywhere in the stream that comments are
accepted. In particular, the cat&minus;blob command can be
used in the middle of a commit but not in the middle of a
data command.</p>

<p style="margin-left:11%; margin-top: 1em">See
&ldquo;Responses To Commands&rdquo; below for details about
how to read this output safely.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ls</b> <br>
Prints information about the object at a path to a file
descriptor previously arranged with the
&minus;&minus;cat&minus;blob&minus;fd argument. This allows
printing a blob from the active commit (with cat&minus;blob)
or copying a blob or tree from a previous commit for use in
the current one (with filemodify).</p>

<p style="margin-left:11%; margin-top: 1em">The ls command
can be used anywhere in the stream that comments are
accepted, including the middle of a commit.</p>

<p style="margin-left:11%; margin-top: 1em">Reading from
the active commit</p>

<p style="margin-left:17%;">This form can only be used in
the middle of a commit. The path names a directory entry
within fast&minus;import&rsquo;s active commit. The path
must be quoted in this case.</p>

<p style="margin-left:23%; margin-top: 1em">'ls' SP
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">Reading from a
named tree</p>

<p style="margin-left:17%;">The &lt;dataref&gt; can be a
mark reference (:&lt;idnum&gt;) or the full 40&minus;byte
SHA&minus;1 of a Git tag, commit, or tree object,
preexisting or waiting to be written. The path is relative
to the top level of the tree named by &lt;dataref&gt;.</p>

<p style="margin-left:23%; margin-top: 1em">'ls' SP
&lt;dataref&gt; SP &lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">See filemodify
above for a detailed description of &lt;path&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Output uses the
same format as git ls&minus;tree &lt;tree&gt; &minus;&minus;
&lt;path&gt;:</p>

<p style="margin-left:17%; margin-top: 1em">&lt;mode&gt; SP
('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;dataref&gt; represents the blob, tree, or commit object
at &lt;path&gt; and can be used in later
<i>cat&minus;blob</i>, <i>filemodify</i>, or <i>ls</i>
commands.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
file or subtree at that path, <i>git fast&minus;import</i>
will instead report</p>

<p style="margin-left:17%; margin-top: 1em">missing SP
&lt;path&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">See
&ldquo;Responses To Commands&rdquo; below for details about
how to read this output safely.</p>

<p style="margin-left:11%; margin-top: 1em"><b>feature</b>
<br>
Require that fast&minus;import supports the specified
feature, or abort if it does not.</p>

<p style="margin-left:17%; margin-top: 1em">'feature' SP
&lt;feature&gt; ('=' &lt;argument&gt;)? LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;feature&gt; part of the command may be any one of the
following:</p>


<p style="margin-left:11%; margin-top: 1em">date&minus;format,
export&minus;marks, relative&minus;marks,
no&minus;relative&minus;marks, force</p>

<p style="margin-left:17%;">Act as though the corresponding
command&minus;line option with a leading
<i>&minus;&minus;</i> was passed on the command line (see
OPTIONS, above).</p>


<p style="margin-left:11%; margin-top: 1em">import&minus;marks,
import&minus;marks&minus;if&minus;exists</p>

<p style="margin-left:17%;">Like
&minus;&minus;import&minus;marks except in two respects:
first, only one &quot;feature import&minus;marks&quot; or
&quot;feature import&minus;marks&minus;if&minus;exists&quot;
command is allowed per stream; second, an
&minus;&minus;import&minus;marks= or
&minus;&minus;import&minus;marks&minus;if&minus;exists
command&minus;line option overrides any of these
&quot;feature&quot; commands in the stream; third,
&quot;feature import&minus;marks&minus;if&minus;exists&quot;
like a corresponding command&minus;line option silently
skips a nonexistent file.</p>


<p style="margin-left:11%; margin-top: 1em">cat&minus;blob,
ls</p>

<p style="margin-left:17%;">Require that the backend
support the <i>cat&minus;blob</i> or <i>ls</i> command.
Versions of fast&minus;import not supporting the specified
command will exit with a message indicating so. This lets
the import error out early with a clear message, rather than
wasting time on the early part of an import before the
unsupported command is detected.</p>

<p style="margin-left:11%; margin-top: 1em">notes</p>

<p style="margin-left:17%;">Require that the backend
support the <i>notemodify</i> (N) subcommand to the
<i>commit</i> command. Versions of fast&minus;import not
supporting notes will exit with a message indicating so.</p>

<p style="margin-left:11%; margin-top: 1em">done</p>

<p style="margin-left:17%;">Error out if the stream ends
without a <i>done</i> command. Without this feature, errors
causing the frontend to end abruptly at a convenient point
in the stream can go undetected. This may occur, for
example, if an import front end dies in mid&minus;operation
without emitting SIGTERM or SIGKILL at its subordinate git
fast&minus;import instance.</p>

<p style="margin-left:11%; margin-top: 1em"><b>option</b>
<br>
Processes the specified option so that git fast&minus;import
behaves in a way that suits the frontend&rsquo;s needs. Note
that options specified by the frontend are overridden by any
options the user may specify to git fast&minus;import
itself.</p>

<p style="margin-left:17%; margin-top: 1em">'option' SP
&lt;option&gt; LF</p>

<p style="margin-left:11%; margin-top: 1em">The
&lt;option&gt; part of the command may contain any of the
options listed in the OPTIONS section that do not change
import semantics, without the leading <i>&minus;&minus;</i>
and is treated in the same way.</p>

<p style="margin-left:11%; margin-top: 1em">Option commands
must be the first commands on the input (not counting
feature commands), to give an option command after any
non&minus;option command is an error.</p>

<p style="margin-left:11%; margin-top: 1em">The following
commandline options change import semantics and may
therefore not be passed as option:</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
date&minus;format</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
import&minus;marks</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
export&minus;marks</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
cat&minus;blob&minus;fd</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
force</p>

<p style="margin-left:11%; margin-top: 1em"><b>done</b>
<br>
If the done feature is not in use, treated as if EOF was
read. This can be used to tell fast&minus;import to finish
early.</p>

<p style="margin-left:11%; margin-top: 1em">If the
&minus;&minus;done command line option or feature done
command is in use, the done command is mandatory and marks
the end of the stream.</p>

<h2>RESPONSES TO COMMANDS
<a name="RESPONSES TO COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">New objects
written by fast&minus;import are not available immediately.
Most fast&minus;import commands have no visible effect until
the next checkpoint (or completion). The frontend can send
commands to fill fast&minus;import&rsquo;s input pipe
without worrying about how quickly they will take effect,
which improves performance by simplifying scheduling.</p>

<p style="margin-left:11%; margin-top: 1em">For some
frontends, though, it is useful to be able to read back data
from the current repository as it is being updated (for
example when the source material describes objects in terms
of patches to be applied to previously imported objects).
This can be accomplished by connecting the frontend and
fast&minus;import via bidirectional pipes:</p>

<p style="margin-left:17%; margin-top: 1em">mkfifo
fast&minus;import&minus;output <br>
frontend &lt;fast&minus;import&minus;output | <br>
git fast&minus;import &gt;fast&minus;import&minus;output</p>

<p style="margin-left:11%; margin-top: 1em">A frontend set
up this way can use progress, ls, and cat&minus;blob
commands to read information from the import in
progress.</p>

<p style="margin-left:11%; margin-top: 1em">To avoid
deadlock, such frontends must completely consume any pending
output from progress, ls, and cat&minus;blob before
performing writes to fast&minus;import that might block.</p>

<h2>CRASH REPORTS
<a name="CRASH REPORTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If
fast&minus;import is supplied invalid input it will
terminate with a non&minus;zero exit status and create a
crash report in the top level of the Git repository it was
importing into. Crash reports contain a snapshot of the
internal fast&minus;import state as well as the most recent
commands that lead up to the crash.</p>

<p style="margin-left:11%; margin-top: 1em">All recent
commands (including stream comments, file changes and
progress commands) are shown in the command history within
the crash report, but raw file data and commit messages are
excluded from the crash report. This exclusion saves space
within the report file and reduces the amount of buffering
that fast&minus;import must perform during execution.</p>

<p style="margin-left:11%; margin-top: 1em">After writing a
crash report fast&minus;import will close the current
packfile and export the marks table. This allows the
frontend developer to inspect the repository state and
resume the import from the point where it crashed. The
modified branches and tags are not updated during a crash,
as the import did not complete successfully. Branch and tag
information can be found in the crash report and must be
applied manually if the update is needed.</p>

<p style="margin-left:11%; margin-top: 1em">An example
crash:</p>

<p style="margin-left:17%; margin-top: 1em">$ cat &gt;in
&lt;&lt;END_OF_INPUT <br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 &minus;0400
<br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
this is my commit <br>
EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
.gitignore <br>
EOF <br>
M 777 inline bob <br>
END_OF_INPUT</p>

<p style="margin-left:17%; margin-top: 1em">$ git
fast&minus;import &lt;in <br>
fatal: Corrupt mode: M 777 inline bob <br>
fast&minus;import: dumping crash report to
.git/fast_import_crash_8434</p>

<p style="margin-left:17%; margin-top: 1em">$ cat
.git/fast_import_crash_8434 <br>
fast&minus;import crash report: <br>
fast&minus;import process: 8434 <br>
parent process : 1391 <br>
at Sat Sep 1 00:58:12 2007</p>

<p style="margin-left:17%; margin-top: 1em">fatal: Corrupt
mode: M 777 inline bob</p>

<p style="margin-left:17%; margin-top: 1em">Most Recent
Commands Before Crash <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
# my very first test commit <br>
commit refs/heads/master <br>
committer Shawn O. Pearce &lt;spearce&gt; 19283 &minus;0400
<br>
# who is that guy anyway? <br>
data &lt;&lt;EOF <br>
M 644 inline .gitignore <br>
data &lt;&lt;EOF <br>
* M 777 inline bob</p>

<p style="margin-left:17%; margin-top: 1em">Active Branch
LRU <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
active_branches = 1 cur, 5 max</p>

<p style="margin-left:17%; margin-top: 1em">pos clock name
<br>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br>
1) 0 refs/heads/master</p>

<p style="margin-left:17%; margin-top: 1em">Inactive
Branches <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
refs/heads/master: <br>
status : active loaded dirty <br>
tip commit : 0000000000000000000000000000000000000000 <br>
old tree : 0000000000000000000000000000000000000000 <br>
cur tree : 0000000000000000000000000000000000000000 <br>
commit clock: 0 <br>
last pack :</p>


<p style="margin-left:17%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
END OF CRASH REPORT</p>

<h2>TIPS AND TRICKS
<a name="TIPS AND TRICKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
tips and tricks have been collected from various users of
fast&minus;import, and are offered here as suggestions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use One Mark
Per Commit</b> <br>
When doing a repository conversion, use a unique mark per
commit (mark :&lt;n&gt;) and supply the
&minus;&minus;export&minus;marks option on the command line.
fast&minus;import will dump a file which lists every mark
and the Git object SHA&minus;1 that corresponds to it. If
the frontend can tie the marks back to the source
repository, it is easy to verify the accuracy and
completeness of the import by comparing each Git commit to
the corresponding source revision.</p>

<p style="margin-left:11%; margin-top: 1em">Coming from a
system such as Perforce or Subversion this should be quite
simple, as the fast&minus;import mark can also be the
Perforce changeset number or the Subversion revision
number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Freely Skip
Around Branches</b> <br>
Don&rsquo;t bother trying to optimize the frontend to stick
to one branch at a time during an import. Although doing so
might be slightly faster for fast&minus;import, it tends to
increase the complexity of the frontend code
considerably.</p>

<p style="margin-left:11%; margin-top: 1em">The branch LRU
builtin to fast&minus;import tends to behave very well, and
the cost of activating an inactive branch is so low that
bouncing around between branches has virtually no impact on
import performance.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Handling
Renames</b> <br>
When importing a renamed file or directory, simply delete
the old name(s) and modify the new name(s) during the
corresponding commit. Git performs rename detection
after&minus;the&minus;fact, rather than explicitly during a
commit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use Tag
Fixup Branches</b> <br>
Some other SCM systems let the user create a tag from
multiple files which are not from the same commit/changeset.
Or to create tags which are a subset of the files available
in the repository.</p>

<p style="margin-left:11%; margin-top: 1em">Importing these
tags as&minus;is in Git is impossible without making at
least one commit which &ldquo;fixes up&rdquo; the files to
match the content of the tag. Use fast&minus;import&rsquo;s
reset command to reset a dummy branch outside of your normal
branch space to the base commit for the tag, then commit one
or more file fixup commits, and finally tag the dummy
branch.</p>

<p style="margin-left:11%; margin-top: 1em">For example
since all normal branches are stored under refs/heads/ name
the tag fixup branch TAG_FIXUP. This way it is impossible
for the fixup branch used by the importer to have namespace
conflicts with real branches imported from the source (the
name TAG_FIXUP is not refs/heads/TAG_FIXUP).</p>

<p style="margin-left:11%; margin-top: 1em">When committing
fixups, consider using merge to connect the commit(s) which
are supplying file revisions to the fixup branch. Doing so
will allow tools such as <i>git blame</i> to track through
the real commit history and properly annotate the source
files.</p>

<p style="margin-left:11%; margin-top: 1em">After
fast&minus;import terminates the frontend will need to do rm
.git/TAG_FIXUP to remove the dummy branch.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Import Now,
Repack Later</b> <br>
As soon as fast&minus;import completes the Git repository is
completely valid and ready for use. Typically this takes
only a very short time, even for considerably large projects
(100,000+ commits).</p>

<p style="margin-left:11%; margin-top: 1em">However
repacking the repository is necessary to improve data
locality and access performance. It can also take hours on
extremely large projects (especially if &minus;f and a large
&minus;&minus;window parameter is used). Since repacking is
safe to run alongside readers and writers, run the repack in
the background and let it finish when it finishes. There is
no reason to wait to explore your new Git project!</p>

<p style="margin-left:11%; margin-top: 1em">If you choose
to wait for the repack, don&rsquo;t try to run benchmarks or
performance tests until repacking is completed.
fast&minus;import outputs suboptimal packfiles that are
simply never seen in real use situations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Repacking
Historical Data</b> <br>
If you are repacking very old imported data (e.g. older than
the last year), consider expending some extra CPU time and
supplying &minus;&minus;window=50 (or higher) when you run
<i>git repack</i>. This will take longer, but will also
produce a smaller packfile. You only need to expend the
effort once, and everyone using your project will benefit
from the smaller repository.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Include Some
Progress Messages</b> <br>
Every once in a while have your frontend emit a progress
message to fast&minus;import. The contents of the messages
are entirely free&minus;form, so one suggestion would be to
output the current month and year each time the current
commit date moves into the next month. Your users will feel
better knowing how much of the data stream has been
processed.</p>

<h2>PACKFILE OPTIMIZATION
<a name="PACKFILE OPTIMIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When packing a
blob fast&minus;import always attempts to deltify against
the last blob written. Unless specifically arranged for by
the frontend, this will probably not be a prior version of
the same file, so the generated delta will not be the
smallest possible. The resulting packfile will be
compressed, but will not be optimal.</p>

<p style="margin-left:11%; margin-top: 1em">Frontends which
have efficient access to all revisions of a single file (for
example reading an RCS/CVS ,v file) can choose to supply all
revisions of that file as a sequence of consecutive blob
commands. This allows fast&minus;import to deltify the
different file revisions against each other, saving space in
the final packfile. Marks can be used to later identify
individual file revisions during a sequence of commit
commands.</p>

<p style="margin-left:11%; margin-top: 1em">The packfile(s)
created by fast&minus;import do not encourage good disk
access patterns. This is caused by fast&minus;import writing
the data in the order it is received on standard input,
while Git typically organizes data within packfiles to make
the most recent (current tip) data appear before historical
data. Git also clusters commits together, speeding up
revision traversal through better cache locality.</p>

<p style="margin-left:11%; margin-top: 1em">For this reason
it is strongly recommended that users repack the repository
with git repack &minus;a &minus;d after fast&minus;import
completes, allowing Git to reorganize the packfiles for
faster data access. If blob deltas are suboptimal (see
above) then also adding the &minus;f option to force
recomputation of all deltas can significantly reduce the
final packfile size (30&minus;50% smaller can be quite
typical).</p>

<h2>MEMORY UTILIZATION
<a name="MEMORY UTILIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a
number of factors which affect how much memory
fast&minus;import requires to perform an import. Like
critical sections of core Git, fast&minus;import uses its
own memory allocators to amortize any overheads associated
with malloc. In practice fast&minus;import tends to amortize
any malloc overheads to 0, due to its use of large block
allocations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per
object</b> <br>
fast&minus;import maintains an in&minus;memory structure for
every object written in this execution. On a 32 bit system
the structure is 32 bytes, on a 64 bit system the structure
is 40 bytes (due to the larger pointer sizes). Objects in
the table are not deallocated until fast&minus;import
terminates. Importing 2 million objects on a 32 bit system
will require approximately 64 MiB of memory.</p>

<p style="margin-left:11%; margin-top: 1em">The object
table is actually a hashtable keyed on the object name (the
unique SHA&minus;1). This storage configuration allows
fast&minus;import to reuse an existing or already written
object and avoid writing duplicates to the output packfile.
Duplicate blobs are surprisingly common in an import,
typically due to branch merges in the source.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per mark</b>
<br>
Marks are stored in a sparse array, using 1 pointer (4 bytes
or 8 bytes, depending on pointer size) per mark. Although
the array is sparse, frontends are still strongly encouraged
to use marks between 1 and n, where n is the total number of
marks required for this import.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per
branch</b> <br>
Branches are classified as active and inactive. The memory
usage of the two classes is significantly different.</p>

<p style="margin-left:11%; margin-top: 1em">Inactive
branches are stored in a structure which uses 96 or 120
bytes (32 bit or 64 bit systems, respectively), plus the
length of the branch name (typically under 200 bytes), per
branch. fast&minus;import will easily handle as many as
10,000 inactive branches in under 2 MiB of memory.</p>

<p style="margin-left:11%; margin-top: 1em">Active branches
have the same overhead as inactive branches, but also
contain copies of every tree that has been recently modified
on that branch. If subtree include has not been modified
since the branch became active, its contents will not be
loaded into memory, but if subtree src has been modified by
a commit since the branch became active, then its contents
will be loaded in memory.</p>

<p style="margin-left:11%; margin-top: 1em">As active
branches store metadata about the files contained on that
branch, their in&minus;memory storage size can grow to a
considerable size (see below).</p>


<p style="margin-left:11%; margin-top: 1em">fast&minus;import
automatically moves active branches to inactive status based
on a simple least&minus;recently&minus;used algorithm. The
LRU chain is updated on each commit command. The maximum
number of active branches can be increased or decreased on
the command line with
&minus;&minus;active&minus;branches=.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per active
tree</b> <br>
Trees (aka directories) use just 12 bytes of memory on top
of the memory required for their entries (see &ldquo;per
active file&rdquo; below). The cost of a tree is virtually
0, as its overhead amortizes out over the individual file
entries.</p>

<p style="margin-left:11%; margin-top: 1em"><b>per active
file entry</b> <br>
Files (and pointers to subtrees) within active trees require
52 or 64 bytes (32/64 bit platforms) per entry. To conserve
space, file and tree names are pooled in a common string
table, allowing the filename &ldquo;Makefile&rdquo; to use
just 16 bytes (after including the string header overhead)
no matter how many times it occurs within the project.</p>

<p style="margin-left:11%; margin-top: 1em">The active
branch LRU, when coupled with the filename string pool and
lazy loading of subtrees, allows fast&minus;import to
efficiently import projects with 2,000+ branches and 45,114+
files in a very limited memory footprint (less than 2.7 MiB
per active branch).</p>

<h2>SIGNALS
<a name="SIGNALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sending
<b>SIGUSR1</b> to the <i>git fast&minus;import</i> process
ends the current packfile early, simulating a checkpoint
command. The impatient operator can use this facility to
peek at the objects and refs from an import in progress, at
the cost of some added running time and worse
compression.</p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Part of the
<b>git</b>(1) suite</p>
<hr>
</body>
</html>
