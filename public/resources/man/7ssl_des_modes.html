<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:24:29 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DES_MODES</title>

</head>
<body>

<h1 align="center">DES_MODES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">des_modes
&minus; the variants of DES and other crypto algorithms of
OpenSSL</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Several crypto
algorithms for OpenSSL can be used in a number of modes.
Those are used for using block ciphers in a way similar to
stream ciphers, among other things.</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Electronic
Codebook Mode ( <small>ECB</small> )</b> <br>
Normally, this is found as the function
<i>algorithm_ecb_encrypt()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>64 bits are enciphered at a time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The order of the blocks can be rearranged without
detection.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The same plaintext block always produces the same
ciphertext block (for the same key) making it vulnerable to
a &rsquo;dictionary attack&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>An error will only affect one ciphertext block.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Cipher Block
Chaining Mode ( <small>CBC</small> )</b> <br>
Normally, this is found as the function
<i>algorithm_cbc_encrypt()</i>. Be aware that
<i>des_cbc_encrypt()</i> is not really <small>DES
CBC</small> (it does not update the <small>IV</small> ); use
<i>des_ncbc_encrypt()</i> instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">a multiple of 64 bits are
enciphered at a time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <small>CBC</small> mode produces the same ciphertext
whenever the same plaintext is encrypted using the same key
and starting variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The chaining operation makes the ciphertext blocks
dependent on the current and all preceding plaintext blocks
and therefore blocks can not be rearranged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The use of different starting variables prevents the
same plaintext enciphering to the same ciphertext.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>An error will affect the current and the following
ciphertext blocks.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Cipher
Feedback Mode ( <small>CFB</small> )</b> <br>
Normally, this is found as the function
<i>algorithm_cfb_encrypt()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">a number of bits (j) &lt;= 64
are enciphered at a time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <small>CFB</small> mode produces the same ciphertext
whenever the same plaintext is encrypted using the same key
and starting variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The chaining operation makes the ciphertext variables
dependent on the current and all preceding variables and
therefore j&minus;bit variables are chained together and can
not be rearranged.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The use of different starting variables prevents the
same plaintext enciphering to the same ciphertext.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The strength of the <small>CFB</small> mode depends on
the size of k (maximal if j == k). In my implementation this
is always the case.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Selection of a small value for j will require more
cycles through the encipherment algorithm per unit of
plaintext and thus cause greater processing overheads.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Only multiples of j bits can be enciphered.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>An error will affect the current and the following
ciphertext variables.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Output
Feedback Mode ( <small>OFB</small> )</b> <br>
Normally, this is found as the function
<i>algorithm_ofb_encrypt()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">a number of bits (j) &lt;= 64
are enciphered at a time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <small>OFB</small> mode produces the same ciphertext
whenever the same plaintext enciphered using the same key
and starting variable. More over, in the <small>OFB</small>
mode the same key stream is produced when the same key and
start variable are used. Consequently, for security reasons
a specific start variable should be used only once for a
given key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The absence of chaining makes the <small>OFB</small>
more vulnerable to specific attacks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The use of different start variables values prevents the
same plaintext enciphering to the same ciphertext, by
producing different key streams.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Selection of a small value for j will require more
cycles through the encipherment algorithm per unit of
plaintext and thus cause greater processing overheads.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Only multiples of j bits can be enciphered.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><small>OFB</small> mode of operation does not extend
ciphertext errors in the resultant plaintext output. Every
bit error in the ciphertext causes only one bit to be in
error in the deciphered plaintext.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><small>OFB</small> mode is not self-synchronizing. If
the two operation of encipherment and decipherment get out
of synchronism, the system needs to be re-initialized.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Each re-initialization should use a value of the start
variable different from the start variable values used
before with the same key. The reason for this is that an
identical bit stream would be produced each time from the
same parameters. This would be susceptible to a &rsquo;known
plaintext&rsquo; attack.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Triple
<small>ECB</small> Mode</b> <br>
Normally, this is found as the function
<i>algorithm_ecb3_encrypt()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Encrypt with key1, decrypt with
key2 and encrypt with key3 again.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>As for <small>ECB</small> encryption but increases the
key length to 168 bits. There are theoretic attacks that can
be used that make the effective key length 112 bits, but
this attack also requires 2^56 blocks of memory, not very
likely, even for the <small>NSA.</small></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If both keys are the same it is equivalent to encrypting
once with just one key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If the first and last key are the same, the key length
is 112 bits. There are attacks that could reduce the
effective key strength to only slightly more than 56 bits,
but these require a lot of memory.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If all 3 keys are the same, this is effectively the same
as normal ecb mode.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Triple
<small>CBC</small> Mode</b> <br>
Normally, this is found as the function
<i>algorithm_ede3_cbc_encrypt()</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Encrypt with key1, decrypt with
key2 and then encrypt with key3.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>As for <small>CBC</small> encryption but increases the
key length to 168 bits with the same restrictions as for
triple ecb mode.</p></td></tr>
</table>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This text was
been written in large parts by Eric Young in his original
documentation for SSLeay, the predecessor of OpenSSL. In
turn, he attributed it to:</p>

<pre style="margin-left:11%; margin-top: 1em">        AS 2805.5.2
        Australian Standard
        Electronic funds transfer &minus; Requirements for interfaces,
        Part 5.2: Modes of operation for an n&minus;bit block cipher algorithm
        Appendix A</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>blowfish</i>(3),
<i>des</i>(3), <i>idea</i>(3), <i>rc2</i>(3)</p>
<hr>
</body>
</html>
