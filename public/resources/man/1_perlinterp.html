<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:15 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLINTERP</title>

</head>
<body>

<h1 align="center">PERLINTERP</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ELEMENTS OF THE INTERPRETER">ELEMENTS OF THE INTERPRETER</a><br>
<a href="#OP TREES">OP TREES</a><br>
<a href="#STACKS">STACKS</a><br>
<a href="#MILLIONS OF MACROS">MILLIONS OF MACROS</a><br>
<a href="#FURTHER READING">FURTHER READING</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlinterp
&minus; An overview of the Perl interpreter</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
provides an overview of how the Perl interpreter works at
the level of C code, along with pointers to the relevant C
source code files.</p>

<h2>ELEMENTS OF THE INTERPRETER
<a name="ELEMENTS OF THE INTERPRETER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The work of the
interpreter has two main stages: compiling the code into the
internal representation, or bytecode, and then executing it.
&quot;Compiled code&quot; in perlguts explains exactly how
the compilation stage happens.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a short
breakdown of perl&rsquo;s operation:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Startup</b>
<br>
The action begins in <i>perlmain.c</i>. (or
<i>miniperlmain.c</i> for miniperl) This is very high-level
code, enough to fit on a single screen, and it resembles the
code found in perlembed; most of the real action takes place
in <i>perl.c</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>perlmain.c</i>
is generated by <tt>&quot;ExtUtils::Miniperl&quot;</tt> from
<i>miniperlmain.c</i> at make time, so you should make perl
to follow this along.</p>

<p style="margin-left:11%; margin-top: 1em">First,
<i>perlmain.c</i> allocates some memory and constructs a
Perl interpreter, along these lines:</p>

<pre style="margin-left:11%; margin-top: 1em">    1 PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
    2
    3 if (!PL_do_undump) {
    4     my_perl = perl_alloc();
    5     if (!my_perl)
    6         exit(1);
    7     perl_construct(my_perl);
    8     PL_perl_destruct_level = 0;
    9 }</pre>


<p style="margin-left:11%; margin-top: 1em">Line 1 is a
macro, and its definition is dependent on your operating
system. Line 3 references <tt>&quot;PL_do_undump&quot;</tt>,
a global variable &minus; all global variables in Perl start
with <tt>&quot;PL_&quot;</tt>. This tells you whether the
current running program was created with the
<tt>&quot;&minus;u&quot;</tt> flag to perl and then
<i>undump</i>, which means it&rsquo;s going to be false in
any sane context.</p>

<p style="margin-left:11%; margin-top: 1em">Line 4 calls a
function in <i>perl.c</i> to allocate memory for a Perl
interpreter. It&rsquo;s quite a simple function, and the
guts of it looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));</pre>


<p style="margin-left:11%; margin-top: 1em">Here you see an
example of Perl&rsquo;s system abstraction, which
we&rsquo;ll see later: <tt>&quot;PerlMem_malloc&quot;</tt>
is either your system&rsquo;s <tt>&quot;malloc&quot;</tt>,
or Perl&rsquo;s own <tt>&quot;malloc&quot;</tt> as defined
in <i>malloc.c</i> if you selected that option at configure
time.</p>

<p style="margin-left:11%; margin-top: 1em">Next, in line
7, we construct the interpreter using perl_construct, also
in <i>perl.c</i>; this sets up all the special variables
that Perl needs, the stacks, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">Now we pass
Perl the command line options, and tell it to go:</p>

<pre style="margin-left:11%; margin-top: 1em"> exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
 if (!exitstatus)
     perl_run(my_perl);
 exitstatus = perl_destruct(my_perl);
 perl_free(my_perl);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;perl_parse&quot;
is actually a wrapper around
<tt>&quot;S_parse_body&quot;</tt>, as defined in
<i>perl.c</i>, which processes the command line options,
sets up any statically linked <small>XS</small> modules,
opens the program and calls <tt>&quot;yyparse&quot;</tt> to
parse it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parsing</b>
<br>
The aim of this stage is to take the Perl source, and turn
it into an op tree. We&rsquo;ll see what one of those looks
like later. Strictly speaking, there&rsquo;s three things
going on here.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;yyparse&quot;</tt>,
the parser, lives in <i>perly.c</i>, although you&rsquo;re
better off reading the original <small>YACC</small> input in
<i>perly.y</i>. (Yes, Virginia, there <b>is</b> a
<small>YACC</small> grammar for Perl!) The job of the parser
is to take your code and &quot;understand&quot; it,
splitting it into sentences, deciding which operands go with
which operators and so on.</p>

<p style="margin-left:11%; margin-top: 1em">The parser is
nobly assisted by the lexer, which chunks up your input into
tokens, and decides what type of thing each token is: a
variable name, an operator, a bareword, a subroutine, a core
function, and so on. The main point of entry to the lexer is
<tt>&quot;yylex&quot;</tt>, and that and its associated
routines can be found in <i>toke.c</i>. Perl isn&rsquo;t
much like other computer languages; it&rsquo;s highly
context sensitive at times, it can be tricky to work out
what sort of token something is, or where a token ends. As
such, there&rsquo;s a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if
you&rsquo;re not used to it.</p>

<p style="margin-left:11%; margin-top: 1em">As the parser
understands a Perl program, it builds up a tree of
operations for the interpreter to perform during execution.
The routines which construct and link together the various
operations are to be found in <i>op.c</i>, and will be
examined later.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Optimization</b>
<br>
Now the parsing stage is complete, and the finished tree
represents the operations that the Perl interpreter needs to
perform to execute our program. Next, Perl does a dry run
over the tree looking for optimisations: constant
expressions such as <tt>&quot;3 + 4&quot;</tt> will be
computed now, and the optimizer will also see if any
multiple operations can be replaced with a single one. For
instance, to fetch the variable <tt>$foo</tt>, instead of
grabbing the glob <tt>*foo</tt> and looking at the scalar
component, the optimizer fiddles the op tree to use a
function which directly looks up the scalar in question. The
main optimizer is <tt>&quot;peep&quot;</tt> in <i>op.c</i>,
and many ops have their own optimizing functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Running</b>
<br>
Now we&rsquo;re finally ready to go: we have compiled Perl
byte code, and all that&rsquo;s left to do is run it. The
actual execution is done by the
<tt>&quot;runops_standard&quot;</tt> function in
<i>run.c</i>; more specifically, it&rsquo;s done by these
three innocent looking lines:</p>

<pre style="margin-left:11%; margin-top: 1em">    while ((PL_op = PL_op&minus;&gt;op_ppaddr(aTHX))) {
        PERL_ASYNC_CHECK();
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You may be more
comfortable with the Perl version of that:</p>

<pre style="margin-left:11%; margin-top: 1em">    PERL_ASYNC_CHECK() while $Perl::op = &amp;{$Perl::op&minus;&gt;{function}};</pre>


<p style="margin-left:11%; margin-top: 1em">Well, maybe
not. Anyway, each op contains a function pointer, which
stipulates the function which will actually carry out the
operation. This function will return the next op in the
sequence &minus; this allows for things like
<tt>&quot;if&quot;</tt> which choose the next op dynamically
at run time. The <tt>&quot;PERL_ASYNC_CHECK&quot;</tt> makes
sure that things like signals interrupt execution if
required.</p>

<p style="margin-left:11%; margin-top: 1em">The actual
functions called are known as <small>PP</small> code, and
they&rsquo;re spread between four files: <i>pp_hot.c</i>
contains the &quot;hot&quot; code, which is most often used
and highly optimized, <i>pp_sys.c</i> contains all the
system-specific functions, <i>pp_ctl.c</i> contains the
functions which implement control structures
(<tt>&quot;if&quot;</tt>, <tt>&quot;while&quot;</tt> and the
like) and <i>pp.c</i> contains everything else. These are,
if you like, the C code for Perl&rsquo;s built-in functions
and operators.</p>

<p style="margin-left:11%; margin-top: 1em">Note that each
<tt>&quot;pp_&quot;</tt> function is expected to return a
pointer to the next op. Calls to perl subs (and eval blocks)
are handled within the same runops loop, and do not consume
extra space on the C stack. For example,
<tt>&quot;pp_entersub&quot;</tt> and
<tt>&quot;pp_entertry&quot;</tt> just push a
<tt>&quot;CxSUB&quot;</tt> or <tt>&quot;CxEVAL&quot;</tt>
block struct onto the context stack which contain the
address of the op following the sub call or eval. They then
return the first op of that sub or eval block, and so
execution continues of that sub or block. Later, a
<tt>&quot;pp_leavesub&quot;</tt> or
<tt>&quot;pp_leavetry&quot;</tt> op pops the
<tt>&quot;CxSUB&quot;</tt> or <tt>&quot;CxEVAL&quot;</tt>,
retrieves the return op from it, and returns it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exception
handing</b> <br>
Perl&rsquo;s exception handing (i.e.
<tt>&quot;die&quot;</tt> etc.) is built on top of the
low-level
<tt>&quot;setjmp()&quot;</tt>/<tt>&quot;longjmp()&quot;</tt>
C&minus;library functions. These basically provide a way to
capture the current <small>PC</small> and <small>SP</small>
registers and later restore them; i.e. a
<tt>&quot;longjmp()&quot;</tt> continues at the point in
code where a previous <tt>&quot;setjmp()&quot;</tt> was
done, with anything further up on the C stack being lost.
This is why code should always save values using
<tt>&quot;SAVE_FOO&quot;</tt> rather than in auto
variables.</p>

<p style="margin-left:11%; margin-top: 1em">The perl core
wraps <tt>&quot;setjmp()&quot;</tt> etc in the macros
<tt>&quot;JMPENV_PUSH&quot;</tt> and
<tt>&quot;JMPENV_JUMP&quot;</tt>. The basic rule of perl
exceptions is that <tt>&quot;exit&quot;</tt>, and
<tt>&quot;die&quot;</tt> (in the absence of
<tt>&quot;eval&quot;</tt>) perform a
<tt>JMPENV_JUMP(2)</tt>, while <tt>&quot;die&quot;</tt>
within <tt>&quot;eval&quot;</tt> does a
<tt>JMPENV_JUMP(3)</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">At entry points
to perl, such as <tt>&quot;perl_parse()&quot;</tt>,
<tt>&quot;perl_run()&quot;</tt> and <tt>&quot;call_sv(cv,
G_EVAL)&quot;</tt> each does a
<tt>&quot;JMPENV_PUSH&quot;</tt>, then enter a runops loop
or whatever, and handle possible exception returns. For a 2
return, final cleanup is performed, such as popping stacks
and calling <tt>&quot;CHECK&quot;</tt> or
<tt>&quot;END&quot;</tt> blocks. Amongst other things, this
is how scope cleanup still occurs during an
<tt>&quot;exit&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If a
<tt>&quot;die&quot;</tt> can find a
<tt>&quot;CxEVAL&quot;</tt> block on the context stack, then
the stack is popped to that level and the return op in that
block is assigned to <tt>&quot;PL_restartop&quot;</tt>; then
a <tt>JMPENV_JUMP(3)</tt> is performed. This normally passes
control back to the guard. In the case of
<tt>&quot;perl_run&quot;</tt> and
<tt>&quot;call_sv&quot;</tt>, a non-null
<tt>&quot;PL_restartop&quot;</tt> triggers re-entry to the
runops loop. The is the normal way that
<tt>&quot;die&quot;</tt> or <tt>&quot;croak&quot;</tt> is
handled within an <tt>&quot;eval&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes ops
are executed within an inner runops loop, such as tie, sort
or overload code. In this case, something like</p>

<pre style="margin-left:11%; margin-top: 1em">    sub FETCH { eval { die } }</pre>


<p style="margin-left:11%; margin-top: 1em">would cause a
longjmp right back to the guard in
<tt>&quot;perl_run&quot;</tt>, popping both runops loops,
which is clearly incorrect. One way to avoid this is for the
tie code to do a <tt>&quot;JMPENV_PUSH&quot;</tt> before
executing <tt>&quot;FETCH&quot;</tt> in the inner runops
loop, but for efficiency reasons, perl in fact just sets a
flag, using <tt>&quot;CATCH_SET(TRUE)&quot;</tt>. The
<tt>&quot;pp_require&quot;</tt>,
<tt>&quot;pp_entereval&quot;</tt> and
<tt>&quot;pp_entertry&quot;</tt> ops check this flag, and if
true, they call <tt>&quot;docatch&quot;</tt>, which does a
<tt>&quot;JMPENV_PUSH&quot;</tt> and starts a new runops
level to execute the code, rather than doing it on the
current loop.</p>

<p style="margin-left:11%; margin-top: 1em">As a further
optimisation, on exit from the eval block in the
<tt>&quot;FETCH&quot;</tt>, execution of the code following
the block is still carried on in the inner loop. When an
exception is raised, <tt>&quot;docatch&quot;</tt> compares
the <tt>&quot;JMPENV&quot;</tt> level of the
<tt>&quot;CxEVAL&quot;</tt> with
<tt>&quot;PL_top_env&quot;</tt> and if they differ, just
re-throws the exception. In this way any inner loops get
popped.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example.</p>

<pre style="margin-left:11%; margin-top: 1em">    1: eval { tie @a, 'A' };
    2: sub A::TIEARRAY {
    3:     eval { die };
    4:     die;
    5: }</pre>


<p style="margin-left:11%; margin-top: 1em">To run this
code, <tt>&quot;perl_run&quot;</tt> is called, which does a
<tt>&quot;JMPENV_PUSH&quot;</tt> then enters a runops loop.
This loop executes the eval and tie ops on line 1, with the
eval pushing a <tt>&quot;CxEVAL&quot;</tt> onto the context
stack.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;pp_tie&quot;</tt> does a
<tt>&quot;CATCH_SET(TRUE)&quot;</tt>, then starts a second
runops loop to execute the body of
<tt>&quot;TIEARRAY&quot;</tt>. When it executes the entertry
op on line 3, <tt>&quot;CATCH_GET&quot;</tt> is true, so
<tt>&quot;pp_entertry&quot;</tt> calls
<tt>&quot;docatch&quot;</tt> which does a
<tt>&quot;JMPENV_PUSH&quot;</tt> and starts a third runops
loop, which then executes the die op. At this point the C
call stack looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    Perl_pp_die
    Perl_runops      # third loop
    S_docatch_body
    S_docatch
    Perl_pp_entertry
    Perl_runops      # second loop
    S_call_body
    Perl_call_sv
    Perl_pp_tie
    Perl_runops      # first loop
    S_run_body
    perl_run
    main</pre>


<p style="margin-left:11%; margin-top: 1em">and the context
and data stacks, as shown by
<tt>&quot;&minus;Dstv&quot;</tt>, look like:</p>

<pre style="margin-left:11%; margin-top: 1em">    STACK 0: MAIN
      CX 0: BLOCK  =&gt;
      CX 1: EVAL   =&gt; AV()  PV(&quot;A&quot;\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =&gt;
      retop=(null)
      CX 1: EVAL   =&gt; *
    retop=nextstate</pre>


<p style="margin-left:11%; margin-top: 1em">The die pops
the first <tt>&quot;CxEVAL&quot;</tt> off the context stack,
sets <tt>&quot;PL_restartop&quot;</tt> from it, does a
<tt>JMPENV_JUMP(3)</tt>, and control returns to the top
<tt>&quot;docatch&quot;</tt>. This then starts another
third-level runops level, which executes the nextstate,
pushmark and die ops on line 4. At the point that the second
<tt>&quot;pp_die&quot;</tt> is called, the C call stack
looks exactly like that above, even though we are no longer
within an inner eval; this is because of the optimization
mentioned earlier. However, the context stack now looks like
this, ie with the top CxEVAL popped:</p>

<pre style="margin-left:11%; margin-top: 1em">    STACK 0: MAIN
      CX 0: BLOCK  =&gt;
      CX 1: EVAL   =&gt; AV()  PV(&quot;A&quot;\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =&gt;
      retop=(null)</pre>


<p style="margin-left:11%; margin-top: 1em">The die on line
4 pops the context stack back down to the CxEVAL, leaving it
as:</p>

<pre style="margin-left:11%; margin-top: 1em">    STACK 0: MAIN
      CX 0: BLOCK  =&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">As usual,
<tt>&quot;PL_restartop&quot;</tt> is extracted from the
<tt>&quot;CxEVAL&quot;</tt>, and a <tt>JMPENV_JUMP(3)</tt>
done, which pops the C stack back to the docatch:</p>

<pre style="margin-left:11%; margin-top: 1em">    S_docatch
    Perl_pp_entertry
    Perl_runops      # second loop
    S_call_body
    Perl_call_sv
    Perl_pp_tie
    Perl_runops      # first loop
    S_run_body
    perl_run
    main</pre>


<p style="margin-left:11%; margin-top: 1em">In this case,
because the <tt>&quot;JMPENV&quot;</tt> level recorded in
the <tt>&quot;CxEVAL&quot;</tt> differs from the current
one, <tt>&quot;docatch&quot;</tt> just does a
<tt>JMPENV_JUMP(3)</tt> and the C stack unwinds to:</p>

<pre style="margin-left:11%; margin-top: 1em">    perl_run
    main</pre>


<p style="margin-left:11%; margin-top: 1em">Because
<tt>&quot;PL_restartop&quot;</tt> is non-null,
<tt>&quot;run_body&quot;</tt> starts a new runops loop and
execution continues.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>INTERNAL
VARIABLE TYPES</small></b> <br>
You should by now have had a look at perlguts, which tells
you about Perl&rsquo;s internal variable types: SVs, HVs,
AVs and the rest. If not, do that now.</p>

<p style="margin-left:11%; margin-top: 1em">These variables
are used not only to represent Perl-space variables, but
also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance,
is an ordinary Perl hash. Your code is represented by an
<small>SV</small> as it&rsquo;s read into the parser; any
program files you call are opened via ordinary Perl
filehandles, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">The core
Devel::Peek module lets us examine SVs from a Perl program.
Let&rsquo;s see, for instance, how Perl treats the constant
<tt>&quot;hello&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">      % perl &minus;MDevel::Peek &minus;e 'Dump(&quot;hello&quot;)'
    1 SV = PV(0xa041450) at 0xa04ecbc
    2   REFCNT = 1
    3   FLAGS = (POK,READONLY,pPOK)
    4   PV = 0xa0484e0 &quot;hello&quot;\0
    5   CUR = 5
    6   LEN = 6</pre>


<p style="margin-left:11%; margin-top: 1em">Reading
<tt>&quot;Devel::Peek&quot;</tt> output takes a bit of
practise, so let&rsquo;s go through it line by line.</p>

<p style="margin-left:11%; margin-top: 1em">Line 1 tells us
we&rsquo;re looking at an <small>SV</small> which lives at
<tt>0xa04ecbc</tt> in memory. SVs themselves are very simple
structures, but they contain a pointer to a more complex
structure. In this case, it&rsquo;s a <small>PV</small> , a
structure which holds a string value, at location
<tt>0xa041450</tt>. Line 2 is the reference count; there are
no other references to this data, so it&rsquo;s 1.</p>

<p style="margin-left:11%; margin-top: 1em">Line 3 are the
flags for this <small>SV</small> &minus; it&rsquo;s
<small>OK</small> to use it as a <small>PV</small> ,
it&rsquo;s a read-only <small>SV</small> (because it&rsquo;s
a constant) and the data is a <small>PV</small> internally.
Next we&rsquo;ve got the contents of the string, starting at
location <tt>0xa0484e0</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Line 5 gives us
the current length of the string &minus; note that this does
<b>not</b> include the null terminator. Line 6 is not the
length of the string, but the length of the currently
allocated buffer; as the string grows, Perl automatically
extends the available storage via a routine called
<tt>&quot;SvGROW&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">You can get at
any of these quantities from C very easily; just add
<tt>&quot;Sv&quot;</tt> to the name of the field shown in
the snippet, and you&rsquo;ve got a macro which will return
the value: <tt>&quot;SvCUR(sv)&quot;</tt> returns the
current length of the string,
<tt>&quot;SvREFCOUNT(sv)&quot;</tt> returns the reference
count, <tt>&quot;SvPV(sv, len)&quot;</tt> returns the string
itself with its length, and so on. More macros to manipulate
these properties can be found in perlguts.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
take an example of manipulating a <small>PV</small> , from
<tt>&quot;sv_catpvn&quot;</tt>, in <i>sv.c</i></p>

<pre style="margin-left:11%; margin-top: 1em">     1  void
     2  Perl_sv_catpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
     3  {
     4      STRLEN tlen;
     5      char *junk;
     6      junk = SvPV_force(sv, tlen);
     7      SvGROW(sv, tlen + len + 1);
     8      if (ptr == junk)
     9          ptr = SvPVX(sv);
    10      Move(ptr,SvPVX(sv)+tlen,len,char);
    11      SvCUR(sv) += len;
    12      *SvEND(sv) = '\0';
    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
    14      SvTAINT(sv);
    15  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is a
function which adds a string, <tt>&quot;ptr&quot;</tt>, of
length <tt>&quot;len&quot;</tt> onto the end of the
<small>PV</small> stored in <tt>&quot;sv&quot;</tt>. The
first thing we do in line 6 is make sure that the
<small>SV</small> <b>has</b> a valid <small>PV</small> , by
calling the <tt>&quot;SvPV_force&quot;</tt> macro to force a
<small>PV</small> . As a side effect,
<tt>&quot;tlen&quot;</tt> gets set to the current value of
the <small>PV</small> , and the <small>PV</small> itself is
returned to <tt>&quot;junk&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In line 7, we
make sure that the <small>SV</small> will have enough room
to accommodate the old string, the new string and the null
terminator. If <tt>&quot;LEN&quot;</tt> isn&rsquo;t big
enough, <tt>&quot;SvGROW&quot;</tt> will reallocate space
for us.</p>

<p style="margin-left:11%; margin-top: 1em">Now, if
<tt>&quot;junk&quot;</tt> is the same as the string
we&rsquo;re trying to add, we can grab the string directly
from the <small>SV</small> ; <tt>&quot;SvPVX&quot;</tt> is
the address of the <small>PV</small> in the
<small>SV</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Line 10 does
the actual catenation: the <tt>&quot;Move&quot;</tt> macro
moves a chunk of memory around: we move the string
<tt>&quot;ptr&quot;</tt> to the end of the <small>PV</small>
&minus; that&rsquo;s the start of the <small>PV</small> plus
its current length. We&rsquo;re moving
<tt>&quot;len&quot;</tt> bytes of type
<tt>&quot;char&quot;</tt>. After doing so, we need to tell
Perl we&rsquo;ve extended the string, by altering
<tt>&quot;CUR&quot;</tt> to reflect the new length.
<tt>&quot;SvEND&quot;</tt> is a macro which gives us the end
of the string, so that needs to be a
<tt>&quot;\0&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Line 13
manipulates the flags; since we&rsquo;ve changed the
<small>PV</small> , any <small>IV</small> or
<small>NV</small> values will no longer be valid: if we have
<tt>&quot;$a=10; $a.=&quot;6&quot;;&quot;</tt> we
don&rsquo;t want to use the old <small>IV</small> of 10.
<tt>&quot;SvPOK_only_utf8&quot;</tt> is a special
UTF&minus;8&minus;aware version of
<tt>&quot;SvPOK_only&quot;</tt>, a macro which turns off the
<small>IOK</small> and <small>NOK</small> flags and turns on
<small>POK</small> . The final <tt>&quot;SvTAINT&quot;</tt>
is a macro which launders tainted data if taint mode is
turned on.</p>

<p style="margin-left:11%; margin-top: 1em">AVs and HVs are
more complicated, but SVs are by far the most common
variable type being thrown around. Having seen something of
how we manipulate these, let&rsquo;s go on and look at how
the op tree is constructed.</p>

<h2>OP TREES
<a name="OP TREES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">First, what is
the op tree, anyway? The op tree is the parsed
representation of your program, as we saw in our section on
parsing, and it&rsquo;s the sequence of operations that Perl
goes through to execute your program, as we saw in
&quot;Running&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">An op is a
fundamental operation that Perl can perform: all the
built-in functions and operators are ops, and there are a
series of ops which deal with concepts the interpreter needs
internally &minus; entering and leaving a block, ending a
statement, fetching a variable, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">The op tree is
connected in two ways: you can imagine that there are two
&quot;routes&quot; through it, two orders in which you can
traverse the tree. First, parse order reflects how the
parser understood the code, and secondly, execution order
tells perl what order to perform the operations in.</p>

<p style="margin-left:11%; margin-top: 1em">The easiest way
to examine the op tree is to stop Perl after it has finished
parsing, and get it to dump out the tree. This is exactly
what the compiler backends B::Terse, B::Concise and B::Debug
do.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
have a look at how Perl sees <tt>&quot;$a = $b +
$c&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">     % perl &minus;MO=Terse &minus;e '$a=$b+$c'
     1  LISTOP (0x8179888) leave
     2      OP (0x81798b0) enter
     3      COP (0x8179850) nextstate
     4      BINOP (0x8179828) sassign
     5          BINOP (0x8179800) add [1]
     6              UNOP (0x81796e0) null [15]
     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
     8              UNOP (0x81797e0) null [15]
     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
    10          UNOP (0x816b4f0) null [15]
    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a</pre>


<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
start in the middle, at line 4. This is a
<small>BINOP</small> , a binary operator, which is at
location <tt>0x8179828</tt>. The specific operator in
question is <tt>&quot;sassign&quot;</tt> &minus; scalar
assignment &minus; and you can find the code which
implements it in the function
<tt>&quot;pp_sassign&quot;</tt> in <i>pp_hot.c</i>. As a
binary operator, it has two children: the add operator,
providing the result of <tt>&quot;$b+$c&quot;</tt>, is
uppermost on line 5, and the left hand side is on line
10.</p>

<p style="margin-left:11%; margin-top: 1em">Line 10 is the
null op: this does exactly nothing. What is that doing
there? If you see the null op, it&rsquo;s a sign that
something has been optimized away after parsing. As we
mentioned in &quot;Optimization&quot;, the optimization
stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens,
instead of rewriting the op tree and cleaning up the
dangling pointers, it&rsquo;s easier just to replace the
redundant operation with the null op. Originally, the tree
would have looked like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    10          SVOP (0x816b4f0) rv2sv [15]
    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a</pre>


<p style="margin-left:11%; margin-top: 1em">That is, fetch
the <tt>&quot;a&quot;</tt> entry from the main symbol table,
and then look at the scalar component of it:
<tt>&quot;gvsv&quot;</tt> (<tt>&quot;pp_gvsv&quot;</tt> into
<i>pp_hot.c</i>) happens to do both these things.</p>

<p style="margin-left:11%; margin-top: 1em">The right hand
side, starting at line 5 is similar to what we&rsquo;ve just
seen: we have the <tt>&quot;add&quot;</tt> op
(<tt>&quot;pp_add&quot;</tt> also in <i>pp_hot.c</i>) add
together two <tt>&quot;gvsv&quot;</tt>s.</p>

<p style="margin-left:11%; margin-top: 1em">Now,
what&rsquo;s this about?</p>

<pre style="margin-left:11%; margin-top: 1em">     1  LISTOP (0x8179888) leave
     2      OP (0x81798b0) enter
     3      COP (0x8179850) nextstate</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;enter&quot;
and <tt>&quot;leave&quot;</tt> are scoping ops, and their
job is to perform any housekeeping every time you enter and
leave a block: lexical variables are tidied up, unreferenced
variables are destroyed, and so on. Every program will have
those first three lines: <tt>&quot;leave&quot;</tt> is a
list, and its children are all the statements in the block.
Statements are delimited by <tt>&quot;nextstate&quot;</tt>,
so a block is a collection of <tt>&quot;nextstate&quot;</tt>
ops, with the ops to be performed for each statement being
the children of <tt>&quot;nextstate&quot;</tt>.
<tt>&quot;enter&quot;</tt> is a single op which functions as
a marker.</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
how Perl parsed the program, from top to bottom:</p>

<pre style="margin-left:11%; margin-top: 1em">                        Program
                           |
                       Statement
                           |
                           =
                          / \
                         /   \
                        $a   +
                            / \
                          $b   $c</pre>


<p style="margin-left:11%; margin-top: 1em">However,
it&rsquo;s impossible to <b>perform</b> the operations in
this order: you have to find the values of <tt>$b</tt> and
<tt>$c</tt> before you add them together, for instance. So,
the other thread that runs through the op tree is the
execution order: each op has a field
<tt>&quot;op_next&quot;</tt> which points to the next op to
be run, so following these pointers tells us how perl
executes the code. We can traverse the tree in this order
using the <tt>&quot;exec&quot;</tt> option to
<tt>&quot;B::Terse&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">     % perl &minus;MO=Terse,exec &minus;e '$a=$b+$c'
     1  OP (0x8179928) enter
     2  COP (0x81798c8) nextstate
     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
     5  BINOP (0x8179878) add [1]
     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
     7  BINOP (0x81798a0) sassign
     8  LISTOP (0x8179900) leave</pre>


<p style="margin-left:11%; margin-top: 1em">This probably
makes more sense for a human: enter a block, start a
statement. Get the values of <tt>$b</tt> and <tt>$c</tt>,
and add them together. Find <tt>$a</tt>, and assign one to
the other. Then leave.</p>

<p style="margin-left:11%; margin-top: 1em">The way Perl
builds up these op trees in the parsing process can be
unravelled by examining <i>perly.y</i>, the
<small>YACC</small> grammar. Let&rsquo;s take the piece we
need to construct the tree for <tt>&quot;$a = $b +
$c&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><tt>1 term :
term ASSIGNOP term <br>
2 { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); } <br>
3 | term ADDOP term <br>
4 { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }</tt></p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
not used to reading <small>BNF</small> grammars, this is how
it works: You&rsquo;re fed certain things by the tokeniser,
which generally end up in upper case. Here,
<tt>&quot;ADDOP&quot;</tt>, is provided when the tokeniser
sees <tt>&quot;+&quot;</tt> in your code.
<tt>&quot;ASSIGNOP&quot;</tt> is provided when
<tt>&quot;=&quot;</tt> is used for assigning. These are
&quot;terminal symbols&quot;, because you can&rsquo;t get
any simpler than them.</p>

<p style="margin-left:11%; margin-top: 1em">The grammar,
lines one and three of the snippet above, tells you how to
build up more complex forms. These complex forms,
&quot;non-terminal symbols&quot; are generally placed in
lower case. <tt>&quot;term&quot;</tt> here is a non-terminal
symbol, representing a single expression.</p>

<p style="margin-left:11%; margin-top: 1em">The grammar
gives you the following rule: you can make the thing on the
left of the colon if you see all the things on the right in
sequence. This is called a &quot;reduction&quot;, and the
aim of parsing is to completely reduce the input. There are
several different ways you can perform a reduction,
separated by vertical bars: so, <tt>&quot;term&quot;</tt>
followed by <tt>&quot;=&quot;</tt> followed by
<tt>&quot;term&quot;</tt> makes a <tt>&quot;term&quot;</tt>,
and <tt>&quot;term&quot;</tt> followed by
<tt>&quot;+&quot;</tt> followed by <tt>&quot;term&quot;</tt>
can also make a <tt>&quot;term&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">So, if you see
two terms with an <tt>&quot;=&quot;</tt> or
<tt>&quot;+&quot;</tt>, between them, you can turn them into
a single expression. When you do this, you execute the code
in the block on the next line: if you see
<tt>&quot;=&quot;</tt>, you&rsquo;ll do the code in line 2.
If you see <tt>&quot;+&quot;</tt>, you&rsquo;ll do the code
in line 4. It&rsquo;s this code which contributes to the op
tree.</p>

<pre style="margin-left:11%; margin-top: 1em">            |   term ADDOP term
            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }</pre>


<p style="margin-left:11%; margin-top: 1em">What this does
is creates a new binary op, and feeds it a number of
variables. The variables refer to the tokens: <tt>$1</tt> is
the first token in the input, <tt>$2</tt> the second, and so
on &minus; think regular expression backreferences.
<tt>$$</tt> is the op returned from this reduction. So, we
call <tt>&quot;newBINOP&quot;</tt> to create a new binary
operator. The first parameter to
<tt>&quot;newBINOP&quot;</tt>, a function in <i>op.c</i>, is
the op type. It&rsquo;s an addition operator, so we want the
type to be <tt>&quot;ADDOP&quot;</tt>. We could specify this
directly, but it&rsquo;s right there as the second token in
the input, so we use <tt>$2</tt>. The second parameter is
the op&rsquo;s flags: 0 means &quot;nothing special&quot;.
Then the things to add: the left and right hand side of our
expression, in scalar context.</p>

<h2>STACKS
<a name="STACKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When perl
executes something like <tt>&quot;addop&quot;</tt>, how does
it pass on its results to the next op? The answer is,
through the use of stacks. Perl has a number of stacks to
store things it&rsquo;s currently working on, and
we&rsquo;ll look at the three most important ones here.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Argument
stack</b> <br>
Arguments are passed to <small>PP</small> code and returned
from <small>PP</small> code using the argument stack,
<tt>&quot;ST&quot;</tt>. The typical way to handle arguments
is to pop them off the stack, deal with them how you wish,
and then push the result back onto the stack. This is how,
for instance, the cosine operator works:</p>

<pre style="margin-left:11%; margin-top: 1em">      NV value;
      value = POPn;
      value = Perl_cos(value);
      XPUSHn(value);</pre>


<p style="margin-left:11%; margin-top: 1em">We&rsquo;ll see
a more tricky example of this when we consider Perl&rsquo;s
macros below. <tt>&quot;POPn&quot;</tt> gives you the
<small>NV</small> (floating point value) of the top
<small>SV</small> on the stack: the <tt>$x</tt> in
<tt>&quot;cos($x)&quot;</tt>. Then we compute the cosine,
and push the result back as an <small>NV</small> . The
<tt>&quot;X&quot;</tt> in <tt>&quot;XPUSHn&quot;</tt> means
that the stack should be extended if necessary &minus; it
can&rsquo;t be necessary here, because we know there&rsquo;s
room for one more item on the stack, since we&rsquo;ve just
removed one! The <tt>&quot;XPUSH*&quot;</tt> macros at least
guarantee safety.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
you can fiddle with the stack directly:
<tt>&quot;SP&quot;</tt> gives you the first element in your
portion of the stack, and <tt>&quot;TOP*&quot;</tt> gives
you the top SV/IV/NV/etc. on the stack. So, for instance, to
do unary negation of an integer:</p>

<pre style="margin-left:11%; margin-top: 1em">     SETi(&minus;TOPi);</pre>


<p style="margin-left:11%; margin-top: 1em">Just set the
integer value of the top stack entry to its negation.</p>

<p style="margin-left:11%; margin-top: 1em">Argument stack
manipulation in the core is exactly the same as it is in
XSUBs &minus; see perlxstut, perlxs and perlguts for a
longer description of the macros used in stack
manipulation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mark
stack</b> <br>
I say &quot;your portion of the stack&quot; above because
<small>PP</small> code doesn&rsquo;t necessarily get the
whole stack to itself: if your function calls another
function, you&rsquo;ll only want to expose the arguments
aimed for the called function, and not (necessarily) let it
get at your own data. The way we do this is to have a
&quot;virtual&quot; bottom-of-stack, exposed to each
function. The mark stack keeps bookmarks to locations in the
argument stack usable by each function. For instance, when
dealing with a tied variable, (internally, something with
&quot;P&quot; magic) Perl has to call methods for accesses
to the tied variables. However, we need to separate the
arguments exposed to the method to the argument exposed to
the original function &minus; the store or fetch or whatever
it may be. Here&rsquo;s roughly how the tied
<tt>&quot;push&quot;</tt> is implemented; see
<tt>&quot;av_push&quot;</tt> in <i>av.c</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">     1  PUSHMARK(SP);
     2  EXTEND(SP,2);
     3  PUSHs(SvTIED_obj((SV*)av, mg));
     4  PUSHs(val);
     5  PUTBACK;
     6  ENTER;
     7  call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD);
     8  LEAVE;</pre>


<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
examine the whole implementation, for practice:</p>

<pre style="margin-left:11%; margin-top: 1em">     1  PUSHMARK(SP);</pre>


<p style="margin-left:11%; margin-top: 1em">Push the
current state of the stack pointer onto the mark stack. This
is so that when we&rsquo;ve finished adding items to the
argument stack, Perl knows how many things we&rsquo;ve added
recently.</p>

<pre style="margin-left:11%; margin-top: 1em">     2  EXTEND(SP,2);
     3  PUSHs(SvTIED_obj((SV*)av, mg));
     4  PUSHs(val);</pre>


<p style="margin-left:11%; margin-top: 1em">We&rsquo;re
going to add two more items onto the argument stack: when
you have a tied array, the <tt>&quot;PUSH&quot;</tt>
subroutine receives the object and the value to be pushed,
and that&rsquo;s exactly what we have here &minus; the tied
object, retrieved with <tt>&quot;SvTIED_obj&quot;</tt>, and
the value, the <small>SV</small>
<tt>&quot;val&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">     5  PUTBACK;</pre>


<p style="margin-left:11%; margin-top: 1em">Next we tell
Perl to update the global stack pointer from our internal
variable: <tt>&quot;dSP&quot;</tt> only gave us a local
copy, not a reference to the global.</p>

<pre style="margin-left:11%; margin-top: 1em">     6  ENTER;
     7  call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD);
     8  LEAVE;</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;ENTER&quot;
and <tt>&quot;LEAVE&quot;</tt> localise a block of code
&minus; they make sure that all variables are tidied up,
everything that has been localised gets its previous value
returned, and so on. Think of them as the
<tt>&quot;{&quot;</tt> and <tt>&quot;}&quot;</tt> of a Perl
block.</p>

<p style="margin-left:11%; margin-top: 1em">To actually do
the magic method call, we have to call a subroutine in Perl
space: <tt>&quot;call_method&quot;</tt> takes care of that,
and it&rsquo;s described in perlcall. We call the
<tt>&quot;PUSH&quot;</tt> method in scalar context, and
we&rsquo;re going to discard its return value. The
<i>call_method()</i> function removes the top element of the
mark stack, so there is nothing for the caller to clean
up.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Save
stack</b> <br>
C doesn&rsquo;t have a concept of local scope, so perl
provides one. We&rsquo;ve seen that
<tt>&quot;ENTER&quot;</tt> and <tt>&quot;LEAVE&quot;</tt>
are used as scoping braces; the save stack implements the C
equivalent of, for example:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
        local $foo = 42;
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">See
&quot;Localizing changes&quot; in perlguts for how to use
the save stack.</p>

<h2>MILLIONS OF MACROS
<a name="MILLIONS OF MACROS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One thing
you&rsquo;ll notice about the Perl source is that it&rsquo;s
full of macros. Some have called the pervasive use of macros
the hardest thing to understand, others find it adds to
clarity. Let&rsquo;s take an example, the code which
implements the addition operator:</p>

<pre style="margin-left:11%; margin-top: 1em">   1  PP(pp_add)
   2  {
   3      dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
   4      {
   5        dPOPTOPnnrl_ul;
   6        SETn( left + right );
   7        RETURN;
   8      }
   9  }</pre>


<p style="margin-left:11%; margin-top: 1em">Every line here
(apart from the braces, of course) contains a macro. The
first line sets up the function declaration as Perl expects
for <small>PP</small> code; line 3 sets up variable
declarations for the argument stack and the target, the
return value of the operation. Finally, it tries to see if
the addition operation is overloaded; if so, the appropriate
subroutine is called.</p>

<p style="margin-left:11%; margin-top: 1em">Line 5 is
another variable declaration &minus; all variable
declarations start with <tt>&quot;d&quot;</tt> &minus; which
pops from the top of the argument stack two NVs (hence
<tt>&quot;nn&quot;</tt>) and puts them into the variables
<tt>&quot;right&quot;</tt> and <tt>&quot;left&quot;</tt>,
hence the <tt>&quot;rl&quot;</tt>. These are the two
operands to the addition operator. Next, we call
<tt>&quot;SETn&quot;</tt> to set the <small>NV</small> of
the return value to the result of adding the two values.
This done, we return &minus; the <tt>&quot;RETURN&quot;</tt>
macro makes sure that our return value is properly handled,
and we pass the next operator to run back to the main run
loop.</p>

<p style="margin-left:11%; margin-top: 1em">Most of these
macros are explained in perlapi, and some of the more
important ones are explained in perlxs as well. Pay special
attention to &quot;Background and
<small>PERL_IMPLICIT_CONTEXT</small> &quot; in perlguts for
information on the <tt>&quot;[pad]THX_?&quot;</tt>
macros.</p>

<h2>FURTHER READING
<a name="FURTHER READING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For more
information on the Perl internals, please see the documents
listed at &quot;Internals and C Language Interface&quot; in
perl.</p>
<hr>
</body>
</html>
