<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:58:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT&minus;REBASE</title>

</head>
<body>

<h1 align="center">GIT&minus;REBASE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFIGURATION">CONFIGURATION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#MERGE STRATEGIES">MERGE STRATEGIES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#INTERACTIVE MODE">INTERACTIVE MODE</a><br>
<a href="#SPLITTING COMMITS">SPLITTING COMMITS</a><br>
<a href="#RECOVERING FROM UPSTREAM REBASE">RECOVERING FROM UPSTREAM REBASE</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#GIT">GIT</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-rebase
&minus; Forward&minus;port local commits to the updated
upstream head</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git
rebase</i> [&minus;i | &minus;&minus;interactive] [options]
[&minus;&minus;exec &lt;cmd&gt;] [&minus;&minus;onto
&lt;newbase&gt;] <br>
[&lt;upstream&gt;] [&lt;branch&gt;] <i><br>
git rebase</i> [&minus;i | &minus;&minus;interactive]
[options] [&minus;&minus;exec &lt;cmd&gt;]
[&minus;&minus;onto &lt;newbase&gt;] <br>
&minus;&minus;root [&lt;branch&gt;] <i><br>
git rebase</i> &minus;&minus;continue | &minus;&minus;skip |
&minus;&minus;abort | &minus;&minus;edit&minus;todo</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If
&lt;branch&gt; is specified, <i>git rebase</i> will perform
an automatic git checkout &lt;branch&gt; before doing
anything else. Otherwise it remains on the current
branch.</p>

<p style="margin-left:11%; margin-top: 1em">If
&lt;upstream&gt; is not specified, the upstream configured
in branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge
options will be used; see <b>git-config</b>(1) for details.
If you are currently not on any branch or if the current
branch does not have a configured upstream, the rebase will
abort.</p>

<p style="margin-left:11%; margin-top: 1em">All changes
made by commits in the current branch but that are not in
&lt;upstream&gt; are saved to a temporary area. This is the
same set of commits that would be shown by git log
&lt;upstream&gt;..HEAD (or git log HEAD, if
&minus;&minus;root is specified).</p>

<p style="margin-left:11%; margin-top: 1em">The current
branch is reset to &lt;upstream&gt;, or &lt;newbase&gt; if
the &minus;&minus;onto option was supplied. This has the
exact same effect as git reset &minus;&minus;hard
&lt;upstream&gt; (or &lt;newbase&gt;). ORIG_HEAD is set to
point at the tip of the branch before the reset.</p>

<p style="margin-left:11%; margin-top: 1em">The commits
that were previously saved into the temporary area are then
reapplied to the current branch, one by one, in order. Note
that any commits in HEAD which introduce the same textual
changes as a commit in HEAD..&lt;upstream&gt; are omitted
(i.e., a patch already accepted upstream with a different
commit message or timestamp will be skipped).</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
that a merge failure will prevent this process from being
completely automatic. You will have to resolve any such
merge failure and run git rebase &minus;&minus;continue.
Another option is to bypass the commit that caused the merge
failure with git rebase &minus;&minus;skip. To check out the
original &lt;branch&gt; and remove the
.git/rebase&minus;apply working files, use the command git
rebase &minus;&minus;abort instead.</p>

<p style="margin-left:11%; margin-top: 1em">Assume the
following history exists and the current branch is
&quot;topic&quot;:</p>


<p style="margin-left:17%; margin-top: 1em">A&minus;&minus;&minus;B&minus;&minus;&minus;C
topic <br>
/ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;F&minus;&minus;&minus;G
master</p>

<p style="margin-left:11%; margin-top: 1em">From this
point, the result of either of the following commands:</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
master <br>
git rebase master topic</p>

<p style="margin-left:11%; margin-top: 1em">would be:</p>


<p style="margin-left:17%; margin-top: 1em">A'&minus;&minus;B'&minus;&minus;C'
topic <br>
/ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;F&minus;&minus;&minus;G
master</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
The latter form is just a short&minus;hand of git checkout
topic followed by git rebase master. When rebase exits topic
will remain the checked&minus;out branch.</p>

<p style="margin-left:11%; margin-top: 1em">If the upstream
branch already contains a change you have made (e.g.,
because you mailed a patch which was applied upstream), then
that commit will be skipped. For example, running &lsquo;git
rebase master&lsquo; on the following history (in which
A&rsquo; and A introduce the same set of changes, but have
different committer information):</p>


<p style="margin-left:17%; margin-top: 1em">A&minus;&minus;&minus;B&minus;&minus;&minus;C
topic <br>
/ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;A'&minus;&minus;&minus;F
master</p>

<p style="margin-left:11%; margin-top: 1em">will result
in:</p>


<p style="margin-left:17%; margin-top: 1em">B'&minus;&minus;&minus;C'
topic <br>
/ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;A'&minus;&minus;&minus;F
master</p>

<p style="margin-left:11%; margin-top: 1em">Here is how you
would transplant a topic branch based on one branch to
another, to pretend that you forked the topic branch from
the latter branch, using rebase &minus;&minus;onto.</p>

<p style="margin-left:11%; margin-top: 1em">First
let&rsquo;s assume your <i>topic</i> is based on branch
<i>next</i>. For example, a feature developed in
<i>topic</i> depends on some functionality which is found in
<i>next</i>.</p>


<p style="margin-left:17%; margin-top: 1em">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
\ <br>

o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
next <br>
\ <br>
o&minus;&minus;&minus;o&minus;&minus;&minus;o topic</p>

<p style="margin-left:11%; margin-top: 1em">We want to make
<i>topic</i> forked from branch <i>master</i>; for example,
because the functionality on which <i>topic</i> depends was
merged into the more stable <i>master</i> branch. We want
our tree to look like this:</p>


<p style="margin-left:17%; margin-top: 1em">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
| \ <br>
| o'&minus;&minus;o'&minus;&minus;o' topic <br>
\ <br>

o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
next</p>

<p style="margin-left:11%; margin-top: 1em">We can get this
using the following command:</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
&minus;&minus;onto master next topic</p>

<p style="margin-left:11%; margin-top: 1em">Another example
of &minus;&minus;onto option is to rebase part of a branch.
If we have the following situation:</p>


<p style="margin-left:17%; margin-top: 1em">H&minus;&minus;&minus;I&minus;&minus;&minus;J
topicB <br>
/ <br>
E&minus;&minus;&minus;F&minus;&minus;&minus;G topicA <br>
/ <br>

A&minus;&minus;&minus;B&minus;&minus;&minus;C&minus;&minus;&minus;D
master</p>

<p style="margin-left:11%; margin-top: 1em">then the
command</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
&minus;&minus;onto master topicA topicB</p>

<p style="margin-left:11%; margin-top: 1em">would result
in:</p>


<p style="margin-left:17%; margin-top: 1em">H'&minus;&minus;I'&minus;&minus;J'
topicB <br>
/ <br>
| E&minus;&minus;&minus;F&minus;&minus;&minus;G topicA <br>
|/ <br>

A&minus;&minus;&minus;B&minus;&minus;&minus;C&minus;&minus;&minus;D
master</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
when topicB does not depend on topicA.</p>

<p style="margin-left:11%; margin-top: 1em">A range of
commits could also be removed with rebase. If we have the
following situation:</p>


<p style="margin-left:17%; margin-top: 1em">E&minus;&minus;&minus;F&minus;&minus;&minus;G&minus;&minus;&minus;H&minus;&minus;&minus;I&minus;&minus;&minus;J
topicA</p>

<p style="margin-left:11%; margin-top: 1em">then the
command</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
&minus;&minus;onto topicA~5 topicA~3 topicA</p>

<p style="margin-left:11%; margin-top: 1em">would result in
the removal of commits F and G:</p>


<p style="margin-left:17%; margin-top: 1em">E&minus;&minus;&minus;H'&minus;&minus;&minus;I'&minus;&minus;&minus;J'
topicA</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
if F and G were flawed in some way, or should not be part of
topicA. Note that the argument to &minus;&minus;onto and the
&lt;upstream&gt; parameter can be any valid
commit&minus;ish.</p>

<p style="margin-left:11%; margin-top: 1em">In case of
conflict, <i>git rebase</i> will stop at the first
problematic commit and leave conflict markers in the tree.
You can use <i>git diff</i> to locate the markers
(&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to resolve the
conflict. For each file you edit, you need to tell Git that
the conflict has been resolved, typically this would be done
with</p>

<p style="margin-left:17%; margin-top: 1em">git add
&lt;filename&gt;</p>

<p style="margin-left:11%; margin-top: 1em">After resolving
the conflict manually and updating the index with the
desired resolution, you can continue the rebasing process
with</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
&minus;&minus;continue</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
you can undo the <i>git rebase</i> with</p>

<p style="margin-left:17%; margin-top: 1em">git rebase
&minus;&minus;abort</p>

<h2>CONFIGURATION
<a name="CONFIGURATION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">rebase.stat</p>

<p style="margin-left:17%;">Whether to show a diffstat of
what changed upstream since the last rebase. False by
default.</p>


<p style="margin-left:11%; margin-top: 1em">rebase.autosquash</p>

<p style="margin-left:17%;">If set to true enable
<i>&minus;&minus;autosquash</i> option by default.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&minus;&minus;onto
&lt;newbase&gt;</p>

<p style="margin-left:17%;">Starting point at which to
create the new commits. If the &minus;&minus;onto option is
not specified, the starting point is &lt;upstream&gt;. May
be any valid commit, and not just an existing branch
name.</p>

<p style="margin-left:17%; margin-top: 1em">As a special
case, you may use &quot;A...B&quot; as a shortcut for the
merge base of A and B if there is exactly one merge base.
You can leave out at most one of A and B, in which case it
defaults to HEAD.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;upstream&gt;</p>

<p style="margin-left:17%;">Upstream branch to compare
against. May be any valid commit, not just an existing
branch name. Defaults to the configured upstream for the
current branch.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;branch&gt;</p>

<p style="margin-left:17%;">Working branch; defaults to
HEAD.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;continue</p>

<p style="margin-left:17%;">Restart the rebasing process
after having resolved a merge conflict.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;abort</p>

<p style="margin-left:17%;">Abort the rebase operation and
reset HEAD to the original branch. If &lt;branch&gt; was
provided when the rebase operation was started, then HEAD
will be reset to &lt;branch&gt;. Otherwise HEAD will be
reset to where it was when the rebase operation was
started.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;keep&minus;empty</p>

<p style="margin-left:17%;">Keep the commits that do not
change anything from its parents in the result.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;skip</p>

<p style="margin-left:17%;">Restart the rebasing process by
skipping the current patch.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;edit&minus;todo</p>

<p style="margin-left:17%;">Edit the todo list during an
interactive rebase.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;m,
&minus;&minus;merge</p>

<p style="margin-left:17%;">Use merging strategies to
rebase. When the recursive (default) merge strategy is used,
this allows rebase to be aware of renames on the upstream
side.</p>

<p style="margin-left:17%; margin-top: 1em">Note that a
rebase merge works by replaying each commit from the working
branch on top of the &lt;upstream&gt; branch. Because of
this, when a merge conflict happens, the side reported as
<i>ours</i> is the so&minus;far rebased series, starting
with &lt;upstream&gt;, and <i>theirs</i> is the working
branch. In other words, the sides are swapped.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;s
&lt;strategy&gt;,
&minus;&minus;strategy=&lt;strategy&gt;</p>

<p style="margin-left:17%;">Use the given merge strategy.
If there is no &minus;s option <i>git
merge&minus;recursive</i> is used instead. This implies
&minus;&minus;merge.</p>

<p style="margin-left:17%; margin-top: 1em">Because <i>git
rebase</i> replays each commit from the working branch on
top of the &lt;upstream&gt; branch using the given strategy,
using the <i>ours</i> strategy simply discards all patches
from the &lt;branch&gt;, which makes little sense.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;X
&lt;strategy&minus;option&gt;,
&minus;&minus;strategy&minus;option=&lt;strategy&minus;option&gt;</p>

<p style="margin-left:17%;">Pass the
&lt;strategy&minus;option&gt; through to the merge strategy.
This implies &minus;&minus;merge and, if no strategy has
been specified, &minus;s recursive. Note the reversal of
<i>ours</i> and <i>theirs</i> as noted above for the
&minus;m option.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q,
&minus;&minus;quiet</p>

<p style="margin-left:17%;">Be quiet. Implies
&minus;&minus;no&minus;stat.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v,
&minus;&minus;verbose</p>

<p style="margin-left:17%;">Be verbose. Implies
&minus;&minus;stat.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;stat</p>

<p style="margin-left:17%;">Show a diffstat of what changed
upstream since the last rebase. The diffstat is also
controlled by the configuration option rebase.stat.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;n,
&minus;&minus;no&minus;stat</p>

<p style="margin-left:17%;">Do not show a diffstat as part
of the rebase process.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;verify</p>

<p style="margin-left:17%;">This option bypasses the
pre&minus;rebase hook. See also <b>githooks</b>(5).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;verify</p>

<p style="margin-left:17%;">Allows the pre&minus;rebase
hook to run, which is the default. This option can be used
to override &minus;&minus;no&minus;verify. See also
<b>githooks</b>(5).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;C&lt;n&gt;</p>

<p style="margin-left:17%;">Ensure at least &lt;n&gt; lines
of surrounding context match before and after each change.
When fewer lines of surrounding context exist they all must
match. By default no context is ever ignored.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;f,
&minus;&minus;force&minus;rebase</p>

<p style="margin-left:17%;">Force the rebase even if the
current branch is a descendant of the commit you are
rebasing onto. Normally non&minus;interactive rebase will
exit with the message &quot;Current branch is up to
date&quot; in such a situation. Incompatible with the
&minus;&minus;interactive option.</p>

<p style="margin-left:17%; margin-top: 1em">You may find
this (or &minus;&minus;no&minus;ff with an interactive
rebase) helpful after reverting a topic branch merge, as
this option recreates the topic branch with fresh commits so
it can be remerged successfully without needing to
&quot;revert the reversion&quot; (see the
<b><font color="#0000FF">revert&minus;a&minus;faulty&minus;merge
How&minus;To</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">for details).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;&minus;ignore&minus;whitespace,
&minus;&minus;whitespace=&lt;option&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">These
flag are passed to the <i>git apply</i> program (see
<b>git-apply</b>(1)) that applies the patch. Incompatible
with the &minus;&minus;interactive option.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;&minus;committer&minus;date&minus;is&minus;author&minus;date,
&minus;&minus;ignore&minus;date</font></p>

<p style="margin-left:17%;"><font color="#000000">These
flags are passed to <i>git am</i> to easily change the dates
of the rebased commits (see <b>git-am</b>(1)). Incompatible
with the &minus;&minus;interactive option.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;i,
&minus;&minus;interactive</font></p>

<p style="margin-left:17%;"><font color="#000000">Make a
list of the commits which are about to be rebased. Let the
user edit that list before rebasing. This mode can also be
used to split commits (see SPLITTING COMMITS
below).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;p,
&minus;&minus;preserve&minus;merges</font></p>

<p style="margin-left:17%;"><font color="#000000">Instead
of ignoring merges, try to recreate them.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
uses the &minus;&minus;interactive machinery internally, but
combining it with the &minus;&minus;interactive option
explicitly is generally not a good idea unless you know what
you are doing (see BUGS below).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;x
&lt;cmd&gt;, &minus;&minus;exec &lt;cmd&gt;</font></p>

<p style="margin-left:17%;"><font color="#000000">Append
&quot;exec &lt;cmd&gt;&quot; after each line creating a
commit in the final history. &lt;cmd&gt; will be interpreted
as one or more shell commands.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option can only be used with the &minus;&minus;interactive
option (see INTERACTIVE MODE below).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">You
may execute several commands by either using one instance of
&minus;&minus;exec with several commands:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">git
rebase &minus;i &minus;&minus;exec &quot;cmd1 &amp;&amp;
cmd2 &amp;&amp; ...&quot;</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">or
by giving more than one &minus;&minus;exec:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">git
rebase &minus;i &minus;&minus;exec &quot;cmd1&quot;
&minus;&minus;exec &quot;cmd2&quot; &minus;&minus;exec
...</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
&minus;&minus;autosquash is used, &quot;exec&quot; lines
will not be appended for the intermediate commits, and will
only appear at the end of each squash/fixup
series.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;&minus;root</font></p>

<p style="margin-left:17%;"><font color="#000000">Rebase
all commits reachable from &lt;branch&gt;, instead of
limiting them with an &lt;upstream&gt;. This allows you to
rebase the root commit(s) on a branch. When used with
&minus;&minus;onto, it will skip changes already contained
in &lt;newbase&gt; (instead of &lt;upstream&gt;) whereas
without &minus;&minus;onto it will operate on every change.
When used together with both &minus;&minus;onto and
&minus;&minus;preserve&minus;merges, <i>all</i> root commits
will be rewritten to have &lt;newbase&gt; as parent
instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;&minus;autosquash,
&minus;&minus;no&minus;autosquash</font></p>

<p style="margin-left:17%;"><font color="#000000">When the
commit log message begins with &quot;squash! ...&quot; (or
&quot;fixup! ...&quot;), and there is a commit whose title
begins with the same ..., automatically modify the todo list
of rebase &minus;i so that the commit marked for squashing
comes right after the commit to be modified, and change the
action of the moved commit from pick to squash (or
fixup).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option is only valid when the
<i>&minus;&minus;interactive</i> option is used.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
the <i>&minus;&minus;autosquash</i> option is enabled by
default using the configuration variable rebase.autosquash,
this option can be used to override and disable this
setting.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">&minus;&minus;no&minus;ff</font></p>

<p style="margin-left:17%;"><font color="#000000">With
&minus;&minus;interactive, cherry&minus;pick all rebased
commits instead of fast&minus;forwarding over the unchanged
ones. This ensures that the entire history of the rebased
branch is composed of new commits.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Without
&minus;&minus;interactive, this is a synonym for
&minus;&minus;force&minus;rebase.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">You
may find this helpful after reverting a topic branch merge,
as this option recreates the topic branch with fresh commits
so it can be remerged successfully without needing to
&quot;revert the reversion&quot; (see the</font>
<b><font color="#0000FF">revert&minus;a&minus;faulty&minus;merge
How&minus;To</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">for details).</font></p>

<h2>MERGE STRATEGIES
<a name="MERGE STRATEGIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
merge mechanism (<i>git&minus;merge</i> and
<i>git&minus;pull</i> commands) allows the backend <i>merge
strategies</i> to be chosen with &minus;s option. Some
strategies can also take their own options, which can be
passed by giving &minus;X&lt;option&gt; arguments to
<i>git&minus;merge</i> and/or
<i>git&minus;pull</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">resolve</font></p>

<p style="margin-left:17%;"><font color="#000000">This can
only resolve two heads (i.e. the current branch and another
branch you pulled from) using a 3&minus;way merge algorithm.
It tries to carefully detect criss&minus;cross merge
ambiguities and is considered generally safe and
fast.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">recursive</font></p>

<p style="margin-left:17%;"><font color="#000000">This can
only resolve two heads using a 3&minus;way merge algorithm.
When there is more than one common ancestor that can be used
for 3&minus;way merge, it creates a merged tree of the
common ancestors and uses that as the reference tree for the
3&minus;way merge. This has been reported to result in fewer
merge conflicts without causing mis&minus;merges by tests
done on actual merge commits taken from Linux 2.6 kernel
development history. Additionally this can detect and handle
merges involving renames. This is the default merge strategy
when pulling or merging one branch.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
<i>recursive</i> strategy can take the following
options:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ours</font></p>

<p style="margin-left:23%;"><font color="#000000">This
option forces conflicting hunks to be auto&minus;resolved
cleanly by favoring <i>our</i> version. Changes from the
other tree that do not conflict with our side are reflected
to the merge result. For a binary file, the entire contents
are taken from our side.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">This
should not be confused with the <i>ours</i> merge strategy,
which does not even look at what the other tree contains at
all. It discards everything the other tree did, declaring
<i>our</i> history contains all that happened in
it.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">theirs</font></p>

<p style="margin-left:23%;"><font color="#000000">This is
the opposite of <i>ours</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">patience</font></p>

<p style="margin-left:23%;"><font color="#000000">With this
option, <i>merge&minus;recursive</i> spends a little extra
time to avoid mismerges that sometimes occur due to
unimportant matching lines (e.g., braces from distinct
functions). Use this when the branches to be merged have
diverged wildly. See also
<b>git-diff</b>(1)&minus;&minus;patience.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">diff&minus;algorithm=[patience|minimal|histogram|myers]</font></p>

<p style="margin-left:23%;"><font color="#000000">Tells
<i>merge&minus;recursive</i> to use a different diff
algorithm, which can help avoid mismerges that occur due to
unimportant matching lines (such as braces from distinct
functions). See also
<b>git-diff</b>(1)&minus;&minus;diff&minus;algorithm.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ignore&minus;space&minus;change,
ignore&minus;all&minus;space,
ignore&minus;space&minus;at&minus;eol</font></p>

<p style="margin-left:23%;"><font color="#000000">Treats
lines with the indicated type of whitespace change as
unchanged for the sake of a three&minus;way merge.
Whitespace changes mixed with other changes to a line are
not ignored. See also <b>git-diff</b>(1)&minus;b, &minus;w,
and
&minus;&minus;ignore&minus;space&minus;at&minus;eol.</font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000">&bull;
If <i>their</i> version only introduces whitespace changes
to a line, <i>our</i> version is used;</font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000">&bull;
If <i>our</i> version introduces whitespace changes but
<i>their</i> version includes a substantial change,
<i>their</i> version is used;</font></p>


<p style="margin-left:29%; margin-top: 1em"><font color="#000000">&bull;
Otherwise, the merge proceeds in the usual way.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">renormalize</font></p>

<p style="margin-left:23%;"><font color="#000000">This runs
a virtual check&minus;out and check&minus;in of all three
stages of a file when resolving a three&minus;way merge.
This option is meant to be used when merging branches with
different clean filters or end&minus;of&minus;line
normalization rules. See &quot;Merging branches with
differing checkin/checkout attributes&quot; in
<b>gitattributes</b>(5) for details.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">no&minus;renormalize</font></p>

<p style="margin-left:23%;"><font color="#000000">Disables
the renormalize option. This overrides the merge.renormalize
configuration variable.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">rename&minus;threshold=&lt;n&gt;</font></p>

<p style="margin-left:23%;"><font color="#000000">Controls
the similarity threshold used for rename detection. See also
<b>git-diff</b>(1)&minus;M.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">subtree[=&lt;path&gt;]</font></p>

<p style="margin-left:23%;"><font color="#000000">This
option is a more advanced form of <i>subtree</i> strategy,
where the strategy makes a guess on how two trees must be
shifted to match with each other when merging. Instead, the
specified path is prefixed (or stripped from the beginning)
to make the shape of two trees to match.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">octopus</font></p>

<p style="margin-left:17%;"><font color="#000000">This
resolves cases with more than two heads, but refuses to do a
complex merge that needs manual resolution. It is primarily
meant to be used for bundling topic branch heads together.
This is the default merge strategy when pulling or merging
more than one branch.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">ours</font></p>

<p style="margin-left:17%;"><font color="#000000">This
resolves any number of heads, but the resulting tree of the
merge is always that of the current branch head, effectively
ignoring all changes from all other branches. It is meant to
be used to supersede old development history of side
branches. Note that this is different from the &minus;Xours
option to the <i>recursive</i> merge strategy.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">subtree</font></p>

<p style="margin-left:17%;"><font color="#000000">This is a
modified recursive strategy. When merging trees A and B, if
B corresponds to a subtree of A, B is first adjusted to
match the tree structure of A, instead of reading the trees
at the same level. This adjustment is also done to the
common ancestor tree.</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">You
should understand the implications of using <i>git
rebase</i> on a repository that you share. See also
RECOVERING FROM UPSTREAM REBASE below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">When
the git&minus;rebase command is run, it will first execute a
&quot;pre&minus;rebase&quot; hook if one exists. You can use
this hook to do sanity checks and reject the rebase if it
isn&rsquo;t appropriate. Please see the template
pre&minus;rebase hook script for an example.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Upon
completion, &lt;branch&gt; will be the current
branch.</font></p>

<h2>INTERACTIVE MODE
<a name="INTERACTIVE MODE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Rebasing
interactively means that you have a chance to edit the
commits which are rebased. You can reorder the commits, and
you can remove them (weeding out bad or otherwise unwanted
patches).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
interactive mode is meant for this type of
workflow:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">1.
have a wonderful idea</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">2.
hack on the code</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">3.
prepare a series for submission</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">4.
submit</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">where
point 2. consists of several instances of</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">a)
regular use</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">1.
finish something worthy of a commit</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">2.
commit</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">b)
independent fixup</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">1.
realize that something does not work</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">2.
fix that</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">3.
commit it</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Sometimes
the thing fixed in b.2. cannot be amended to the
not&minus;quite perfect commit it fixes, because that commit
is buried deeply in a patch series. That is exactly what
interactive rebase is for: use it after plenty of
&quot;a&quot;s and &quot;b&quot;s, by rearranging and
editing commits, and squashing multiple commits into
one.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Start
it with the last commit you want to retain
as&minus;is:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">git
rebase &minus;i
&lt;after&minus;this&minus;commit&gt;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">An
editor will be fired up with all the commits in your current
branch (ignoring merge commits), which come after the given
commit. You can reorder the commits in this list to your
heart&rsquo;s content, and you can remove them. The list
looks more or less like this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">pick
deadbee The oneline of this commit <br>
pick fa1afe1 The oneline of the next commit <br>
...</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
oneline descriptions are purely for your pleasure; <i>git
rebase</i> will not look at them but at the commit names
(&quot;deadbee&quot; and &quot;fa1afe1&quot; in this
example), so do not delete or edit the names.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">By
replacing the command &quot;pick&quot; with the command
&quot;edit&quot;, you can tell <i>git rebase</i> to stop
after applying that commit, so that you can edit the files
and/or the commit message, amend the commit, and continue
rebasing.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
you just want to edit the commit message for a commit,
replace the command &quot;pick&quot; with the command
&quot;reword&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
you want to fold two or more commits into one, replace the
command &quot;pick&quot; for the second and subsequent
commits with &quot;squash&quot; or &quot;fixup&quot;. If the
commits had different authors, the folded commit will be
attributed to the author of the first commit. The suggested
commit message for the folded commit is the concatenation of
the commit messages of the first commit and of those with
the &quot;squash&quot; command, but omits the commit
messages of commits with the &quot;fixup&quot;
command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>git
rebase</i> will stop when &quot;pick&quot; has been replaced
with &quot;edit&quot; or when a command fails due to merge
errors. When you are done editing and/or resolving conflicts
you can continue with git rebase
&minus;&minus;continue.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
example, if you want to reorder the last 5 commits, such
that what was HEAD~4 becomes the new HEAD. To achieve that,
you would call <i>git rebase</i> like this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git rebase &minus;i HEAD~5</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">And
move the first patch to the end of the list.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">You
might want to preserve merges, if you have a history like
this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">X
<br>
\ <br>
A&minus;&minus;&minus;M&minus;&minus;&minus;B <br>
/ <br>

&minus;&minus;&minus;o&minus;&minus;&minus;O&minus;&minus;&minus;P&minus;&minus;&minus;Q</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Suppose
you want to rebase the side branch starting at &quot;A&quot;
to &quot;Q&quot;. Make sure that the current HEAD is
&quot;B&quot;, and call</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git rebase &minus;i &minus;p &minus;&minus;onto Q
O</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Reordering
and editing commits usually creates untested intermediate
steps. You may want to check that your history editing did
not break anything by running a test, or at least
recompiling at intermediate points in history by using the
&quot;exec&quot; command (shortcut &quot;x&quot;). You may
do so by creating a todo list like this one:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">pick
deadbee Implement feature XXX <br>
fixup f1a5c00 Fix to feature XXX <br>
exec make <br>
pick c0ffeee The oneline of the next commit <br>
edit deadbab The oneline of the commit after <br>
exec cd subdir; make test <br>
...</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
interactive rebase will stop when a command fails (i.e.
exits with non&minus;0 status) to give you an opportunity to
fix the problem. You can continue with git rebase
&minus;&minus;continue.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
&quot;exec&quot; command launches the command in a shell
(the one specified in $SHELL, or the default shell if $SHELL
is not set), so you can use shell features (like
&quot;cd&quot;, &quot;&gt;&quot;, &quot;;&quot; ...). The
command is run from the root of the working tree.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git rebase &minus;i &minus;&minus;exec &quot;make
test&quot;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
command lets you check that intermediate commits are
compilable. The todo list becomes like that:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">pick
5928aea one <br>
exec make test <br>
pick 04d0fda two <br>
exec make test <br>
pick ba46169 three <br>
exec make test <br>
pick f4593f9 four <br>
exec make test</font></p>

<h2>SPLITTING COMMITS
<a name="SPLITTING COMMITS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
interactive mode, you can mark commits with the action
&quot;edit&quot;. However, this does not necessarily mean
that <i>git rebase</i> expects the result of this edit to be
exactly one commit. Indeed, you can undo the commit, or you
can add other commits. This can be used to split a commit
into two:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Start an interactive rebase with git rebase &minus;i
&lt;commit&gt;^, where &lt;commit&gt; is the commit you want
to split. In fact, any commit range will do, as long as it
contains that commit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Mark the commit you want to split with the action
&quot;edit&quot;.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
When it comes to editing that commit, execute git reset
HEAD^. The effect is that the HEAD is rewound by one, and
the index follows suit. However, the working tree stays the
same.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Now add the changes to the index that you want to have in
the first commit. You can use git add (possibly
interactively) or <i>git gui</i> (or both) to do
that.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Commit the now&minus;current index with whatever commit
message is appropriate now.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Repeat the last two steps until your working tree is
clean.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Continue the rebase with git rebase
&minus;&minus;continue.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
you are not absolutely sure that the intermediate revisions
are consistent (they compile, pass the testsuite, etc.) you
should use <i>git stash</i> to stash away the
not&minus;yet&minus;committed changes after each commit,
test, and amend the commit if fixes are
necessary.</font></p>

<h2>RECOVERING FROM UPSTREAM REBASE
<a name="RECOVERING FROM UPSTREAM REBASE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Rebasing
(or any other form of rewriting) a branch that others have
based work on is a bad idea: anyone downstream of it is
forced to manually fix their history. This section explains
how to do the fix from the downstream&rsquo;s point of view.
The real fix, however, would be to avoid rebasing the
upstream in the first place.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">To
illustrate, suppose you are in a situation where someone
develops a <i>subsystem</i> branch, and you are working on a
<i>topic</i> that is dependent on this <i>subsystem</i>. You
might end up with a history like the following:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
\ <br>

o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
subsystem <br>
\ <br>
*&minus;&minus;&minus;*&minus;&minus;&minus;*
topic</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
<i>subsystem</i> is rebased against <i>master</i>, the
following happens:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
\ \ <br>

o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'
subsystem <br>
\ <br>
*&minus;&minus;&minus;*&minus;&minus;&minus;*
topic</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
you now continue development as usual, and eventually merge
<i>topic</i> to <i>subsystem</i>, the commits from
<i>subsystem</i> will remain duplicated forever:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
\ \ <br>

o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;M
subsystem <br>
\ / <br>

*&minus;&minus;&minus;*&minus;&minus;&minus;*&minus;..........&minus;*&minus;&minus;*
topic</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Such
duplicates are generally frowned upon because they clutter
up history, making it harder to follow. To clean things up,
you need to transplant the commits on <i>topic</i> to the
new <i>subsystem</i> tip, i.e., rebase <i>topic</i>. This
becomes a ripple effect: anyone downstream from <i>topic</i>
is forced to rebase too, and so on!</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">There
are two kinds of fixes, discussed in the following
subsections:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Easy
case: The changes are literally the same.</font></p>

<p style="margin-left:17%;"><font color="#000000">This
happens if the <i>subsystem</i> rebase was a simple rebase
and had no conflicts.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Hard
case: The changes are not the same.</font></p>

<p style="margin-left:17%;"><font color="#000000">This
happens if the <i>subsystem</i> rebase had conflicts, or
used &minus;&minus;interactive to omit, edit, squash, or
fixup commits; or if the upstream used one of commit
&minus;&minus;amend, reset, or
filter&minus;branch.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>The
easy case</b> <br>
Only works if the changes (patch IDs based on the diff
contents) on <i>subsystem</i> are literally the same before
and after the rebase <i>subsystem</i> did.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
that case, the fix is easy because <i>git rebase</i> knows
to skip changes that are already present in the new
upstream. So if you say (assuming you&rsquo;re on
<i>topic</i>)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git rebase subsystem</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">you
will end up with the fixed history</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o&minus;&minus;&minus;o
master <br>
\ <br>

o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'&minus;&minus;o'
subsystem <br>
\ <br>
*&minus;&minus;&minus;*&minus;&minus;&minus;*
topic</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>The
hard case</b> <br>
Things get more complicated if the <i>subsystem</i> changes
do not exactly correspond to the ones before the
rebase.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b>
<br>
While an &quot;easy case recovery&quot; sometimes appears to
be successful even in the hard case, it may have unintended
consequences. For example, a commit that was removed via git
rebase &minus;&minus;interactive will be
<b>resurrected</b>!</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
idea is to manually tell <i>git rebase</i> &quot;where the
old <i>subsystem</i> ended and your <i>topic</i>
began&quot;, that is, what the old merge&minus;base between
them was. You will have to find a way to name the last
commit of the old <i>subsystem</i>, for example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
With the <i>subsystem</i> reflog: after <i>git fetch</i>,
the old tip of <i>subsystem</i> is at subsystem@{1}.
Subsequent fetches will increase the number. (See
<b>git-reflog</b>(1).)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">&bull;
Relative to the tip of <i>topic</i>: knowing that your
<i>topic</i> has three commits, the old tip of
<i>subsystem</i> must be topic~3.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">You
can then transplant the old subsystem..topic to the new tip
by saying (for the reflog case, and assuming you are on
<i>topic</i> already):</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">$
git rebase &minus;&minus;onto subsystem
subsystem@{1}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
ripple effect of a &quot;hard case&quot; recovery is
especially bad: <i>everyone</i> downstream from <i>topic</i>
will now have to perform a &quot;hard case&quot; recovery
too!</font></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>The
todo list presented by &minus;&minus;preserve&minus;merges
&minus;&minus;interactive does not represent the topology of
the revision graph. Editing commits and rewording their
commit messages should work fine, but attempts to reorder
commits tend to produce counterintuitive
results.</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>For
example, an attempt to rearrange</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>1
&minus;&minus;&minus; 2 &minus;&minus;&minus; 3
&minus;&minus;&minus; 4 &minus;&minus;&minus;
5</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>to</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>1
&minus;&minus;&minus; 2 &minus;&minus;&minus; 4
&minus;&minus;&minus; 3 &minus;&minus;&minus;
5</big></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>by
moving the &quot;pick 4&quot; line will result in the
following history:</big></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><big>3
<br>
/ <br>
1 &minus;&minus;&minus; 2 &minus;&minus;&minus; 4
&minus;&minus;&minus; 5</big></font></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><big>Part
of the <b>git</b>(1) suite</big></font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000"><big>1.</big></font></p> </td>
<td width="2%"></td>
<td width="43%">



<p style="margin-top: 1em"><font color="#000000"><big>revert-a-faulty-merge
How-To</big></font></p> </td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000"><big>file:///usr/share/doc/git-1.8.3.1/howto/revert-a-faulty-merge.txt</big></font></p>
<hr>
</body>
</html>
