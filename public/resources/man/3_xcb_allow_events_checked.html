<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:10:32 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>xcb_allow_events</title>

</head>
<body>

<h1 align="center">xcb_allow_events</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#REQUEST ARGUMENTS">REQUEST ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">xcb_allow_events
&minus; release queued events</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;xcb/xproto.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Request
function</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p>xcb_void_cookie_t
<b>xcb_allow_events</b>(xcb_connection_t&nbsp;*<i>conn</i>,
uint8_t&nbsp;<i>mode</i>,
xcb_timestamp_t&nbsp;<i>time</i>);</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>REQUEST ARGUMENTS
<a name="REQUEST ARGUMENTS"></a>
</h2>
<td width="11%"></td>
<td width="6%"></td>
<td width="9%"></td>
<td width="43%">
</td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>conn</i></p></td>
<td width="9%"></td>
<td width="43%">


<p>The XCB connection to X11.</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>mode</i></p></td>
<td width="9%"></td>
<td width="43%">


<p>One of the following values:</p></td>
<td width="31%">
</td></tr>
</table>


<p style="margin-left:26%;"><i>XCB_ALLOW_ASYNC_POINTER</i></p>

<p style="margin-left:42%;">For AsyncPointer, if the
pointer is frozen by the client, pointer event processing
continues normally. If the pointer is frozen twice by the
client on behalf of two separate grabs, AsyncPointer thaws
for both. AsyncPointer has no effect if the pointer is not
frozen by the client, but the pointer need not be grabbed by
the client.</p>

<p style="margin-left:42%; margin-top: 1em">TODO: rewrite
this in more understandable terms.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_SYNC_POINTER</i></p>

<p style="margin-left:42%;">For SyncPointer, if the pointer
is frozen and actively grabbed by the client, pointer event
processing continues normally until the next ButtonPress or
ButtonRelease event is reported to the client, at which time
the pointer again appears to freeze. However, if the
reported event causes the pointer grab to be released, then
the pointer does not freeze. SyncPointer has no effect if
the pointer is not frozen by the client or if the pointer is
not grabbed by the client.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_REPLAY_POINTER</i></p>

<p style="margin-left:42%;">For ReplayPointer, if the
pointer is actively grabbed by the client and is frozen as
the result of an event having been sent to the client
(either from the activation of a GrabButton or from a
previous AllowEvents with mode SyncPointer but not from a
GrabPointer), then the pointer grab is released and that
event is completely reprocessed, this time ignoring any
passive grabs at or above (towards the root) the grab-window
of the grab just released. The request has no effect if the
pointer is not grabbed by the client or if the pointer is
not frozen as the result of an event.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_ASYNC_KEYBOARD</i></p>

<p style="margin-left:42%;">For AsyncKeyboard, if the
keyboard is frozen by the client, keyboard event processing
continues normally. If the keyboard is frozen twice by the
client on behalf of two separate grabs, AsyncKeyboard thaws
for both. AsyncKeyboard has no effect if the keyboard is not
frozen by the client, but the keyboard need not be grabbed
by the client.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_SYNC_KEYBOARD</i></p>

<p style="margin-left:42%;">For SyncKeyboard, if the
keyboard is frozen and actively grabbed by the client,
keyboard event processing continues normally until the next
KeyPress or KeyRelease event is reported to the client, at
which time the keyboard again appears to freeze. However, if
the reported event causes the keyboard grab to be released,
then the keyboard does not freeze. SyncKeyboard has no
effect if the keyboard is not frozen by the client or if the
keyboard is not grabbed by the client.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_REPLAY_KEYBOARD</i></p>

<p style="margin-left:42%;">For ReplayKeyboard, if the
keyboard is actively grabbed by the client and is frozen as
the result of an event having been sent to the client
(either from the activation of a GrabKey or from a previous
AllowEvents with mode SyncKeyboard but not from a
GrabKeyboard), then the keyboard grab is released and that
event is completely reprocessed, this time ignoring any
passive grabs at or above (towards the root) the grab-window
of the grab just released. The request has no effect if the
keyboard is not grabbed by the client or if the keyboard is
not frozen as the result of an event.</p>


<p style="margin-left:26%;"><i>XCB_ALLOW_ASYNC_BOTH</i></p>

<p style="margin-left:42%;">For AsyncBoth, if the pointer
and the keyboard are frozen by the client, event processing
for both devices continues normally. If a device is frozen
twice by the client on behalf of two separate grabs,
AsyncBoth thaws for both. AsyncBoth has no effect unless
both pointer and keyboard are frozen by the client.</p>

<p style="margin-left:26%;"><i>XCB_ALLOW_SYNC_BOTH</i></p>

<p style="margin-left:42%;">For SyncBoth, if both pointer
and keyboard are frozen by the client, event processing (for
both devices) continues normally until the next ButtonPress,
ButtonRelease, KeyPress, or KeyRelease event is reported to
the client for a grabbed device (button event for the
pointer, key event for the keyboard), at which time the
devices again appear to freeze. However, if the reported
event causes the grab to be released, then the devices do
not freeze (but if the other device is still grabbed, then a
subsequent event for it will still cause both devices to
freeze). SyncBoth has no effect unless both pointer and
keyboard are frozen by the client. If the pointer or
keyboard is frozen twice by the client on behalf of two
separate grabs, SyncBoth thaws for both (but a subsequent
freeze for SyncBoth will only freeze each device once).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>time</i></p></td>
<td width="9%"></td>
<td width="74%">


<p>Timestamp to avoid race conditions when running X over
the network.</p></td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The special
value <i>XCB_CURRENT_TIME</i> will be replaced with the
current server time.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Releases queued
events if the client has caused a device (pointer/keyboard)
to freeze due to grabbing it actively. This request has no
effect if <i>time</i> is earlier than the last-grab time of
the most recent active grab for this client or if
<i>time</i> is later than the current X server time.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Returns an
<i>xcb_void_cookie_t</i>. Errors (if any) have to be handled
in the event loop.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
handle errors directly with <i>xcb_request_check</i>
instead, use <i>xcb_allow_events_checked</i>. See
<b>xcb-requests(3)</b> for details.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>xcb_value_error_t</i></p>

<p style="margin-left:26%;">You specified an invalid
<i>mode</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>xcb-requests</b>(3)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated from
xproto.xml. Contact xcb@lists.freedesktop.org for
corrections and improvements.</p>
<hr>
</body>
</html>
