<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Threads</title>

</head>
<body>

<h1 align="center">Threads</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#INTRODUCTION">INTRODUCTION</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SCRIPT-LEVEL ACCESS TO THREADS">SCRIPT-LEVEL ACCESS TO THREADS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_ConditionNotify,
Tcl_ConditionWait, Tcl_ConditionFinalize, Tcl_GetThreadData,
Tcl_MutexLock, Tcl_MutexUnlock, Tcl_MutexFinalize,
Tcl_CreateThread, Tcl_JoinThread &minus; Tcl thread
support</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_ConditionNotify</b>(<i>condPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_ConditionWait</b>(<i>condPtr, mutexPtr, timePtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_ConditionFinalize</b>(<i>condPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Void * <b><br>
Tcl_GetThreadData</b>(<i>keyPtr, size</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_MutexLock</b>(<i>mutexPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_MutexUnlock</b>(<i>mutexPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_MutexFinalize</b>(<i>mutexPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_CreateThread</b>(<i>idPtr, threadProc, clientData,
stackSize, flags</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_JoinThread</b>(<i>id, result</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p style="margin-top: 1em">Tcl_Condition <i>*condPtr</i>
(in)</p> </td>
<td width="16%"></td>
<td width="18%">


<p style="margin-top: 1em">A condition variable, which must
be associated with a mutex lock.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_Mutex <i>*mutexPtr</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>A mutex lock.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_Time <i>*timePtr</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>A time limit on the condition wait. NULL to wait
forever. Note that a polling value of 0 seconds does not
make much sense.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_ThreadDataKey <i>*keyPtr</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>This identifies a block of thread local storage. The key
should be static and process-wide, yet each thread will end
up associating a different block of storage with this
key.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>int <i>*size</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>The size of the thread local storage block. This amount
of data is allocated and initialized to zero the first time
each thread calls <b>Tcl_GetThreadData</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_ThreadId <i>*idPtr</i> (out)</p></td>
<td width="16%"></td>
<td width="18%">


<p>The referred storage will contain the id of the newly
created thread as returned by the operating system.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_ThreadId <i>id</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>Id of the thread waited upon.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>Tcl_ThreadCreateProc <i>threadProc</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>This procedure will act as the <b>main()</b> of the
newly created thread. The specified <i>clientData</i> will
be its sole argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>ClientData <i>clientData</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>Arbitrary information. Passed as sole argument to the
<i>threadProc</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>int <i>stackSize</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>The size of the stack given to the new thread.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>int <i>flags</i> (in)</p></td>
<td width="16%"></td>
<td width="18%">


<p>Bitmask containing flags allowing the caller to modify
behaviour of the new thread.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p>int <i>*result</i> (out)</p></td>
<td width="16%"></td>
<td width="18%">


<p>The referred storage is used to place the exit code of
the thread waited upon into it.</p></td></tr>
</table>


<p style="margin-left:82%;">_________________________________________________________________</p>

<h2>INTRODUCTION
<a name="INTRODUCTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Beginning with
the 8.1 release, the Tcl core is thread safe, which allows
you to incorporate Tcl into multithreaded applications
without customizing the Tcl core. To enable Tcl
multithreading support, you must include the
<b>&minus;&minus;enable-threads</b> option to
<b>configure</b> when you configure and compile your Tcl
core.</p>

<p style="margin-left:11%; margin-top: 1em">An important
constraint of the Tcl threads implementation is that <i>only
the thread that created a Tcl interpreter can use that
interpreter</i>. In other words, multiple threads can not
access the same Tcl interpreter. (However, a single thread
can safely create and use multiple interpreters.)</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl provides
<b>Tcl_CreateThread</b> for creating threads. The caller can
determine the size of the stack given to the new thread and
modify the behaviour through the supplied <i>flags</i>. The
value <b>TCL_THREAD_STACK_DEFAULT</b> for the
<i>stackSize</i> indicates that the default size as
specified by the operating system is to be used for the new
thread. As for the flags, currently only the values
<b>TCL_THREAD_NOFLAGS</b> and <b>TCL_THREAD_JOINABLE</b> are
defined. The first of them invokes the default behaviour
with no specialties. Using the second value marks the new
thread as <i>joinable</i>. This means that another thread
can wait for the such marked thread to exit and join it.</p>

<p style="margin-left:11%; margin-top: 1em">Restrictions:
On some UNIX systems the pthread-library does not contain
the functionality to specify the stack size of a thread. The
specified value for the stack size is ignored on these
systems. Windows currently does not support joinable
threads. This flag value is therefore ignored on this
platform.</p>

<p style="margin-left:11%; margin-top: 1em">Tcl provides
the <b>Tcl_ExitThread</b> and <b>Tcl_FinalizeThread</b>
functions for terminating threads and invoking optional
per-thread exit handlers. See the <b>Tcl_Exit</b> page for
more information on these procedures.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_JoinThread</b> function is provided to allow threads
to wait upon the exit of another thread, which must have
been marked as joinable through usage of the
<b>TCL_THREAD_JOINABLE</b>-flag during its creation via
<b>Tcl_CreateThread</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Trying to wait
for the exit of a non-joinable thread or a thread which is
already waited upon will result in an error. Waiting for a
joinable thread which already exited is possible, the system
will retain the necessary information until after the call
to <b>Tcl_JoinThread</b>. This means that not calling
<b>Tcl_JoinThread</b> for a joinable thread will cause a
memory leak.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_GetThreadData</b> call returns a pointer to a block
of thread-private data. Its argument is a key that is shared
by all threads and a size for the block of storage. The
storage is automatically allocated and initialized to all
zeros the first time each thread asks for it. The storage is
automatically deallocated by <b>Tcl_FinalizeThread</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SYNCHRONIZATION
AND COMMUNICATION</b> <br>
Tcl provides <b>Tcl_ThreadQueueEvent</b> and
<b>Tcl_ThreadAlert</b> for handling event queuing in
multithreaded applications. See the <b>Notifier</b> manual
page for more information on these procedures.</p>

<p style="margin-left:11%; margin-top: 1em">A mutex is a
lock that is used to serialize all threads through a piece
of code by calling <b>Tcl_MutexLock</b> and
<b>Tcl_MutexUnlock</b>. If one thread holds a mutex, any
other thread calling <b>Tcl_MutexLock</b> will block until
<b>Tcl_MutexUnlock</b> is called. A mutex can be destroyed
after its use by calling <b>Tcl_MutexFinalize</b>. The
result of locking a mutex twice from the same thread is
undefined. On some platforms it will result in a deadlock.
The <b>Tcl_MutexLock</b>, <b>Tcl_MutexUnlock</b> and
<b>Tcl_MutexFinalize</b> procedures are defined as empty
macros if not compiling with threads enabled. For
declaration of mutexes the <b>TCL_DECLARE_MUTEX</b> macro
should be used. This macro assures correct mutex handling
even when the core is compiled without threads enabled.</p>

<p style="margin-left:11%; margin-top: 1em">A condition
variable is used as a signaling mechanism: a thread can lock
a mutex and then wait on a condition variable with
<b>Tcl_ConditionWait</b>. This atomically releases the mutex
lock and blocks the waiting thread until another thread
calls <b>Tcl_ConditionNotify</b>. The caller of
<b>Tcl_ConditionNotify</b> should have the associated mutex
held by previously calling <b>Tcl_MutexLock</b>, but this is
not enforced. Notifying the condition variable unblocks all
threads waiting on the condition variable, but they do not
proceed until the mutex is released with
<b>Tcl_MutexUnlock</b>. The implementation of
<b>Tcl_ConditionWait</b> automatically locks the mutex
before returning.</p>

<p style="margin-left:11%; margin-top: 1em">The caller of
<b>Tcl_ConditionWait</b> should be prepared for spurious
notifications by calling <b>Tcl_ConditionWait</b> within a
while loop that tests some invariant.</p>

<p style="margin-left:11%; margin-top: 1em">A condition
variable can be destroyed after its use by calling
<b>Tcl_ConditionFinalize</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_ConditionNotify</b>, <b>Tcl_ConditionWait</b> and
<b>Tcl_ConditionFinalize</b> procedures are defined as empty
macros if not compiling with threads enabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INITIALIZATION</b>
<br>
All of these synchronization objects are self-initializing.
They are implemented as opaque pointers that should be NULL
upon first use. The mutexes and condition variables are
either cleaned up by process exit handlers (if living that
long) or explicitly by calls to <b>Tcl_MutexFinalize</b> or
<b>Tcl_ConditionFinalize</b>. Thread local storage is
reclaimed during <b>Tcl_FinalizeThread</b>.</p>

<h2>SCRIPT-LEVEL ACCESS TO THREADS
<a name="SCRIPT-LEVEL ACCESS TO THREADS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl provides no
built-in commands for scripts to use to create, manage,
<big>&#9474;</big> or join threads, nor any script-level
access to mutex or condition <big>&#9474;</big> variables.
It provides such facilities only via C interfaces, and
<big>&#9474;</big> leaves it up to packages to expose these
matters to the script level. <big>&#9474;</big> One such
package is the <b>Thread</b> package.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_GetCurrentThread(3),
Tcl_ThreadQueueEvent(3), Tcl_ThreadAlert(3),
Tcl_ExitThread(3), Tcl_FinalizeThread(3),
Tcl_CreateThreadExitHandler(3),
Tcl_DeleteThreadExitHandler(3), Thread</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">thread, mutex,
condition variable, thread local storage</p>
<hr>
</body>
</html>
