<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:15 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLINTERN</title>

</head>
<body>

<h1 align="center">PERLINTERN</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Compile-time scope hooks">Compile-time scope hooks</a><br>
<a href="#CV reference counts and CvOUTSIDE">CV reference counts and CvOUTSIDE</a><br>
<a href="#Embedding Functions">Embedding Functions</a><br>
<a href="#Functions in file op.c">Functions in file op.c</a><br>
<a href="#Functions in file pp_ctl.c">Functions in file pp_ctl.c</a><br>
<a href="#GV Functions">GV Functions</a><br>
<a href="#Hash Manipulation Functions">Hash Manipulation Functions</a><br>
<a href="#IO Functions">IO Functions</a><br>
<a href="#Magical Functions">Magical Functions</a><br>
<a href="#MRO Functions">MRO Functions</a><br>
<a href="#Optree Manipulation Functions">Optree Manipulation Functions</a><br>
<a href="#Pad Data Structures">Pad Data Structures</a><br>
<a href="#Per-Interpreter Variables">Per-Interpreter Variables</a><br>
<a href="#Stack Manipulation Macros">Stack Manipulation Macros</a><br>
<a href="#SV Manipulation Functions">SV Manipulation Functions</a><br>
<a href="#SV-Body Allocation">SV-Body Allocation</a><br>
<a href="#Unicode Support">Unicode Support</a><br>
<a href="#Undocumented functions">Undocumented functions</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="7%">


<p>perlintern &minus; autogenerated documentation of purely
internal</p> </td>
<td width="8%">
</td>
<td width="77%">


<p>Perl functions</p></td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This file is
the autogenerated documentation of functions in the Perl
interpreter that are documented using Perl&rsquo;s internal
documentation format but are not marked as part of the Perl
<small>API</small> . In other words, <b>they are not for use
in extensions</b>!</p>

<h2>Compile-time scope hooks
<a name="Compile-time scope hooks"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">BhkENTRY</p>

<p style="margin-left:23%;">Return an entry from the
<small>BHK</small> structure. <i>which</i> is a preprocessor
token indicating which entry to return. If the appropriate
flag is not set this will return <small>NULL</small> . The
type of the return value depends on which entry you ask
for.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        void *  BhkENTRY(BHK *hk, which)</pre>


<p style="margin-left:11%;">BhkFLAGS</p>

<p style="margin-left:23%;">Return the <small>BHK</small>
&rsquo;s flags.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        U32     BhkFLAGS(BHK *hk)</pre>



<p style="margin-left:11%;"><small>CALL_BLOCK_HOOKS</small></p>

<p style="margin-left:23%;">Call all the registered block
hooks for type <i>which</i>. <i>which</i> is a preprocessing
token; the type of <i>arg</i> depends on <i>which</i>.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    CALL_BLOCK_HOOKS(which, arg)</pre>


<h2>CV reference counts and CvOUTSIDE
<a name="CV reference counts and CvOUTSIDE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CvWEAKOUTSIDE</p>

<p style="margin-left:23%;">Each <small>CV</small> has a
pointer, <tt>&quot;CvOUTSIDE()&quot;</tt>, to its lexically
enclosing <small>CV</small> (if any). Because pointers to
anonymous sub prototypes are stored in
<tt>&quot;&amp;&quot;</tt> pad slots, it is a possible to
get a circular reference, with the parent pointing to the
child and vice-versa. To avoid the ensuing memory leak, we
do not increment the reference count of the
<small>CV</small> pointed to by
<tt>&quot;CvOUTSIDE&quot;</tt> in the <i>one specific
instance</i> that the parent has a
<tt>&quot;&amp;&quot;</tt> pad slot pointing back to us. In
this case, we set the <tt>&quot;CvWEAKOUTSIDE&quot;</tt>
flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent
when freeing the child.</p>

<p style="margin-left:23%; margin-top: 1em">There is a
further complication with non-closure anonymous subs (i.e.
those that do not refer to any lexicals outside that sub).
In this case, the anonymous prototype is shared rather than
being cloned. This has the consequence that the parent may
be freed while there are still active children, eg</p>

<pre style="margin-left:23%; margin-top: 1em">    BEGIN { $a = sub { eval '$x' } }</pre>


<p style="margin-left:23%; margin-top: 1em">In this case,
the <small>BEGIN</small> is freed immediately after
execution since there are no active references to it: the
anon sub prototype has <tt>&quot;CvWEAKOUTSIDE&quot;</tt>
set since it&rsquo;s not a closure, and <tt>$a</tt> points
to the same <small>CV</small> , so it doesn&rsquo;t
contribute to <small>BEGIN</small> &rsquo;s refcount either.
When <tt>$a</tt> is executed, the <tt>&quot;eval
'$x'&quot;</tt> causes the chain of
<tt>&quot;CvOUTSIDE&quot;</tt>s to be followed, and the
freed <small>BEGIN</small> is accessed.</p>

<p style="margin-left:23%; margin-top: 1em">To avoid this,
whenever a <small>CV</small> and its associated pad is
freed, any <tt>&quot;&amp;&quot;</tt> entries in the pad are
explicitly removed from the pad, and if the refcount of the
pointed-to anon sub is still positive, then that
child&rsquo;s <tt>&quot;CvOUTSIDE&quot;</tt> is set to point
to its grandparent. This will only occur in the single
specific case of a non-closure anon prototype having one or
more active references (such as <tt>$a</tt> above).</p>

<p style="margin-left:23%; margin-top: 1em">One other thing
to consider is that a <small>CV</small> may be merely
undefined rather than freed, eg <tt>&quot;undef
&amp;foo&quot;</tt>. In this case, its refcount may not have
reached zero, but we still delete its pad and its
<tt>&quot;CvROOT&quot;</tt> etc. Since various children may
still have their <tt>&quot;CvOUTSIDE&quot;</tt> pointing at
this undefined <small>CV</small> , we keep its own
<tt>&quot;CvOUTSIDE&quot;</tt> for the time being, so that
the chain of lexical scopes is unbroken. For example, the
following should print 123:</p>

<pre style="margin-left:23%; margin-top: 1em">    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a&minus;&gt;();
        bool    CvWEAKOUTSIDE(CV *cv)</pre>


<h2>Embedding Functions
<a name="Embedding Functions"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">cv_dump</p></td>
<td width="1%"></td>
<td width="39%">


<p style="margin-top: 1em">dump the contents of a
<small>CV</small></p> </td>
<td width="38%">
</td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">        void    cv_dump(CV *cv, const char *title)</pre>


<p style="margin-left:11%;">do_dump_pad</p>

<p style="margin-left:23%;">Dump the contents of a
padlist</p>

<pre style="margin-left:23%; margin-top: 1em">        void    do_dump_pad(I32 level, PerlIO *file,
                            PADLIST *padlist, int full)</pre>


<p style="margin-left:11%;">intro_my</p>

<p style="margin-left:23%;">&quot;Introduce&quot; my
variables to visible status.</p>

<pre style="margin-left:23%; margin-top: 1em">        U32     intro_my()</pre>


<p style="margin-left:11%;">padlist_dup</p>

<p style="margin-left:23%;">Duplicates a pad.</p>

<pre style="margin-left:23%; margin-top: 1em">        AV *    padlist_dup(AV *srcpad, CLONE_PARAMS *param)</pre>


<p style="margin-left:11%;">pad_alloc_name</p>

<p style="margin-left:23%;">Allocates a place in the
currently-compiling pad (via &quot;pad_alloc&quot; in
perlapi) and then stores a name for that entry.
<i>namesv</i> is adopted and becomes the name entry; it must
already contain the name string and be sufficiently
upgraded. <i>typestash</i> and <i>ourstash</i> and the
<tt>&quot;padadd_STATE&quot;</tt> flag get added to
<i>namesv</i>. None of the other processing of
&quot;pad_add_name_pvn&quot; in perlapi is done. Returns the
offset of the allocated pad slot.</p>

<pre style="margin-left:23%; margin-top: 1em">        PADOFFSET pad_alloc_name(SV *namesv, U32 flags,
                                 HV *typestash, HV *ourstash)</pre>


<p style="margin-left:11%;">pad_block_start</p>

<p style="margin-left:23%;">Update the pad compilation
state variables on entry to a new block</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_block_start(int full)</pre>


<p style="margin-left:11%;">pad_check_dup</p>

<p style="margin-left:23%;">Check for duplicate
declarations: report any of:</p>

<pre style="margin-left:23%; margin-top: 1em">     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the
       same stash as C&lt;ourstash&gt;</pre>



<p style="margin-left:23%; margin-top: 1em">&quot;is_our&quot;
indicates that the name to check is an &rsquo;our&rsquo;
declaration.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_check_dup(SV *name, U32 flags,
                              const HV *ourstash)</pre>


<p style="margin-left:11%;">pad_findlex</p>

<p style="margin-left:23%;">Find a named lexical anywhere
in a chain of nested pads. Add fake entries in the inner
pads if it&rsquo;s found in an outer one.</p>

<p style="margin-left:23%; margin-top: 1em">Returns the
offset in the bottom pad of the lex or the fake lex. cv is
the <small>CV</small> in which to start the search, and seq
is the current cop_seq to match against. If warn is true,
print appropriate warnings. The out_* vars return values,
and so are pointers to where the returned values should be
stored. out_capture, if non-null, requests that the
innermost instance of the lexical is captured; out_name_sv
is set to the innermost matched namesv or fake namesv;
out_flags returns the flags normally associated with the
<small>IVX</small> field of a fake namesv.</p>

<p style="margin-left:23%; margin-top: 1em">Note that
<i>pad_findlex()</i> is recursive; it recurses up the chain
of CVs, then comes back down, adding fake entries as it
goes. It has to be this way because fake namesvs in anon
protoypes have to store in xlow the index into the parent
pad.</p>

<pre style="margin-left:23%; margin-top: 1em">        PADOFFSET pad_findlex(const char *namepv,
                              STRLEN namelen, U32 flags,
                              const CV* cv, U32 seq, int warn,
                              SV** out_capture,
                              SV** out_name_sv, int *out_flags)</pre>


<p style="margin-left:11%;">pad_fixup_inner_anons</p>

<p style="margin-left:23%;">For any anon CVs in the pad,
change CvOUTSIDE of that <small>CV</small> from old_cv to
new_cv if necessary. Needed when a newly-compiled
<small>CV</small> has to be moved to a pre-existing
<small>CV</small> struct.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_fixup_inner_anons(PADLIST *padlist,
                                      CV *old_cv, CV *new_cv)</pre>


<p style="margin-left:11%;">pad_free</p>

<p style="margin-left:23%;">Free the <small>SV</small> at
offset po in the current pad.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_free(PADOFFSET po)</pre>


<p style="margin-left:11%;">pad_leavemy</p>

<p style="margin-left:23%;">Cleanup at end of scope during
compilation: set the max seq number for lexicals in this
scope and warn of any lexicals that never got
introduced.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_leavemy()</pre>


<p style="margin-left:11%;">pad_push</p>

<p style="margin-left:23%;">Push a new pad frame onto the
padlist, unless there&rsquo;s already a pad at this depth,
in which case don&rsquo;t bother creating a new one. Then
give the new pad an <tt>@_</tt> in slot zero.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_push(PADLIST *padlist, int depth)</pre>


<p style="margin-left:11%;">pad_reset</p>

<p style="margin-left:23%;">Mark all the current
temporaries for reuse</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_reset()</pre>


<p style="margin-left:11%;">pad_swipe</p>

<p style="margin-left:23%;">Abandon the tmp in the current
pad at offset po and replace with a new one.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_swipe(PADOFFSET po, bool refadjust)</pre>


<h2>Functions in file op.c
<a name="Functions in file op.c"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">core_prototype</p>

<p style="margin-left:23%;">This function assigns the
prototype of the named core function to
<tt>&quot;sv&quot;</tt>, or to a new mortal
<small>SV</small> if <tt>&quot;sv&quot;</tt> is
<small>NULL</small> . It returns the modified
<tt>&quot;sv&quot;</tt>, or <small>NULL</small> if the core
function has no prototype. <tt>&quot;code&quot;</tt> is a
code as returned by <tt>&quot;keyword()&quot;</tt>. It must
be negative and unequal to &minus;KEY_CORE.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    core_prototype(SV *sv, const char *name,
                               const int code,
                               int * const opnum)</pre>


<h2>Functions in file pp_ctl.c
<a name="Functions in file pp_ctl.c"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">docatch</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">Check for the cases 0 or 3 of
cur_env.je_ret, only used inside an eval context.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">0 is used as
continue inside eval,</p>

<p style="margin-left:23%; margin-top: 1em">3 is used for a
die caught by an inner eval &minus; continue inner loop</p>

<p style="margin-left:23%; margin-top: 1em">See cop.h:
je_mustcatch, when set at any runlevel to
<small>TRUE</small> , means eval ops must establish a local
jmpenv to handle exception traps.</p>

<pre style="margin-left:23%; margin-top: 1em">        OP*     docatch(OP *o)</pre>


<h2>GV Functions
<a name="GV Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">gv_try_downgrade</p>

<p style="margin-left:23%;">If the typeglob
<tt>&quot;gv&quot;</tt> can be expressed more succinctly, by
having something other than a real <small>GV</small> in its
place in the stash, replace it with the optimised form.
Basic requirements for this are that <tt>&quot;gv&quot;</tt>
is a real typeglob, is sufficiently ordinary, and is only
referenced from its package. This function is meant to be
used when a <small>GV</small> has been looked up in part to
see what was there, causing upgrading, but based on what was
found it turns out that the real <small>GV</small>
isn&rsquo;t required after all.</p>

<p style="margin-left:23%; margin-top: 1em">If
<tt>&quot;gv&quot;</tt> is a completely empty typeglob, it
is deleted from the stash.</p>

<p style="margin-left:23%; margin-top: 1em">If
<tt>&quot;gv&quot;</tt> is a typeglob containing only a
sufficiently-ordinary constant sub, the typeglob is replaced
with a scalar-reference placeholder that more compactly
represents the same thing.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    gv_try_downgrade(GV* gv)</pre>


<h2>Hash Manipulation Functions
<a name="Hash Manipulation Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">hv_ename_add</p>

<p style="margin-left:23%;">Adds a name to a stash&rsquo;s
internal list of effective names. See
<tt>&quot;hv_ename_delete&quot;</tt>.</p>

<p style="margin-left:23%; margin-top: 1em">This is called
when a stash is assigned to a new location in the symbol
table.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    hv_ename_add(HV *hv, const char *name, U32 len,
                             U32 flags)</pre>


<p style="margin-left:11%;">hv_ename_delete</p>

<p style="margin-left:23%;">Removes a name from a
stash&rsquo;s internal list of effective names. If this is
the name returned by <tt>&quot;HvENAME&quot;</tt>, then
another name in the list will take its place
(<tt>&quot;HvENAME&quot;</tt> will use it).</p>

<p style="margin-left:23%; margin-top: 1em">This is called
when a stash is deleted from the symbol table.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    hv_ename_delete(HV *hv, const char *name,
                                U32 len, U32 flags)</pre>


<p style="margin-left:11%;">refcounted_he_chain_2hv</p>

<p style="margin-left:23%;">Generates and returns a
<tt>&quot;HV *&quot;</tt> representing the content of a
<tt>&quot;refcounted_he&quot;</tt> chain. <i>flags</i> is
currently unused and must be zero.</p>

<pre style="margin-left:23%; margin-top: 1em">        HV *    refcounted_he_chain_2hv(
                    const struct refcounted_he *c, U32 flags
                )</pre>


<p style="margin-left:11%;">refcounted_he_fetch_pv</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    refcounted_he_fetch_pv(
                    const struct refcounted_he *chain,
                    const char *key, U32 hash, U32 flags
                )</pre>


<p style="margin-left:11%;">refcounted_he_fetch_pvn</p>

<p style="margin-left:23%;">Search along a
<tt>&quot;refcounted_he&quot;</tt> chain for an entry with
the key specified by <i>keypv</i> and <i>keylen</i>. If
<i>flags</i> has the
<tt>&quot;REFCOUNTED_HE_KEY_UTF8&quot;</tt> bit set, the key
octets are interpreted as <small>UTF&minus;8</small> ,
otherwise they are interpreted as Latin&minus;1. <i>hash</i>
is a precomputed hash of the key string, or zero if it has
not been precomputed. Returns a mortal scalar representing
the value associated with the key, or
<tt>&amp;PL_sv_placeholder</tt> if there is no value
associated with the key.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    refcounted_he_fetch_pvn(
                    const struct refcounted_he *chain,
                    const char *keypv, STRLEN keylen, U32 hash,
                    U32 flags
                )</pre>


<p style="margin-left:11%;">refcounted_he_fetch_pvs</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a literal
string instead of a string/length pair, and no precomputed
hash.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    refcounted_he_fetch_pvs(
                    const struct refcounted_he *chain,
                    const char *key, U32 flags
                )</pre>


<p style="margin-left:11%;">refcounted_he_fetch_sv</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a Perl scalar
instead of a string/length pair.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    refcounted_he_fetch_sv(
                    const struct refcounted_he *chain, SV *key,
                    U32 hash, U32 flags
                )</pre>


<p style="margin-left:11%;">refcounted_he_free</p>

<p style="margin-left:23%;">Decrements the reference count
of a <tt>&quot;refcounted_he&quot;</tt> by one. If the
reference count reaches zero the structure&rsquo;s memory is
freed, which (recursively) causes a reduction of its parent
<tt>&quot;refcounted_he&quot;</tt>&rsquo;s reference count.
It is safe to pass a null pointer to this function: no
action occurs in this case.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    refcounted_he_free(struct refcounted_he *he)</pre>


<p style="margin-left:11%;">refcounted_he_inc</p>

<p style="margin-left:23%;">Increment the reference count
of a <tt>&quot;refcounted_he&quot;</tt>. The pointer to the
<tt>&quot;refcounted_he&quot;</tt> is also returned. It is
safe to pass a null pointer to this function: no action
occurs and a null pointer is returned.</p>

<pre style="margin-left:23%; margin-top: 1em">        struct refcounted_he * refcounted_he_inc(
                                   struct refcounted_he *he
                               )</pre>


<p style="margin-left:11%;">refcounted_he_new_pv</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<pre style="margin-left:23%; margin-top: 1em">        struct refcounted_he * refcounted_he_new_pv(
                                   struct refcounted_he *parent,
                                   const char *key, U32 hash,
                                   SV *value, U32 flags
                               )</pre>


<p style="margin-left:11%;">refcounted_he_new_pvn</p>

<p style="margin-left:23%;">Creates a new
<tt>&quot;refcounted_he&quot;</tt>. This consists of a
single key/value pair and a reference to an existing
<tt>&quot;refcounted_he&quot;</tt> chain (which may be
empty), and thus forms a longer chain. When using the longer
chain, the new key/value pair takes precedence over any
entry for the same key further along the chain.</p>

<p style="margin-left:23%; margin-top: 1em">The new key is
specified by <i>keypv</i> and <i>keylen</i>. If <i>flags</i>
has the <tt>&quot;REFCOUNTED_HE_KEY_UTF8&quot;</tt> bit set,
the key octets are interpreted as <small>UTF&minus;8</small>
, otherwise they are interpreted as Latin&minus;1.
<i>hash</i> is a precomputed hash of the key string, or zero
if it has not been precomputed.</p>

<p style="margin-left:23%; margin-top: 1em"><i>value</i> is
the scalar value to store for this key. <i>value</i> is
copied by this function, which thus does not take ownership
of any reference to it, and later changes to the scalar will
not be reflected in the value visible in the
<tt>&quot;refcounted_he&quot;</tt>. Complex types of scalar
will not be stored with referential integrity, but will be
coerced to strings. <i>value</i> may be either null or
<tt>&amp;PL_sv_placeholder</tt> to indicate that no value is
to be associated with the key; this, as with any non-null
value, takes precedence over the existence of a value for
the key further along the chain.</p>

<p style="margin-left:23%; margin-top: 1em"><i>parent</i>
points to the rest of the <tt>&quot;refcounted_he&quot;</tt>
chain to be attached to the new
<tt>&quot;refcounted_he&quot;</tt>. This function takes
ownership of one reference to <i>parent</i>, and returns one
reference to the new <tt>&quot;refcounted_he&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        struct refcounted_he * refcounted_he_new_pvn(
                                   struct refcounted_he *parent,
                                   const char *keypv,
                                   STRLEN keylen, U32 hash,
                                   SV *value, U32 flags
                               )</pre>


<p style="margin-left:11%;">refcounted_he_new_pvs</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a literal
string instead of a string/length pair, and no precomputed
hash.</p>

<pre style="margin-left:23%; margin-top: 1em">        struct refcounted_he * refcounted_he_new_pvs(
                                   struct refcounted_he *parent,
                                   const char *key, SV *value,
                                   U32 flags
                               )</pre>


<p style="margin-left:11%;">refcounted_he_new_sv</p>

<p style="margin-left:23%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a Perl scalar
instead of a string/length pair.</p>

<pre style="margin-left:23%; margin-top: 1em">        struct refcounted_he * refcounted_he_new_sv(
                                   struct refcounted_he *parent,
                                   SV *key, U32 hash, SV *value,
                                   U32 flags
                               )</pre>


<h2>IO Functions
<a name="IO Functions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">start_glob</p>

<p style="margin-left:23%;">Function called by
<tt>&quot;do_readline&quot;</tt> to spawn a glob (or do the
glob inside perl on <small>VMS</small> ). This code used to
be inline, but now perl uses <tt>&quot;File::Glob&quot;</tt>
this glob starter is only used by miniperl during the build
process. Moving it away shrinks pp_hot.c; shrinking pp_hot.c
helps speed perl up.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        PerlIO* start_glob(SV *tmpglob, IO *io)</pre>


<h2>Magical Functions
<a name="Magical Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">magic_clearhint</p>

<p style="margin-left:23%;">Triggered by a delete from %^H,
records the key to
<tt>&quot;PL_compiling.cop_hints_hash&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        int     magic_clearhint(SV* sv, MAGIC* mg)</pre>


<p style="margin-left:11%;">magic_clearhints</p>

<p style="margin-left:23%;">Triggered by clearing %^H,
resets <tt>&quot;PL_compiling.cop_hints_hash&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        int     magic_clearhints(SV* sv, MAGIC* mg)</pre>


<p style="margin-left:11%;">magic_methcall</p>

<p style="margin-left:23%;">Invoke a magic method (like
<small>FETCH</small> ).</p>


<p style="margin-left:23%; margin-top: 1em"><tt>&quot;sv&quot;</tt>
and <tt>&quot;mg&quot;</tt> are the tied thingy and the tie
magic.</p>


<p style="margin-left:23%; margin-top: 1em"><tt>&quot;meth&quot;</tt>
is the name of the method to call.</p>


<p style="margin-left:23%; margin-top: 1em"><tt>&quot;argc&quot;</tt>
is the number of args (in addition to <tt>$self</tt>) to
pass to the method.</p>

<p style="margin-left:23%; margin-top: 1em">The
<tt>&quot;flags&quot;</tt> can be:</p>

<pre style="margin-left:23%; margin-top: 1em">    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef</pre>


<p style="margin-left:23%; margin-top: 1em">The arguments
themselves are any values following the
<tt>&quot;flags&quot;</tt> argument.</p>

<p style="margin-left:23%; margin-top: 1em">Returns the
<small>SV</small> (if any) returned by the method, or
<small>NULL</small> on failure.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV*     magic_methcall(SV *sv, const MAGIC *mg,
                               const char *meth, U32 flags,
                               U32 argc, ...)</pre>


<p style="margin-left:11%;">magic_sethint</p>

<p style="margin-left:23%;">Triggered by a store to %^H,
records the key/value pair to
<tt>&quot;PL_compiling.cop_hints_hash&quot;</tt>. It is
assumed that hints aren&rsquo;t storing anything that would
need a deep copy. Maybe we should warn if we find a
reference.</p>

<pre style="margin-left:23%; margin-top: 1em">        int     magic_sethint(SV* sv, MAGIC* mg)</pre>


<p style="margin-left:11%;">mg_localize</p>

<p style="margin-left:23%;">Copy some of the magic from an
existing <small>SV</small> to new localized version of that
<small>SV</small> . Container magic (eg <tt>%ENV</tt>,
<tt>$1</tt>, tie) gets copied, value magic doesn&rsquo;t (eg
taint, pos).</p>

<p style="margin-left:23%; margin-top: 1em">If setmagic is
false then no set magic will be called on the new (empty)
<small>SV</small> . This typically means that assignment
will soon follow (e.g. &rsquo;local <tt>$x</tt> =
<tt>$y</tt>&rsquo;), and that will handle the magic.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    mg_localize(SV* sv, SV* nsv, bool setmagic)</pre>


<h2>MRO Functions
<a name="MRO Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">mro_get_linear_isa_dfs</p>

<p style="margin-left:23%;">Returns the Depth-First Search
linearization of <tt>@ISA</tt> the given stash. The return
value is a read-only AV*. <tt>&quot;level&quot;</tt> should
be 0 (it is used internally in this function&rsquo;s
recursion).</p>

<p style="margin-left:23%; margin-top: 1em">You are
responsible for <tt>&quot;SvREFCNT_inc()&quot;</tt> on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted out from
under you the next time the cache is invalidated).</p>

<pre style="margin-left:23%; margin-top: 1em">        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)</pre>


<p style="margin-left:11%;">mro_isa_changed_in</p>

<p style="margin-left:23%;">Takes the necessary steps
(cache invalidations, mostly) when the <tt>@ISA</tt> of the
given package has changed. Invoked by the
<tt>&quot;setisa&quot;</tt> magic, should not need to invoke
directly.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    mro_isa_changed_in(HV* stash)</pre>


<p style="margin-left:11%;">mro_package_moved</p>

<p style="margin-left:23%;">Call this function to signal to
a stash that it has been assigned to another spot in the
stash hierarchy. <tt>&quot;stash&quot;</tt> is the stash
that has been assigned. <tt>&quot;oldstash&quot;</tt> is the
stash it replaces, if any. <tt>&quot;gv&quot;</tt> is the
glob that is actually being assigned to.</p>

<p style="margin-left:23%; margin-top: 1em">This can also
be called with a null first argument to indicate that
<tt>&quot;oldstash&quot;</tt> has been deleted.</p>

<p style="margin-left:23%; margin-top: 1em">This function
invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those,
including non-existent packages that have corresponding
entries in <tt>&quot;stash&quot;</tt>.</p>

<p style="margin-left:23%; margin-top: 1em">It also sets
the effective names (<tt>&quot;HvENAME&quot;</tt>) on all
the stashes as appropriate.</p>

<p style="margin-left:23%; margin-top: 1em">If the
<tt>&quot;gv&quot;</tt> is present and is not in the symbol
table, then this function simply returns. This checked will
be skipped if <tt>&quot;flags &amp; 1&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    mro_package_moved(HV * const stash,
                                  HV * const oldstash,
                                  const GV * const gv,
                                  U32 flags)</pre>


<h2>Optree Manipulation Functions
<a name="Optree Manipulation Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">finalize_optree</p>

<p style="margin-left:23%;">This function finalizes the
optree. Should be called directly after the complete optree
is built. It does some additional checking which can&rsquo;t
be done in the normal ck_xxx functions and makes the tree
thread-safe.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    finalize_optree(OP* o)</pre>


<h2>Pad Data Structures
<a name="Pad Data Structures"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>CX_CURPAD_SAVE</small></p>

<p style="margin-left:23%;">Save the current pad in the
given context block structure.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    CX_CURPAD_SAVE(struct context)</pre>



<p style="margin-left:11%;"><small>CX_CURPAD_SV</small></p>

<p style="margin-left:23%;">Access the <small>SV</small> at
offset po in the saved current pad in the given context
block structure (can be used as an lvalue).</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)</pre>


<p style="margin-left:11%;"><small>PAD_BASE_SV</small></p>

<p style="margin-left:23%;">Get the value from slot
<tt>&quot;po&quot;</tt> in the base (DEPTH=1) pad of a
padlist</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</pre>



<p style="margin-left:11%;"><small>PAD_CLONE_VARS</small></p>

<p style="margin-left:23%;">Clone the state variables
associated with running and compiling pads.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                               CLONE_PARAMS* param)</pre>



<p style="margin-left:11%;"><small>PAD_COMPNAME_FLAGS</small></p>

<p style="margin-left:23%;">Return the flags for the
current compiling pad name at offset
<tt>&quot;po&quot;</tt>. Assumes a valid slot entry.</p>

<pre style="margin-left:23%; margin-top: 1em">        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)</pre>



<p style="margin-left:11%;"><small>PAD_COMPNAME_GEN</small></p>

<p style="margin-left:23%;">The generation number of the
name at offset <tt>&quot;po&quot;</tt> in the current
compiling pad (lvalue). Note that <tt>&quot;SvUVX&quot;</tt>
is hijacked for this purpose.</p>

<pre style="margin-left:23%; margin-top: 1em">        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)</pre>


<p style="margin-left:11%;">PAD_COMPNAME_GEN_set</p>

<p style="margin-left:23%;">Sets the generation number of
the name at offset <tt>&quot;po&quot;</tt> in the current
ling pad (lvalue) to <tt>&quot;gen&quot;</tt>. Note that
<tt>&quot;SvUV_set&quot;</tt> is hijacked for this
purpose.</p>

<pre style="margin-left:23%; margin-top: 1em">        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</pre>



<p style="margin-left:11%;"><small>PAD_COMPNAME_OURSTASH</small></p>

<p style="margin-left:23%;">Return the stash associated
with an <tt>&quot;our&quot;</tt> variable. Assumes the slot
entry is a valid <tt>&quot;our&quot;</tt> lexical.</p>

<pre style="margin-left:23%; margin-top: 1em">        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)</pre>



<p style="margin-left:11%;"><small>PAD_COMPNAME_PV</small></p>

<p style="margin-left:23%;">Return the name of the current
compiling pad name at offset <tt>&quot;po&quot;</tt>.
Assumes a valid slot entry.</p>

<pre style="margin-left:23%; margin-top: 1em">        char *  PAD_COMPNAME_PV(PADOFFSET po)</pre>



<p style="margin-left:11%;"><small>PAD_COMPNAME_TYPE</small></p>

<p style="margin-left:23%;">Return the type (stash) of the
current compiling pad name at offset
<tt>&quot;po&quot;</tt>. Must be a valid name. Returns null
if not typed.</p>

<pre style="margin-left:23%; margin-top: 1em">        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>pad_peg</p></td>
<td width="1%"></td>
<td width="77%">


<p>When <small>PERL_MAD</small> is enabled, this is a small
no-op function that gets called at the start of each
pad-related function. It can be breakpointed to track all
pad operations. The parameter is a string indicating the
type of pad operation being performed.</p></td></tr>
</table>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    pad_peg(const char *s)</pre>



<p style="margin-left:11%;"><small>PAD_RESTORE_LOCAL</small></p>

<p style="margin-left:23%;">Restore the old pad saved into
the local variable opad by <i><small>PAD_SAVE_LOCAL</small>
()</i></p>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_RESTORE_LOCAL(PAD *opad)</pre>



<p style="margin-left:11%;"><small>PAD_SAVE_LOCAL</small></p>

<p style="margin-left:23%;">Save the current pad to the
local variable opad, then make the current pad equal to
npad</p>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</pre>



<p style="margin-left:11%;"><small>PAD_SAVE_SETNULLPAD</small></p>

<p style="margin-left:23%;">Save the current pad then set
it to null.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_SAVE_SETNULLPAD()</pre>


<p style="margin-left:11%;"><small>PAD_SETSV</small></p>

<p style="margin-left:23%;">Set the slot at offset
<tt>&quot;po&quot;</tt> in the current pad to
<tt>&quot;sv&quot;</tt></p>

<p style="margin-left:23%; margin-top: 1em"><tt>SV *
PAD_SETSV(PADOFFSET po, SV* sv)</tt></p>

<p style="margin-left:11%;"><small>PAD_SET_CUR</small></p>

<p style="margin-left:23%;">Set the current pad to be pad
<tt>&quot;n&quot;</tt> in the padlist, saving the previous
current pad. <small>NB</small> currently this macro expands
to a string too long for some compilers, so it&rsquo;s best
to replace it with</p>

<pre style="margin-left:23%; margin-top: 1em">    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);
        void    PAD_SET_CUR(PADLIST padlist, I32 n)</pre>



<p style="margin-left:11%;"><small>PAD_SET_CUR_NOSAVE</small></p>

<p style="margin-left:23%;">like <small>PAD_SET_CUR</small>
, but without the save</p>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><small>PAD_SV</small></p></td>
<td width="3%"></td>
<td width="72%">


<p>Get the value at offset <tt>&quot;po&quot;</tt> in the
current pad</p></td>
<td width="5%">
</td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">        void    PAD_SV(PADOFFSET po)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">PAD_SVl</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">Lightweight and lvalue version
of <tt>&quot;PAD_SV&quot;</tt>. Get or set the value at
offset <tt>&quot;po&quot;</tt> in the current pad. Unlike
<tt>&quot;PAD_SV&quot;</tt>, does not print diagnostics with
&minus;DX. For internal use only.</p></td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">        SV *    PAD_SVl(PADOFFSET po)</pre>


<p style="margin-left:11%;"><small>SAVECLEARSV</small></p>

<p style="margin-left:23%;">Clear the pointed to pad value
on scope exit. (i.e. the runtime action of
&rsquo;my&rsquo;)</p>

<pre style="margin-left:23%; margin-top: 1em">        void    SAVECLEARSV(SV **svp)</pre>


<p style="margin-left:11%;"><small>SAVECOMPPAD</small></p>

<p style="margin-left:23%;">save PL_comppad and
PL_curpad</p>

<pre style="margin-left:23%; margin-top: 1em">        void    SAVECOMPPAD()</pre>


<p style="margin-left:11%;"><small>SAVEPADSV</small></p>

<p style="margin-left:23%;">Save a pad slot (used to
restore after an iteration)</p>

<p style="margin-left:23%; margin-top: 1em"><small>XXX
DAPM</small> it would make more sense to make the arg a
<small>PADOFFSET</small> void <small>SAVEPADSV</small> (
<small>PADOFFSET</small> po)</p>

<h2>Per-Interpreter Variables
<a name="Per-Interpreter Variables"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">PL_DBsingle</p>

<p style="margin-left:23%;">When Perl is run in debugging
mode, with the <b>&minus;d</b> switch, this
<small>SV</small> is a boolean which indicates whether subs
are being single-stepped. Single-stepping is automatically
turned on after every step. This is the C variable which
corresponds to Perl&rsquo;s <tt>$DB::single</tt> variable.
See <tt>&quot;PL_DBsub&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    PL_DBsingle</pre>


<p style="margin-left:11%;">PL_DBsub</p>

<p style="margin-left:23%;">When Perl is run in debugging
mode, with the <b>&minus;d</b> switch, this
<small>GV</small> contains the <small>SV</small> which holds
the name of the sub being debugged. This is the C variable
which corresponds to Perl&rsquo;s <tt>$DB::sub</tt>
variable. See <tt>&quot;PL_DBsingle&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        GV *    PL_DBsub</pre>


<p style="margin-left:11%;">PL_DBtrace</p>

<p style="margin-left:23%;">Trace variable used when Perl
is run in debugging mode, with the <b>&minus;d</b> switch.
This is the C variable which corresponds to Perl&rsquo;s
<tt>$DB::trace</tt> variable. See
<tt>&quot;PL_DBsingle&quot;</tt>.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV *    PL_DBtrace</pre>


<p style="margin-left:11%;">PL_dowarn</p>

<p style="margin-left:23%;">The C variable which
corresponds to Perl&rsquo;s $^W warning variable.</p>

<pre style="margin-left:23%; margin-top: 1em">        bool    PL_dowarn</pre>


<p style="margin-left:11%;">PL_last_in_gv</p>

<p style="margin-left:23%;">The <small>GV</small> which was
last used for a filehandle input operation.
(<tt>&quot;&lt;FH&gt;&quot;</tt>)</p>

<pre style="margin-left:23%; margin-top: 1em">        GV*     PL_last_in_gv</pre>


<p style="margin-left:11%;">PL_ofsgv</p>

<p style="margin-left:23%;">The glob containing the output
field separator &minus; <tt>&quot;*,&quot;</tt> in Perl
space.</p>

<pre style="margin-left:23%; margin-top: 1em">        GV*     PL_ofsgv</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>PL_rs</p></td>
<td width="5%"></td>
<td width="71%">


<p>The input record separator &minus; <tt>$/</tt> in Perl
space.</p> </td>
<td width="6%">
</td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">        SV*     PL_rs</pre>


<h2>Stack Manipulation Macros
<a name="Stack Manipulation Macros"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em">djSP</p></td>
<td width="6%"></td>
<td width="77%">


<p style="margin-top: 1em">Declare Just
<tt>&quot;SP&quot;</tt>. This is actually identical to
<tt>&quot;dSP&quot;</tt>, and declares a local copy of
perl&rsquo;s stack pointer, available via the
<tt>&quot;SP&quot;</tt> macro. See <tt>&quot;SP&quot;</tt>.
(Available for backward source code compatibility with the
old (Perl 5.005) thread model.)</p></td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">                djSP;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><small>LVRET</small></p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">True if this op will be the
return value of an lvalue subroutine</p></td></tr>
</table>

<h2>SV Manipulation Functions
<a name="SV Manipulation Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">sv_add_arena</p>

<p style="margin-left:23%;">Given a chunk of memory, link
it to the head of the list of arenas, and split it into a
list of free SVs.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    sv_add_arena(char *const ptr, const U32 size,
                             const U32 flags)</pre>


<p style="margin-left:11%;">sv_clean_all</p>

<p style="margin-left:23%;">Decrement the refcnt of each
remaining <small>SV</small> , possibly triggering a cleanup.
This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.</p>

<pre style="margin-left:23%; margin-top: 1em">        I32     sv_clean_all()</pre>


<p style="margin-left:11%;">sv_clean_objs</p>

<p style="margin-left:23%;">Attempt to destroy all objects
not yet freed.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    sv_clean_objs()</pre>


<p style="margin-left:11%;">sv_free_arenas</p>

<p style="margin-left:23%;">Deallocate the memory used by
all arenas. Note that all the individual <small>SV</small>
heads and bodies within the arenas must already have been
freed.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    sv_free_arenas()</pre>


<h2>SV-Body Allocation
<a name="SV-Body Allocation"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">sv_2num</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">Return an <small>SV</small> with
the numeric value of the source <small>SV</small> , doing
any necessary reference or overload conversion. You must use
the <tt>&quot;SvNUM(sv)&quot;</tt> macro to access this
function.</p> </td></tr>
</table>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV*     sv_2num(SV *const sv)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">sv_ref</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">Returns a <small>SV</small>
describing what the <small>SV</small> passed in is a
reference to.</p></td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">        SV*     sv_ref(SV *dst, const SV *const sv,
                       const int ob)</pre>


<h2>Unicode Support
<a name="Unicode Support"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">find_uninit_var</p>

<p style="margin-left:23%;">Find the name of the undefined
variable (if any) that caused the operator to issue a
&quot;Use of uninitialized value&quot; warning. If match is
true, only return a name if its value matches uninit_sv. So
roughly speaking, if a unary operator (such as
<small>OP_COS</small> ) generates a warning, then following
the direct child of the op may yield an
<small>OP_PADSV</small> or <small>OP_GV</small> that gives
the name of the undefined variable. On the other hand, with
<small>OP_ADD</small> there are two branches to follow, so
we only print the variable name if we get an exact
match.</p>

<p style="margin-left:23%; margin-top: 1em">The name is
returned as a mortal <small>SV</small> .</p>

<p style="margin-left:23%; margin-top: 1em">Assumes that
PL_op is the op that originally triggered the error, and
that PL_comppad/PL_curpad points to the currently executing
pad.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
this function is experimental and may change or be removed
without notice.</p>

<pre style="margin-left:23%; margin-top: 1em">        SV*     find_uninit_var(const OP *const obase,
                                const SV *const uninit_sv,
                                bool top)</pre>


<p style="margin-left:11%;">report_uninit</p>

<p style="margin-left:23%;">Print appropriate &quot;Use of
uninitialized variable&quot; warning.</p>

<pre style="margin-left:23%; margin-top: 1em">        void    report_uninit(const SV *uninit_sv)</pre>


<h2>Undocumented functions
<a name="Undocumented functions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions are currently undocumented. If you use one of
them, you may wish to consider creating and submitting
documentation for it. <br>
_add_range_to_invlist <br>
_core_swash_init <br>
_invlist_array_init <br>
_invlist_contents <br>
_invlist_intersection <br>
_invlist_intersection_maybe_complement_2nd <br>
_invlist_invert <br>
_invlist_invert_prop <br>
_invlist_populate_swatch <br>
_invlist_subtract <br>
_invlist_union <br>
_invlist_union_maybe_complement_2nd <br>
_is_utf8__perl_idstart <br>
_new_invlist <br>
_swash_inversion_hash <br>
_swash_to_invlist <br>
_to_fold_latin1 <br>
_to_upper_title_latin1 <br>
aassign_common_vars <br>
add_cp_to_invlist <br>
addmad <br>
allocmy <br>
amagic_is_enabled <br>
append_madprops <br>
apply <br>
av_reify <br>
bind_match <br>
block_end <br>
block_start <br>
boot_core_PerlIO <br>
boot_core_UNIVERSAL <br>
boot_core_mro <br>
cando <br>
check_utf8_print <br>
ck_entersub_args_core <br>
convert <br>
coresub_op <br>
create_eval_scope <br>
cv_ckproto_len_flags <br>
cvgv_set <br>
cvstash_set <br>
deb_stack_all <br>
delete_eval_scope <br>
die_unwind <br>
do_aexec <br>
do_aexec5 <br>
do_eof <br>
do_exec <br>
do_exec3 <br>
do_execfree <br>
do_ipcctl <br>
do_ipcget <br>
do_msgrcv <br>
do_msgsnd <br>
do_ncmp <br>
do_op_xmldump <br>
do_pmop_xmldump <br>
do_print <br>
do_readline <br>
do_seek <br>
do_semop <br>
do_shmio <br>
do_sysseek <br>
do_tell <br>
do_trans <br>
do_vecget <br>
do_vecset <br>
do_vop <br>
dofile <br>
dump_all_perl <br>
dump_packsubs_perl <br>
dump_sub_perl <br>
dump_sv_child <br>
emulate_cop_io <br>
feature_is_enabled <br>
find_rundefsv2 <br>
find_script <br>
free_tied_hv_pool <br>
get_db_sub <br>
get_debug_opts <br>
get_hash_seed <br>
get_invlist_iter_addr <br>
get_invlist_len_addr <br>
get_invlist_version_id_addr <br>
get_invlist_zero_addr <br>
get_no_modify <br>
get_opargs <br>
get_re_arg <br>
getenv_len <br>
hfree_next_entry <br>
hv_backreferences_p <br>
hv_kill_backrefs <br>
hv_undef_flags <br>
init_argv_symbols <br>
init_dbargs <br>
init_debugger <br>
invert <br>
invlist_array <br>
invlist_clone <br>
invlist_iterinit <br>
invlist_len <br>
invlist_max <br>
invlist_set_len <br>
invlist_trim <br>
io_close <br>
is_utf8_X_L <br>
is_utf8_X_LV <br>
is_utf8_X_LVT <br>
is_utf8_X_LV_LVT_V <br>
is_utf8_X_T <br>
is_utf8_X_V <br>
is_utf8_X_begin <br>
is_utf8_X_extend <br>
is_utf8_X_non_hangul <br>
is_utf8_X_prepend <br>
jmaybe <br>
keyword <br>
keyword_plugin_standard <br>
list <br>
localize <br>
mad_free <br>
madlex <br>
madparse <br>
magic_clear_all_env <br>
magic_clearenv <br>
magic_clearisa <br>
magic_clearpack <br>
magic_clearsig <br>
magic_existspack <br>
magic_freearylen_p <br>
magic_freeovrld <br>
magic_get <br>
magic_getarylen <br>
magic_getdefelem <br>
magic_getnkeys <br>
magic_getpack <br>
magic_getpos <br>
magic_getsig <br>
magic_getsubstr <br>
magic_gettaint <br>
magic_getuvar <br>
magic_getvec <br>
magic_killbackrefs <br>
magic_len <br>
magic_nextpack <br>
magic_regdata_cnt <br>
magic_regdatum_get <br>
magic_regdatum_set <br>
magic_scalarpack <br>
magic_set <br>
magic_set_all_env <br>
magic_setamagic <br>
magic_setarylen <br>
magic_setcollxfrm <br>
magic_setdbline <br>
magic_setdefelem <br>
magic_setenv <br>
magic_setisa <br>
magic_setmglob <br>
magic_setnkeys <br>
magic_setpack <br>
magic_setpos <br>
magic_setregexp <br>
magic_setsig <br>
magic_setsubstr <br>
magic_settaint <br>
magic_setutf8 <br>
magic_setuvar <br>
magic_setvec <br>
magic_setvstring <br>
magic_sizepack <br>
magic_wipepack <br>
malloc_good_size <br>
malloced_size <br>
mem_collxfrm <br>
mode_from_discipline <br>
more_bodies <br>
mro_meta_dup <br>
mro_meta_init <br>
munge_qwlist_to_paren_list <br>
my_attrs <br>
my_betoh16 <br>
my_betoh32 <br>
my_betoh64 <br>
my_betohi <br>
my_betohl <br>
my_betohs <br>
my_clearenv <br>
my_htobe16 <br>
my_htobe32 <br>
my_htobe64 <br>
my_htobei <br>
my_htobel <br>
my_htobes <br>
my_htole16 <br>
my_htole32 <br>
my_htole64 <br>
my_htolei <br>
my_htolel <br>
my_htoles <br>
my_letoh16 <br>
my_letoh32 <br>
my_letoh64 <br>
my_letohi <br>
my_letohl <br>
my_letohs <br>
my_lstat_flags <br>
my_stat_flags <br>
my_swabn <br>
my_unexec <br>
newATTRSUB_flags <br>
newGP <br>
newMADPROP <br>
newMADsv <br>
newTOKEN <br>
newXS_len_flags <br>
new_warnings_bitfield <br>
nextargv <br>
oopsAV <br>
oopsHV <br>
op_clear <br>
op_const_sv <br>
op_getmad <br>
op_getmad_weak <br>
op_integerize <br>
op_lvalue_flags <br>
op_refcnt_dec <br>
op_refcnt_inc <br>
op_std_init <br>
op_xmldump <br>
package <br>
package_version <br>
parse_unicode_opts <br>
parser_free <br>
peep <br>
pending_Slabs_to_ro <br>
pmop_xmldump <br>
pmruntime <br>
populate_isa <br>
prepend_madprops <br>
qerror <br>
reg_named_buff <br>
reg_named_buff_iter <br>
reg_numbered_buff_fetch <br>
reg_numbered_buff_length <br>
reg_numbered_buff_store <br>
reg_qr_package <br>
reg_temp_copy <br>
regcurly <br>
regprop <br>
report_evil_fh <br>
report_redefined_cv <br>
report_wrongway_fh <br>
rpeep <br>
rsignal_restore <br>
rsignal_save <br>
rxres_save <br>
same_dirent <br>
sawparens <br>
scalar <br>
scalarvoid <br>
set_regclass_bit <br>
sighandler <br>
softref2xv <br>
sub_crush_depth <br>
sv_add_backref <br>
sv_catxmlpv <br>
sv_catxmlpvn <br>
sv_catxmlsv <br>
sv_compile_2op_is_broken <br>
sv_del_backref <br>
sv_free2 <br>
sv_kill_backrefs <br>
sv_sethek <br>
sv_setsv_cow <br>
sv_unglob <br>
sv_xmlpeek <br>
tied_method <br>
token_free <br>
token_getmad <br>
translate_substr_offsets <br>
try_amagic_bin <br>
try_amagic_un <br>
unshare_hek <br>
utilize <br>
varname <br>
vivify_defelem <br>
vivify_ref <br>
wait4pid <br>
was_lvalue_sub <br>
watch <br>
write_to_stderr <br>
xmldump_all <br>
xmldump_all_perl <br>
xmldump_eval <br>
xmldump_form <br>
xmldump_indent <br>
xmldump_packsubs <br>
xmldump_packsubs_perl <br>
xmldump_sub <br>
xmldump_sub_perl <br>
xmldump_vindent <br>
xs_apiversion_bootcheck <br>
xs_version_bootcheck <br>
yyerror <br>
yyerror_pv <br>
yyerror_pvn <br>
yylex <br>
yyparse <br>
yyunlex</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
autodocumentation system was originally added to the Perl
core by Benjamin Stuhl. Documentation is by whoever was kind
enough to document their functions.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlguts,
perlapi</p>
<hr>
</body>
</html>
