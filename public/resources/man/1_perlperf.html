<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLPERF</title>

</head>
<body>

<h1 align="center">PERLPERF</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#GENERAL GUIDELINES">GENERAL GUIDELINES</a><br>
<a href="#BENCHMARKS">BENCHMARKS</a><br>
<a href="#PROFILING TOOLS">PROFILING TOOLS</a><br>
<a href="#SORTING">SORTING</a><br>
<a href="#LOGGING">LOGGING</a><br>
<a href="#POSTSCRIPT">POSTSCRIPT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlperf
&minus; Perl Performance and Optimization Techniques</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is an
introduction to the use of performance and optimization
techniques which can be used with particular reference to
perl programs. While many perl developers have come from
other languages, and can use their prior knowledge where
appropriate, there are many other people who might benefit
from a few perl specific pointers. If you want the condensed
version, perhaps the best advice comes from the renowned
Japanese Samurai, Miyamoto Musashi, who said:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;Do Not Engage in Useless Activity&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">in 1645.</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perhaps the
most common mistake programmers make is to attempt to
optimize their code before a program actually does anything
useful &minus; this is a bad idea. There&rsquo;s no point in
having an extremely fast program that doesn&rsquo;t work.
The first job is to get a program to <i>correctly</i> do
something <b>useful</b>, (not to mention ensuring the test
suite is fully functional), and only then to consider
optimizing it. Having decided to optimize existing working
code, there are several simple but essential steps to
consider which are intrinsic to any optimization
process.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>ONE
STEP SIDEWAYS</small></b> <br>
Firstly, you need to establish a baseline time for the
existing code, which timing needs to be reliable and
repeatable. You&rsquo;ll probably want to use the
<tt>&quot;Benchmark&quot;</tt> or
<tt>&quot;Devel::NYTProf&quot;</tt> modules, or something
similar, for this step, or perhaps the Unix system
<tt>&quot;time&quot;</tt> utility, whichever is appropriate.
See the base of this document for a longer list of
benchmarking and profiling modules, and recommended further
reading.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>ONE
STEP FORWARD</small></b> <br>
Next, having examined the program for <i>hot spots</i>,
(places where the code seems to run slowly), change the code
with the intention of making it run faster. Using version
control software, like <tt>&quot;subversion&quot;</tt>, will
ensure no changes are irreversible. It&rsquo;s too easy to
fiddle here and fiddle there &minus; don&rsquo;t change too
much at any one time or you might not discover which piece
of code <b>really</b> was the slow bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ANOTHER
STEP SIDEWAYS</small></b> <br>
It&rsquo;s not enough to say: &quot;that will make it run
faster&quot;, you have to check it. Rerun the code under
control of the benchmarking or profiling modules, from the
first step above, and check that the new code executed the
<b>same task</b> in <i>less time</i>. Save your work and
repeat...</p>

<h2>GENERAL GUIDELINES
<a name="GENERAL GUIDELINES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The critical
thing when considering performance is to remember there is
no such thing as a <tt>&quot;Golden Bullet&quot;</tt>, which
is why there are no rules, only guidelines.</p>

<p style="margin-left:11%; margin-top: 1em">It is clear
that inline code is going to be faster than subroutine or
method calls, because there is less overhead, but this
approach has the disadvantage of being less maintainable and
comes at the cost of greater memory usage &minus; there is
no such thing as a free lunch. If you are searching for an
element in a list, it can be more efficient to store the
data in a hash structure, and then simply look to see
whether the key is defined, rather than to loop through the
entire array using <i>grep()</i> for instance.
<i>substr()</i> may be (a lot) faster than <i>grep()</i> but
not as flexible, so you have another trade-off to access.
Your code may contain a line which takes 0.01 of a second to
execute which if you call it 1,000 times, quite likely in a
program parsing even medium sized files for instance, you
already have a 10 second delay, in just one single code
location, and if you call that line 100,000 times, your
entire program will slow down to an unbearable crawl.</p>

<p style="margin-left:11%; margin-top: 1em">Using a
subroutine as part of your sort is a powerful way to get
exactly what you want, but will usually be slower than the
built-in <i>alphabetic</i> <tt>&quot;cmp&quot;</tt> and
<i>numeric</i> <tt>&quot;&lt;=&gt;&quot;</tt> sort
operators. It is possible to make multiple passes over your
data, building indices to make the upcoming sort more
efficient, and to use what is known as the
<tt>&quot;OM&quot;</tt> (Orcish Maneuver) to cache the sort
keys in advance. The cache lookup, while a good idea, can
itself be a source of slowdown by enforcing a double pass
over the data &minus; once to setup the cache, and once to
sort the data. Using <tt>&quot;pack()&quot;</tt> to extract
the required sort key into a consistent string can be an
efficient way to build a single string to compare, instead
of using multiple sort keys, which makes it possible to use
the standard, written in <tt>&quot;c&quot;</tt> and fast,
perl <tt>&quot;sort()&quot;</tt> function on the output, and
is the basis of the <tt>&quot;GRT&quot;</tt> (Guttman
Rossler Transform). Some string combinations can slow the
<tt>&quot;GRT&quot;</tt> down, by just being too plain
complex for it&rsquo;s own good.</p>

<p style="margin-left:11%; margin-top: 1em">For
applications using database backends, the standard
<tt>&quot;DBIx&quot;</tt> namespace has tries to help with
keeping things nippy, not least because it tries to
<i>not</i> query the database until the latest possible
moment, but always read the docs which come with your choice
of libraries. Among the many issues facing developers
dealing with databases should remain aware of is to always
use <tt>&quot;SQL&quot;</tt> placeholders and to consider
pre-fetching data sets when this might prove advantageous.
Splitting up a large file by assigning multiple processes to
parsing a single file, using say <tt>&quot;POE&quot;</tt>,
<tt>&quot;threads&quot;</tt> or <tt>&quot;fork&quot;</tt>
can also be a useful way of optimizing your usage of the
available <tt>&quot;CPU&quot;</tt> resources, though this
technique is fraught with concurrency issues and demands
high attention to detail.</p>

<p style="margin-left:11%; margin-top: 1em">Every case has
a specific application and one or more exceptions, and there
is no replacement for running a few tests and finding out
which method works best for your particular environment,
this is why writing optimal code is not an exact science,
and why we love using Perl so much &minus;
<small>TMTOWTDI</small> .</p>

<h2>BENCHMARKS
<a name="BENCHMARKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Here are a few
examples to demonstrate usage of Perl&rsquo;s benchmarking
tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Assigning
and Dereferencing Variables.</b> <br>
I&rsquo;m sure most of us have seen code which looks like,
(or worse than), this:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ( $obj&minus;&gt;{_ref}&minus;&gt;{_myscore} &gt;= $obj&minus;&gt;{_ref}&minus;&gt;{_yourscore} ) {
        ...</pre>


<p style="margin-left:11%; margin-top: 1em">This sort of
code can be a real eyesore to read, as well as being very
sensitive to typos, and it&rsquo;s much clearer to
dereference the variable explicitly. We&rsquo;re
side-stepping the issue of working with object-oriented
programming techniques to encapsulate variable access via
methods, only accessible through an object. Here we&rsquo;re
just discussing the technical implementation of choice, and
whether this has an effect on performance. We can see
whether this dereferencing operation, has any overhead by
putting comparative code in a file and running a
<tt>&quot;Benchmark&quot;</tt> test.</p>

<p style="margin-left:11%; margin-top: 1em">#
dereference</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl
    use strict;
    use warnings;
    use Benchmark;
    my $ref = {
            'ref'   =&gt; {
                _myscore    =&gt; '100 + 1',
                _yourscore  =&gt; '102 &minus; 1',
            },
    };
    timethese(1000000, {
            'direct'       =&gt; sub {
                my $x = $ref&minus;&gt;{ref}&minus;&gt;{_myscore} . $ref&minus;&gt;{ref}&minus;&gt;{_yourscore} ;
            },
            'dereference'  =&gt; sub {
                my $ref  = $ref&minus;&gt;{ref};
                my $myscore = $ref&minus;&gt;{_myscore};
                my $yourscore = $ref&minus;&gt;{_yourscore};
                my $x = $myscore . $yourscore;
            },
    });</pre>


<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
essential to run any timing measurements a sufficient number
of times so the numbers settle on a numerical average,
otherwise each run will naturally fluctuate due to
variations in the environment, to reduce the effect of
contention for <tt>&quot;CPU&quot;</tt> resources and
network bandwidth for instance. Running the above code for
one million iterations, we can take a look at the report
output by the <tt>&quot;Benchmark&quot;</tt> module, to see
which approach is the most effective.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl dereference
    Benchmark: timing 1000000 iterations of dereference, direct...
    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)</pre>


<p style="margin-left:11%; margin-top: 1em">The difference
is clear to see and the dereferencing approach is slower.
While it managed to execute an average of 628,930 times a
second during our test, the direct approach managed to run
an additional 204,403 times, unfortunately. Unfortunately,
because there are many examples of code written using the
multiple layer direct variable access, and it&rsquo;s
usually horrible. It is, however, minusculy faster. The
question remains whether the minute gain is actually worth
the eyestrain, or the loss of maintainability.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Search and
replace or tr</b> <br>
If we have a string which needs to be modified, while a
regex will almost always be much more flexible,
<tt>&quot;tr&quot;</tt>, an oft underused tool, can still be
a useful. One scenario might be replace all vowels with
another character. The regex solution might look like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $str =~ s/[aeiou]/x/g</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;tr&quot;</tt> alternative might look like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $str =~ tr/aeiou/xxxxx/</pre>


<p style="margin-left:11%; margin-top: 1em">We can put that
into a test file which we can run to check which approach is
the fastest, using a global <tt>$STR</tt> variable to assign
to the <tt>&quot;my $str&quot;</tt> variable so as to avoid
perl trying to optimize any of the work away by noticing
it&rsquo;s assigned only the once.</p>

<p style="margin-left:11%; margin-top: 1em">#
regex-transliterate</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl
    use strict;
    use warnings;
    use Benchmark;
    my $STR = &quot;$$&minus;this and that&quot;;
    timethese( 1000000, {
            'sr'  =&gt; sub { my $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
            'tr'  =&gt; sub { my $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
    });</pre>


<p style="margin-left:11%; margin-top: 1em">Running the
code gives us our results:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl regex&minus;transliterate
    Benchmark: timing 1000000 iterations of sr, tr...
            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;tr&quot;</tt> version is a clear winner. One
solution is flexible, the other is fast &minus; and
it&rsquo;s appropriately the programmer&rsquo;s choice which
to use.</p>

<p style="margin-left:11%; margin-top: 1em">Check the
<tt>&quot;Benchmark&quot;</tt> docs for further useful
techniques.</p>

<h2>PROFILING TOOLS
<a name="PROFILING TOOLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A slightly
larger piece of code will provide something on which a
profiler can produce more extensive reporting statistics.
This example uses the simplistic
<tt>&quot;wordmatch&quot;</tt> program which parses a given
input file and spews out a short report on the contents.</p>

<p style="margin-left:11%; margin-top: 1em"># wordmatch</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl
    use strict;
    use warnings;
    =head1 NAME
    filewords &minus; word analysis of input file
    =head1 SYNOPSIS
        filewords &minus;f inputfilename [&minus;d]
    =head1 DESCRIPTION
    This program parses the given filename, specified with C&lt;&minus;f&gt;, and displays a
    simple analysis of the words found therein.  Use the C&lt;&minus;d&gt; switch to enable
    debugging messages.
    =cut
    use FileHandle;
    use Getopt::Long;
    my $debug   =  0;
    my $file    = '';
    my $result = GetOptions (
        'debug'         =&gt; \$debug,
        'file=s'        =&gt; \$file,
    );
    die(&quot;invalid args&quot;) unless $result;
    unless ( &minus;f $file ) {
        die(&quot;Usage: $0 &minus;f filename [&minus;d]&quot;);
    }
    my $FH = FileHandle&minus;&gt;new(&quot;&lt; $file&quot;) or die(&quot;unable to open file($file): $!&quot;);
    my $i_LINES = 0;
    my $i_WORDS = 0;
    my %count   = ();
    my @lines = &lt;$FH&gt;;
    foreach my $line ( @lines ) {
        $i_LINES++;
        $line =~ s/\n//;
        my @words = split(/ +/, $line);
        my $i_words = scalar(@words);
        $i_WORDS = $i_WORDS + $i_words;
        debug(&quot;line: $i_LINES supplying $i_words words: @words&quot;);
        my $i_word = 0;
        foreach my $word ( @words ) {
            $i_word++;
            $count{$i_LINES}{spec} += matches($i_word, $word, '[^a&minus;zA&minus;Z0&minus;9]');
            $count{$i_LINES}{only} += matches($i_word, $word, '^[^a&minus;zA&minus;Z0&minus;9]+$');
            $count{$i_LINES}{cons} += matches($i_word, $word, '^[(?i:bcdfghjklmnpqrstvwxyz)]+$');
            $count{$i_LINES}{vows} += matches($i_word, $word, '^[(?i:aeiou)]+$');
            $count{$i_LINES}{caps} += matches($i_word, $word, '^[(A&minus;Z)]+$');
        }
    }
    print report( %count );
    sub matches {
        my $i_wd  = shift;
        my $word  = shift;
        my $regex = shift;
        my $has = 0;
        if ( $word =~ /($regex)/ ) {
            $has++ if $1;
        }
        debug(&quot;word: $i_wd &quot;.($has ? 'matches' : 'does not match').&quot; chars: /$regex/&quot;);
        return $has;
    }
    sub report {
        my %report = @_;
        my %rep;
        foreach my $line ( keys %report ) {
            foreach my $key ( keys %{ $report{$line} } ) {
                $rep{$key} += $report{$line}{$key};
            }
        }
        my $report = qq|
    $0 report for $file:
    lines in file: $i_LINES
    words in file: $i_WORDS
    words with special (non&minus;word) characters: $i_spec
    words with only special (non&minus;word) characters: $i_only
    words with only consonants: $i_cons
    words with only capital letters: $i_caps
    words with only vowels: $i_vows
    |;
        return $report;
    }
    sub debug {
        my $message = shift;
        if ( $debug ) {
            print STDERR &quot;DBG: $message\n&quot;;
        }
    }
    exit 0;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Devel::DProf</b>
<br>
This venerable module has been the de-facto standard for
Perl code profiling for more than a decade, but has been
replaced by a number of other modules which have brought us
back to the 21st century. Although you&rsquo;re recommended
to evaluate your tool from the several mentioned here and
from the <small>CPAN</small> list at the base of this
document, (and currently Devel::NYTProf seems to be the
weapon of choice &minus; see below), we&rsquo;ll take a
quick look at the output from Devel::DProf first, to set a
baseline for Perl profiling tools. Run the above program
under the control of <tt>&quot;Devel::DProf&quot;</tt> by
using the <tt>&quot;&minus;d&quot;</tt> switch on the
command-line.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;d:DProf wordmatch &minus;f perl5db.pl
    &lt;...multiple lines snipped...&gt;
    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non&minus;word) characters: 20480
    words with only special (non&minus;word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Devel::DProf&quot;
produces a special file, called <i>tmon.out</i> by default,
and this file is read by the <tt>&quot;dprofpp&quot;</tt>
program, which is already installed as part of the
<tt>&quot;Devel::DProf&quot;</tt> distribution. If you call
<tt>&quot;dprofpp&quot;</tt> with no options, it will read
the <i>tmon.out</i> file in the current directory and
produce a human readable statistics report of the run of
your program. Note that this may take a little time.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; dprofpp
    Total Elapsed Time = 2.951677 Seconds
      User+System Time = 2.871677 Seconds
    Exclusive Times
    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
     1.74   0.050  0.050      1   0.0500 0.0500  main::report
     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Getopt::Long::FindOption
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Symbol::BEGIN
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Fcntl::BEGIN
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Fcntl::bootstrap
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  warnings::BEGIN
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  IO::bootstrap
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Getopt::Long::ConfigDefaults
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Getopt::Long::Configure
     0.00       &minus; &minus;0.000      1        &minus;      &minus;  Symbol::gensym</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;dprofpp&quot;
will produce some quite detailed reporting on the activity
of the <tt>&quot;wordmatch&quot;</tt> program. The
wallclock, user and system, times are at the top of the
analysis, and after this are the main columns defining which
define the report. Check the <tt>&quot;dprofpp&quot;</tt>
docs for details of the many options it supports.</p>

<p style="margin-left:11%; margin-top: 1em">See also
<tt>&quot;Apache::DProf&quot;</tt> which hooks
<tt>&quot;Devel::DProf&quot;</tt> into
<tt>&quot;mod_perl&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Devel::Profiler</b>
<br>
Let&rsquo;s take a look at the same program using a
different profiler: <tt>&quot;Devel::Profiler&quot;</tt>, a
drop-in Perl-only replacement for
<tt>&quot;Devel::DProf&quot;</tt>. The usage is very
slightly different in that instead of using the special
<tt>&quot;&minus;d:&quot;</tt> flag, you pull
<tt>&quot;Devel::Profiler&quot;</tt> in directly as a module
using <tt>&quot;&minus;M&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;MDevel::Profiler wordmatch &minus;f perl5db.pl
    &lt;...multiple lines snipped...&gt;
    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non&minus;word) characters: 20480
    words with only special (non&minus;word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Devel::Profiler&quot;
generates a tmon.out file which is compatible with the
<tt>&quot;dprofpp&quot;</tt> program, thus saving the
construction of a dedicated statistics reader program.
<tt>&quot;dprofpp&quot;</tt> usage is therefore identical to
the above example.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; dprofpp
    Total Elapsed Time =   20.984 Seconds
      User+System Time =   19.981 Seconds
    Exclusive Times
    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
     0.25   0.049  0.049      1   0.0490 0.0490  main::report
     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open</pre>


<p style="margin-left:11%; margin-top: 1em">Interestingly
we get slightly different results, which is mostly because
the algorithm which generates the report is different, even
though the output file format was allegedly identical. The
elapsed, user and system times are clearly showing the time
it took for <tt>&quot;Devel::Profiler&quot;</tt> to execute
its own run, but the column listings feel more accurate
somehow than the ones we had earlier from
<tt>&quot;Devel::DProf&quot;</tt>. The 102% figure has
disappeared, for example. This is where we have to use the
tools at our disposal, and recognise their pros and cons,
before using them. Interestingly, the numbers of calls for
each subroutine are identical in the two reports, it&rsquo;s
the percentages which differ. As the author of
<tt>&quot;Devel::Proviler&quot;</tt> writes:</p>

<pre style="margin-left:11%; margin-top: 1em">    ...running HTML::Template's test suite under Devel::DProf shows output()
    taking NO time but Devel::Profiler shows around 10% of the time is in output().
    I don't know which to trust but my gut tells me something is wrong with
    Devel::DProf.  HTML::Template::output() is a big routine that's called for
    every test. Either way, something needs fixing.</pre>



<p style="margin-left:11%; margin-top: 1em"><small>YMMV</small>
.</p>

<p style="margin-left:11%; margin-top: 1em">See also
<tt>&quot;Devel::Apache::Profiler&quot;</tt> which hooks
<tt>&quot;Devel::Profiler&quot;</tt> into
<tt>&quot;mod_perl&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Devel::SmallProf</b>
<br>
The <tt>&quot;Devel::SmallProf&quot;</tt> profiler examines
the runtime of your Perl program and produces a line-by-line
listing to show how many times each line was called, and how
long each line took to execute. It is called by supplying
the familiar <tt>&quot;&minus;d&quot;</tt> flag to Perl at
runtime.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;d:SmallProf wordmatch &minus;f perl5db.pl
    &lt;...multiple lines snipped...&gt;
    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non&minus;word) characters: 20480
    words with only special (non&minus;word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Devel::SmallProf&quot;
writes it&rsquo;s output into a file called
<i>smallprof.out</i>, by default. The format of the file
looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;num&gt; &lt;time&gt; &lt;ctime&gt; &lt;line&gt;:&lt;text&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">When the
program has terminated, the output may be examined and
sorted using any standard text filtering utilities.
Something like the following may be sufficient:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; cat smallprof.out | grep \d*: | sort &minus;k3 | tac | head &minus;n20
    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
    251215   0.03264   4.40000    79: debug(&quot;word: $i_wd &quot;.($has ? 'matches' :
    251215   0.02693   4.10000    81: return $has;
    260643   0.02841   4.07000   128: if ( $debug ) {
    260643   0.02601   4.04000   126: my $message = shift;
    251215   0.02641   3.91000    73: my $has = 0;
    251215   0.03311   3.71000    70: my $i_wd  = shift;
    251215   0.02699   3.69000    72: my $regex = shift;
    251215   0.02766   3.68000    71: my $word  = shift;
     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
     50243   0.00644   0.89000    56:  my $i_cons = matches($i_word, $word,
     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
     50243   0.00516   0.88000    58:  my $i_caps = matches($i_word, $word, '^[(A&minus;
     50243   0.00631   0.81000    54:  my $i_spec = matches($i_word, $word, '[^a&minus;
     50243   0.00496   0.80000    57:  my $i_vows = matches($i_word, $word,
     50243   0.00688   0.80000    53:  $i_word++;
     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
     50243   0.00683   0.75000    55:  my $i_only = matches($i_word, $word, '^[^a&minus;</pre>


<p style="margin-left:11%; margin-top: 1em">You can
immediately see a slightly different focus to the subroutine
profiling modules, and we start to see exactly which line of
code is taking the most time. That regex line is looking a
bit suspicious, for example. Remember that these tools are
supposed to be used together, there is no single best way to
profile your code, you need to use the best tools for the
job.</p>

<p style="margin-left:11%; margin-top: 1em">See also
<tt>&quot;Apache::SmallProf&quot;</tt> which hooks
<tt>&quot;Devel::SmallProf&quot;</tt> into
<tt>&quot;mod_perl&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Devel::FastProf</b>
<tt><br>
&quot;Devel::FastProf&quot;</tt> is another Perl line
profiler. This was written with a view to getting a faster
line profiler, than is possible with for example
<tt>&quot;Devel::SmallProf&quot;</tt>, because it&rsquo;s
written in <tt>&quot;C&quot;</tt>. To use
<tt>&quot;Devel::FastProf&quot;</tt>, supply the
<tt>&quot;&minus;d&quot;</tt> argument to Perl:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;d:FastProf wordmatch &minus;f perl5db.pl
    &lt;...multiple lines snipped...&gt;
    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non&minus;word) characters: 20480
    words with only special (non&minus;word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Devel::FastProf&quot;
writes statistics to the file <i>fastprof.out</i> in the
current directory. The output file, which can be specified,
can be interpreted by using the <tt>&quot;fprofpp&quot;</tt>
command-line program.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; fprofpp | head &minus;n20
    # fprofpp output format is:
    # filename:line time count: source
    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
    wordmatch:79 1.77774 251215: debug(&quot;word: $i_wd &quot;.($has ? 'matches' : 'does not match').&quot; chars: /$regex/&quot;);
    wordmatch:81 1.47604 251215: return $has;
    wordmatch:126 1.43441 260643: my $message = shift;
    wordmatch:128 1.42156 260643: if ( $debug ) {
    wordmatch:70 1.36824 251215: my $i_wd  = shift;
    wordmatch:71 1.36739 251215: my $word  = shift;
    wordmatch:72 1.35939 251215: my $regex = shift;</pre>


<p style="margin-left:11%; margin-top: 1em">Straightaway we
can see that the number of times each line has been called
is identical to the <tt>&quot;Devel::SmallProf&quot;</tt>
output, and the sequence is only very slightly different
based on the ordering of the amount of time each line took
to execute, <tt>&quot;if ( $debug ) { &quot;</tt> and
<tt>&quot;my $message = shift;&quot;</tt>, for example. The
differences in the actual times recorded might be in the
algorithm used internally, or it could be due to system
resource limitations or contention.</p>

<p style="margin-left:11%; margin-top: 1em">See also the
DBIx::Profile which will profile database queries running
under the <tt>&quot;DBIx::*&quot;</tt> namespace.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Devel::NYTProf</b>
<tt><br>
&quot;Devel::NYTProf&quot;</tt> is the <b>next
generation</b> of Perl code profiler, fixing many
shortcomings in other tools and implementing many cool
features. First of all it can be used as either a
<i>line</i> profiler, a <i>block</i> or a <i>subroutine</i>
profiler, all at once. It can also use sub-microsecond
(100ns) resolution on systems which provide
<tt>&quot;clock_gettime()&quot;</tt>. It can be started and
stopped even by the program being profiled. It&rsquo;s a
one-line entry to profile <tt>&quot;mod_perl&quot;</tt>
applications. It&rsquo;s written in <tt>&quot;c&quot;</tt>
and is probably the fastest profiler available for Perl. The
list of coolness just goes on. Enough of that, let&rsquo;s
see how to it works &minus; just use the familiar
<tt>&quot;&minus;d&quot;</tt> switch to plug it in and run
the code.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;d:NYTProf wordmatch &minus;f perl5db.pl
    wordmatch report for perl5db.pl:
    lines in file: 9427
    words in file: 50243
    words with special (non&minus;word) characters: 20480
    words with only special (non&minus;word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;NYTProf&quot;
will generate a report database into the file
<i>nytprof.out</i> by default. Human readable reports can be
generated from here by using the supplied
<tt>&quot;nytprofhtml&quot;</tt> ( <small>HTML</small>
output) and <tt>&quot;nytprofcsv&quot;</tt> (
<small>CSV</small> output) programs. We&rsquo;ve used the
Unix system <tt>&quot;html2text&quot;</tt> utility to
convert the <i>nytprof/index.html</i> file for convenience
here.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; html2text nytprof/index.html
    Performance Profile Index
    For wordmatch
      Run on Fri Sep 26 13:46:39 2008
    Reported on Fri Sep 26 13:47:23 2008
             Top 15 Subroutines &minus;&minus; ordered by exclusive time
    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
    |      |  |  |Time     |Time     |                                    |
    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |
    For more information see the full list of 189 subroutines.</pre>


<p style="margin-left:11%; margin-top: 1em">The first part
of the report already shows the critical information
regarding which subroutines are using the most time. The
next gives some statistics about the source files
profiled.</p>

<pre style="margin-left:11%; margin-top: 1em">            Source Code Files &minus;&minus; ordered by exclusive time then name
    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
    |       |Time     |       |                            |                    |
    |2699761|15.66654 |6e&minus;06  |line   .    block   .    sub|wordmatch           |
    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
    |323    |0.00248  |8e&minus;06  |line   .    block   .    sub|constant.pm         |
    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
    |198    |0.00085  |4e&minus;06  |line   .    block   .    sub|warnings/register.pm|
    |114    |0.00080  |7e&minus;06  |line   .    block   .    sub|strict.pm           |
    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
    |2701595|15.73869 |       |Total                       |
    |128647 |0.74946  |       |Average                     |
    |       |0.00201  |0.00003|Median                      |
    |       |0.00121  |0.00003|Deviation                   |
    Report produced by the NYTProf 2.03 Perl profiler, developed by Tim Bunce and
    Adam Kaplan.</pre>


<p style="margin-left:11%; margin-top: 1em">At this point,
if you&rsquo;re using the <i>html</i> report, you can click
through the various links to bore down into each subroutine
and each line of code. Because we&rsquo;re using the text
reporting here, and there&rsquo;s a whole directory full of
reports built for each source file, we&rsquo;ll just display
a part of the corresponding <i>wordmatch&minus;line.html</i>
file, sufficient to give an idea of the sort of output you
can expect from this cool tool.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; html2text nytprof/wordmatch&minus;line.html
    Performance Profile &minus;&minus; &minus;block view&minus;.&minus;line view&minus;.&minus;sub view&minus;
    For wordmatch
    Run on Fri Sep 26 13:46:39 2008
    Reported on Fri Sep 26 13:47:22 2008
    File wordmatch
     Subroutines &minus;&minus; ordered by exclusive time
    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
    |      | | |Time     |Time     |              |
    |251215|5|1|13.09263 |10.47692 |main::|matches|
    |260642|2|1|2.71199  |2.71199  |main::|debug  |
    |1     |1|1|0.21404  |0.21404  |main::|report |
    |0     |0|0|0        |0        |main::|BEGIN  |
    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
    |    |      |Time     |       |                                               |
    |1   |      |         |       |#!/usr/bin/perl                                |
    |2   |      |         |       |                                               |
    |    |      |         |       |use strict;                                    |
    |3   |3     |0.00086  |0.00029|# spent 0.00003s making 1 calls to strict::    |
    |    |      |         |       |import                                         |
    |    |      |         |       |use warnings;                                  |
    |4   |3     |0.01563  |0.00521|# spent 0.00012s making 1 calls to warnings::  |
    |    |      |         |       |import                                         |
    |5   |      |         |       |                                               |
    |6   |      |         |       |=head1 NAME                                    |
    |7   |      |         |       |                                               |
    |8   |      |         |       |filewords &minus; word analysis of input file        |
    &lt;...snip...&gt;
    |62  |1     |0.00445  |0.00445|print report( %count );                        |
    |    |      |         |       |# spent 0.21404s making 1 calls to main::report|
    |63  |      |         |       |                                               |
    |    |      |         |       |# spent 23.56955s (10.47692+2.61571) within    |
    |    |      |         |       |main::matches which was called 251215 times,   |
    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
    |    |      |         |       |sub matches {                                  |
    &lt;...snip...&gt;
    |102 |      |         |       |                                               |
    |    |      |         |       |# spent 2.71199s within main::debug which was  |
    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
    |    |      |         |       |0.00001s/call                                  |
    |    |      |         |       |sub debug {                                    |
    |104 |260642|0.58496  |2e&minus;06  |my $message = shift;                           |
    |105 |      |         |       |                                               |
    |106 |260642|1.09917  |4e&minus;06  |if ( $debug ) {                                |
    |107 |      |         |       |print STDERR &quot;DBG: $message\n&quot;;                |
    |108 |      |         |       |}                                              |
    |109 |      |         |       |}                                              |
    |110 |      |         |       |                                               |
    |111 |1     |0.01501  |0.01501|exit 0;                                        |
    |112 |      |         |       |                                               |</pre>


<p style="margin-left:11%; margin-top: 1em">Oodles of very
useful information in there &minus; this seems to be the way
forward.</p>

<p style="margin-left:11%; margin-top: 1em">See also
<tt>&quot;Devel::NYTProf::Apache&quot;</tt> which hooks
<tt>&quot;Devel::NYTProf&quot;</tt> into
<tt>&quot;mod_perl&quot;</tt>.</p>

<h2>SORTING
<a name="SORTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl modules
are not the only tools a performance analyst has at their
disposal, system tools like <tt>&quot;time&quot;</tt> should
not be overlooked as the next example shows, where we take a
quick look at sorting. Many books, theses and articles, have
been written about efficient sorting algorithms, and this is
not the place to repeat such work, there&rsquo;s several
good sorting modules which deserve taking a look at too:
<tt>&quot;Sort::Maker&quot;</tt>,
<tt>&quot;Sort::Key&quot;</tt> spring to mind. However,
it&rsquo;s still possible to make some observations on
certain Perl specific interpretations on issues relating to
sorting data sets and give an example or two with regard to
how sorting large data volumes can effect performance.
Firstly, an often overlooked point when sorting large
amounts of data, one can attempt to reduce the data set to
be dealt with and in many cases <tt>&quot;grep()&quot;</tt>
can be quite useful as a simple filter:</p>

<pre style="margin-left:11%; margin-top: 1em">    @data = sort grep { /$filter/ } @incoming</pre>


<p style="margin-left:11%; margin-top: 1em">A command such
as this can vastly reduce the volume of material to actually
sort through in the first place, and should not be too
lightly disregarded purely on the basis of its simplicity.
The <tt>&quot;KISS&quot;</tt> principle is too often
overlooked &minus; the next example uses the simple system
<tt>&quot;time&quot;</tt> utility to demonstrate.
Let&rsquo;s take a look at an actual example of sorting the
contents of a large file, an apache logfile would do. This
one has over a quarter of a million lines, is 50M in size,
and a snippet of it looks like this:</p>

<p style="margin-left:11%; margin-top: 1em"># logfile</p>

<pre style="margin-left:11%; margin-top: 1em">    188.209&minus;65&minus;87.adsl&minus;dyn.isp.belgacom.be &minus; &minus; [08/Feb/2007:12:57:16 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;&minus;&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    188.209&minus;65&minus;87.adsl&minus;dyn.isp.belgacom.be &minus; &minus; [08/Feb/2007:12:57:16 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;&minus;&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    151.56.71.198 &minus; &minus; [08/Feb/2007:12:57:41 +0000] &quot;GET /suse&minus;on&minus;vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux&minus;on&minus;laptops.com/sony.html&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en&minus;US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    151.56.71.198 &minus; &minus; [08/Feb/2007:12:57:42 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse&minus;on&minus;vaio.html&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en&minus;US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    151.56.71.198 &minus; &minus; [08/Feb/2007:12:57:43 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;&minus;&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en&minus;US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    217.113.68.60 &minus; &minus; [08/Feb/2007:13:02:15 +0000] &quot;GET / HTTP/1.1&quot; 304 &minus; &quot;&minus;&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    217.113.68.60 &minus; &minus; [08/Feb/2007:13:02:16 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    debora.to.isac.cnr.it &minus; &minus; [08/Feb/2007:13:03:58 +0000] &quot;GET /suse&minus;on&minus;vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux&minus;on&minus;laptops.com/sony.html&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    debora.to.isac.cnr.it &minus; &minus; [08/Feb/2007:13:03:58 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse&minus;on&minus;vaio.html&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    debora.to.isac.cnr.it &minus; &minus; [08/Feb/2007:13:03:58 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;&minus;&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    195.24.196.99 &minus; &minus; [08/Feb/2007:13:26:48 +0000] &quot;GET / HTTP/1.0&quot; 200 3309 &quot;&minus;&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    195.24.196.99 &minus; &minus; [08/Feb/2007:13:26:58 +0000] &quot;GET /data/css HTTP/1.0&quot; 404 206 &quot;http://www.rfi.net/&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    195.24.196.99 &minus; &minus; [08/Feb/2007:13:26:59 +0000] &quot;GET /favicon.ico HTTP/1.0&quot; 404 209 &quot;&minus;&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    crawl1.cosmixcorp.com &minus; &minus; [08/Feb/2007:13:27:57 +0000] &quot;GET /robots.txt HTTP/1.0&quot; 200 179 &quot;&minus;&quot; &quot;voyager/1.0&quot;
    crawl1.cosmixcorp.com &minus; &minus; [08/Feb/2007:13:28:25 +0000] &quot;GET /links.html HTTP/1.0&quot; 200 3413 &quot;&minus;&quot; &quot;voyager/1.0&quot;
    fhm226.internetdsl.tpnet.pl &minus; &minus; [08/Feb/2007:13:37:32 +0000] &quot;GET /suse&minus;on&minus;vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux&minus;on&minus;laptops.com/sony.html&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    fhm226.internetdsl.tpnet.pl &minus; &minus; [08/Feb/2007:13:37:34 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse&minus;on&minus;vaio.html&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    80.247.140.134 &minus; &minus; [08/Feb/2007:13:57:35 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;&minus;&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)&quot;
    80.247.140.134 &minus; &minus; [08/Feb/2007:13:57:37 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)&quot;
    pop.compuscan.co.za &minus; &minus; [08/Feb/2007:14:10:43 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;&minus;&quot; &quot;www.clamav.net&quot;
    livebot&minus;207&minus;46&minus;98&minus;57.search.live.com &minus; &minus; [08/Feb/2007:14:12:04 +0000] &quot;GET /robots.txt HTTP/1.0&quot; 200 179 &quot;&minus;&quot; &quot;msnbot/1.0 (+http://search.msn.com/msnbot.htm)&quot;
    livebot&minus;207&minus;46&minus;98&minus;57.search.live.com &minus; &minus; [08/Feb/2007:14:12:04 +0000] &quot;GET /html/oracle.html HTTP/1.0&quot; 404 214 &quot;&minus;&quot; &quot;msnbot/1.0 (+http://search.msn.com/msnbot.htm)&quot;
    dslb&minus;088&minus;064&minus;005&minus;154.pools.arcor&minus;ip.net &minus; &minus; [08/Feb/2007:14:12:15 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;&minus;&quot; &quot;www.clamav.net&quot;
    196.201.92.41 &minus; &minus; [08/Feb/2007:14:15:01 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;&minus;&quot; &quot;MOT&minus;L7/08.B7.DCR MIB/2.2.1 Profile/MIDP&minus;2.0 Configuration/CLDC&minus;1.1&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The specific
task here is to sort the 286,525 lines of this file by
Response Code, Query, Browser, Referring Url, and lastly
Date. One solution might be to use the following code, which
iterates over the files given on the command-line.</p>

<p style="margin-left:11%; margin-top: 1em">#
sort-apache-log</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl &minus;n
    use strict;
    use warnings;
    my @data;
    LINE:
    while ( &lt;&gt; ) {
        my $line = $_;
        if (
            $line =~ m/^(
                ([\w\.\&minus;]+)             # client
                \s*&minus;\s*&minus;\s*\[
                ([^]]+)                 # date
                \]\s*&quot;\w+\s*
                (\S+)                   # query
                [^&quot;]+&quot;\s*
                (\d+)                   # status
                \s+\S+\s+&quot;[^&quot;]*&quot;\s+&quot;
                ([^&quot;]*)                 # browser
                &quot;
                .*
            )$/x
        ) {
            my @chunks = split(/ +/, $line);
            my $ip      = $1;
            my $date    = $2;
            my $query   = $3;
            my $status  = $4;
            my $browser = $5;
            push(@data, [$ip, $date, $query, $status, $browser, $line]);
        }
    }
    my @sorted = sort {
        $a&minus;&gt;[3] cmp $b&minus;&gt;[3]
                ||
        $a&minus;&gt;[2] cmp $b&minus;&gt;[2]
                ||
        $a&minus;&gt;[0] cmp $b&minus;&gt;[0]
                ||
        $a&minus;&gt;[1] cmp $b&minus;&gt;[1]
                ||
        $a&minus;&gt;[4] cmp $b&minus;&gt;[4]
    } @data;
    foreach my $data ( @sorted ) {
        print $data&minus;&gt;[5];
    }
    exit 0;</pre>


<p style="margin-left:11%; margin-top: 1em">When running
this program, redirect <tt>&quot;STDOUT&quot;</tt> so it is
possible to check the output is correct from following test
runs and use the system <tt>&quot;time&quot;</tt> utility to
check the overall runtime.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; time ./sort&minus;apache&minus;log logfile &gt; out&minus;sort
    real    0m17.371s
    user    0m15.757s
    sys     0m0.592s</pre>


<p style="margin-left:11%; margin-top: 1em">The program
took just over 17 wallclock seconds to run. Note the
different values <tt>&quot;time&quot;</tt> outputs,
it&rsquo;s important to always use the same one, and to not
confuse what each one means. <br>
Elapsed Real Time</p>

<p style="margin-left:17%;">The overall, or wallclock, time
between when <tt>&quot;time&quot;</tt> was called, and when
it terminates. The elapsed time includes both user and
system times, and time spent waiting for other users and
processes on the system. Inevitably, this is the most
approximate of the measurements given.</p>

<p style="margin-left:11%;">User <small>CPU</small>
Time</p>

<p style="margin-left:17%;">The user time is the amount of
time the entire process spent on behalf of the user on this
system executing this program.</p>

<p style="margin-left:11%;">System <small>CPU</small>
Time</p>

<p style="margin-left:17%;">The system time is the amount
of time the kernel itself spent executing routines, or
system calls, on behalf of this process user.</p>

<p style="margin-left:11%; margin-top: 1em">Running this
same process as a <tt>&quot;Schwarzian Transform&quot;</tt>
it is possible to eliminate the input and output arrays for
storing all the data, and work on the input directly as it
arrives too. Otherwise, the code looks fairly similar:</p>

<p style="margin-left:11%; margin-top: 1em">#
sort-apache-log-schwarzian</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl &minus;n
    use strict;
    use warnings;
    print
        map $_&minus;&gt;[0] =&gt;
        sort {
            $a&minus;&gt;[4] cmp $b&minus;&gt;[4]
                    ||
            $a&minus;&gt;[3] cmp $b&minus;&gt;[3]
                    ||
            $a&minus;&gt;[1] cmp $b&minus;&gt;[1]
                    ||
            $a&minus;&gt;[2] cmp $b&minus;&gt;[2]
                    ||
            $a&minus;&gt;[5] cmp $b&minus;&gt;[5]
        }
        map  [ $_, m/^(
            ([\w\.\&minus;]+)             # client
            \s*&minus;\s*&minus;\s*\[
            ([^]]+)                 # date
            \]\s*&quot;\w+\s*
            (\S+)                   # query
            [^&quot;]+&quot;\s*
            (\d+)                   # status
            \s+\S+\s+&quot;[^&quot;]*&quot;\s+&quot;
            ([^&quot;]*)                 # browser
            &quot;
            .*
        )$/xo ]
        =&gt; &lt;&gt;;
    exit 0;</pre>


<p style="margin-left:11%; margin-top: 1em">Run the new
code against the same logfile, as above, to check the new
time.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; time ./sort&minus;apache&minus;log&minus;schwarzian logfile &gt; out&minus;schwarz
    real    0m9.664s
    user    0m8.873s
    sys     0m0.704s</pre>


<p style="margin-left:11%; margin-top: 1em">The time has
been cut in half, which is a respectable speed improvement
by any standard. Naturally, it is important to check the
output is consistent with the first program run, this is
where the Unix system <tt>&quot;cksum&quot;</tt> utility
comes in.</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; cksum out&minus;sort out&minus;schwarz
    3044173777 52029194 out&minus;sort
    3044173777 52029194 out&minus;schwarz</pre>



<p style="margin-left:11%; margin-top: 1em"><small>BTW</small>
. Beware too of pressure from managers who see you speed a
program up by 50% of the runtime once, only to get a request
one month later to do the same again (true story) &minus;
you&rsquo;ll just have to point out your only human, even if
you are a Perl programmer, and you&rsquo;ll see what you can
do...</p>

<h2>LOGGING
<a name="LOGGING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An essential
part of any good development process is appropriate error
handling with appropriately informative messages, however
there exists a school of thought which suggests that log
files should be <i>chatty</i>, as if the chain of unbroken
output somehow ensures the survival of the program. If speed
is in any way an issue, this approach is wrong.</p>

<p style="margin-left:11%; margin-top: 1em">A common sight
is code which looks something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    logger&minus;&gt;debug( &quot;A logging message via process&minus;id: $$ INC: &quot; . Dumper(\%INC) )</pre>


<p style="margin-left:11%; margin-top: 1em">The problem is
that this code will always be parsed and executed, even when
the debug level set in the logging configuration file is
zero. Once the <i>debug()</i> subroutine has been entered,
and the internal <tt>$debug</tt> variable confirmed to be
zero, for example, the message which has been sent in will
be discarded and the program will continue. In the example
given though, the \%INC hash will already have been dumped,
and the message string constructed, all of which work could
be bypassed by a debug variable at the statement level, like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    logger&minus;&gt;debug( &quot;A logging message via process&minus;id: $$ INC: &quot; . Dumper(\%INC) ) if $DEBUG;</pre>


<p style="margin-left:11%; margin-top: 1em">This effect can
be demonstrated by setting up a test script with both forms,
including a <tt>&quot;debug()&quot;</tt> subroutine to
emulate typical <tt>&quot;logger()&quot;</tt>
functionality.</p>

<p style="margin-left:11%; margin-top: 1em"># ifdebug</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl
    use strict;
    use warnings;
    use Benchmark;
    use Data::Dumper;
    my $DEBUG = 0;
    sub debug {
        my $msg = shift;
        if ( $DEBUG ) {
            print &quot;DEBUG: $msg\n&quot;;
        }
    };
    timethese(100000, {
            'debug'       =&gt; sub {
                debug( &quot;A $0 logging message via process&minus;id: $$&quot; . Dumper(\%INC) )
            },
            'ifdebug'  =&gt; sub {
                debug( &quot;A $0 logging message via process&minus;id: $$&quot; . Dumper(\%INC) ) if $DEBUG
            },
    });</pre>


<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s see
what <tt>&quot;Benchmark&quot;</tt> makes of this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl ifdebug
    Benchmark: timing 100000 iterations of constant, sub...
       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
                (warning: too few iterations for a reliable count)
         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)</pre>


<p style="margin-left:11%; margin-top: 1em">In the one case
the code, which does exactly the same thing as far as
outputting any debugging information is concerned, in other
words nothing, takes 14 seconds, and in the other case the
code takes one hundredth of a second. Looks fairly
definitive. Use a <tt>$DEBUG</tt> variable
<small>BEFORE</small> you call the subroutine, rather than
relying on the smart functionality inside it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Logging if
<small>DEBUG</small> (constant)</b> <br>
It&rsquo;s possible to take the previous idea a little
further, by using a compile time <tt>&quot;DEBUG&quot;</tt>
constant.</p>

<p style="margin-left:11%; margin-top: 1em">#
ifdebug-constant</p>

<pre style="margin-left:11%; margin-top: 1em">    #!/usr/bin/perl
    use strict;
    use warnings;
    use Benchmark;
    use Data::Dumper;
    use constant
        DEBUG =&gt; 0
    ;
    sub debug {
        if ( DEBUG ) {
            my $msg = shift;
            print &quot;DEBUG: $msg\n&quot;;
        }
    };
    timethese(100000, {
            'debug'       =&gt; sub {
                debug( &quot;A $0 logging message via process&minus;id: $$&quot; . Dumper(\%INC) )
            },
            'constant'  =&gt; sub {
                debug( &quot;A $0 logging message via process&minus;id: $$&quot; . Dumper(\%INC) ) if DEBUG
            },
    });</pre>


<p style="margin-left:11%; margin-top: 1em">Running this
program produces the following output:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl ifdebug&minus;constant
    Benchmark: timing 100000 iterations of constant, sub...
      constant:  0 wallclock secs (&minus;0.00 usr +  0.00 sys = &minus;0.00 CPU) @ &minus;7205759403792793600000.00/s (n=100000)
                (warning: too few iterations for a reliable count)
           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;DEBUG&quot;</tt> constant wipes the floor with
even the <tt>$debug</tt> variable, clocking in at minus zero
seconds, and generates a &quot;warning: too few iterations
for a reliable count&quot; message into the bargain. To see
what is really going on, and why we had too few iterations
when we thought we asked for 100000, we can use the very
useful <tt>&quot;B::Deparse&quot;</tt> to inspect the new
code:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;MO=Deparse ifdebug&minus;constant
    use Benchmark;
    use Data::Dumper;
    use constant ('DEBUG', 0);
    sub debug {
        use warnings;
        use strict 'refs';
        0;
    }
    use warnings;
    use strict 'refs';
    timethese(100000, {'sub', sub {
        debug &quot;A $0 logging message via process&minus;id: $$&quot; . Dumper(\%INC);
    }
    , 'constant', sub {
        0;
    }
    });
    ifdebug&minus;constant syntax OK</pre>


<p style="margin-left:11%; margin-top: 1em">The output
shows the <i>constant()</i> subroutine we&rsquo;re testing
being replaced with the value of the
<tt>&quot;DEBUG&quot;</tt> constant: zero. The line to be
tested has been completely optimized away, and you
can&rsquo;t get much more efficient than that.</p>

<h2>POSTSCRIPT
<a name="POSTSCRIPT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
has provided several way to go about identifying hot-spots,
and checking whether any modifications have improved the
runtime of the code.</p>

<p style="margin-left:11%; margin-top: 1em">As a final
thought, remember that it&rsquo;s not (at the time of
writing) possible to produce a useful program which will run
in zero or negative time and this basic principle can be
written as: <i>useful programs are slow</i> by their very
definition. It is of course possible to write a nearly
instantaneous program, but it&rsquo;s not going to do very
much, here&rsquo;s a very efficient one:</p>

<pre style="margin-left:11%; margin-top: 1em">    $&gt; perl &minus;e 0</pre>


<p style="margin-left:11%; margin-top: 1em">Optimizing that
any further is a job for <tt>&quot;p5p&quot;</tt>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Further reading
can be found using the modules and links below.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>PERLDOCS</small></b>
<br>
For example: <tt>&quot;perldoc &minus;f sort&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">perlfaq4.</p>

<p style="margin-left:11%; margin-top: 1em">perlfork,
perlfunc, perlretut, perlthrtut.</p>

<p style="margin-left:11%; margin-top: 1em">threads.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>MAN
PAGES</small></b> <tt><br>
&quot;time&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MODULES</small></b>
<br>
It&rsquo;s not possible to individually showcase all the
performance related code for Perl here, naturally, but
here&rsquo;s a short list of modules from the
<small>CPAN</small> which deserve further attention.</p>

<pre style="margin-left:11%; margin-top: 1em">    Apache::DProf
    Apache::SmallProf
    Benchmark
    DBIx::Profile
    Devel::AutoProfiler
    Devel::DProf
    Devel::DProfLB
    Devel::FastProf
    Devel::GraphVizProf
    Devel::NYTProf
    Devel::NYTProf::Apache
    Devel::Profiler
    Devel::Profile
    Devel::Profit
    Devel::SmallProf
    Devel::WxProf
    POE::Devel::Profiler
    Sort::Key
    Sort::Maker</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>URLS</small></b>
<br>
Very useful online reference material:</p>

<pre style="margin-left:11%; margin-top: 1em">    http://www.ccl4.org/~nick/P/Fast_Enough/
    http://www&minus;128.ibm.com/developerworks/library/l&minus;optperl.html
    http://perlbuzz.com/2007/11/bind&minus;output&minus;variables&minus;in&minus;dbi&minus;for&minus;speed&minus;and&minus;safety.html
    http://en.wikipedia.org/wiki/Performance_analysis
    http://apache.perl.org/docs/1.0/guide/performance.html
    http://perlgolf.sourceforge.net/
    http://www.sysarch.com/Perl/sort_paper.html</pre>


<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Richard Foley
&lt;richard.foley@rfi.net&gt; Copyright (c) 2008</p>
<hr>
</body>
</html>
