<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:33 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLTRAP</title>

</head>
<body>

<h1 align="center">PERLTRAP</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perltrap
&minus; Perl traps for the unwary</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The biggest
trap of all is forgetting to <tt>&quot;use
warnings&quot;</tt> or use the <b>&minus;w</b> switch; see
perllexwarn and perlrun. The second biggest trap is not
making your entire program runnable under <tt>&quot;use
strict&quot;</tt>. The third biggest trap is not reading the
list of changes in this version of Perl; see perldelta.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Awk
Traps</b> <br>
Accustomed <b>awk</b> users should take special note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A Perl program executes only once, not once for each
input line. You can do an implicit loop with
<tt>&quot;&minus;n&quot;</tt> or
<tt>&quot;&minus;p&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The English module, loaded via</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    use English;</pre>


<p style="margin-left:17%; margin-top: 1em">allows you to
refer to special variables (like <tt>$/</tt>) with names
(like <tt>$RS</tt>), as though they were in <b>awk</b>; see
perlvar for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Semicolons are required after
all simple statements in Perl (except at the end of a
block). Newline is not a statement delimiter.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Curly brackets are required on <tt>&quot;if&quot;</tt>s
and <tt>&quot;while&quot;</tt>s.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Variables begin with &quot;$&quot;, &quot;@&quot; or
&quot;%&quot; in Perl.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Arrays index from 0. Likewise string positions in
<i>substr()</i> and <i>index()</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have to decide whether your array has numeric or
string indices.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Hash values do not spring into existence upon mere
reference.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have to decide whether you want to use string or
numeric comparisons.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Reading an input line does not split it for you. You get
to split it to an array yourself. And the <i>split()</i>
operator has different arguments than
<b>awk</b>&rsquo;s.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The current input line is normally in <tt>$_</tt>, not
<tt>$0</tt>. It generally does not have the newline
stripped. ($0 is the name of the program executed.) See
perlvar.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>$&lt;<i>digit</i>&gt; does not refer to fields--it
refers to substrings matched by the last match pattern.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <i>print()</i> statement does not add field and
record separators unless you set <tt>$,</tt> and
<tt>&quot;$\&quot;</tt>. You can set <tt>$OFS</tt> and
<tt>$ORS</tt> if you&rsquo;re using the English module.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You must open your files before you print to them.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The range operator is &quot;..&quot;, not comma. The
comma operator works as in C.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The match operator is &quot;=~&quot;, not &quot;~&quot;.
(&quot;~&quot; is the one&rsquo;s complement operator, as in
C.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The exponentiation operator is &quot;**&quot;, not
&quot;^&quot;. &quot;^&quot; is the <small>XOR</small>
operator, as in C. (You know, one could get the feeling that
<b>awk</b> is basically incompatible with C.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The concatenation operator is &quot;.&quot;, not the
null string. (Using the null string would render
<tt>&quot;/pat/ /pat/&quot;</tt> unparsable, because the
third slash would be interpreted as a division operator--the
tokenizer is in fact slightly context sensitive for
operators like &quot;/&quot;, &quot;?&quot;, and
&quot;&gt;&quot;. And in fact, &quot;.&quot; itself can be
the beginning of a number.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <tt>&quot;next&quot;</tt>,
<tt>&quot;exit&quot;</tt>, and <tt>&quot;continue&quot;</tt>
keywords work differently.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The following variables work differently:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">      Awk       Perl
      ARGC      scalar @ARGV (compare with $#ARGV)
      ARGV[0]   $0
      FILENAME  $ARGV
      FNR       $. &minus; something
      FS        (whatever you like)
      NF        $#Fld, or some such
      NR        $.
      OFMT      $#
      OFS       $,
      ORS       $\
      RLENGTH   length($&amp;)
      RS        $/
      RSTART    length($`)
      SUBSEP    $;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You cannot set <tt>$RS</tt> to a
pattern, only a string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When in doubt, run the <b>awk</b> construct through
<b>a2p</b> and see what it gives you.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>C/C
<small>++</small> Traps</b> <br>
Cerebral C and C <small>++</small> programmers should take
note of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Curly brackets are required on
<tt>&quot;if&quot;</tt>&rsquo;s and
<tt>&quot;while&quot;</tt>&rsquo;s.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You must use <tt>&quot;elsif&quot;</tt> rather than
<tt>&quot;else if&quot;</tt>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <tt>&quot;break&quot;</tt> and
<tt>&quot;continue&quot;</tt> keywords from C become in Perl
<tt>&quot;last&quot;</tt> and <tt>&quot;next&quot;</tt>,
respectively. Unlike in C, these do <i>not</i> work within a
<tt>&quot;do { } while&quot;</tt> construct. See &quot;Loop
Control&quot; in perlsyn.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The switch statement is called
<tt>&quot;given/when&quot;</tt> and only available in perl
5.10 or newer. See &quot;Switch Statements&quot; in
perlsyn.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Variables begin with &quot;$&quot;, &quot;@&quot; or
&quot;%&quot; in Perl.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Comments begin with &quot;#&quot;, not &quot;/*&quot; or
&quot;//&quot;. Perl may interpret C/C <small>++</small>
comments as division operators, unterminated regular
expressions or the defined-or operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You can&rsquo;t take the address of anything, although a
similar operator in Perl is the backslash, which creates a
reference.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;ARGV&quot;</tt> must be capitalized.
<tt>$ARGV[0]</tt> is C&rsquo;s <tt>&quot;argv[1]&quot;</tt>,
and <tt>&quot;argv[0]&quot;</tt> ends up in <tt>$0</tt>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>System calls such as <i>link()</i>, <i>unlink()</i>,
<i>rename()</i>, etc. return nonzero for success, not 0.
(<i>system()</i>, however, returns zero for success.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Signal handlers deal with signal names, not numbers. Use
<tt>&quot;kill &minus;l&quot;</tt> to find their names on
your system.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Sed
Traps</b> <br>
Seasoned <b>sed</b> programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A Perl program executes only
once, not once for each input line. You can do an implicit
loop with <tt>&quot;&minus;n&quot;</tt> or
<tt>&quot;&minus;p&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Backreferences in substitutions use &quot;$&quot; rather
than &quot;\&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The pattern matching metacharacters &quot;(&quot;,
&quot;)&quot;, and &quot;|&quot; do not have backslashes in
front.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The range operator is <tt>&quot;...&quot;</tt>, rather
than comma.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Shell
Traps</b> <br>
Sharp shell programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The backtick operator does
variable interpolation without regard to the presence of
single quotes in the command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The backtick operator does no translation of the return
value, unlike <b>csh</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Shells (especially <b>csh</b>) do several levels of
substitution on each command line. Perl does substitution in
only certain constructs such as double quotes, backticks,
angle brackets, and search patterns.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Shells interpret scripts a little bit at a time. Perl
compiles the entire program before executing it (except for
<tt>&quot;BEGIN&quot;</tt> blocks, which execute at compile
time).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The arguments are available via <tt>@ARGV</tt>, not
<tt>$1</tt>, <tt>$2</tt>, etc.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The environment is not automatically made available as
separate scalar variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The shell&rsquo;s <tt>&quot;test&quot;</tt> uses
&quot;=&quot;, &quot;!=&quot;, &quot;&lt;&quot; etc for
string comparisons and &quot;&minus;eq&quot;,
&quot;&minus;ne&quot;, &quot;&minus;lt&quot; etc for numeric
comparisons. This is the reverse of Perl, which uses
<tt>&quot;eq&quot;</tt>, <tt>&quot;ne&quot;</tt>,
<tt>&quot;lt&quot;</tt> for string comparisons, and
<tt>&quot;==&quot;</tt>, <tt>&quot;!=&quot;
&quot;&lt;&quot;</tt> etc for numeric comparisons.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Perl
Traps</b> <br>
Practicing Perl Programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Remember that many operations
behave differently in a list context than they do in a
scalar one. See perldata for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Avoid barewords if you can, especially all lowercase
ones. You can&rsquo;t tell by just looking at it whether a
bareword is a function or a string. By using quotes on
strings and parentheses on function calls, you won&rsquo;t
ever get them confused.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You cannot discern from mere inspection which builtins
are unary operators (like <i>chop()</i> and <i>chdir()</i>)
and which are list operators (like <i>print()</i> and
<i>unlink()</i>). (Unless prototyped, user-defined
subroutines can <b>only</b> be list operators, never unary
ones.) See perlop and perlsub.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>People have a hard time remembering that some functions
default to <tt>$_</tt>, or <tt>@ARGV</tt>, or whatever, but
that others which you might expect to do not.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The &lt; <small>FH</small> &gt; construct is not the
name of the filehandle, it is a readline operation on that
handle. The data read is assigned to <tt>$_</tt> only if the
file read is the sole condition in a while loop:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    while (&lt;FH&gt;)      { }
    while (defined($_ = &lt;FH&gt;)) { }..
    &lt;FH&gt;;  # data discarded!</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Remember not to use
<tt>&quot;=&quot;</tt> when you need
<tt>&quot;=~&quot;</tt>; these two constructs are quite
different:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    $x =  /foo/;
    $x =~ /foo/;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The <tt>&quot;do {}&quot;</tt>
construct isn&rsquo;t a real loop that you can use loop
control on.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Use <tt>&quot;my()&quot;</tt> for local variables
whenever you can get away with it (but see perlform for
where you can&rsquo;t). Using <tt>&quot;local()&quot;</tt>
actually gives a local value to a global variable, which
leaves you open to unforeseen side-effects of dynamic
scoping.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you localize an exported variable in a module, its
exported value will not change. The local name becomes an
alias to a new value but the external name is still an alias
for the original.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Perl4 to
Perl5 Traps</b> <br>
Practicing Perl4 Programmers should take note of the
following Perl4&minus;to&minus;Perl5 specific traps.</p>

<p style="margin-left:11%; margin-top: 1em">They&rsquo;re
crudely ordered according to the following list: <br>
Discontinuance, Deprecation, and BugFix traps</p>

<p style="margin-left:17%;">Anything that&rsquo;s been
fixed as a perl4 bug, removed as a perl4 feature or
deprecated as a perl4 feature with the intent to encourage
usage of some other perl5 feature.</p>

<p style="margin-left:11%;">Parsing Traps</p>

<p style="margin-left:17%;">Traps that appear to stem from
the new parser.</p>

<p style="margin-left:11%;">Numerical Traps</p>

<p style="margin-left:17%;">Traps having to do with
numerical or mathematical operators.</p>

<p style="margin-left:11%;">General data type traps</p>

<p style="margin-left:17%;">Traps involving perl standard
data types.</p>

<p style="margin-left:11%;">Context Traps &minus; scalar,
list contexts</p>

<p style="margin-left:17%;">Traps related to context within
lists, scalar statements/declarations.</p>

<p style="margin-left:11%;">Precedence Traps</p>

<p style="margin-left:17%;">Traps related to the precedence
of parsing, evaluation, and execution of code.</p>

<p style="margin-left:11%;">General Regular Expression
Traps using s///, etc.</p>

<p style="margin-left:17%;">Traps related to the use of
pattern matching.</p>

<p style="margin-left:11%;">Subroutine, Signal, Sorting
Traps</p>

<p style="margin-left:17%;">Traps related to the use of
signals and signal handlers, general subroutines, and
sorting, along with sorting subroutines.</p>

<p style="margin-left:11%;"><small>OS</small> Traps</p>

<p style="margin-left:17%;">OS-specific traps.</p>

<p style="margin-left:11%;"><small>DBM</small> Traps</p>

<p style="margin-left:17%;">Traps specific to the use of
<tt>&quot;dbmopen()&quot;</tt>, and specific dbm
implementations.</p>

<p style="margin-left:11%;">Unclassified Traps</p>

<p style="margin-left:17%;">Everything else.</p>

<p style="margin-left:11%; margin-top: 1em">If you find an
example of a conversion trap that is not listed here, please
submit it to &lt;<i>perlbug@perl.org</i>&gt; for inclusion.
Also note that at least some of these can be caught with the
<tt>&quot;use warnings&quot;</tt> pragma or the
<b>&minus;w</b> switch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Discontinuance,
Deprecation, and BugFix traps</b> <br>
Anything that has been discontinued, deprecated, or fixed as
a bug from perl4.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="80%">


<p>Symbols starting with &quot;_&quot; no longer forced
into main</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Symbols
starting with &quot;_&quot; are no longer forced into
package main, except for <tt>$_</tt> itself (and
<tt>@_</tt>, etc.).</p>

<pre style="margin-left:17%; margin-top: 1em">    package test;
    $_legacy = 1;
    package main;
    print &quot;\$_legacy is &quot;,$_legacy,&quot;\n&quot;;
    # perl4 prints: $_legacy is 1
    # perl5 prints: $_legacy is</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="81%">


<p style="margin-top: 1em">Double-colon valid package
separator in variable name</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Double-colon is
now a valid package separator in a variable name. Thus these
behave differently in perl4 vs. perl5, because the packages
don&rsquo;t exist.</p>

<pre style="margin-left:17%; margin-top: 1em">    $a=1;$b=2;$c=3;$var=4;
    print &quot;$a::$b::$c &quot;;
    print &quot;$var::abc::xyz\n&quot;;
    # perl4 prints: 1::2::3 4::abc::xyz
    # perl5 prints: 3</pre>


<p style="margin-left:17%; margin-top: 1em">Given that
<tt>&quot;::&quot;</tt> is now the preferred package
delimiter, it is debatable whether this should be classed as
a bug or not. (The older package delimiter, &rsquo; ,is used
here)</p>

<pre style="margin-left:17%; margin-top: 1em">    $x = 10;
    print &quot;x=${'x}\n&quot;;
    # perl4 prints: x=10
    # perl5 prints: Can't find string terminator &quot;'&quot; anywhere before EOF</pre>


<p style="margin-left:17%; margin-top: 1em">You can avoid
this problem, and remain compatible with perl4, if you
always explicitly include the package name:</p>

<pre style="margin-left:17%; margin-top: 1em">    $x = 10;
    print &quot;x=${main'x}\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">Also see
precedence traps, for parsing <tt>$:</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">2nd and 3rd args to
<tt>&quot;splice()&quot;</tt> are now in scalar context</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The second and
third arguments of <tt>&quot;splice()&quot;</tt> are now
evaluated in scalar context (as the Camel says) rather than
list context.</p>

<pre style="margin-left:17%; margin-top: 1em">    sub sub1{return(0,2) }          # return a 2&minus;element list
    sub sub2{ return(1,2,3)}        # return a 3&minus;element list
    @a1 = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);
    @a2 = splice(@a1,&amp;sub1,&amp;sub2);
    print join(' ',@a2),&quot;\n&quot;;
    # perl4 prints: a b
    # perl5 prints: c d e</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Can&rsquo;t do
<tt>&quot;goto&quot;</tt> into a block that is optimized
away</p> </td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You can&rsquo;t
do a <tt>&quot;goto&quot;</tt> into a block that is
optimized away. Darn.</p>

<pre style="margin-left:17%; margin-top: 1em">    goto marker1;
    for(1){
    marker1:
        print &quot;Here I is!\n&quot;;
    }
    # perl4 prints: Here I is!
    # perl5 errors: Can't &quot;goto&quot; into the middle of a foreach loop</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Can&rsquo;t use whitespace as
variable name or quote delimiter</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">It is no longer
syntactically legal to use whitespace as the name of a
variable, or as a delimiter for any kind of quote construct.
Double darn.</p>

<pre style="margin-left:17%; margin-top: 1em">    $a = (&quot;foo bar&quot;);
    $b = q baz ;
    print &quot;a is $a, b is $b\n&quot;;
    # perl4 prints: a is foo bar, b is baz
    # perl5 errors: Bareword found where operator expected</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">


<p style="margin-top: 1em"><tt>&quot;while/if BLOCK
BLOCK&quot;</tt> gone</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The archaic
while/if <small>BLOCK BLOCK</small> syntax is no longer
supported.</p>

<pre style="margin-left:17%; margin-top: 1em">    if { 1 } {
        print &quot;True!&quot;;
    }
    else {
        print &quot;False!&quot;;
    }
    # perl4 prints: True!
    # perl5 errors: syntax error at test.pl line 1, near &quot;if {&quot;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;**&quot;</tt> binds
tighter than unary minus</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;**&quot;</tt> operator now binds more tightly than
unary minus. It was documented to work this way before, but
didn&rsquo;t.</p>

<pre style="margin-left:17%; margin-top: 1em">    print &minus;4**2,&quot;\n&quot;;
    # perl4 prints: 16
    # perl5 prints: &minus;16</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>&quot;foreach&quot;</tt>
changed when iterating over a list</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The meaning of
<tt>&quot;foreach{}&quot;</tt> has changed slightly when it
is iterating over a list which is not an array. This used to
assign the list to a temporary array, but no longer does so
(for efficiency). This means that you&rsquo;ll now be
iterating over the actual values, not over copies of the
values. Modifications to the loop variable can change the
original values.</p>

<pre style="margin-left:17%; margin-top: 1em">    @list = ('ab','abc','bcd','def');
    foreach $var (grep(/ab/,@list)){
        $var = 1;
    }
    print (join(':',@list));
    # perl4 prints: ab:abc:bcd:def
    # perl5 prints: 1:1:bcd:def</pre>


<p style="margin-left:17%; margin-top: 1em">To retain Perl4
semantics you need to assign your list explicitly to a
temporary array and then iterate over that. For example, you
might need to change</p>

<pre style="margin-left:17%; margin-top: 1em">    foreach $var (grep(/ab/,@list)){</pre>


<p style="margin-left:17%; margin-top: 1em">to</p>

<pre style="margin-left:17%; margin-top: 1em">    foreach $var (@tmp = grep(/ab/,@list)){</pre>


<p style="margin-left:17%; margin-top: 1em">Otherwise
changing <tt>$var</tt> will clobber the values of
<tt>@list</tt>. (This most often happens when you use
<tt>$_</tt> for the loop variable, and call subroutines in
the loop that don&rsquo;t properly localize
<tt>$_</tt>.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p style="margin-top: 1em"><tt>&quot;split&quot;</tt> with
no args behavior changed</p></td>
<td width="26%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;split&quot;</tt>
with no arguments now behaves like <tt>&quot;split '
'&quot;</tt> (which doesn&rsquo;t return an initial null
field if <tt>$_</tt> starts with whitespace), it used to
behave like <tt>&quot;split /\s+/&quot;</tt> (which
does).</p>

<pre style="margin-left:17%; margin-top: 1em">    $_ = ' hi mom';
    print join(':', split);
    # perl4 prints: :hi:mom
    # perl5 prints: hi:mom</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em"><b>&minus;e</b> behavior
fixed</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Perl 4 would
ignore any text which was attached to an <b>&minus;e</b>
switch, always taking the code snippet from the following
arg. Additionally, it would silently accept an
<b>&minus;e</b> switch without a following arg. Both of
these behaviors have been fixed.</p>

<pre style="margin-left:17%; margin-top: 1em">    perl &minus;e'print &quot;attached to &minus;e&quot;' 'print &quot;separate arg&quot;'
    # perl4 prints: separate arg
    # perl5 prints: attached to &minus;e
    perl &minus;e
    # perl4 prints:
    # perl5 dies: No code specified for &minus;e.</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em"><tt>&quot;push&quot;</tt>
returns number of elements in resulting list</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In Perl 4 the
return value of <tt>&quot;push&quot;</tt> was undocumented,
but it was actually the last value being pushed onto the
target list. In Perl 5 the return value of
<tt>&quot;push&quot;</tt> is documented, but has changed, it
is the number of elements in the resulting list.</p>

<pre style="margin-left:17%; margin-top: 1em">    @x = ('existing');
    print push(@x, 'first new', 'second new');
    # perl4 prints: second new
    # perl5 prints: 3</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">Some error messages differ</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Some error
messages will be different.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;split()&quot;</tt>
honors subroutine args</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In Perl 4, if
in list context the delimiters to the first argument of
<tt>&quot;split()&quot;</tt> were <tt>&quot;??&quot;</tt>,
the result would be placed in <tt>@_</tt> as well as being
returned. Perl 5 has more respect for your subroutine
arguments.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p style="margin-top: 1em">Bugs removed</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Some bugs may
have been inadvertently removed. :&minus;)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parsing
Traps</b> <br>
Perl4&minus;to&minus;Perl5 traps from having to do with
parsing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="66%">


<p style="margin-top: 1em">Space between . and = triggers
syntax error</p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note the space
between . and =</p>

<pre style="margin-left:17%; margin-top: 1em">    $string . = &quot;more string&quot;;
    print $string;
    # perl4 prints: more string
    # perl5 prints: syntax error at &minus; line 1, near &quot;. =&quot;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p style="margin-top: 1em">Better parsing in perl 5</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Better parsing
in perl 5</p>

<pre style="margin-left:17%; margin-top: 1em">    sub foo {}
    &amp;foo
    print(&quot;hello, world\n&quot;);
    # perl4 prints: hello, world
    # perl5 prints: syntax error</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">


<p style="margin-top: 1em">Function parsing</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">&quot;if it
looks like a function, it is a function&quot; rule.</p>

<pre style="margin-left:17%; margin-top: 1em">  print
    ($foo == 1) ? &quot;is one\n&quot; : &quot;is zero\n&quot;;
    # perl4 prints: is zero
    # perl5 warns: &quot;Useless use of a constant in void context&quot; if using &minus;w</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p style="margin-top: 1em">String interpolation of
<tt>$#array</tt> differs</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">String
interpolation of the <tt>$#array</tt> construct differs when
braces are to used around the name.</p>

<pre style="margin-left:17%; margin-top: 1em">    @a = (1..3);
    print &quot;${#a}&quot;;
    # perl4 prints: 2
    # perl5 fails with syntax error
    @a = (1..3);
    print &quot;$#{a}&quot;;
    # perl4 prints: {a}
    # perl5 prints: 2</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Perl guesses on
<tt>&quot;map&quot;</tt>, <tt>&quot;grep&quot;</tt> followed
by <tt>&quot;{&quot;</tt> if it starts <small>BLOCK</small>
or hash ref</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When perl sees
<tt>&quot;map {&quot;</tt> (or <tt>&quot;grep {&quot;</tt>),
it has to guess whether the <tt>&quot;{&quot;</tt> starts a
<small>BLOCK</small> or a hash reference. If it guesses
wrong, it will report a syntax error near the
<tt>&quot;}&quot;</tt> and the missing (or unexpected)
comma.</p>

<p style="margin-left:17%; margin-top: 1em">Use unary
<tt>&quot;+&quot;</tt> before <tt>&quot;{&quot;</tt> on a
hash reference, and unary <tt>&quot;+&quot;</tt> applied to
the first thing in a <small>BLOCK</small> (after
<tt>&quot;{&quot;</tt>), for perl to guess right all the
time. (See &quot;map&quot; in perlfunc.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Numerical
Traps</b> <br>
Perl4&minus;to&minus;Perl5 traps having to do with numerical
operators, operands, or output from same.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="60%">


<p style="margin-top: 1em">Formatted output and significant
digits</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Formatted
output and significant digits. In general, Perl 5 tries to
be more precise. For example, on a Solaris Sparc:</p>

<pre style="margin-left:18%; margin-top: 1em">    print 7.373504 &minus; 0, &quot;\n&quot;;
    printf &quot;%20.18f\n&quot;, 7.373504 &minus; 0;
    # Perl4 prints:
    7.3750399999999996141
    7.375039999999999614
    # Perl5 prints:
    7.373504
    7.373503999999999614</pre>


<p style="margin-left:18%; margin-top: 1em">Notice how the
first result looks better in Perl 5.</p>

<p style="margin-left:18%; margin-top: 1em">Your results
may vary, since your floating point formatting routines and
even floating point format may be slightly different.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Auto-increment operator over
signed int limit deleted</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">This specific
item has been deleted. It demonstrated how the
auto-increment operator would not catch when a number went
over the signed int limit. Fixed in version 5.003_04. But
always be wary when using large integers. If in doubt:</p>

<pre style="margin-left:18%; margin-top: 1em">   use Math::BigInt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Assignment of return values from
numeric equality tests doesn&rsquo;t work</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Assignment of
return values from numeric equality tests does not work in
perl5 when the test evaluates to false (0). Logical tests
now return a null, instead of 0</p>

<pre style="margin-left:18%; margin-top: 1em">    $p = ($test == 1);
    print $p,&quot;\n&quot;;
    # perl4 prints: 0
    # perl5 prints:</pre>


<p style="margin-left:18%; margin-top: 1em">Also see
&quot;//, etc.&quot;&quot; in &quot;General Regular
Expression Traps using s for another example of this new
feature...</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="28%">


<p style="margin-top: 1em">Bitwise string ops</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">When bitwise
operators which can operate upon either numbers or strings
(<tt>&quot;&amp; | ^ ~&quot;</tt>) are given only strings as
arguments, perl4 would treat the operands as bitstrings so
long as the program contained a call to the
<tt>&quot;vec()&quot;</tt> function. perl5 treats the string
operands as bitstrings. (See &quot;Bitwise String
Operators&quot; in perlop for more details.)</p>

<pre style="margin-left:18%; margin-top: 1em">    $fred = &quot;10&quot;;
    $barney = &quot;12&quot;;
    $betty = $fred &amp; $barney;
    print &quot;$betty\n&quot;;
    # Uncomment the next line to change perl4's behavior
    # ($dummy) = vec(&quot;dummy&quot;, 0, 0);
    # Perl4 prints:
    8
    # Perl5 prints:
    10
    # If vec() is used anywhere in the program, both print:
    10</pre>


<p style="margin-left:11%; margin-top: 1em"><b>General data
type traps</b> <br>
Perl4&minus;to&minus;Perl5 traps involving most data-types,
and their usage within certain expressions and/or
context.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Negative array subscripts now
count from the end of array</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Negative array
subscripts now count from the end of the array.</p>

<pre style="margin-left:18%; margin-top: 1em">    @a = (1, 2, 3, 4, 5);
    print &quot;The third element of the array is $a[3] also expressed as $a[&minus;2] \n&quot;;
    # perl4 prints: The third element of the array is 4 also expressed as
    # perl5 prints: The third element of the array is 4 also expressed as 4</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="76%">


<p style="margin-top: 1em">Setting <tt>$#array</tt> lower
now discards array elements</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Setting
<tt>$#array</tt> lower now discards array elements, and
makes them impossible to recover.</p>

<pre style="margin-left:18%; margin-top: 1em">    @a = (a,b,c,d,e);
    print &quot;Before: &quot;,join('',@a);
    $#a =1;
    print &quot;, After: &quot;,join('',@a);
    $#a =3;
    print &quot;, Recovered: &quot;,join('',@a),&quot;\n&quot;;
    # perl4 prints: Before: abcde, After: ab, Recovered: abcd
    # perl5 prints: Before: abcde, After: ab, Recovered: ab</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="45%">


<p style="margin-top: 1em">Hashes get defined before
use</p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Hashes get
defined before use</p>

<pre style="margin-left:18%; margin-top: 1em">    local($s,@a,%h);
    die &quot;scalar \$s defined&quot; if defined($s);
    die &quot;array \@a defined&quot; if defined(@a);
    die &quot;hash \%h defined&quot; if defined(%h);
    # perl4 prints:
    # perl5 dies: hash %h defined</pre>


<p style="margin-left:18%; margin-top: 1em">Perl will now
generate a warning when it sees defined(@a) and
defined(%h).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="79%">


<p style="margin-top: 1em">Glob assignment from localized
variable to variable</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">glob assignment
from variable to variable will fail if the assigned variable
is localized subsequent to the assignment</p>

<pre style="margin-left:18%; margin-top: 1em">    @a = (&quot;This is Perl 4&quot;);
    *b = *a;
    local(@a);
    print @b,&quot;\n&quot;;
    # perl4 prints: This is Perl 4
    # perl5 prints:</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="39%">


<p style="margin-top: 1em">Assigning
<tt>&quot;undef&quot;</tt> to glob</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Assigning
<tt>&quot;undef&quot;</tt> to a glob has no effect in Perl
5. In Perl 4 it undefines the associated scalar (but may
have other side effects including SEGVs). Perl 5 will also
warn if <tt>&quot;undef&quot;</tt> is assigned to a
typeglob. (Note that assigning <tt>&quot;undef&quot;</tt> to
a typeglob is different than calling the
<tt>&quot;undef&quot;</tt> function on a typeglob
(<tt>&quot;undef *foo&quot;</tt>), which has quite a few
effects.</p>

<pre style="margin-left:18%; margin-top: 1em">    $foo = &quot;bar&quot;;
    *foo = undef;
    print $foo;
    # perl4 prints:
    # perl4 warns: &quot;Use of uninitialized variable&quot; if using &minus;w
    # perl5 prints: bar
    # perl5 warns: &quot;Undefined value assigned to typeglob&quot; if using &minus;w</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="59%">


<p style="margin-top: 1em">Changes in unary negation (of
strings)</p> </td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Changes in
unary negation (of strings) This change effects both the
return value and what it does to auto(magic)increment.</p>

<pre style="margin-left:18%; margin-top: 1em">    $x = &quot;aaa&quot;;
    print ++$x,&quot; : &quot;;
    print &minus;$x,&quot; : &quot;;
    print ++$x,&quot;\n&quot;;
    # perl4 prints: aab : &minus;0 : 1
    # perl5 prints: aab : &minus;aab : aac</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="51%">


<p style="margin-top: 1em">Modifying of constants
prohibited</p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">perl 4 lets you
modify constants:</p>

<pre style="margin-left:18%; margin-top: 1em">    $foo = &quot;x&quot;;
    &amp;mod($foo);
    for ($x = 0; $x &lt; 3; $x++) {
        &amp;mod(&quot;a&quot;);
    }
    sub mod {
        print &quot;before: $_[0]&quot;;
        $_[0] = &quot;m&quot;;
        print &quot;  after: $_[0]\n&quot;;
    }
    # perl4:
    # before: x  after: m
    # before: a  after: m
    # before: m  after: m
    # before: m  after: m
    # Perl5:
    # before: x  after: m
    # Modification of a read&minus;only value attempted at foo.pl line 12.
    # before: a</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>&quot;defined
$var&quot;</tt> behavior changed</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The behavior is
slightly different for:</p>

<pre style="margin-left:18%; margin-top: 1em">    print &quot;$x&quot;, defined $x
    # perl 4: 1
    # perl 5: &lt;no output, $x is not called into existence&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="25%">


<p style="margin-top: 1em">Variable Suicide</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Variable
suicide behavior is more consistent under Perl 5. Perl5
exhibits the same behavior for hashes and scalars, that
perl4 exhibits for only scalars.</p>

<pre style="margin-left:18%; margin-top: 1em">    $aGlobal{ &quot;aKey&quot; } = &quot;global value&quot;;
    print &quot;MAIN:&quot;, $aGlobal{&quot;aKey&quot;}, &quot;\n&quot;;
    $GlobalLevel = 0;
    &amp;test( *aGlobal );
    sub test {
        local( *theArgument ) = @_;
        local( %aNewLocal ); # perl 4 != 5.001l,m
        $aNewLocal{&quot;aKey&quot;} = &quot;this should never appear&quot;;
        print &quot;SUB: &quot;, $theArgument{&quot;aKey&quot;}, &quot;\n&quot;;
        $aNewLocal{&quot;aKey&quot;} = &quot;level $GlobalLevel&quot;;   # what should print
        $GlobalLevel++;
        if( $GlobalLevel&lt;4 ) {
            &amp;test( *aNewLocal );
        }
    }
    # Perl4:
    # MAIN:global value
    # SUB: global value
    # SUB: level 0
    # SUB: level 1
    # SUB: level 2
    # Perl5:
    # MAIN:global value
    # SUB: global value
    # SUB: this should never appear
    # SUB: this should never appear
    # SUB: this should never appear</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Context
Traps &minus; scalar, list contexts</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Elements of argument lists for
formats evaluated in list context</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The elements of
argument lists for formats are now evaluated in list
context. This means you can interpolate list values now.</p>

<pre style="margin-left:18%; margin-top: 1em">    @fmt = (&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;);
    format STDOUT=
    @&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
    @fmt;
    .
    write;
    # perl4 errors:  Please use commas to separate fields in file
    # perl5 prints: foo     bar      baz</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em"><tt>&quot;caller()&quot;</tt>
returns false value in scalar context if no caller
present</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The
<tt>&quot;caller()&quot;</tt> function now returns a false
value in a scalar context if there is no caller. This lets
library files determine if they&rsquo;re being required.</p>

<pre style="margin-left:18%; margin-top: 1em">    caller() ? (print &quot;You rang?\n&quot;) : (print &quot;Got a 0\n&quot;);
    # perl4 errors: There is no caller
    # perl5 prints: Got a 0</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Comma operator in scalar context
gives scalar context to args</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The comma
operator in a scalar context is now guaranteed to give a
scalar context to its last argument. It gives scalar or void
context to any preceding arguments, depending on
circumstances.</p>

<pre style="margin-left:18%; margin-top: 1em">    @y= ('a','b','c');
    $x = (1, 2, @y);
    print &quot;x = $x\n&quot;;
    # Perl4 prints:  x = c   # Interpolates array @y into the list
    # Perl5 prints:  x = 3   # Evaluates array @y in scalar context</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="51%">


<p style="margin-top: 1em"><tt>&quot;sprintf()&quot;</tt>
prototyped as <tt>&quot;($;@)&quot;</tt></p></td>
<td width="31%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;sprintf()&quot;</tt>
is prototyped as ($;@), so its first argument is given
scalar context. Thus, if passed an array, it will probably
not do what you want, unlike Perl 4:</p>

<pre style="margin-left:18%; margin-top: 1em">    @z = ('%s%s', 'foo', 'bar');
    $x = sprintf(@z);
    print $x;
    # perl4 prints: foobar
    # perl5 prints: 3</pre>



<p style="margin-left:18%; margin-top: 1em">&quot;printf()&quot;
works the same as it did in Perl 4, though:</p>

<pre style="margin-left:18%; margin-top: 1em">    @z = ('%s%s', 'foo', 'bar');
    printf STDOUT (@z);
    # perl4 prints: foobar
    # perl5 prints: foobar</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Precedence
Traps</b> <br>
Perl4&minus;to&minus;Perl5 traps involving precedence
order.</p>

<p style="margin-left:11%; margin-top: 1em">Perl 4 has
almost the same precedence rules as Perl 5 for the operators
that they both have. Perl 4 however, seems to have had some
inconsistencies that made the behavior differ from what was
documented.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="59%">


<p style="margin-top: 1em"><small>LHS</small> vs.
<small>RHS</small> of any assignment operator</p></td>
<td width="23%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><small>LHS</small>
vs. <small>RHS</small> of any assignment operator.
<small>LHS</small> is evaluated first in perl4, second in
perl5; this can affect the relationship between side-effects
in sub-expressions.</p>

<pre style="margin-left:18%; margin-top: 1em">    @arr = ( 'left', 'right' );
    $a{shift @arr} = shift @arr;
    print join( ' ', keys %a );
    # perl4 prints: left
    # perl5 prints: right</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="68%">


<p style="margin-top: 1em">Semantic errors introduced due
to precedence</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">These are now
semantic errors because of precedence:</p>

<pre style="margin-left:18%; margin-top: 1em">    @list = (1,2,3,4,5);
    %map = (&quot;a&quot;,1,&quot;b&quot;,2,&quot;c&quot;,3,&quot;d&quot;,4);
    $n = shift @list + 2;   # first item in list plus 2
    print &quot;n is $n, &quot;;
    $m = keys %map + 2;     # number of items in hash plus 2
    print &quot;m is $m\n&quot;;
    # perl4 prints: n is 3, m is 6
    # perl5 errors and fails to compile</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Precedence of assignment
operators same as the precedence of assignment</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The precedence
of assignment operators is now the same as the precedence of
assignment. Perl 4 mistakenly gave them the precedence of
the associated operator. So you now must parenthesize them
in expressions like</p>

<pre style="margin-left:18%; margin-top: 1em">    /foo/ ? ($a += 2) : ($a &minus;= 2);</pre>


<p style="margin-left:18%; margin-top: 1em">Otherwise</p>

<pre style="margin-left:18%; margin-top: 1em">    /foo/ ? $a += 2 : $a &minus;= 2</pre>


<p style="margin-left:18%; margin-top: 1em">would be
erroneously parsed as</p>

<pre style="margin-left:18%; margin-top: 1em">    (/foo/ ? $a += 2 : $a) &minus;= 2;</pre>


<p style="margin-left:18%; margin-top: 1em">On the other
hand,</p>

<pre style="margin-left:18%; margin-top: 1em">    $a += /foo/ ? 1 : 2;</pre>


<p style="margin-left:18%; margin-top: 1em">now works as a
C programmer would expect.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="70%">


<p style="margin-top: 1em"><tt>&quot;open&quot;</tt>
requires parentheses around filehandle</p></td>
<td width="12%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    open FOO || die;</pre>


<p style="margin-left:18%; margin-top: 1em">is now
incorrect. You need parentheses around the filehandle.
Otherwise, perl5 leaves the statement as its default
precedence:</p>

<pre style="margin-left:18%; margin-top: 1em">    open(FOO || die);
    # perl4 opens or dies
    # perl5 opens FOO, dying only if 'FOO' is false, i.e. never</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="42%">


<p style="margin-top: 1em"><tt>$:</tt> precedence over
<tt>$::</tt> gone</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">perl4 gives the
special variable, <tt>$:</tt> precedence, where perl5 treats
<tt>$::</tt> as main <tt>&quot;package&quot;</tt></p>

<p style="margin-left:18%; margin-top: 1em"><tt>$a =
&quot;x&quot;; print &quot;$::a&quot;; <br>
# perl 4 prints: &minus;:a <br>
# perl 5 prints: x</tt></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="68%">


<p style="margin-top: 1em">Precedence of file test
operators documented</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">perl4 had buggy
precedence for the file test operators vis-a-vis the
assignment operators. Thus, although the precedence table
for perl4 leads one to believe <tt>&quot;&minus;e $foo .=
&quot;q&quot;&quot;</tt> should parse as
<tt>&quot;((&minus;e $foo) .= &quot;q&quot;)&quot;</tt>, it
actually parses as <tt>&quot;(&minus;e ($foo .=
&quot;q&quot;))&quot;</tt>. In perl5, the precedence is as
documented.</p>

<pre style="margin-left:18%; margin-top: 1em">    &minus;e $foo .= &quot;q&quot;
    # perl4 prints: no output
    # perl5 prints: Can't modify &minus;e in concatenation</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em"><tt>&quot;keys&quot;</tt>,
<tt>&quot;each&quot;</tt>, <tt>&quot;values&quot;</tt> are
regular named unary operators</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">In perl4,
<i>keys()</i>, <i>each()</i> and <i>values()</i> were
special high-precedence operators that operated on a single
hash, but in perl5, they are regular named unary operators.
As documented, named unary operators have lower precedence
than the arithmetic and concatenation operators <tt>&quot;+
&minus; .&quot;</tt>, but the perl4 variants of these
operators actually bind tighter than <tt>&quot;+ &minus;
.&quot;</tt>. Thus, for:</p>

<pre style="margin-left:18%; margin-top: 1em">    %foo = 1..10;
    print keys %foo &minus; 1
    # perl4 prints: 4
    # perl5 prints: Type of arg 1 to keys must be hash (not subtraction)</pre>


<p style="margin-left:18%; margin-top: 1em">The perl4
behavior was probably more useful, if less consistent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>General
Regular Expression Traps using s///, etc.</b> <br>
All types of <small>RE</small> traps.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="65%">



<p style="margin-top: 1em"><tt>&quot;s'$lhs'$rhs'&quot;</tt>
interpolates on either side</p></td>
<td width="17%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;s'$lhs'$rhs'&quot;</tt>
now does no interpolation on either side. It used to
interpolate <tt>$lhs</tt> but not <tt>$rhs</tt>. (And still
does not match a literal &rsquo;$&rsquo; in string)</p>

<pre style="margin-left:18%; margin-top: 1em">    $a=1;$b=2;
    $string = '1 2 $a $b';
    $string =~ s'$a'$b';
    print $string,&quot;\n&quot;;
    # perl4 prints: $b 2 $a $b
    # perl5 prints: 1 2 $a $b</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;m//g&quot;</tt>
attaches its state to the searched string</p></td>
<td width="8%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;m//g&quot;</tt>
now attaches its state to the searched string rather than
the regular expression. (Once the scope of a block is left
for the sub, the state of the searched string is lost)</p>

<pre style="margin-left:18%; margin-top: 1em">    $_ = &quot;ababab&quot;;
    while(m/ab/g){
        &amp;doit(&quot;blah&quot;);
    }
    sub doit{local($_) = shift; print &quot;Got $_ &quot;}
    # perl4 prints: Got blah Got blah Got blah Got blah
    # perl5 prints: infinite loop blah...</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;m//o&quot;</tt> used
within an anonymous sub</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Currently, if
you use the <tt>&quot;m//o&quot;</tt> qualifier on a regular
expression within an anonymous sub, <i>all</i> closures
generated from that anonymous sub will use the regular
expression as it was compiled when it was used the very
first time in any such closure. For instance, if you say</p>

<pre style="margin-left:18%; margin-top: 1em">    sub build_match {
        my($left,$right) = @_;
        return sub { $_[0] =~ /$left stuff $right/o; };
    }
    $good = build_match('foo','bar');
    $bad = build_match('baz','blarch');
    print $good&minus;&gt;('foo stuff bar') ? &quot;ok\n&quot; : &quot;not ok\n&quot;;
    print $bad&minus;&gt;('baz stuff blarch') ? &quot;ok\n&quot; : &quot;not ok\n&quot;;
    print $bad&minus;&gt;('foo stuff bar') ? &quot;not ok\n&quot; : &quot;ok\n&quot;;</pre>


<p style="margin-left:18%; margin-top: 1em">For most builds
of Perl5, this will print: ok not ok not ok</p>


<p style="margin-left:18%; margin-top: 1em"><i>build_match()</i>
will always return a sub which matches the contents of
<tt>$left</tt> and <tt>$right</tt> as they were the
<i>first</i> time that <i>build_match()</i> was called, not
as they are in the current call.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="42%">


<p style="margin-top: 1em"><tt>$+</tt> isn&rsquo;t set to
whole match</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If no
parentheses are used in a match, Perl4 sets <tt>$+</tt> to
the whole match, just like <tt>$&amp;</tt>. Perl5 does
not.</p>

<pre style="margin-left:18%; margin-top: 1em">    &quot;abcdef&quot; =~ /b.*e/;
    print &quot;\$+ = $+\n&quot;;
    # perl4 prints: bcde
    # perl5 prints:</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="74%">


<p style="margin-top: 1em">Substitution now returns null
string if it fails</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">substitution
now returns the null string if it fails</p>

<pre style="margin-left:18%; margin-top: 1em">    $string = &quot;test&quot;;
    $value = ($string =~ s/foo//);
    print $value, &quot;\n&quot;;
    # perl4 prints: 0
    # perl5 prints:</pre>


<p style="margin-left:18%; margin-top: 1em">Also see
&quot;Numerical Traps&quot; for another example of this new
feature.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="64%">


<p style="margin-top: 1em"><tt>&quot;s`lhs`rhs`&quot;</tt>
is now a normal substitution</p></td>
<td width="18%">
</td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;s`lhs`rhs`&quot;</tt>
(using backticks) is now a normal substitution, with no
backtick expansion</p>

<pre style="margin-left:18%; margin-top: 1em">    $string = &quot;&quot;;
    $string =~ s`^`hostname`;
    print $string, &quot;\n&quot;;
    # perl4 prints: &lt;the local hostname&gt;
    # perl5 prints: hostname</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="80%">


<p style="margin-top: 1em">Stricter parsing of variables in
regular expressions</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Stricter
parsing of variables used in regular expressions</p>

<pre style="margin-left:18%; margin-top: 1em">    s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;
    # perl4: compiles w/o error
    # perl5: with Scalar found where operator expected ..., near &quot;$opt$plus&quot;</pre>


<p style="margin-left:18%; margin-top: 1em">an added
component of this example, apparently from the same script,
is the actual value of the s&rsquo;d string after the
substitution. <tt>&quot;[$opt]&quot;</tt> is a character
class in perl4 and an array subscript in perl5</p>

<pre style="margin-left:18%; margin-top: 1em">    $grpc = 'a';
    $opt  = 'r';
    $_ = 'bar';
    s/^([^$grpc]*$grpc[$opt]?)/foo/;
    print;
    # perl4 prints: foo
    # perl5 prints: foobar</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;m?x?&quot;</tt>
matches only once</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Under perl5,
<tt>&quot;m?x?&quot;</tt> matches only once, like
<tt>&quot;?x?&quot;</tt>. Under perl4, it matched
repeatedly, like <tt>&quot;/x/&quot;</tt> or
<tt>&quot;m!x!&quot;</tt>.</p>

<pre style="margin-left:18%; margin-top: 1em">    $test = &quot;once&quot;;
    sub match { $test =~ m?once?; }
    &amp;match();
    if( &amp;match() ) {
        # m?x? matches more then once
        print &quot;perl4\n&quot;;
    } else {
        # m?x? matches only once
        print &quot;perl5\n&quot;;
    }
    # perl4 prints: perl4
    # perl5 prints: perl5</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="71%">


<p style="margin-top: 1em">Failed matches don&rsquo;t reset
the match variables</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Unlike in Ruby,
failed matches in Perl do not reset the match variables ($1,
<tt>$2</tt>, ..., <tt>&quot;$`&quot;</tt>, ...).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Subroutine,
Signal, Sorting Traps</b> <br>
The general group of Perl4&minus;to&minus;Perl5 traps having
to do with Signals, Sorting, and their related subroutines,
as well as general subroutine traps. Includes some
OS-Specific traps.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Barewords that used to look like
strings look like subroutine calls</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Barewords that
used to look like strings to Perl will now look like
subroutine calls if a subroutine by that name is defined
before the compiler sees them.</p>

<pre style="margin-left:18%; margin-top: 1em">    sub SeeYa { warn&quot;Hasta la vista, baby!&quot; }
    $SIG{'TERM'} = SeeYa;
    print &quot;SIGTERM is now $SIG{'TERM'}\n&quot;;
    # perl4 prints: SIGTERM is now main'SeeYa
    # perl5 prints: SIGTERM is now main::1 (and warns &quot;Hasta la vista, baby!&quot;)</pre>


<p style="margin-left:18%; margin-top: 1em">Use
<b>&minus;w</b> to catch this one</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Reverse is no longer allowed as
the name of a sort subroutine</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">reverse is no
longer allowed as the name of a sort subroutine.</p>

<pre style="margin-left:18%; margin-top: 1em">    sub reverse{ print &quot;yup &quot;; $a &lt;=&gt; $b }
    print sort reverse (2,1,3);
    # perl4 prints: yup yup 123
    # perl5 prints: 123
    # perl5 warns (if using &minus;w): Ambiguous call resolved as CORE::reverse()</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>&quot;warn()&quot;</tt>
won&rsquo;t let you specify a filehandle.</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Although it
_always_ printed to <small>STDERR</small> , <i>warn()</i>
would let you specify a filehandle in perl4. With perl5 it
does not.</p>

<pre style="margin-left:18%; margin-top: 1em">    warn STDERR &quot;Foo!&quot;;
    # perl4 prints: Foo!
    # perl5 prints: String found where operator expected</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>OS</small>
Traps</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="56%">


<p style="margin-top: 1em">SysV resets signal handler
correctly</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Under
<small>HPUX</small> , and some other SysV OSes, one had to
reset any signal handler, within the signal handler
function, each time a signal was handled with perl4. With
perl5, the reset is now done correctly. Any code relying on
the handler _not_ being reset will have to be reworked.</p>

<p style="margin-left:18%; margin-top: 1em">Since version
5.002, Perl uses <i>sigaction()</i> under SysV.</p>

<pre style="margin-left:18%; margin-top: 1em">    sub gotit {
        print &quot;Got @_... &quot;;
    }
    $SIG{'INT'} = 'gotit';
    $| = 1;
    $pid = fork;
    if ($pid) {
        kill('INT', $pid);
        sleep(1);
        kill('INT', $pid);
    } else {
        while (1) {sleep(10);}
    }
    # perl4 (HPUX) prints: Got INT...
    # perl5 (HPUX) prints: Got INT... Got INT...</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="48%">


<p style="margin-top: 1em">SysV <tt>&quot;seek()&quot;</tt>
appends correctly</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Under SysV
OSes, <tt>&quot;seek()&quot;</tt> on a file opened to append
<tt>&quot;&gt;&gt;&quot;</tt> now does the right thing
w.r.t. the <i>fopen()</i> manpage. e.g., &minus; When a file
is opened for append, it is impossible to overwrite
information already in the file.</p>

<pre style="margin-left:18%; margin-top: 1em">    open(TEST,&quot;&gt;&gt;seek.test&quot;);
    $start = tell TEST;
    foreach(1 .. 9){
        print TEST &quot;$_ &quot;;
    }
    $end = tell TEST;
    seek(TEST,$start,0);
    print TEST &quot;18 characters here&quot;;
    # perl4 (solaris) seek.test has: 18 characters here
    # perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18 characters here</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Interpolation
Traps</b> <br>
Perl4&minus;to&minus;Perl5 traps having to do with how
things get interpolated within certain expressions,
statements, contexts, or whatever.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em"><tt>&quot;@&quot;</tt> always
interpolates an array in double-quotish strings</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">@ now always
interpolates an array in double-quotish strings.</p>

<pre style="margin-left:18%; margin-top: 1em">    print &quot;To: someone@somewhere.com\n&quot;;
    # perl4 prints: To:someone@somewhere.com
    # perl &lt; 5.6.1, error : In string, @somewhere now must be written as \@somewhere
    # perl &gt;= 5.6.1, warning : Possible unintended interpolation of @somewhere in string</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Double-quoted strings may no
longer end with an unescaped $</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Double-quoted
strings may no longer end with an unescaped $.</p>

<pre style="margin-left:18%; margin-top: 1em">    $foo = &quot;foo$&quot;;
    print &quot;foo is $foo\n&quot;;
    # perl4 prints: foo is foo$
    # perl5 errors: Final $ should be \$ or $name</pre>


<p style="margin-left:18%; margin-top: 1em">Note: perl5
<small>DOES NOT</small> error on the terminating @ in
<tt>$bar</tt></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Arbitrary expressions are
evaluated inside braces within double quotes</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Perl now
sometimes evaluates arbitrary expressions inside braces that
occur within double quotes (usually when the opening brace
is preceded by <tt>&quot;$&quot;</tt> or
<tt>&quot;@&quot;</tt>).</p>

<pre style="margin-left:18%; margin-top: 1em">    @www = &quot;buz&quot;;
    $foo = &quot;foo&quot;;
    $bar = &quot;bar&quot;;
    sub foo { return &quot;bar&quot; };
    print &quot;|@{w.w.w}|${main'foo}|&quot;;
    # perl4 prints: |@{w.w.w}|foo|
    # perl5 prints: |buz|bar|</pre>


<p style="margin-left:18%; margin-top: 1em">Note that you
can <tt>&quot;use strict;&quot;</tt> to ward off such
trappiness under perl5.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>$$x</tt> now tries to
dereference <tt>$x</tt></p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The construct
&quot;this is $$x&quot; used to interpolate the pid at that
point, but now tries to dereference <tt>$x</tt>. <tt>$$</tt>
by itself still works fine, however.</p>

<pre style="margin-left:18%; margin-top: 1em">    $s = &quot;a reference&quot;;
    $x = *s;
    print &quot;this is $$x\n&quot;;
    # perl4 prints: this is XXXx   (XXX is the current pid)
    # perl5 prints: this is a reference</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Creation of hashes on the fly
with <tt>&quot;eval &quot;EXPR&quot;&quot;</tt> requires
protection</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Creation of
hashes on the fly with <tt>&quot;eval
&quot;EXPR&quot;&quot;</tt> now requires either both
<tt>&quot;$&quot;</tt>&rsquo;s to be protected in the
specification of the hash name, or both curlies to be
protected. If both curlies are protected, the result will be
compatible with perl4 and perl5. This is a very common
practice, and should be changed to use the block form of
<tt>&quot;eval{}&quot;</tt> if possible.</p>

<pre style="margin-left:18%; margin-top: 1em">    $hashname = &quot;foobar&quot;;
    $key = &quot;baz&quot;;
    $value = 1234;
    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;
    (defined($foobar{'baz'})) ?  (print &quot;Yup&quot;) : (print &quot;Nope&quot;);
    # perl4 prints: Yup
    # perl5 prints: Nope</pre>


<p style="margin-left:18%; margin-top: 1em">Changing</p>

<pre style="margin-left:18%; margin-top: 1em">    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;</pre>


<p style="margin-left:18%; margin-top: 1em">to</p>

<pre style="margin-left:18%; margin-top: 1em">    eval &quot;\$\$hashname{'$key'} = q|$value|&quot;;</pre>


<p style="margin-left:18%; margin-top: 1em">causes the
following result:</p>

<pre style="margin-left:18%; margin-top: 1em">    # perl4 prints: Nope
    # perl5 prints: Yup</pre>


<p style="margin-left:18%; margin-top: 1em">or, changing
to</p>

<pre style="margin-left:18%; margin-top: 1em">    eval &quot;\$$hashname\{'$key'\} = q|$value|&quot;;</pre>


<p style="margin-left:18%; margin-top: 1em">causes the
following result:</p>

<pre style="margin-left:18%; margin-top: 1em">    # perl4 prints: Yup
    # perl5 prints: Yup
    # and is compatible for both versions</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="45%">


<p style="margin-top: 1em">Bugs in earlier perl
versions</p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">perl4 programs
which unconsciously rely on the bugs in earlier perl
versions.</p>

<pre style="margin-left:18%; margin-top: 1em">    perl &minus;e '$bar=q/not/; print &quot;This is $foo{$bar} perl5&quot;'
    # perl4 prints: This is not perl5
    # perl5 prints: This is perl5</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="68%">


<p style="margin-top: 1em">Array and hash brackets during
interpolation</p> </td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">You also have
to be careful about array and hash brackets during
interpolation.</p>

<pre style="margin-left:18%; margin-top: 1em">    print &quot;$foo[&quot;
    perl 4 prints: [
    perl 5 prints: syntax error
    print &quot;$foo{&quot;
    perl 4 prints: {
    perl 5 prints: syntax error</pre>


<p style="margin-left:18%; margin-top: 1em">Perl 5 is
expecting to find an index or key name following the
respective brackets, as well as an ending bracket of the
appropriate type. In order to mimic the behavior of Perl 4,
you must escape the bracket like so.</p>

<pre style="margin-left:18%; margin-top: 1em">    print &quot;$foo\[&quot;;
    print &quot;$foo\{&quot;;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="47%">


<p style="margin-top: 1em">Interpolation of
<tt>&quot;\$$foo{bar}&quot;</tt></p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Similarly,
watch out for: <tt>&quot;\$$foo{bar}&quot;</tt></p>

<p style="margin-left:18%; margin-top: 1em"><tt>$foo =
&quot;baz&quot;; <br>
print &quot;\$$foo{bar}\n&quot;; <br>
# perl4 prints: $baz{bar} <br>
# perl5 prints: $</tt></p>

<p style="margin-left:18%; margin-top: 1em">Perl 5 is
looking for <tt>$foo{bar}</tt> which doesn&rsquo;t exist,
but perl 4 is happy just to expand <tt>$foo</tt> to
&quot;baz&quot; by itself. Watch out for this especially in
<tt>&quot;eval&quot;</tt>&rsquo;s.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em"><tt>&quot;qq()&quot;</tt> string
passed to <tt>&quot;eval&quot;</tt> will not find string
terminator</p> </td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;qq()&quot;</tt>
string passed to <tt>&quot;eval&quot;</tt></p>

<p style="margin-left:18%; margin-top: 1em"><tt>eval qq(
<br>
foreach \$y (keys %\$x\) { <br>
\$count++; <br>
} <br>
); <br>
# perl4 runs this ok <br>
# perl5 prints: Can't find string terminator
&quot;)&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DBM</small>
Traps</b> <br>
General <small>DBM</small> traps.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Perl5 must have been linked with
same dbm/ndbm as the default for
<tt>&quot;dbmopen()&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Existing dbm
databases created under perl4 (or any other dbm/ndbm tool)
may cause the same script, run under perl5, to fail. The
build of perl5 must have been linked with the same dbm/ndbm
as the default for <tt>&quot;dbmopen()&quot;</tt> to
function properly without <tt>&quot;tie&quot;</tt>&rsquo;ing
to an extension dbm implementation.</p>

<pre style="margin-left:18%; margin-top: 1em">    dbmopen (%dbm, &quot;file&quot;, undef);
    print &quot;ok\n&quot;;
    # perl4 prints: ok
    # perl5 prints: ok (IFF linked with &minus;ldbm or &minus;lndbm)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em"><small>DBM</small> exceeding
limit on the key/value size will cause perl5 to exit
immediately</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Existing dbm
databases created under perl4 (or any other dbm/ndbm tool)
may cause the same script, run under perl5, to fail. The
error generated when exceeding the limit on the key/value
size will cause perl5 to exit immediately.</p>

<pre style="margin-left:18%; margin-top: 1em">    dbmopen(DB, &quot;testdb&quot;,0600) || die &quot;couldn't open db! $!&quot;;
    $DB{'trap'} = &quot;x&quot; x 1024;  # value too large for most dbm/ndbm
    print &quot;YUP\n&quot;;
    # perl4 prints:
    dbm store returned &minus;1, errno 28, key &quot;trap&quot; at &minus; line 3.
    YUP
    # perl5 prints:
    dbm store returned &minus;1, errno 28, key &quot;trap&quot; at &minus; line 3.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Unclassified
Traps</b> <br>
Everything else.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="62%">



<p style="margin-top: 1em"><tt>&quot;require&quot;</tt>/<tt>&quot;do&quot;</tt>
trap using returned value</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If the file
doit.pl has:</p>

<pre style="margin-left:18%; margin-top: 1em">    sub foo {
        $rc = do &quot;./do.pl&quot;;
        return 8;
    }
    print &amp;foo, &quot;\n&quot;;</pre>


<p style="margin-left:18%; margin-top: 1em">And the do.pl
file has the following single line:</p>

<pre style="margin-left:18%; margin-top: 1em">    return 3;</pre>


<p style="margin-left:18%; margin-top: 1em">Running doit.pl
gives the following:</p>

<pre style="margin-left:18%; margin-top: 1em">    # perl 4 prints: 3 (aborts the subroutine early)
    # perl 5 prints: 8</pre>


<p style="margin-left:18%; margin-top: 1em">Same behavior
if you replace <tt>&quot;do&quot;</tt> with
<tt>&quot;require&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>&quot;split&quot;</tt> on
empty string with <small>LIMIT</small> specified</p></td>
<td width="14%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    $string = '';
    @list = split(/foo/, $string, 2)</pre>


<p style="margin-left:18%; margin-top: 1em">Perl4 returns a
one element list containing the empty string but Perl5
returns an empty list.</p>

<p style="margin-left:11%; margin-top: 1em">As always, if
any of these are ever officially declared as bugs,
they&rsquo;ll be fixed and removed.</p>
<hr>
</body>
</html>
