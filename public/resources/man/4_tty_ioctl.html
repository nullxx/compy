<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:22:52 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TTY_IOCTL</title>

</head>
<body>

<h1 align="center">TTY_IOCTL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">tty_ioctl
&minus; ioctls for terminals and serial lines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;termios.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ioctl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>,
...);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>ioctl</b>(2) call for terminals and serial ports accepts
many possible command arguments. Most require a third
argument, of varying type, here called <i>argp</i> or
<i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Use of
<i>ioctl</i> makes for nonportable programs. Use the POSIX
interface described in <b>termios</b>(3) whenever
possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Get and set
terminal attributes</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCGETS</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcgetattr(fd,
argp)</i>. <br>
Get the current serial port settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETS</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSANOW, argp)</i>. <br>
Set the current serial port settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETSW</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSADRAIN, argp)</i>. <br>
Allow the output buffer to drain, and set the current serial
port settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TCSETSF</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Equivalent to <i>tcsetattr(fd,
TCSAFLUSH, argp)</i>. <br>
Allow the output buffer to drain, discard pending input, and
set the current serial port settings.</p>

<p style="margin-left:11%; margin-top: 1em">The following
four ioctls are just like <b>TCGETS</b>, <b>TCSETS</b>,
<b>TCSETSW</b>, <b>TCSETSF</b>, except that they take a
<i>struct termio&nbsp;*</i> instead of a <i>struct
termios&nbsp;*</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCGETA</b></p></td>
<td width="77%">


<p><b>struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETA</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETAW</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><b>TCSETAF</b></p></td>
<td width="77%">


<p><b>const struct termio *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Locking the
termios structure</b> <br>
The <i>termios</i> structure of a terminal can be locked.
The lock is itself a <i>termios</i> structure, with nonzero
bits or fields indicating a locked value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCGLCKTRMIOS</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Gets the locking status of the
<i>termios</i> structure of the terminal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCSLCKTRMIOS</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>const struct termios *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Sets the locking status of the
<i>termios</i> structure of the terminal. Only root (more
precisely: a process with the <b>CAP_SYS_ADMIN</b>
capability) can do this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Get and set
window size</b> <br>
Window sizes are kept in the kernel, but not used by the
kernel (except in the case of virtual consoles, where the
kernel will update the window size when the size of the
virtual console changes, for example, by loading a new
font).</p>

<p style="margin-left:11%; margin-top: 1em">The following
constants and structure are defined in
<i>&lt;sys/ioctl.h&gt;</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCGWINSZ</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>struct winsize *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Get window size.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCSWINSZ</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>const struct winsize *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Set window size.</p>

<p style="margin-left:11%; margin-top: 1em">The struct used
by these ioctls is defined as</p>

<p style="margin-left:17%; margin-top: 1em">struct winsize
{ <br>
unsigned short ws_row; <br>
unsigned short ws_col; <br>
unsigned short ws_xpixel; /* unused */ <br>
unsigned short ws_ypixel; /* unused */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">When the window
size changes, a <b>SIGWINCH</b> signal is sent to the
foreground process group.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Sending a
break <br>
TCSBRK int</b> <i>arg</i></p>

<p style="margin-left:22%;">Equivalent to
<i>tcsendbreak(fd, arg)</i>. <br>
If the terminal is using asynchronous serial data
transmission, and <i>arg</i> is zero, then send a break (a
stream of zero bits) for between 0.25 and 0.5 seconds. If
the terminal is not using asynchronous serial data
transmission, then either a break is sent, or the function
returns without doing anything. When <i>arg</i> is nonzero,
nobody knows what will happen.</p>

<p style="margin-left:22%; margin-top: 1em">(SVr4,
UnixWare, Solaris, Linux treat <i>tcsendbreak(fd,arg)</i>
with nonzero <i>arg</i> like <i>tcdrain(fd)</i>. SunOS
treats <i>arg</i> as a multiplier, and sends a stream of
bits <i>arg</i> times as long as done for zero <i>arg</i>.
DG/UX and AIX treat <i>arg</i> (when nonzero) as a time
interval measured in milliseconds. HP-UX ignores
<i>arg</i>.)</p>

<p style="margin-left:11%;"><b>TCSBRKP int</b>
<i>arg</i></p>

<p style="margin-left:22%;">So-called &quot;POSIX
version&quot; of <b>TCSBRK</b>. It treats nonzero <i>arg</i>
as a timeinterval measured in deciseconds, and does nothing
when the driver does not support breaks.</p>

<p style="margin-left:11%;"><b>TIOCSBRK void</b></p>

<p style="margin-left:22%;">Turn break on, that is, start
sending zero bits.</p>

<p style="margin-left:11%;"><b>TIOCCBRK void</b></p>

<p style="margin-left:22%;">Turn break off, that is, stop
sending zero bits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Software
flow control <br>
TCXONC int</b> <i>arg</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcflow(fd,
arg)</i>. <br>
See <b>tcflow</b>(3) for the argument values <b>TCOOFF</b>,
<b>TCOON</b>, <b>TCIOFF</b>, <b>TCION</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Buffer count
and flushing <br>
FIONREAD int *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the number of bytes in the
input buffer.</p>

<p style="margin-left:11%;"><b>TIOCINQ int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Same as <b>FIONREAD</b>.</p>

<p style="margin-left:11%;"><b>TIOCOUTQ int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Get the number of bytes in the
output buffer.</p>

<p style="margin-left:11%;"><b>TCFLSH int</b>
<i>arg</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcflush(fd,
arg)</i>. <br>
See <b>tcflush</b>(3) for the argument values
<b>TCIFLUSH</b>, <b>TCOFLUSH</b>, <b>TCIOFLUSH</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Faking input
<br>
TIOCSTI const char *</b><i>argp</i></p>

<p style="margin-left:22%;">Insert the given byte in the
input queue.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Redirecting
console output <br>
TIOCCONS void</b></p>

<p style="margin-left:22%;">Redirect output that would have
gone to <i>/dev/console</i> or <i>/dev/tty0</i> to the given
terminal. If that was a pseudoterminal master, send it to
the slave. In Linux before version 2.6.10, anybody can do
this as long as the output was not redirected yet; since
version 2.6.10, only root (a process with the
<b>CAP_SYS_ADMIN</b> capability) may do this. If output was
redirected already <b>EBUSY</b> is returned, but redirection
can be stopped by using this ioctl with <i>fd</i> pointing
at <i>/dev/console</i> or <i>/dev/tty0</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Controlling
terminal <br>
TIOCSCTTY int</b> <i>arg</i></p>

<p style="margin-left:22%;">Make the given terminal the
controlling terminal of the calling process. The calling
process must be a session leader and not have a controlling
terminal already. If this terminal is already the
controlling terminal of a different session group then the
ioctl fails with <b>EPERM</b>, unless the caller is root
(more precisely: has the <b>CAP_SYS_ADMIN</b> capability)
and <i>arg</i> equals 1, in which case the terminal is
stolen, and all processes that had it as controlling
terminal lose it.</p>

<p style="margin-left:11%;"><b>TIOCNOTTY void</b></p>

<p style="margin-left:22%;">If the given terminal was the
controlling terminal of the calling process, give up this
controlling terminal. If the process was session leader,
then send <b>SIGHUP</b> and <b>SIGCONT</b> to the foreground
process group and all processes in the current session lose
their controlling terminal.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process
group and session ID <br>
TIOCGPGRP pid_t *</b><i>argp</i></p>

<p style="margin-left:22%;">When successful, equivalent to
<i>*argp = tcgetpgrp(fd)</i>. <br>
Get the process group ID of the foreground process group on
this terminal.</p>

<p style="margin-left:11%;"><b>TIOCSPGRP const pid_t
*</b><i>argp</i></p>

<p style="margin-left:22%;">Equivalent to <i>tcsetpgrp(fd,
*argp)</i>. <br>
Set the foreground process group ID of this terminal.</p>

<p style="margin-left:11%;"><b>TIOCGSID pid_t
*</b><i>argp</i></p>

<p style="margin-left:22%;">Get the session ID of the given
terminal. This will fail with <b>ENOTTY</b> in case the
terminal is not a master pseudoterminal and not our
controlling terminal. Strange.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exclusive
mode <br>
TIOCEXCL void</b></p>

<p style="margin-left:22%;">Put the terminal into exclusive
mode. No further <b>open</b>(2) operations on the terminal
are permitted. (They will fail with <b>EBUSY</b>, except for
root, that is, a process with the <b>CAP_SYS_ADMIN</b>
capability.)</p>

<p style="margin-left:11%;"><b>TIOCNXCL void</b></p>

<p style="margin-left:22%;">Disable exclusive mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Line
discipline <br>
TIOCGETD int *</b><i>argp</i></p>

<p style="margin-left:22%;">Get the line discipline of the
terminal.</p>

<p style="margin-left:11%;"><b>TIOCSETD const int
*</b><i>argp</i></p>

<p style="margin-left:22%;">Set the line discipline of the
terminal.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pseudoterminal
ioctls <br>
TIOCPKT const int *</b><i>argp</i></p>

<p style="margin-left:22%;">Enable (when *<i>argp</i> is
nonzero) or disable packet mode. Can be applied to the
master side of a pseudoterminal only (and will return
<b>ENOTTY</b> otherwise). In packet mode, each subsequent
<b>read</b>(2) will return a packet that either contains a
single nonzero control byte, or has a single byte containing
zero (' ') followed by data written on the slave side of the
pseudoterminal. If the first byte is not <b>TIOCPKT_DATA</b>
(0), it is an OR of one or more of the following bits:</p>


<p style="margin-left:22%; margin-top: 1em">TIOCPKT_FLUSHREAD
The read queue for the terminal is flushed. <br>
TIOCPKT_FLUSHWRITE The write queue for the terminal is
flushed. <br>
TIOCPKT_STOP Output to the terminal is stopped. <br>
TIOCPKT_START Output to the terminal is restarted. <br>
TIOCPKT_DOSTOP The start and stop characters are
<b>^S</b>/<b>^Q</b>. <br>
TIOCPKT_NOSTOP The start and stop characters are not
<b>^S</b>/<b>^Q</b>.</p>

<p style="margin-left:22%; margin-top: 1em">While this mode
is in use, the presence of control status information to be
read from the master side may be detected by a
<b>select</b>(2) for exceptional conditions.</p>

<p style="margin-left:22%; margin-top: 1em">This mode is
used by <b>rlogin</b>(1) and <b>rlogind</b>(8) to implement
a remote-echoed, locally <b>^S</b>/<b>^Q</b> flow-controlled
remote login.</p>

<p style="margin-left:22%; margin-top: 1em">The BSD ioctls
<b>TIOCSTOP</b>, <b>TIOCSTART</b>, <b>TIOCUCNTL</b>,
<b>TIOCREMOTE</b> have not been implemented under Linux.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modem
control</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCMGET</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">get the status of modem
bits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCMSET</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">set the status of modem
bits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCMBIC</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">clear the indicated modem
bits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCMBIS</b></p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p><b>const int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">set the indicated modem
bits.</p>

<p style="margin-left:11%; margin-top: 1em">Bits used by
these four ioctls:</p>

<p style="margin-left:11%; margin-top: 1em">TIOCM_LE DSR
(data set ready/line enable) <br>
TIOCM_DTR DTR (data terminal ready) <br>
TIOCM_RTS RTS (request to send) <br>
TIOCM_ST Secondary TXD (transmit) <br>
TIOCM_SR Secondary RXD (receive) <br>
TIOCM_CTS CTS (clear to send) <br>
TIOCM_CAR DCD (data carrier detect) <br>
TIOCM_CD see TIOCM_CAR <br>
TIOCM_RNG RNG (ring) <br>
TIOCM_RI see TIOCM_RNG <br>
TIOCM_DSR DSR (data set ready)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Marking a
line as local</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCGSOFTCAR</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">(&quot;Get software carrier
flag&quot;) Get the status of the CLOCAL flag in the c_cflag
field of the <i>termios</i> structure.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCSSOFTCAR</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>const int *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">(&quot;Set software carrier
flag&quot;) Set the CLOCAL flag in the <i>termios</i>
structure when *<i>argp</i> is nonzero, and clear it
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>CLOCAL</b> flag for a line is off, the hardware carrier
detect (DCD) signal is significant, and an <b>open</b>(2) of
the corresponding terminal will block until DCD is asserted,
unless the <b>O_NONBLOCK</b> flag is given. If <b>CLOCAL</b>
is set, the line behaves as if DCD is always asserted. The
software carrier flag is usually turned on for local
devices, and is off for lines with modems.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Linux-specific</b>
<br>
For the <b>TIOCLINUX</b> ioctl, see
<b>console_ioctl</b>(4).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Kernel
debugging <br>
#include &lt;linux/tty.h&gt;</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p><b>TIOCTTYGSTRUCT</b></p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p><b>struct tty_struct *</b><i>argp</i></p></td></tr>
</table>

<p style="margin-left:22%;">Get the <i>tty_struct</i>
corresponding to <i>fd</i>.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>ioctl</b>(2) system call returns 0 on success. On error
it returns &minus;1 and sets <i>errno</i> appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em">Invalid command parameter.</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ENOIOCTLCMD</b></p>

<p style="margin-left:22%;">Unknown command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOTTY</b></p></td>
<td width="2%"></td>
<td width="36%">


<p>Inappropriate <i>fd</i>.</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="36%">


<p>Insufficient permission.</p></td>
<td width="42%">
</td></tr>
</table>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Check the
condition of DTR on the serial port.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;termios.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;sys/ioctl.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(void) <br>
{ <br>
int fd, serial;</p>

<p style="margin-left:11%; margin-top: 1em">fd =
open(&quot;/dev/ttyS0&quot;, O_RDONLY); <br>
ioctl(fd, TIOCMGET, &amp;serial); <br>
if (serial &amp; TIOCM_DTR) <br>
puts(&quot;TIOCM_DTR is not set&quot;); <br>
else <br>
puts(&quot;TIOCM_DTR is set&quot;); <br>
close(fd); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ioctl</b>(2),
<b>termios</b>(3), <b>console_ioctl</b>(4),
<b>pty</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
