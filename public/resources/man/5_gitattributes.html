<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:23:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GITATTRIBUTES</title>

</head>
<body>

<h1 align="center">GITATTRIBUTES</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EFFECTS">EFFECTS</a><br>
<a href="#USING MACRO ATTRIBUTES">USING MACRO ATTRIBUTES</a><br>
<a href="#DEFINING MACRO ATTRIBUTES">DEFINING MACRO ATTRIBUTES</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">gitattributes
&minus; defining attributes per path</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">$GIT_DIR/info/attributes,
.gitattributes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A gitattributes
file is a simple text file that gives attributes to
pathnames.</p>

<p style="margin-left:11%; margin-top: 1em">Each line in
gitattributes file is of form:</p>

<p style="margin-left:17%; margin-top: 1em">pattern attr1
attr2 ...</p>

<p style="margin-left:11%; margin-top: 1em">That is, a
pattern followed by an attributes list, separated by
whitespaces. When the pattern matches the path in question,
the attributes listed on the line are given to the path.</p>

<p style="margin-left:11%; margin-top: 1em">Each attribute
can be in one of these states for a given path:</p>

<p style="margin-left:11%; margin-top: 1em">Set</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;true&quot;; this is specified by listing
only the name of the attribute in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Unset</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;false&quot;; this is specified by
listing the name of the attribute prefixed with a dash
&minus; in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Set to a
value</p>

<p style="margin-left:17%;">The path has the attribute with
specified string value; this is specified by listing the
name of the attribute followed by an equal sign = and its
value in the attribute list.</p>


<p style="margin-left:11%; margin-top: 1em">Unspecified</p>

<p style="margin-left:17%;">No pattern matches the path,
and nothing says if the path has or does not have the
attribute, the attribute for the path is said to be
Unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">When more than
one pattern matches the path, a later line overrides an
earlier line. This overriding is done per attribute. The
rules how the pattern matches paths are the same as in
.gitignore files; see <b>gitignore</b>(5). Unlike
.gitignore, negative patterns are forbidden.</p>

<p style="margin-left:11%; margin-top: 1em">When deciding
what attributes are assigned to a path, Git consults
$GIT_DIR/info/attributes file (which has the highest
precedence), .gitattributes file in the same directory as
the path in question, and its parent directories up to the
toplevel of the work tree (the further the directory that
contains .gitattributes is from the path in question, the
lower its precedence). Finally global and system&minus;wide
files are considered (they have the lowest precedence).</p>

<p style="margin-left:11%; margin-top: 1em">When the
.gitattributes file is missing from the work tree, the path
in the index is used as a fall&minus;back. During checkout
process, .gitattributes in the index is used and then the
file in the working tree is used as a fall&minus;back.</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
affect only a single repository (i.e., to assign attributes
to files that are particular to one user&rsquo;s workflow
for that repository), then attributes should be placed in
the $GIT_DIR/info/attributes file. Attributes which should
be version&minus;controlled and distributed to other
repositories (i.e., attributes of interest to all users)
should go into .gitattributes files. Attributes that should
affect all repositories for a single user should be placed
in a file specified by the core.attributesfile configuration
option (see <b>git-config</b>(1)). Its default value is
$XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is
either not set or empty, $HOME/.config/git/attributes is
used instead. Attributes for all users on a system should be
placed in the $(prefix)/etc/gitattributes file.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes you
would need to override an setting of an attribute for a path
to Unspecified state. This can be done by listing the name
of the attribute prefixed with an exclamation point !.</p>

<h2>EFFECTS
<a name="EFFECTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Certain
operations by Git can be influenced by assigning particular
attributes to a path. Currently, the following operations
are attributes&minus;aware.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Checking&minus;out
and checking&minus;in</b> <br>
These attributes affect how the contents stored in the
repository are copied to the working tree files when
commands such as <i>git checkout</i> and <i>git merge</i>
run. They also affect how Git stores the contents you
prepare in the working tree in the repository upon <i>git
add</i> and <i>git commit</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>text</big></b></p>

<p style="margin-left:17%;">This attribute enables and
controls end&minus;of&minus;line normalization. When a text
file is normalized, its line endings are converted to LF in
the repository. To control what line ending style is used in
the working directory, use the eol attribute for a single
file and the core.eol configuration variable for all text
files.</p>

<p style="margin-left:17%; margin-top: 1em">Set</p>

<p style="margin-left:23%;">Setting the text attribute on a
path enables end&minus;of&minus;line normalization and marks
the path as a text file. End&minus;of&minus;line conversion
takes place without guessing the content type.</p>

<p style="margin-left:17%; margin-top: 1em">Unset</p>

<p style="margin-left:23%;">Unsetting the text attribute on
a path tells Git not to attempt any end&minus;of&minus;line
conversion upon checkin or checkout.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;auto&quot;</p>

<p style="margin-left:23%;">When text is set to
&quot;auto&quot;, the path is marked for automatic
end&minus;of&minus;line normalization. If Git decides that
the content is text, its line endings are normalized to LF
on checkin.</p>


<p style="margin-left:17%; margin-top: 1em">Unspecified</p>

<p style="margin-left:23%;">If the text attribute is
unspecified, Git uses the core.autocrlf configuration
variable to determine if the file should be converted.</p>

<p style="margin-left:17%; margin-top: 1em">Any other value
causes Git to act as if text has been left unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>eol</big></b></p>

<p style="margin-left:17%;">This attribute sets a specific
line&minus;ending style to be used in the working directory.
It enables end&minus;of&minus;line normalization without any
content checks, effectively setting the text attribute.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;crlf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings for this file on checkin and convert
them to CRLF when the file is checked out.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;lf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings to LF on checkin and prevents
conversion to CRLF when the file is checked out.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>Backwards
compatibility with crlf attribute</big></b></p>

<p style="margin-left:17%;">For backwards compatibility,
the crlf attribute is interpreted as follows:</p>

<p style="margin-left:23%; margin-top: 1em">crlf text <br>
&minus;crlf &minus;text <br>
crlf=input eol=lf</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>End-of-line
conversion</big></b></p>

<p style="margin-left:17%;">While Git normally leaves file
contents alone, it can be configured to normalize line
endings to LF in the repository and, optionally, to convert
them to CRLF when files are checked out.</p>

<p style="margin-left:17%; margin-top: 1em">Here is an
example that will make Git normalize .txt, .vcproj and .sh
files, ensure that .vcproj files have CRLF and .sh files
have LF in the working directory, and prevent .jpg files
from being normalized regardless of their content.</p>

<p style="margin-left:23%; margin-top: 1em">*.txt text <br>
*.vcproj eol=crlf <br>
*.sh eol=lf <br>
*.jpg &minus;text</p>

<p style="margin-left:17%; margin-top: 1em">Other source
code management systems normalize all text files in their
repositories, and there are two ways to enable similar
automatic normalization in Git.</p>

<p style="margin-left:17%; margin-top: 1em">If you simply
want to have CRLF line endings in your working directory
regardless of the repository you are working with, you can
set the config variable &quot;core.autocrlf&quot; without
changing any attributes.</p>

<p style="margin-left:23%; margin-top: 1em">[core] <br>
autocrlf = true</p>

<p style="margin-left:17%; margin-top: 1em">This does not
force normalization of all text files, but does ensure that
text files that you introduce to the repository have their
line endings normalized to LF when they are added, and that
files that are already normalized in the repository stay
normalized.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
interoperate with a source code management system that
enforces end&minus;of&minus;line normalization, or you
simply want all text files in your repository to be
normalized, you should instead set the text attribute to
&quot;auto&quot; for <i>all</i> files.</p>

<p style="margin-left:23%; margin-top: 1em">* text=auto</p>

<p style="margin-left:17%; margin-top: 1em">This ensures
that all files that Git considers to be text will have
normalized (LF) line endings in the repository. The core.eol
configuration variable controls which line endings Git will
use for normalized files in your working directory; the
default is to use the native line ending for your platform,
or CRLF if core.autocrlf is set.</p>


<p style="margin-left:23%; margin-top: 1em"><b><big>Note</big></b>
<br>
When text=auto normalization is enabled in an existing
repository, any text files containing CRLFs should be
normalized. If they are not they will be normalized the next
time someone tries to change them, causing unfortunate
misattribution. From a clean working directory:</p>

<p style="margin-left:23%; margin-top: 1em">$ echo &quot;*
text=auto&quot; &gt;&gt;.gitattributes <br>
$ rm .git/index # Remove the index to force Git to <br>
$ git reset # re&minus;scan the working directory <br>
$ git status # Show files that will be normalized <br>
$ git add &minus;u <br>
$ git add .gitattributes <br>
$ git commit &minus;m &quot;Introduce
end&minus;of&minus;line normalization&quot;</p>

<p style="margin-left:17%; margin-top: 1em">If any files
that should not be normalized show up in <i>git status</i>,
unset their text attribute before running <i>git add
&minus;u</i>.</p>

<p style="margin-left:23%; margin-top: 1em">manual.pdf
&minus;text</p>

<p style="margin-left:17%; margin-top: 1em">Conversely,
text files that Git does not detect can have normalization
enabled manually.</p>

<p style="margin-left:23%; margin-top: 1em">weirdchars.txt
text</p>

<p style="margin-left:17%; margin-top: 1em">If
core.safecrlf is set to &quot;true&quot; or
&quot;warn&quot;, Git verifies if the conversion is
reversible for the current setting of core.autocrlf. For
&quot;true&quot;, Git rejects irreversible conversions; for
&quot;warn&quot;, Git only prints a warning but accepts an
irreversible conversion. The safety triggers to prevent such
a conversion done to the files in the work tree, but there
are a few exceptions. Even though...</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
add</i> itself does not touch the files in the work tree,
the next checkout would, so the safety triggers;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
apply</i> to update a text file with a patch does touch the
files in the work tree, but the operation is about text
files and CRLF conversion is about fixing the line ending
inconsistencies, so the safety does not trigger;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
diff</i> itself does not touch the files in the work tree,
it is often run to inspect the changes you intend to next
<i>git add</i>. To catch potential problems early, safety
triggers.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>ident</big></b></p>

<p style="margin-left:17%;"><big>When the attribute ident
is set for a path, Git replaces $Id$ in the blob object with
$Id:, followed by the 40&minus;character hexadecimal blob
object name, followed by a dollar sign $ upon checkout. Any
byte sequence that begins with $Id: and ends with $ in the
worktree file is replaced with $Id$ upon
check&minus;in.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>filter</big></b></big></p>

<p style="margin-left:17%;"><big>A filter attribute can be
set to a string value that names a filter driver specified
in the configuration.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A filter
driver consists of a clean command and a smudge command,
either of which can be left unspecified. Upon checkout, when
the smudge command is specified, the command is fed the blob
object from its standard input, and its standard output is
used to update the worktree file. Similarly, the clean
command is used to convert the contents of worktree file
upon checkin.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>One use of
the content filtering is to massage the content into a shape
that is more convenient for the platform, filesystem, and
the user to use. For this mode of operation, the key phrase
here is &quot;more convenient&quot; and not &quot;turning
something unusable into usable&quot;. In other words, the
intent is that if someone unsets the filter driver
definition, or does not have the appropriate filter program,
the project should still be usable.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Another
use of the content filtering is to store the content that
cannot be directly used in the repository (e.g. a UUID that
refers to the true content stored outside Git, or an
encrypted content) and turn it into a usable form upon
checkout (e.g. download the external content, or decrypt the
encrypted content).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>These two
filters behave differently, and by default, a filter is
taken as the former, massaging the contents into more
convenient shape. A missing filter driver definition in the
config, or a filter driver that exits with a non&minus;zero
status, is not an error but makes the filter a no&minus;op
passthru.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
declare that a filter turns a content that by itself is
unusable into a usable content by setting the
filter.&lt;driver&gt;.required configuration variable to
true.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, in .gitattributes, you would assign the filter
attribute for paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.c
filter=indent</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then you
would define a &quot;filter.indent.clean&quot; and
&quot;filter.indent.smudge&quot; configuration in your
.git/config to specify a pair of commands to modify the
contents of C programs when the source files are checked in
(&quot;clean&quot; is run) and checked out (no change is
made because the command is &quot;cat&quot;).</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;indent&quot;] <br>
clean = indent <br>
smudge = cat</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For best
results, clean should not alter its output further if it is
run twice (&quot;clean&rarr;clean&quot; should be equivalent
to &quot;clean&quot;), and multiple smudge commands should
not alter clean's output
(&quot;smudge&rarr;smudge&rarr;clean&quot; should be
equivalent to &quot;clean&quot;). See the section on merging
below.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
&quot;indent&quot; filter is well&minus;behaved in this
regard: it will not modify input that is already correctly
indented. In this case, the lack of a smudge filter means
that the clean filter <i>must</i> accept its own output
without modifying it.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If a
filter <i>must</i> succeed in order to make the stored
contents usable, you can declare that the filter is
required, in the configuration:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;crypt&quot;] <br>
clean = openssl enc ... <br>
smudge = openssl enc &minus;d ... <br>
required</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Sequence
&quot;%f&quot; on the filter command line is replaced with
the name of the file the filter is working on. A filter
might use this in keyword substitution. For
example:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;p4&quot;] <br>
clean = git&minus;p4&minus;filter &minus;&minus;clean %f
<br>
smudge = git&minus;p4&minus;filter &minus;&minus;smudge
%f</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Interaction
between checkin/checkout attributes</big></b></big></p>

<p style="margin-left:17%;"><big>In the check&minus;in
codepath, the worktree file is first converted with filter
driver (if specified and corresponding driver defined), then
the result is processed with ident (if specified), and then
finally with text (again, if specified and
applicable).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In the
check&minus;out codepath, the blob content is first
converted with text, and then ident and fed to
filter.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Merging
branches with differing checkin/checkout
attributes</big></b></big></p>

<p style="margin-left:17%;"><big>If you have added
attributes to a file that cause the canonical repository
format for that file to change, such as adding a
clean/smudge filter or text/eol/ident attributes, merging
anything where the attribute is not in place would normally
cause merge conflicts.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To prevent
these unnecessary merge conflicts, Git can be told to run a
virtual check&minus;out and check&minus;in of all three
stages of a file when resolving a three&minus;way merge by
setting the merge.renormalize configuration variable. This
prevents changes caused by check&minus;in conversion from
causing spurious merge conflicts when a converted file is
merged with an unconverted file.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>As long as
a &quot;smudge&rarr;clean&quot; results in the same output
as a &quot;clean&quot; even on files that are already
smudged, this strategy will automatically resolve all
filter&minus;related conflicts. Filters that do not act in
this way may cause additional merge conflicts that must be
resolved manually.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b>Generating
diff text <big><br>
diff</big></b></big></p>

<p style="margin-left:17%;"><big>The attribute diff affects
how Git generates diffs for particular files. It can tell
Git whether to generate a textual patch for the path or to
treat the path as a binary file. It can also affect what
line is shown on the hunk header @@ &minus;k,l +n,m @@ line,
tell Git to use an external command to generate the diff, or
ask Git to convert binary files to a text format before
generating the diff.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Set</big></p>

<p style="margin-left:23%;"><big>A path to which the diff
attribute is set is treated as text, even when they contain
byte values that normally never appear in text files, such
as NUL.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unset</big></p>

<p style="margin-left:23%;"><big>A path to which the diff
attribute is unset will generate Binary files differ (or a
binary patch, if binary patches are enabled).</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unspecified</big></p>

<p style="margin-left:23%;"><big>A path to which the diff
attribute is unspecified first gets its contents inspected,
and if it looks like text, it is treated as text. Otherwise
it would generate Binary files differ.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>String</big></p>

<p style="margin-left:23%;"><big>Diff is shown using the
specified diff driver. Each driver may specify one or more
options, as described in the following section. The options
for the diff driver &quot;foo&quot; are defined by the
configuration variables in the &quot;diff.foo&quot; section
of the Git config file.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
an external diff driver</big></b></big></p>

<p style="margin-left:17%;"><big>The definition of a diff
driver is done in gitconfig, not gitattributes file, so
strictly speaking this manual page is a wrong place to talk
about it. However...</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To define
an external diff driver jcdiff, add a section to your
$GIT_DIR/config file (or $HOME/.gitconfig file) like
this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jcdiff&quot;] <br>
command = j&minus;c&minus;diff</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When Git
needs to show you a diff for the path with diff attribute
set to jcdiff, it calls the command you specified with the
above configuration, i.e. j&minus;c&minus;diff, with 7
parameters, just like GIT_EXTERNAL_DIFF program is called.
See <b>git</b>(1) for details.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
a custom hunk-header</big></b></big></p>

<p style="margin-left:17%;"><big>Each group of changes
(called a &quot;hunk&quot;) in the textual diff output is
prefixed with a line of the form:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>@@
&minus;k,l +n,m @@ TEXT</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This is
called a <i>hunk header</i>. The &quot;TEXT&quot; portion is
by default a line that begins with an alphabet, an
underscore or a dollar sign; this matches what GNU <i>diff
&minus;p</i> output uses. This default selection however is
not suited for some contents, and you can use a customized
pattern to make a selection.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>First, in
.gitattributes, you would assign the diff attribute for
paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.tex
diff=tex</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then, you
would define a &quot;diff.tex.xfuncname&quot; configuration
to specify a regular expression that matches a line that you
would want to appear as the hunk header &quot;TEXT&quot;.
Add a section to your $GIT_DIR/config file (or
$HOME/.gitconfig file) like this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;tex&quot;] <br>
xfuncname = &quot;^(\\\\(sub)*section\\{.*)$&quot;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note. A
single level of backslashes are eaten by the configuration
file parser, so you would need to double the backslashes;
the pattern above picks a line that begins with a backslash,
and zero or more occurrences of sub followed by section
followed by open brace, to the end of line.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>There are
a few built&minus;in patterns to make this easier, and tex
is one of them, so you do not have to write the above in
your configuration file (you still need to enable this with
the attribute mechanism, via .gitattributes). The following
built in patterns are available:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; ada
suitable for source code in the Ada language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
bibtex suitable for files with BibTeX coded
references.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; cpp
suitable for source code in the C and C++
languages.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
csharp suitable for source code in the C#
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
fortran suitable for source code in the Fortran
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
html suitable for HTML/XHTML documents.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
java suitable for source code in the Java
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
matlab suitable for source code in the MATLAB
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
objc suitable for source code in the Objective&minus;C
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
pascal suitable for source code in the Pascal/Delphi
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
perl suitable for source code in the Perl
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; php
suitable for source code in the PHP language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
python suitable for source code in the Python
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
ruby suitable for source code in the Ruby
language.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; tex
suitable for source code for LaTeX documents.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Customizing
word diff</big></b></big></p>

<p style="margin-left:17%;"><big>You can customize the
rules that git diff &minus;&minus;word&minus;diff uses to
split words in a line, by specifying an appropriate regular
expression in the &quot;diff.*.wordRegex&quot; configuration
variable. For example, in TeX a backslash followed by a
sequence of letters forms a command, but several such
commands can be run together without intervening whitespace.
To separate them, use a regular expression in your
$GIT_DIR/config file (or $HOME/.gitconfig file) like
this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;tex&quot;] <br>
wordRegex =
&quot;\\\\[a&minus;zA&minus;Z]+|[{}]|\\\\.|[^\\{}[:space:]]+&quot;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A
built&minus;in pattern is provided for all languages listed
in the previous section.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Performing
text diffs of binary files</big></b></big></p>

<p style="margin-left:17%;"><big>Sometimes it is desirable
to see the diff of a text&minus;converted version of some
binary files. For example, a word processor document can be
converted to an ASCII text representation, and the diff of
the text shown. Even though this conversion loses some
information, the resulting diff is useful for human viewing
(but cannot be applied directly).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
textconv config option is used to define a program for
performing such a conversion. The program should take a
single argument, the name of a file to convert, and produce
the resulting text on stdout.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, to show the diff of the exif information of a file
instead of the binary information (assuming you have the
exif tool installed), add the following section to your
$GIT_DIR/config file (or $HOME/.gitconfig file):</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jpg&quot;] <br>
textconv = exif</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
The text conversion is generally a one&minus;way conversion;
in this example, we lose the actual image contents and focus
just on the text data. This means that diffs generated by
textconv are <i>not</i> suitable for applying. For this
reason, only git diff and the git log family of commands
(i.e., log, whatchanged, show) will perform text conversion.
git format&minus;patch will never generate this output. If
you want to send somebody a text&minus;converted diff of a
binary file (e.g., because it quickly conveys the changes
you have made), you should generate it separately and send
it as a comment <i>in addition to</i> the usual binary diff
that you might send.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Because
text conversion can be slow, especially when doing a large
number of them with git log &minus;p, Git provides a
mechanism to cache the output and use it in future diffs. To
enable caching, set the &quot;cachetextconv&quot; variable
in your diff driver&rsquo;s config. For example:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jpg&quot;] <br>
textconv = exif <br>
cachetextconv = true</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This will
cache the result of running &quot;exif&quot; on each blob
indefinitely. If you change the textconv config variable for
a diff driver, Git will automatically invalidate the cache
entries and re&minus;run the textconv filter. If you want to
invalidate the cache manually (e.g., because your version of
&quot;exif&quot; was updated and now produces better
output), you can remove the cache manually with git
update&minus;ref &minus;d refs/notes/textconv/jpg (where
&quot;jpg&quot; is the name of the diff driver, as in the
example above).</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Choosing
textconv versus external diff</big></b></big></p>

<p style="margin-left:17%;"><big><big>If you want to show
differences between binary or specially&minus;formatted
blobs in your repository, you can choose to use either an
external diff command, or to use textconv to convert them to
a diff&minus;able text format. Which method you choose
depends on your exact situation.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
advantage of using an external diff command is flexibility.
You are not bound to find line&minus;oriented changes, nor
is it necessary for the output to resemble unified diff. You
are free to locate and report changes in the most
appropriate way for your data format.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>A
textconv, by comparison, is much more limiting. You provide
a transformation of the data into a line&minus;oriented text
format, and Git uses its regular diff tools to generate the
output. There are several advantages to choosing this
method:</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>1.
Ease of use. It is often much simpler to write a binary to
text transformation than it is to perform your own diff. In
many cases, existing programs can be used as textconv
filters (e.g., exif, odt2txt).</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>2.
Git diff features. By performing only the transformation
step yourself, you can still utilize many of Git&rsquo;s
diff features, including colorization, word&minus;diff, and
combined diffs for merges.</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>3.
Caching. Textconv caching can speed up repeated diffs, such
as those you might trigger by running git log
&minus;p.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Marking
files as binary</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Git usually guesses
correctly whether a blob contains text or binary data by
examining the beginning of the contents. However, sometimes
you may want to override its decision, either because a blob
contains binary data later in the file, or because the
content, while technically composed of text characters, is
opaque to a human reader. For example, many postscript files
contain only ascii characters, but produce noisy and
meaningless diffs.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
simplest way to mark a file as binary is to unset the diff
attribute in the .gitattributes file:</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>*.ps
&minus;diff</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
will cause Git to generate Binary files differ (or a binary
patch, if binary patches are enabled) instead of a regular
diff.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>However,
one may also want to specify other diff driver attributes.
For example, you might want to use textconv to convert
postscript files to an ascii representation for human
viewing, but otherwise treat them as binary files. You
cannot specify both &minus;diff and diff=ps attributes. The
solution is to use the diff.*.binary config
option:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;ps&quot;] <br>
textconv = ps2ascii <br>
binary = true</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Performing
a three&minus;way merge <big><br>
merge</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The attribute merge
affects how three versions of a file are merged when a
file&minus;level merge is necessary during git merge, and
other commands such as git revert and git
cherry&minus;pick.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Set</big></big></p>

<p style="margin-left:23%;"><big><big>Built&minus;in
3&minus;way merge driver is used to merge the contents in a
way similar to <i>merge</i> command of RCS suite. This is
suitable for ordinary text files.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unset</big></big></p>

<p style="margin-left:23%;"><big><big>Take the version from
the current branch as the tentative merge result, and
declare that the merge has conflicts. This is suitable for
binary files that do not have a well&minus;defined merge
semantics.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unspecified</big></big></p>

<p style="margin-left:23%;"><big><big>By default, this uses
the same built&minus;in 3&minus;way merge driver as is the
case when the merge attribute is set. However, the
merge.default configuration variable can name different
merge driver to be used with paths for which the merge
attribute is unspecified.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>String</big></big></p>

<p style="margin-left:23%;"><big><big>3&minus;way merge is
performed using the specified custom merge driver. The
built&minus;in 3&minus;way merge driver can be explicitly
specified by asking for &quot;text&quot; driver; the
built&minus;in &quot;take the current branch&quot; driver
can be requested with &quot;binary&quot;.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Built-in
merge drivers</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>There are a few
built&minus;in low&minus;level merge drivers defined that
can be asked for via the merge attribute.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>text</big></big></p>

<p style="margin-left:23%;"><big><big>Usual 3&minus;way
file level merge for text files. Conflicted regions are
marked with conflict markers &lt;&lt;&lt;&lt;&lt;&lt;&lt;,
======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. The version from
your branch appears before the ======= marker, and the
version from the merged branch appears after the =======
marker.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>binary</big></big></p>

<p style="margin-left:23%;"><big><big>Keep the version from
your branch in the work tree, but leave the path in the
conflicted state for the user to sort out.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>union</big></big></p>

<p style="margin-left:23%;"><big><big>Run 3&minus;way file
level merge for text files, but take lines from both
versions, instead of leaving conflict markers. This tends to
leave the added lines in the resulting file in random order
and the user should verify the result. Do not use this if
you do not understand the implications.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Defining
a custom merge driver</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The definition of a
merge driver is done in the .git/config file, not in the
gitattributes file, so strictly speaking this manual page is
a wrong place to talk about it. However...</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>To
define a custom merge driver filfre, add a section to your
$GIT_DIR/config file (or $HOME/.gitconfig file) like
this:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[merge
&quot;filfre&quot;] <br>
name = feel&minus;free merge driver <br>
driver = filfre %O %A %B <br>
recursive = binary</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
merge.*.name variable gives the driver a
human&minus;readable name.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
&lsquo;merge.*.driver&lsquo; variable&rsquo;s value is used
to construct a command to run to merge ancestor&rsquo;s
version (%O), current version (%A) and the other
branches&rsquo; version (%B). These three tokens are
replaced with the names of temporary files that hold the
contents of these versions when the command line is built.
Additionally, %L will be replaced with the conflict marker
size (see below).</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
merge driver is expected to leave the result of the merge in
the file named with %A by overwriting it, and exit with zero
status if it managed to merge them cleanly, or
non&minus;zero if there were conflicts.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
merge.*.recursive variable specifies what other merge driver
to use when the merge driver is called for an internal merge
between common ancestors, when there are more than one. When
left unspecified, the driver itself is used for both
internal merge and the final merge.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>conflict-marker-size</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>This attribute
controls the length of conflict markers left in the work
tree file during a conflicted merge. Only setting to the
value to a positive integer has any meaningful
effect.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>For
example, this line in .gitattributes can be used to tell the
merge machinery to leave much longer (instead of the usual
7&minus;character&minus;long) conflict markers when merging
the file Documentation/git&minus;merge.txt results in a
conflict.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>Documentation/git&minus;merge.txt
conflict&minus;marker&minus;size=32</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Checking
whitespace errors <big><br>
whitespace</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The core.whitespace
configuration variable allows you to define what <i>diff</i>
and <i>apply</i> should consider whitespace errors for all
paths in the project (See <b>git-config</b>(1)). This
attribute gives you finer control per path.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Set</big></big></p>

<p style="margin-left:23%;"><big><big>Notice all types of
potential whitespace errors known to Git. The tab width is
taken from the value of the core.whitespace configuration
variable.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unset</big></big></p>

<p style="margin-left:23%;"><big><big>Do not notice
anything as error.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Unspecified</big></big></p>

<p style="margin-left:23%;"><big><big>Use the value of the
core.whitespace configuration variable to decide what to
notice as error.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>String</big></big></p>

<p style="margin-left:23%;"><big><big>Specify a comma
separate list of common whitespace problems to notice in the
same format as the core.whitespace configuration
variable.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Creating
an archive <big><br>
export-ignore</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Files and directories
with the attribute export&minus;ignore won&rsquo;t be added
to archive files.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>export-subst</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>If the attribute
export&minus;subst is set for a file then Git will expand
several placeholders when adding this file to an archive.
The expansion depends on the availability of a commit ID,
i.e., if <b>git-archive</b>(1) has been given a tree instead
of a commit or a tag then no replacement will be done. The
placeholders are the same as those for the option
&minus;&minus;pretty=format: of <b>git-log</b>(1), except
that they need to be wrapped like this:
$Format:PLACEHOLDERS$ in the file. E.g. the string
$Format:%H$ will be replaced by the commit
hash.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Packing
objects <big><br>
delta</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Delta compression
will not be attempted for blobs for paths with the attribute
delta set to false.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Viewing
files in GUI tools <big><br>
encoding</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>The value of this
attribute specifies the character encoding that should be
used by GUI tools (e.g. <b>gitk</b>(1) and
<b>git-gui</b>(1)) to display the contents of the relevant
file. Note that due to performance considerations
<b>gitk</b>(1) does not use this attribute unless you
manually enable per&minus;file encodings in its
options.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>If
this attribute is not set or has an invalid value, the value
of the gui.encoding configuration variable is used instead
(See <b>git-config</b>(1)).</big></big></p>

<h2>USING MACRO ATTRIBUTES
<a name="USING MACRO ATTRIBUTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>You
do not want any end&minus;of&minus;line conversions applied
to, nor textual diffs produced for, any binary file you
track. You would need to specify e.g.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>*.jpg
&minus;text &minus;diff</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>but
that may become cumbersome, when you have many attributes.
Using macro attributes, you can define an attribute that,
when set, also sets or unsets a number of other attributes
at the same time. The system knows a built&minus;in macro
attribute, binary:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>*.jpg
binary</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Setting
the &quot;binary&quot; attribute also unsets the
&quot;text&quot; and &quot;diff&quot; attributes as above.
Note that macro attributes can only be &quot;Set&quot;,
though setting one might have the effect of setting or
unsetting other attributes or even returning other
attributes to the &quot;Unspecified&quot;
state.</big></big></p>

<h2>DEFINING MACRO ATTRIBUTES
<a name="DEFINING MACRO ATTRIBUTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big>Custom
macro attributes can be defined only in the .gitattributes
file at the toplevel (i.e. not in any subdirectory). The
built&minus;in macro attribute &quot;binary&quot; is
equivalent to:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>[attr]binary
&minus;diff &minus;merge &minus;text</big></big></p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>If
you have these three gitattributes file:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
$GIT_DIR/info/attributes)</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>a*
foo !bar &minus;baz</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
.gitattributes) <br>
abc foo bar baz</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>(in
t/.gitattributes) <br>
ab* merge=filfre <br>
abc &minus;foo &minus;bar <br>
*.c frotz</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>the
attributes given to path t/abc are computed as
follows:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>1. By
examining t/.gitattributes (which is in the same directory
as the path in question), Git finds that the first line
matches. merge attribute is set. It also finds that the
second line matches, and attributes foo and bar are
unset.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>2.
Then it examines .gitattributes (which is in the parent
directory), and finds that the first line matches, but
t/.gitattributes file already decided how merge, foo and bar
attributes should be given to this path, so it leaves foo
and bar unset. Attribute baz is set.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>3.
Finally it examines $GIT_DIR/info/attributes. This file is
used to override the in&minus;tree settings. The first line
is a match, and foo is set, bar is reverted to unspecified
state, and baz is unset.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>As
the result, the attributes assignment to t/abc
becomes:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>foo
set to true <br>
bar unspecified <br>
baz set to false <br>
merge set to string value &quot;filfre&quot; <br>
frotz unspecified</big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><b>git-check-attr</b>(1).</big></big></p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>Part
of the <b>git</b>(1) suite</big></big></p>
<hr>
</body>
</html>
