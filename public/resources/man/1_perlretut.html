<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:29 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLRETUT</title>

</head>
<body>

<h1 align="center">PERLRETUT</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Part 1: The basics">Part 1: The basics</a><br>
<a href="#Part 2: Power tools">Part 2: Power tools</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR AND COPYRIGHT">AUTHOR AND COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlretut
&minus; Perl regular expressions tutorial</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page
provides a basic tutorial on understanding, creating and
using regular expressions in Perl. It serves as a complement
to the reference page on regular expressions perlre. Regular
expressions are an integral part of the
<tt>&quot;m//&quot;</tt>, <tt>&quot;s///&quot;</tt>,
<tt>&quot;qr//&quot;</tt> and <tt>&quot;split&quot;</tt>
operators and so this tutorial also overlaps with
&quot;Regexp Quote-Like Operators&quot; in perlop and
&quot;split&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">Perl is widely
renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.
Perl regular expressions display an efficiency and
flexibility unknown in most other computer languages.
Mastering even the basics of regular expressions will allow
you to manipulate text with surprising ease.</p>

<p style="margin-left:11%; margin-top: 1em">What is a
regular expression? A regular expression is simply a string
that describes a pattern. Patterns are in common use these
days; examples are the patterns typed into a search engine
to find web pages and the patterns used to list files in a
directory, e.g., <tt>&quot;ls *.txt&quot;</tt> or
<tt>&quot;dir *.*&quot;</tt>. In Perl, the patterns
described by regular expressions are used to search strings,
extract desired parts of strings, and to do search and
replace operations.</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expressions have the undeserved reputation of being abstract
and difficult to understand. Regular expressions are
constructed using simple concepts like conditionals and
loops and are no more difficult to understand than the
corresponding <tt>&quot;if&quot;</tt> conditionals and
<tt>&quot;while&quot;</tt> loops in the Perl language
itself. In fact, the main challenge in learning regular
expressions is just getting used to the terse notation used
to express these concepts.</p>

<p style="margin-left:11%; margin-top: 1em">This tutorial
flattens the learning curve by discussing regular expression
concepts, along with their notation, one at a time and with
many examples. The first part of the tutorial will progress
from the simplest word searches to the basic regular
expression concepts. If you master the first part, you will
have all the tools needed to solve about 98% of your needs.
The second part of the tutorial is for those comfortable
with the basics and hungry for more power tools. It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.</p>

<p style="margin-left:11%; margin-top: 1em">A note: to save
time, &rsquo;regular expression&rsquo; is often abbreviated
as regexp or regex. Regexp is a more natural abbreviation
than regex, but is harder to pronounce. The Perl pod
documentation is evenly split on regexp vs regex; in Perl,
there is more than one way to abbreviate it. We&rsquo;ll use
regexp in this tutorial.</p>

<h2>Part 1: The basics
<a name="Part 1: The basics"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Simple word
matching</b> <br>
The simplest regexp is simply a word, or more generally, a
string of characters. A regexp consisting of a word matches
any string that contains that word:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;Hello World&quot; =~ /World/;  # matches</pre>


<p style="margin-left:11%; margin-top: 1em">What is this
Perl statement all about? <tt>&quot;Hello World&quot;</tt>
is a simple double-quoted string. <tt>&quot;World&quot;</tt>
is the regular expression and the <tt>&quot;//&quot;</tt>
enclosing <tt>&quot;/World/&quot;</tt> tells Perl to search
a string for a match. The operator <tt>&quot;=~&quot;</tt>
associates the string with the regexp match and produces a
true value if the regexp matched, or false if the regexp did
not match. In our case, <tt>&quot;World&quot;</tt> matches
the second word in <tt>&quot;Hello World&quot;</tt>, so the
expression is true. Expressions like this are useful in
conditionals:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (&quot;Hello World&quot; =~ /World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">There are
useful variations on this theme. The sense of the match can
be reversed by using the <tt>&quot;!~&quot;</tt>
operator:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (&quot;Hello World&quot; !~ /World/) {
        print &quot;It doesn't match\n&quot;;
    }
    else {
        print &quot;It matches\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The literal
string in the regexp can be replaced by a variable:</p>

<pre style="margin-left:11%; margin-top: 1em">    $greeting = &quot;World&quot;;
    if (&quot;Hello World&quot; =~ /$greeting/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
matching against the special default variable <tt>$_</tt>,
the <tt>&quot;$_ =~&quot;</tt> part can be omitted:</p>

<pre style="margin-left:11%; margin-top: 1em">    $_ = &quot;Hello World&quot;;
    if (/World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">And finally,
the <tt>&quot;//&quot;</tt> default delimiters for a match
can be changed to arbitrary delimiters by putting an
<tt>'m'</tt> out front:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;Hello World&quot; =~ m!World!;   # matches, delimited by '!'
    &quot;Hello World&quot; =~ m{World};   # matches, note the matching '{}'
    &quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;/World/&quot;,
<tt>&quot;m!World!&quot;</tt>, and
<tt>&quot;m{World}&quot;</tt> all represent the same thing.
When, e.g., the quote (<tt>&quot;&quot;&quot;</tt>) is used
as a delimiter, the forward slash <tt>'/'</tt> becomes an
ordinary character and can be used in this regexp without
trouble.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
consider how different regexps would match <tt>&quot;Hello
World&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;Hello World&quot; =~ /world/;  # doesn't match
    &quot;Hello World&quot; =~ /o W/;    # matches
    &quot;Hello World&quot; =~ /oW/;     # doesn't match
    &quot;Hello World&quot; =~ /World /; # doesn't match</pre>


<p style="margin-left:11%; margin-top: 1em">The first
regexp <tt>&quot;world&quot;</tt> doesn&rsquo;t match
because regexps are case-sensitive. The second regexp
matches because the substring <tt>'o&nbsp;W'</tt> occurs in
the string <tt>&quot;Hello&nbsp;World&quot;</tt>. The space
character &rsquo; &rsquo; is treated like any other
character in a regexp and is needed to match in this case.
The lack of a space character is the reason the third regexp
<tt>'oW'</tt> doesn&rsquo;t match. The fourth regexp
<tt>'World '</tt> doesn&rsquo;t match because there is a
space at the end of the regexp, but not at the end of the
string. The lesson here is that regexps must match a part of
the string <i>exactly</i> in order for the statement to be
true.</p>

<p style="margin-left:11%; margin-top: 1em">If a regexp
matches in more than one place in the string, Perl will
always match at the earliest possible point in the
string:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;Hello World&quot; =~ /o/;       # matches 'o' in 'Hello'
    &quot;That hat is red&quot; =~ /hat/; # matches 'hat' in 'That'</pre>


<p style="margin-left:11%; margin-top: 1em">With respect to
character matching, there are a few more points you need to
know about. First of all, not all characters can be used
&rsquo;as is&rsquo; in a match. Some characters, called
<i>metacharacters</i>, are reserved for use in regexp
notation. The metacharacters are</p>

<pre style="margin-left:11%; margin-top: 1em">    {}[]()^$.|*+?\</pre>


<p style="margin-left:11%; margin-top: 1em">The
significance of each of these will be explained in the rest
of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash
before it:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;2+2=4&quot; =~ /2+2/;    # doesn't match, + is a metacharacter
    &quot;2+2=4&quot; =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    &quot;The interval is [0,1).&quot; =~ /[0,1)./     # is a syntax error!
    &quot;The interval is [0,1).&quot; =~ /\[0,1\)\./  # matches
    &quot;#!/usr/bin/perl&quot; =~ /#!\/usr\/bin\/perl/;  # matches</pre>


<p style="margin-left:11%; margin-top: 1em">In the last
regexp, the forward slash <tt>'/'</tt> is also backslashed,
because it is used to delimit the regexp. This can lead to
<small>LTS</small> (leaning toothpick syndrome), however,
and it is often more readable to change delimiters.</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;#!/usr/bin/perl&quot; =~ m!#\!/usr/bin/perl!;  # easier to read</pre>


<p style="margin-left:11%; margin-top: 1em">The backslash
character <tt>'\'</tt> is a metacharacter itself and needs
to be backslashed:</p>

<pre style="margin-left:11%; margin-top: 1em">    'C:\WIN32' =~ /C:\\WIN/;   # matches</pre>


<p style="margin-left:11%; margin-top: 1em">In addition to
the metacharacters, there are some <small>ASCII</small>
characters which don&rsquo;t have printable character
equivalents and are instead represented by <i>escape
sequences</i>. Common examples are <tt>&quot;\t&quot;</tt>
for a tab, <tt>&quot;\n&quot;</tt> for a newline,
<tt>&quot;\r&quot;</tt> for a carriage return and
<tt>&quot;\a&quot;</tt> for a bell (or alert). If your
string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g.,
<tt>&quot;\033&quot;</tt>, or hexadecimal escape sequence,
e.g., <tt>&quot;\x1B&quot;</tt> may be a more natural
representation for your bytes. Here are some examples of
escapes:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;1000\t2000&quot; =~ m(0\t2)   # matches
    &quot;1000\n2000&quot; =~ /0\n20/   # matches
    &quot;1000\t2000&quot; =~ /\000\t2/ # doesn't match, &quot;0&quot; ne &quot;\000&quot;
    &quot;cat&quot;   =~ /\o{143}\x61\x74/ # matches in ASCII, but a weird way
                                 # to spell cat</pre>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;ve
been around Perl a while, all this talk of escape sequences
may seem familiar. Similar escape sequences are used in
double-quoted strings and in fact the regexps in Perl are
mostly treated as double-quoted strings. This means that
variables can be used in regexps as well. Just like
double-quoted strings, the values of the variables in the
regexp will be substituted in before the regexp is evaluated
for matching purposes. So we have:</p>

<pre style="margin-left:11%; margin-top: 1em">    $foo = 'house';
    'housecat' =~ /$foo/;      # matches
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches</pre>


<p style="margin-left:11%; margin-top: 1em">So far, so
good. With the knowledge above you can already perform
searches with just about any literal string regexp you can
dream up. Here is a <i>very simple</i> emulation of the Unix
grep program:</p>

<pre style="margin-left:11%; margin-top: 1em">    % cat &gt; simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (&lt;&gt;) {
        print if /$regexp/;
    }
    ^D
    % chmod +x simple_grep
    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards</pre>


<p style="margin-left:11%; margin-top: 1em">This program is
easy to understand. <tt>&quot;#!/usr/bin/perl&quot;</tt> is
the standard way to invoke a perl program from the shell.
<tt>&quot;$regexp&nbsp;=&nbsp;shift;&quot;</tt> saves the
first command line argument as the regexp to be used,
leaving the rest of the command line arguments to be treated
as files. <tt>&quot;while&nbsp;(&lt;&gt;)&quot;</tt> loops
over all the lines in all the files. For each line,
<tt>&quot;print&nbsp;if&nbsp;/$regexp/;&quot;</tt> prints
the line if the regexp matches the line. In this line, both
<tt>&quot;print&quot;</tt> and
<tt>&quot;/$regexp/&quot;</tt> use the default variable
<tt>$_</tt> implicitly.</p>

<p style="margin-left:11%; margin-top: 1em">With all of the
regexps above, if the regexp matched anywhere in the string,
it was considered a match. Sometimes, however, we&rsquo;d
like to specify <i>where</i> in the string the regexp should
try to match. To do this, we would use the <i>anchor</i>
metacharacters <tt>&quot;^&quot;</tt> and
<tt>&quot;$&quot;</tt>. The anchor <tt>&quot;^&quot;</tt>
means match at the beginning of the string and the anchor
<tt>&quot;$&quot;</tt> means match at the end of the string,
or before a newline at the end of the string. Here is how
they are used:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;housekeeper&quot; =~ /keeper/;    # matches
    &quot;housekeeper&quot; =~ /^keeper/;   # doesn't match
    &quot;housekeeper&quot; =~ /keeper$/;   # matches
    &quot;housekeeper\n&quot; =~ /keeper$/; # matches</pre>


<p style="margin-left:11%; margin-top: 1em">The second
regexp doesn&rsquo;t match because <tt>&quot;^&quot;</tt>
constrains <tt>&quot;keeper&quot;</tt> to match only at the
beginning of the string, but
<tt>&quot;housekeeper&quot;</tt> has keeper starting in the
middle. The third regexp does match, since the
<tt>&quot;$&quot;</tt> constrains
<tt>&quot;keeper&quot;</tt> to match only at the end of the
string.</p>

<p style="margin-left:11%; margin-top: 1em">When both
<tt>&quot;^&quot;</tt> and <tt>&quot;$&quot;</tt> are used
at the same time, the regexp has to match both the beginning
and the end of the string, i.e., the regexp matches the
whole string. Consider</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;keeper&quot; =~ /^keep$/;      # doesn't match
    &quot;keeper&quot; =~ /^keeper$/;    # matches
    &quot;&quot;       =~ /^$/;          # ^$ matches an empty string</pre>


<p style="margin-left:11%; margin-top: 1em">The first
regexp doesn&rsquo;t match because the string has more to it
than <tt>&quot;keep&quot;</tt>. Since the second regexp is
exactly the string, it matches. Using both
<tt>&quot;^&quot;</tt> and <tt>&quot;$&quot;</tt> in a
regexp forces the complete string to match, so it gives you
complete control over which strings match and which
don&rsquo;t. Suppose you are looking for a fellow named
bert, off in a string by himself:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;dogbert&quot; =~ /bert/;   # matches, but not what you want
    &quot;dilbert&quot; =~ /^bert/;  # doesn't match, but ..
    &quot;bertram&quot; =~ /^bert/;  # matches, so still not good enough
    &quot;bertram&quot; =~ /^bert$/; # doesn't match, good
    &quot;dilbert&quot; =~ /^bert$/; # doesn't match, good
    &quot;bert&quot;    =~ /^bert$/; # matches, perfect</pre>


<p style="margin-left:11%; margin-top: 1em">Of course, in
the case of a literal string, one could just as easily use
the string comparison
<tt>&quot;$string&nbsp;eq&nbsp;'bert'&quot;</tt> and it
would be more efficient. The <tt>&quot;^...$&quot;</tt>
regexp really becomes useful when we add in the more
powerful regexp tools below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
character classes</b> <br>
Although one can already do quite a lot with the literal
string regexps above, we&rsquo;ve only scratched the surface
of regular expression technology. In this and subsequent
sections we will introduce regexp concepts (and associated
metacharacter notations) that will allow a regexp to
represent not just a single character sequence, but a
<i>whole class</i> of them.</p>

<p style="margin-left:11%; margin-top: 1em">One such
concept is that of a <i>character class</i>. A character
class allows a set of possible characters, rather than just
a single character, to match at a particular point in a
regexp. Character classes are denoted by brackets
<tt>&quot;[...]&quot;</tt>, with the set of characters to be
possibly matched inside. Here are some examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    /cat/;       # matches 'cat'
    /[bcr]at/;   # matches 'bat, 'cat', or 'rat'
    /item[0123456789]/;  # matches 'item0' or ... or 'item9'
    &quot;abc&quot; =~ /[cab]/;    # matches 'a'</pre>


<p style="margin-left:11%; margin-top: 1em">In the last
statement, even though <tt>'c'</tt> is the first character
in the class, <tt>'a'</tt> matches because the first
character position in the string is the earliest point at
which the regexp can match.</p>

<pre style="margin-left:11%; margin-top: 1em">    /[yY][eE][sS]/;      # match 'yes' in a case&minus;insensitive way
                         # 'yes', 'Yes', 'YES', etc.</pre>


<p style="margin-left:11%; margin-top: 1em">This regexp
displays a common task: perform a case-insensitive match.
Perl provides a way of avoiding all those brackets by simply
appending an <tt>'i'</tt> to the end of the match. Then
<tt>&quot;/[yY][eE][sS]/;&quot;</tt> can be rewritten as
<tt>&quot;/yes/i;&quot;</tt>. The <tt>'i'</tt> stands for
case-insensitive and is an example of a <i>modifier</i> of
the matching operation. We will meet other modifiers later
in the tutorial.</p>

<p style="margin-left:11%; margin-top: 1em">We saw in the
section above that there were ordinary characters, which
represented themselves, and special characters, which needed
a backslash <tt>&quot;\&quot;</tt> to represent themselves.
The same is true in a character class, but the sets of
ordinary and special characters inside a character class are
different than those outside a character class. The special
characters for a character class are
<tt>&quot;&minus;]\^$&quot;</tt> (and the pattern delimiter,
whatever it is). <tt>&quot;]&quot;</tt> is special because
it denotes the end of a character class.
<tt>&quot;$&quot;</tt> is special because it denotes a
scalar variable. <tt>&quot;\&quot;</tt> is special because
it is used in escape sequences, just like above. Here is how
the special characters <tt>&quot;]$\&quot;</tt> are
handled:</p>

<pre style="margin-left:11%; margin-top: 1em">   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat', 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'</pre>


<p style="margin-left:11%; margin-top: 1em">The last two
are a little tricky. In <tt>&quot;[\$x]&quot;</tt>, the
backslash protects the dollar sign, so the character class
has two members <tt>&quot;$&quot;</tt> and
<tt>&quot;x&quot;</tt>. In <tt>&quot;[\\$x]&quot;</tt>, the
backslash is protected, so <tt>$x</tt> is treated as a
variable and substituted in double quote fashion.</p>

<p style="margin-left:11%; margin-top: 1em">The special
character <tt>'&minus;'</tt> acts as a range operator within
character classes, so that a contiguous set of characters
can be written as a range. With ranges, the unwieldy
<tt>&quot;[0123456789]&quot;</tt> and
<tt>&quot;[abc...xyz]&quot;</tt> become the svelte
<tt>&quot;[0&minus;9]&quot;</tt> and
<tt>&quot;[a&minus;z]&quot;</tt>. Some examples are</p>

<pre style="margin-left:11%; margin-top: 1em">    /item[0&minus;9]/;  # matches 'item0' or ... or 'item9'
    /[0&minus;9bx&minus;z]aa/;  # matches '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0&minus;9a&minus;fA&minus;F]/;  # matches a hexadecimal digit
    /[0&minus;9a&minus;zA&minus;Z_]/; # matches a &quot;word&quot; character,
                    # like those in a Perl variable name</pre>


<p style="margin-left:11%; margin-top: 1em">If
<tt>'&minus;'</tt> is the first or last character in a
character class, it is treated as an ordinary character;
<tt>&quot;[&minus;ab]&quot;</tt>,
<tt>&quot;[ab&minus;]&quot;</tt> and
<tt>&quot;[a\&minus;b]&quot;</tt> are all equivalent.</p>

<p style="margin-left:11%; margin-top: 1em">The special
character <tt>&quot;^&quot;</tt> in the first position of a
character class denotes a <i>negated character class</i>,
which matches any character but those in the brackets. Both
<tt>&quot;[...]&quot;</tt> and <tt>&quot;[^...]&quot;</tt>
must match a character, or the match fails. Then</p>

<pre style="margin-left:11%; margin-top: 1em">    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0&minus;9]/;  # matches a non&minus;numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary</pre>


<p style="margin-left:11%; margin-top: 1em">Now, even
<tt>&quot;[0&minus;9]&quot;</tt> can be a bother to write
multiple times, so in the interest of saving keystrokes and
making regexps more readable, Perl has several abbreviations
for common character classes, as shown below. Since the
introduction of Unicode, unless the <tt>&quot;//a&quot;</tt>
modifier is in effect, these character classes match more
than just a few characters in the <small>ASCII</small>
range.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\d matches a digit, not just [0&minus;9] but also digits
from non-roman scripts</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\s matches a whitespace character, the set [\ \t\r\n\f]
and others</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\w matches a word character (alphanumeric or _), not
just [0&minus;9a&minus;zA&minus;Z_] but also digits and
characters from non-roman scripts</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\D is a negated \d; it represents any other character
than a digit, or [^\d]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\S is a negated \s; it represents any non-whitespace
character [^\s]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\W is a negated \w; it represents any non-word character
[^\w]</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The period &rsquo;.&rsquo; matches any character but
&quot;\n&quot; (unless the modifier <tt>&quot;//s&quot;</tt>
is in effect, as explained below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>\N, like the period, matches any character but
&quot;\n&quot;, but it does so regardless of whether the
modifier <tt>&quot;//s&quot;</tt> is in effect.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;//a&quot;</tt> modifier, available starting in
Perl 5.14, is used to restrict the matches of \d, \s, and \w
to just those in the <small>ASCII</small> range. It is
useful to keep your program from being needlessly exposed to
full Unicode (and its accompanying security considerations)
when all you want is to process English-like text. (The
&quot;a&quot; may be doubled, <tt>&quot;//aa&quot;</tt>, to
provide even more restrictions, preventing case-insensitive
matching of <small>ASCII</small> with non-ASCII characters;
otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly
match a &quot;k&quot; or &quot;K&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\d\s\w\D\S\W&quot;</tt> abbreviations can be used
both inside and outside of character classes. Here are some
in use:</p>

<pre style="margin-left:11%; margin-top: 1em">    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non&minus;word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'</pre>


<p style="margin-left:11%; margin-top: 1em">Because a
period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example,
<tt>&quot;\d&quot;</tt> and <tt>&quot;\w&quot;</tt> are sets
of characters, it is incorrect to think of
<tt>&quot;[^\d\w]&quot;</tt> as <tt>&quot;[\D\W]&quot;</tt>;
in fact <tt>&quot;[^\d\w]&quot;</tt> is the same as
<tt>&quot;[^\w]&quot;</tt>, which is the same as
<tt>&quot;[\W]&quot;</tt>. Think DeMorgan&rsquo;s laws.</p>

<p style="margin-left:11%; margin-top: 1em">An anchor
useful in basic regexps is the <i>word anchor</i>
<tt>&quot;\b&quot;</tt>. This matches a boundary between a
word character and a non-word character
<tt>&quot;\w\W&quot;</tt> or <tt>&quot;\W\w&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Housecat catenates house and cat&quot;;
    $x =~ /cat/;    # matches cat in 'housecat'
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string</pre>


<p style="margin-left:11%; margin-top: 1em">Note in the
last example, the end of the string is considered a word
boundary.</p>

<p style="margin-left:11%; margin-top: 1em">You might
wonder why <tt>'.'</tt> matches everything but
<tt>&quot;\n&quot;</tt> &minus; why not every character? The
reason is that often one is matching against lines and would
like to ignore the newline characters. For instance, while
the string <tt>&quot;\n&quot;</tt> represents one line, we
would like to think of it as empty. Then</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;&quot;   =~ /^$/;    # matches
    &quot;\n&quot; =~ /^$/;    # matches, $ anchors before &quot;\n&quot;
    &quot;&quot;   =~ /./;      # doesn't match; it needs a char
    &quot;&quot;   =~ /^.$/;    # doesn't match; it needs a char
    &quot;\n&quot; =~ /^.$/;    # doesn't match; it needs a char other than &quot;\n&quot;
    &quot;a&quot;  =~ /^.$/;    # matches
    &quot;a\n&quot;  =~ /^.$/;  # matches, $ anchors before &quot;\n&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">This behavior
is convenient, because we usually want to ignore newlines
when we count and match characters in a line. Sometimes,
however, we want to keep track of newlines. We might even
want <tt>&quot;^&quot;</tt> and <tt>&quot;$&quot;</tt> to
anchor at the beginning and end of lines within the string,
rather than just the beginning and end of the string. Perl
allows us to choose between ignoring and paying attention to
newlines by using the <tt>&quot;//s&quot;</tt> and
<tt>&quot;//m&quot;</tt> modifiers. <tt>&quot;//s&quot;</tt>
and <tt>&quot;//m&quot;</tt> stand for single line and
multi-line and they determine whether a string is to be
treated as one continuous string, or as a set of lines. The
two modifiers affect two aspects of how the regexp is
interpreted: 1) how the <tt>'.'</tt> character class is
defined, and 2) where the anchors <tt>&quot;^&quot;</tt> and
<tt>&quot;$&quot;</tt> are able to match. Here are the four
possible combinations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">no modifiers (//): Default
behavior. <tt>'.'</tt> matches any character except
<tt>&quot;\n&quot;</tt>. <tt>&quot;^&quot;</tt> matches only
at the beginning of the string and <tt>&quot;$&quot;</tt>
matches only at the end or before a newline at the end.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>s modifier (//s): Treat string as a single long line.
<tt>'.'</tt> matches any character, even
<tt>&quot;\n&quot;</tt>. <tt>&quot;^&quot;</tt> matches only
at the beginning of the string and <tt>&quot;$&quot;</tt>
matches only at the end or before a newline at the end.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>m modifier (//m): Treat string as a set of multiple
lines. <tt>'.'</tt> matches any character except
<tt>&quot;\n&quot;</tt>. <tt>&quot;^&quot;</tt> and
<tt>&quot;$&quot;</tt> are able to match at the start or end
of <i>any</i> line within the string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>both s and m modifiers (//sm): Treat string as a single
long line, but detect multiple lines. <tt>'.'</tt> matches
any character, even <tt>&quot;\n&quot;</tt>.
<tt>&quot;^&quot;</tt> and <tt>&quot;$&quot;</tt>, however,
are able to match at the start or end of <i>any</i> line
within the string.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here are
examples of <tt>&quot;//s&quot;</tt> and
<tt>&quot;//m&quot;</tt> in action:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;There once was a girl\nWho programmed in Perl\n&quot;;
    $x =~ /^Who/;   # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/s;  # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/m;  # matches, &quot;Who&quot; at start of second line
    $x =~ /^Who/sm; # matches, &quot;Who&quot; at start of second line
    $x =~ /girl.Who/;   # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/s;  # matches, &quot;.&quot; matches &quot;\n&quot;
    $x =~ /girl.Who/m;  # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/sm; # matches, &quot;.&quot; matches &quot;\n&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Most of the
time, the default behavior is what is wanted, but
<tt>&quot;//s&quot;</tt> and <tt>&quot;//m&quot;</tt> are
occasionally very useful. If <tt>&quot;//m&quot;</tt> is
being used, the start of the string can still be matched
with <tt>&quot;\A&quot;</tt> and the end of the string can
still be matched with the anchors <tt>&quot;\Z&quot;</tt>
(matches both the end and the newline before, like
<tt>&quot;$&quot;</tt>), and <tt>&quot;\z&quot;</tt>
(matches only the end):</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /^Who/m;   # matches, &quot;Who&quot; at start of second line
    $x =~ /\AWho/m;  # doesn't match, &quot;Who&quot; is not at start of string
    $x =~ /girl$/m;  # matches, &quot;girl&quot; at end of first line
    $x =~ /girl\Z/m; # doesn't match, &quot;girl&quot; is not at end of string
    $x =~ /Perl\Z/m; # matches, &quot;Perl&quot; is at newline before end
    $x =~ /Perl\z/m; # doesn't match, &quot;Perl&quot; is not at end of string</pre>


<p style="margin-left:11%; margin-top: 1em">We now know how
to create choices among classes of characters in a regexp.
What about choices among words or character strings? Such
choices are described in the next section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Matching
this or that</b> <br>
Sometimes we would like our regexp to be able to match
different possible words or character strings. This is
accomplished by using the <i>alternation</i> metacharacter
<tt>&quot;|&quot;</tt>. To match <tt>&quot;dog&quot;</tt> or
<tt>&quot;cat&quot;</tt>, we form the regexp
<tt>&quot;dog|cat&quot;</tt>. As before, Perl will try to
match the regexp at the earliest possible point in the
string. At each character position, Perl will first try to
match the first alternative, <tt>&quot;dog&quot;</tt>. If
<tt>&quot;dog&quot;</tt> doesn&rsquo;t match, Perl will then
try the next alternative, <tt>&quot;cat&quot;</tt>. If
<tt>&quot;cat&quot;</tt> doesn&rsquo;t match either, then
the match fails and Perl moves to the next position in the
string. Some examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;cats and dogs&quot; =~ /cat|dog|bird/;  # matches &quot;cat&quot;
    &quot;cats and dogs&quot; =~ /dog|cat|bird/;  # matches &quot;cat&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Even though
<tt>&quot;dog&quot;</tt> is the first alternative in the
second regexp, <tt>&quot;cat&quot;</tt> is able to match
earlier in the string.</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;cats&quot;          =~ /c|ca|cat|cats/; # matches &quot;c&quot;
    &quot;cats&quot;          =~ /cats|cat|ca|c/; # matches &quot;cats&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Here, all the
alternatives match at the first string position, so the
first alternative is the one that matches. If some of the
alternatives are truncations of the others, put the longest
ones first to give them a chance to match.</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;cab&quot; =~ /a|b|c/ # matches &quot;c&quot;
                     # /a|b|c/ == /[abc]/</pre>


<p style="margin-left:11%; margin-top: 1em">The last
example points out that character classes are like
alternations of characters. At a given character position,
the first alternative that allows the regexp match to
succeed will be the one that matches.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Grouping
things and hierarchical matching</b> <br>
Alternation allows a regexp to choose among alternatives,
but by itself it is unsatisfying. The reason is that each
alternative is a whole regexp, but sometime we want
alternatives for just part of a regexp. For instance,
suppose we want to search for housecats or housekeepers. The
regexp <tt>&quot;housecat|housekeeper&quot;</tt> fits the
bill, but is inefficient because we had to type
<tt>&quot;house&quot;</tt> twice. It would be nice to have
parts of the regexp be constant, like
<tt>&quot;house&quot;</tt>, and some parts have
alternatives, like <tt>&quot;cat|keeper&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>grouping</i> metacharacters <tt>&quot;()&quot;</tt> solve
this problem. Grouping allows parts of a regexp to be
treated as a single unit. Parts of a regexp are grouped by
enclosing them in parentheses. Thus we could solve the
<tt>&quot;housecat|housekeeper&quot;</tt> by forming the
regexp as <tt>&quot;house(cat|keeper)&quot;</tt>. The regexp
<tt>&quot;house(cat|keeper)&quot;</tt> means match
<tt>&quot;house&quot;</tt> followed by either
<tt>&quot;cat&quot;</tt> or <tt>&quot;keeper&quot;</tt>.
Some more examples are</p>

<pre style="margin-left:11%; margin-top: 1em">    /(a|b)b/;    # matches 'ab' or 'bb'
    /(ac|b)b/;   # matches 'acb' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere
    /(a|[bc])d/; # matches 'ad', 'bd', or 'cd'
    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.
    /(19|20|)\d\d/;  # match years 19xx, 20xx, or the Y2K problem, xx
    &quot;20&quot; =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match</pre>


<p style="margin-left:11%; margin-top: 1em">Alternations
behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the
regexp to match is taken. So in the last example at the
first string position, <tt>&quot;20&quot;</tt> matches the
second alternative, but there is nothing left over to match
the next two digits <tt>&quot;\d\d&quot;</tt>. So Perl moves
on to the next alternative, which is the null alternative
and that works, since <tt>&quot;20&quot;</tt> is two
digits.</p>

<p style="margin-left:11%; margin-top: 1em">The process of
trying one alternative, seeing if it matches, and moving on
to the next alternative, while going back in the string from
where the previous alternative was tried, if it
doesn&rsquo;t, is called <i>backtracking</i>. The term
&rsquo;backtracking&rsquo; comes from the idea that matching
a regexp is like a walk in the woods. Successfully matching
a regexp is like arriving at a destination. There are many
possible trailheads, one for each string position, and each
one is tried in order, left to right. From each trailhead
there may be many paths, some of which get you there, and
some which are dead ends. When you walk along a trail and
hit a dead end, you have to backtrack along the trail to an
earlier point to try another trail. If you hit your
destination, you stop immediately and forget about trying
all the other trails. You are persistent, and only if you
have tried all the trails from all the trailheads and not
arrived at your destination, do you declare failure. To be
concrete, here is a step-by-step analysis of what Perl does
when it tries to match the regexp</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;abcde&quot; =~ /(abd|abc)(df|d|de)/;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">0</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Start with the first letter in
the string &rsquo;a&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>1</p></td>
<td width="5%"></td>
<td width="83%">


<p>Try the first alternative in the first group
&rsquo;abd&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>2</p></td>
<td width="5%"></td>
<td width="83%">


<p>Match &rsquo;a&rsquo; followed by &rsquo;b&rsquo;. So
far so good.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>3</p></td>
<td width="5%"></td>
<td width="83%">


<p>&rsquo;d&rsquo; in the regexp doesn&rsquo;t match
&rsquo;c&rsquo; in the string &minus; a dead end. So
backtrack two characters and pick the second alternative in
the first group &rsquo;abc&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>4</p></td>
<td width="5%"></td>
<td width="83%">


<p>Match &rsquo;a&rsquo; followed by &rsquo;b&rsquo;
followed by &rsquo;c&rsquo;. We are on a roll and have
satisfied the first group. Set <tt>$1</tt> to
&rsquo;abc&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>5</p></td>
<td width="5%"></td>
<td width="83%">


<p>Move on to the second group and pick the first
alternative &rsquo;df&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>6</p></td>
<td width="5%"></td>
<td width="83%">


<p>Match the &rsquo;d&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>7</p></td>
<td width="5%"></td>
<td width="83%">


<p>&rsquo;f&rsquo; in the regexp doesn&rsquo;t match
&rsquo;e&rsquo; in the string, so a dead end. Backtrack one
character and pick the second alternative in the second
group &rsquo;d&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>8</p></td>
<td width="5%"></td>
<td width="83%">


<p>&rsquo;d&rsquo; matches. The second grouping is
satisfied, so set <tt>$2</tt> to &rsquo;d&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>9</p></td>
<td width="5%"></td>
<td width="83%">


<p>We are at the end of the regexp, so we are done! We have
matched &rsquo;abcd&rsquo; out of the string
&quot;abcde&quot;.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There are a
couple of things to note about this analysis. First, the
third alternative in the second group &rsquo;de&rsquo; also
allows a match, but we stopped before we got to it &minus;
at a given character position, leftmost wins. Second, we
were able to get a match at the first character position of
the string &rsquo;a&rsquo;. If there were no matches at the
first position, Perl would move to the second character
position &rsquo;b&rsquo; and attempt the match all over
again. Only when all possible paths at all possible
character positions have been exhausted does Perl give up
and declare
<tt>&quot;$string&nbsp;=~&nbsp;/(abd|abc)(df|d|de)/;&quot;</tt>
to be false.</p>

<p style="margin-left:11%; margin-top: 1em">Even with all
this work, regexp matching happens remarkably fast. To speed
things up, Perl compiles the regexp into a compact sequence
of opcodes that can often fit inside a processor cache. When
the code is executed, these opcodes can then run at full
throttle and search very quickly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extracting
matches</b> <br>
The grouping metacharacters <tt>&quot;()&quot;</tt> also
serve another completely different function: they allow the
extraction of the parts of a string that matched. This is
very useful to find out what matched and for text processing
in general. For each grouping, the part that matched inside
goes into the special variables <tt>$1</tt>, <tt>$2</tt>,
etc. They can be used just as ordinary variables:</p>

<pre style="margin-left:11%; margin-top: 1em">    # extract hours, minutes, seconds
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # match hh:mm:ss format
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Now, we know
that in scalar context,
<tt>&quot;$time&nbsp;=~&nbsp;/(\d\d):(\d\d):(\d\d)/&quot;</tt>
returns a true or false value. In list context, however, it
returns the list of matched values
<tt>&quot;($1,$2,$3)&quot;</tt>. So we could write the code
more compactly as</p>

<pre style="margin-left:11%; margin-top: 1em">    # extract hours, minutes, seconds
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);</pre>


<p style="margin-left:11%; margin-top: 1em">If the
groupings in a regexp are nested, <tt>$1</tt> gets the group
with the leftmost opening parenthesis, <tt>$2</tt> the next
opening parenthesis, etc. Here is a regexp with nested
groups:</p>

<pre style="margin-left:11%; margin-top: 1em">    /(ab(cd|ef)((gi)|j))/;
     1  2      34</pre>


<p style="margin-left:11%; margin-top: 1em">If this regexp
matches, <tt>$1</tt> contains a string starting with
<tt>'ab'</tt>, <tt>$2</tt> is either set to <tt>'cd'</tt> or
<tt>'ef'</tt>, <tt>$3</tt> equals either <tt>'gi'</tt> or
<tt>'j'</tt>, and <tt>$4</tt> is either set to
<tt>'gi'</tt>, just like <tt>$3</tt>, or it remains
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">For
convenience, Perl sets <tt>$+</tt> to the string held by the
highest numbered <tt>$1</tt>, <tt>$2</tt>,... that got
assigned (and, somewhat related, <tt>$^N</tt> to the value
of the <tt>$1</tt>, <tt>$2</tt>,... most-recently assigned;
i.e. the <tt>$1</tt>, <tt>$2</tt>,... associated with the
rightmost closing parenthesis used in the match).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Backreferences</b>
<br>
Closely associated with the matching variables <tt>$1</tt>,
<tt>$2</tt>, ... are the <i>backreferences</i>
<tt>&quot;\g1&quot;</tt>, <tt>&quot;\g2&quot;</tt>,...
Backreferences are simply matching variables that can be
used <i>inside</i> a regexp. This is a really nice feature;
what matches later in a regexp is made to depend on what
matched earlier in the regexp. Suppose we wanted to look for
doubled words in a text, like &rsquo;the the&rsquo;. The
following regexp finds all 3&minus;letter doubles with a
space in between:</p>

<pre style="margin-left:11%; margin-top: 1em">    /\b(\w\w\w)\s\g1\b/;</pre>


<p style="margin-left:11%; margin-top: 1em">The grouping
assigns a value to \g1, so that the same 3&minus;letter
sequence is used for both parts.</p>

<p style="margin-left:11%; margin-top: 1em">A similar task
is to find words consisting of two identical parts:</p>

<pre style="margin-left:11%; margin-top: 1em">    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa</pre>


<p style="margin-left:11%; margin-top: 1em">The regexp has
a single grouping which considers 4&minus;letter
combinations, then 3&minus;letter combinations, etc., and
uses <tt>&quot;\g1&quot;</tt> to look for a repeat. Although
<tt>$1</tt> and <tt>&quot;\g1&quot;</tt> represent the same
thing, care should be taken to use matched variables
<tt>$1</tt>, <tt>$2</tt>,... only <i>outside</i> a regexp
and backreferences <tt>&quot;\g1&quot;</tt>,
<tt>&quot;\g2&quot;</tt>,... only <i>inside</i> a regexp;
not doing so may lead to surprising and unsatisfactory
results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Relative
backreferences</b> <br>
Counting the opening parentheses to get the correct number
for a backreference is error-prone as soon as there is more
than one capturing group. A more convenient technique became
available with Perl 5.10: relative backreferences. To refer
to the immediately preceding capture group one now may write
<tt>&quot;\g{&minus;1}&quot;</tt>, the next but last is
available via <tt>&quot;\g{&minus;2}&quot;</tt>, and so
on.</p>

<p style="margin-left:11%; margin-top: 1em">Another good
reason in addition to readability and maintainability for
using relative backreferences is illustrated by the
following example, where a simple pattern for matching
peculiar strings is used:</p>

<pre style="margin-left:11%; margin-top: 1em">    $a99a = '([a&minus;z])(\d)\g2\g1';   # matches a11a, g22g, x33x, etc.</pre>


<p style="margin-left:11%; margin-top: 1em">Now that we
have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:</p>

<pre style="margin-left:11%; margin-top: 1em">    $line = &quot;code=e99e&quot;;
    if ($line =~ /^(\w+)=$a99a$/){   # unexpected behavior!
        print &quot;$1 is valid\n&quot;;
    } else {
        print &quot;bad line: '$line'\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">But this
doesn&rsquo;t match, at least not the way one might expect.
Only after inserting the interpolated <tt>$a99a</tt> and
looking at the resulting full text of the regexp is it
obvious that the backreferences have backfired. The
subexpression <tt>&quot;(\w+)&quot;</tt> has snatched number
1 and demoted the groups in <tt>$a99a</tt> by one rank. This
can be avoided by using relative backreferences:</p>

<pre style="margin-left:11%; margin-top: 1em">    $a99a = '([a&minus;z])(\d)\g{&minus;1}\g{&minus;2}';  # safe for being interpolated</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Named
backreferences</b> <br>
Perl 5.10 also introduced named capture groups and named
backreferences. To attach a name to a capturing group, you
write either <tt>&quot;(?&lt;name&gt;...)&quot;</tt> or
<tt>&quot;(?'name'...)&quot;</tt>. The backreference may
then be written as <tt>&quot;\g{name}&quot;</tt>. It is
permissible to attach the same name to more than one group,
but then only the leftmost one of the eponymous set can be
referenced. Outside of the pattern a named capture group is
accessible through the <tt>&quot;%+&quot;</tt> hash.</p>

<p style="margin-left:11%; margin-top: 1em">Assuming that
we have to match calendar dates which may be given in one of
the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we
can write three suitable patterns where we use
&rsquo;d&rsquo;, &rsquo;m&rsquo; and &rsquo;y&rsquo;
respectively as the names of the groups capturing the
pertaining components of a date. The matching operation
combines the three patterns as alternatives:</p>

<pre style="margin-left:11%; margin-top: 1em">    $fmt1 = '(?&lt;y&gt;\d\d\d\d)&minus;(?&lt;m&gt;\d\d)&minus;(?&lt;d&gt;\d\d)';
    $fmt2 = '(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)';
    $fmt3 = '(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)';
    for my $d qw( 2006&minus;10&minus;21 15.01.2007 10/31/2005 ){
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print &quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;;
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If any of the
alternatives matches, the hash <tt>&quot;%+&quot;</tt> is
bound to contain the three key-value pairs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Alternative
capture group numbering</b> <br>
Yet another capturing group numbering technique (also as
from Perl 5.10) deals with the problem of referring to
groups within a set of alternatives. Consider a pattern for
matching a time of the day, civil or military style:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # process hour and minute
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Processing the
results requires an additional if statement to determine
whether <tt>$1</tt> and <tt>$2</tt> or <tt>$3</tt> and
<tt>$4</tt> contain the goodies. It would be easier if we
could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct
<tt>&quot;(?|...)&quot;</tt>, set around an alternative
achieves. Here is an extended version of the previous
pattern:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A&minus;Z][A&minus;Z][A&minus;Z])/ ){
        print &quot;hour=$1 minute=$2 zone=$3\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Within the
alternative numbering group, group numbers start at the same
position for each alternative. After the group, numbering
continues with one higher than the maximum reached across
all the alternatives.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Position
information</b> <br>
In addition to what was matched, Perl (since 5.6.0) also
provides the positions of what was matched as contents of
the <tt>&quot;@&minus;&quot;</tt> and
<tt>&quot;@+&quot;</tt> arrays.
<tt>&quot;$&minus;[0]&quot;</tt> is the position of the
start of the entire match and <tt>$+[0]</tt> is the position
of the end. Similarly, <tt>&quot;$&minus;[n]&quot;</tt> is
the position of the start of the <tt>$n</tt> match and
<tt>$+[n]</tt> is the position of the end. If <tt>$n</tt> is
undefined, so are <tt>&quot;$&minus;[n]&quot;</tt> and
<tt>$+[n]</tt>. Then this code</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Mmm...donut, thought Homer&quot;;
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # matches
    foreach $expr (1..$#&minus;) {
        print &quot;Match $expr: '${$expr}' at position ($&minus;[$expr],$+[$expr])\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">prints</p>

<pre style="margin-left:11%; margin-top: 1em">    Match 1: 'Mmm' at position (0,3)
    Match 2: 'donut' at position (6,11)</pre>


<p style="margin-left:11%; margin-top: 1em">Even if there
are no groupings in a regexp, it is still possible to find
out what exactly matched in a string. If you use them, Perl
will set <tt>&quot;$`&quot;</tt> to the part of the string
before the match, will set <tt>$&amp;</tt> to the part of
the string that matched, and will set
<tt>&quot;$'&quot;</tt> to the part of the string after the
match. An example:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;the cat caught the mouse&quot;;
    $x =~ /cat/;  # $` = 'the ', $&amp; = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $&amp; = 'the', $' = ' cat caught the mouse'</pre>


<p style="margin-left:11%; margin-top: 1em">In the second
match, <tt>&quot;$`&quot;</tt> equals <tt>''</tt> because
the regexp matched at the first character position in the
string and stopped; it never saw the second
&rsquo;the&rsquo;. It is important to note that using
<tt>&quot;$`&quot;</tt> and <tt>&quot;$'&quot;</tt> slows
down regexp matching quite a bit, while <tt>$&amp;</tt>
slows it down to a lesser extent, because if they are used
in one regexp in a program, they are generated for
<i>all</i> regexps in the program. So if raw performance is
a goal of your application, they should be avoided. If you
need to extract the corresponding substrings, use
<tt>&quot;@&minus;&quot;</tt> and <tt>&quot;@+&quot;</tt>
instead:</p>

<pre style="margin-left:11%; margin-top: 1em">    $` is the same as substr( $x, 0, $&minus;[0] )
    $&amp; is the same as substr( $x, $&minus;[0], $+[0]&minus;$&minus;[0] )
    $' is the same as substr( $x, $+[0] )</pre>


<p style="margin-left:11%; margin-top: 1em">As of Perl
5.10, the <tt>&quot;${^PREMATCH}&quot;</tt>,
<tt>&quot;${^MATCH}&quot;</tt> and
<tt>&quot;${^POSTMATCH}&quot;</tt> variables may be used.
These are only set if the <tt>&quot;/p&quot;</tt> modifier
is present. Consequently they do not penalize the rest of
the program.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Non-capturing
groupings</b> <br>
A group that is required to bundle a set of alternatives may
or may not be useful as a capturing group. If it
isn&rsquo;t, it just creates a superfluous addition to the
set of available capture group values, inside as well as
outside the regexp. Non-capturing groupings, denoted by
<tt>&quot;(?:regexp)&quot;</tt>, still allow the regexp to
be treated as a single unit, but don&rsquo;t establish a
capturing group at the same time. Both capturing and
non-capturing groupings are allowed to co-exist in the same
regexp. Because there is no extraction, non-capturing
groupings are faster than capturing groupings. Non-capturing
groupings are also handy for choosing exactly which parts of
a regexp are to be extracted to matching variables:</p>

<pre style="margin-left:11%; margin-top: 1em">    # match a number, $1&minus;$4 are set, but we only want $1
    /([+&minus;]?\ *(\d+(\.\d*)?|\.\d+)([eE][+&minus;]?\d+)?)/;
    # match a number faster , only $1 is set
    /([+&minus;]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+&minus;]?\d+)?)/;
    # match a number, get $1 = whole number, $2 = exponent
    /([+&minus;]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+&minus;]?\d+))?)/;</pre>


<p style="margin-left:11%; margin-top: 1em">Non-capturing
groupings are also useful for removing nuisance elements
gathered from a split operation where parentheses are
required for some reason:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','a','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Matching
repetitions</b> <br>
The examples in the previous section display an annoying
weakness. We were only matching 3&minus;letter words, or
chunks of words of 4 letters or less. We&rsquo;d like to be
able to match words or, more generally, strings of any
length, without writing out tedious alternatives like
<tt>&quot;\w\w\w\w|\w\w\w|\w\w|\w&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">This is exactly
the problem the <i>quantifier</i> metacharacters
<tt>&quot;?&quot;</tt>, <tt>&quot;*&quot;</tt>,
<tt>&quot;+&quot;</tt>, and <tt>&quot;{}&quot;</tt> were
created for. They allow us to delimit the number of repeats
for a portion of a regexp we consider to be a match.
Quantifiers are put immediately after the character,
character class, or grouping that we want to specify. They
have the following meanings:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;a?&quot;</tt> means:
match &rsquo;a&rsquo; 1 or 0 times</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a*&quot;</tt> means: match &rsquo;a&rsquo; 0
or more times, i.e., any number of times</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a+&quot;</tt> means: match &rsquo;a&rsquo; 1
or more times, i.e., at least once</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n,m}&quot;</tt> means: match at least
<tt>&quot;n&quot;</tt> times, but not more than
<tt>&quot;m&quot;</tt> times.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n,}&quot;</tt> means: match at least
<tt>&quot;n&quot;</tt> or more times</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n}&quot;</tt> means: match exactly
<tt>&quot;n&quot;</tt> times</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    /[a&minus;z]+\s+\d*/;  # match a lowercase word, at least one space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    /y(es)?/i;       # matches 'y', 'Y', or a case&minus;insensitive 'yes'
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/;    # better match; throw out 3&minus;digit dates
    $year =~ /^\d{2}(\d{2})?$/;  # same thing written differently. However,
                                 # this captures the last two digits in $1
                                 # and the other does not.
    % simple_grep '^(\w+)\g1$' /usr/dict/words   # isn't this easier?
    beriberi
    booboo
    coco
    mama
    murmur
    papa</pre>


<p style="margin-left:11%; margin-top: 1em">For all of
these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to
succeed. Thus with <tt>&quot;/a?.../&quot;</tt>, Perl will
first try to match the regexp with the
<tt>&quot;a&quot;</tt> present; if that fails, Perl will try
to match the regexp without the <tt>&quot;a&quot;</tt>
present. For the quantifier <tt>&quot;*&quot;</tt>, we get
the following:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'</pre>


<p style="margin-left:11%; margin-top: 1em">Which is what
we might expect, the match finds the only
<tt>&quot;cat&quot;</tt> in the string and locks onto it.
Consider, however, this regexp:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 characters match)</pre>


<p style="margin-left:11%; margin-top: 1em">One might
initially guess that Perl would find the
<tt>&quot;at&quot;</tt> in <tt>&quot;cat&quot;</tt> and stop
there, but that wouldn&rsquo;t give the longest possible
string to the first quantifier <tt>&quot;.*&quot;</tt>.
Instead, the first quantifier <tt>&quot;.*&quot;</tt> grabs
as much of the string as possible while still having the
regexp match. In this example, that means having the
<tt>&quot;at&quot;</tt> sequence with the final
<tt>&quot;at&quot;</tt> in the string. The other important
principle illustrated here is that, when there are two or
more elements in a regexp, the <i>leftmost</i> quantifier,
if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over
scraps. Thus in our example, the first quantifier
<tt>&quot;.*&quot;</tt> grabs most of the string, while the
second quantifier <tt>&quot;.*&quot;</tt> gets the empty
string. Quantifiers that grab as much of the string as
possible are called <i>maximal match</i> or <i>greedy</i>
quantifiers.</p>

<p style="margin-left:11%; margin-top: 1em">When a regexp
can match a string in several different ways, we can use the
principles above to predict which way the regexp will
match:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Principle 0: Taken as a whole,
any regexp will be matched at the earliest possible position
in the string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Principle 1: In an alternation
<tt>&quot;a|b|c...&quot;</tt>, the leftmost alternative that
allows a match for the whole regexp will be the one
used.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Principle 2: The maximal matching quantifiers
<tt>&quot;?&quot;</tt>, <tt>&quot;*&quot;</tt>,
<tt>&quot;+&quot;</tt> and <tt>&quot;{n,m}&quot;</tt> will
in general match as much of the string as possible while
still allowing the whole regexp to match.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Principle 3: If there are two or more elements in a
regexp, the leftmost greedy quantifier, if any, will match
as much of the string as possible while still allowing the
whole regexp to match. The next leftmost greedy quantifier,
if any, will try to match as much of the string remaining
available to it as possible, while still allowing the whole
regexp to match. And so on, until all the regexp elements
are satisfied.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As we have seen
above, Principle 0 overrides the others. The regexp will be
matched as early as possible, with the other principles
determining how the regexp matches at that earliest
character position.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of these principles in action:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'</pre>


<p style="margin-left:11%; margin-top: 1em">This regexp
matches at the earliest string position, <tt>'T'</tt>. One
might think that <tt>&quot;e&quot;</tt>, being leftmost in
the alternation, would be matched, but
<tt>&quot;r&quot;</tt> produces the longest string in the
first quantifier.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(m{1,2})(.*)$/;  # matches,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">Here, The
earliest possible match is at the first <tt>'m'</tt> in
<tt>&quot;programming&quot;</tt>.
<tt>&quot;m{1,2}&quot;</tt> is the first quantifier, so it
gets to match a maximal <tt>&quot;mm&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /.*(m{1,2})(.*)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">Here, the
regexp matches at the start of the string. The first
quantifier <tt>&quot;.*&quot;</tt> grabs as much as
possible, leaving just a single <tt>'m'</tt> for the second
quantifier <tt>&quot;m{1,2}&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">Here,
<tt>&quot;.?&quot;</tt> eats its maximal one character at
the earliest possible position in the string, <tt>'a'</tt>
in <tt>&quot;programming&quot;</tt>, leaving
<tt>&quot;m{1,2}&quot;</tt> the opportunity to match both
<tt>&quot;m&quot;</tt>&rsquo;s. Finally,</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;aXXXb&quot; =~ /(X*)/; # matches with $1 = ''</pre>


<p style="margin-left:11%; margin-top: 1em">because it can
match zero copies of <tt>'X'</tt> at the beginning of the
string. If you definitely want to match at least one
<tt>'X'</tt>, use <tt>&quot;X+&quot;</tt>, not
<tt>&quot;X*&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes greed
is not good. At times, we would like quantifiers to match a
<i>minimal</i> piece of string, rather than a maximal piece.
For this purpose, Larry Wall created the <i>minimal
match</i> or <i>non-greedy</i> quantifiers
<tt>&quot;??&quot;</tt>, <tt>&quot;*?&quot;</tt>,
<tt>&quot;+?&quot;</tt>, and <tt>&quot;{}?&quot;</tt>. These
are the usual quantifiers with a <tt>&quot;?&quot;</tt>
appended to them. They have the following meanings:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;a??&quot;</tt> means:
match &rsquo;a&rsquo; 0 or 1 times. Try 0 first, then 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a*?&quot;</tt> means: match &rsquo;a&rsquo; 0
or more times, i.e., any number of times, but as few times
as possible</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a+?&quot;</tt> means: match &rsquo;a&rsquo; 1
or more times, i.e., at least once, but as few times as
possible</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n,m}?&quot;</tt> means: match at least
<tt>&quot;n&quot;</tt> times, not more than
<tt>&quot;m&quot;</tt> times, as few times as possible</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n,}?&quot;</tt> means: match at least
<tt>&quot;n&quot;</tt> times, but as few times as
possible</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n}?&quot;</tt> means: match exactly
<tt>&quot;n&quot;</tt> times. Because we match exactly
<tt>&quot;n&quot;</tt> times, <tt>&quot;a{n}?&quot;</tt> is
equivalent to <tt>&quot;a{n}&quot;</tt> and is just there
for notational consistency.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
look at the example above, but with minimal quantifiers:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">The minimal
string that will allow both the start of the string
<tt>&quot;^&quot;</tt> and the alternation to match is
<tt>&quot;Th&quot;</tt>, with the alternation
<tt>&quot;e|r&quot;</tt> matching <tt>&quot;e&quot;</tt>.
The second quantifier <tt>&quot;.*&quot;</tt> is free to
gobble up the rest of the string.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">The first
string position that this regexp can match is at the first
<tt>'m'</tt> in <tt>&quot;programming&quot;</tt>. At this
position, the minimal <tt>&quot;m{1,2}?&quot;</tt> matches
just one <tt>'m'</tt>. Although the second quantifier
<tt>&quot;.*?&quot;</tt> would prefer to match no
characters, it is constrained by the end-of-string anchor
<tt>&quot;$&quot;</tt> to match the rest of the string.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">In this regexp,
you might expect the first minimal quantifier
<tt>&quot;.*?&quot;</tt> to match the empty string, because
it is not constrained by a <tt>&quot;^&quot;</tt> anchor to
match the beginning of the word. Principle 0 applies here,
however. Because it is possible for the whole regexp to
match at the start of the string, it <i>will</i> match at
the start of the string. Thus the first quantifier has to
match everything up to the first <tt>&quot;m&quot;</tt>. The
second minimal quantifier matches just one
<tt>&quot;m&quot;</tt> and the third quantifier matches the
rest of the string.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'</pre>


<p style="margin-left:11%; margin-top: 1em">Just as in the
previous regexp, the first quantifier
<tt>&quot;.??&quot;</tt> can match earliest at position
<tt>'a'</tt>, so it does. The second quantifier is greedy,
so it matches <tt>&quot;mm&quot;</tt>, and the third matches
the rest of the string.</p>

<p style="margin-left:11%; margin-top: 1em">We can modify
principle 3 above to take into account non-greedy
quantifiers:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Principle 3: If there are two or
more elements in a regexp, the leftmost greedy (non-greedy)
quantifier, if any, will match as much (little) of the
string as possible while still allowing the whole regexp to
match. The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string
remaining available to it as possible, while still allowing
the whole regexp to match. And so on, until all the regexp
elements are satisfied.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Just like
alternation, quantifiers are also susceptible to
backtracking. Here is a step-by-step analysis of the
example</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">0</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Start with the first letter in
the string &rsquo;t&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>1</p></td>
<td width="5%"></td>
<td width="83%">


<p>The first quantifier &rsquo;.*&rsquo; starts out by
matching the whole string &rsquo;the cat in the
hat&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>2</p></td>
<td width="5%"></td>
<td width="83%">


<p>&rsquo;a&rsquo; in the regexp element &rsquo;at&rsquo;
doesn&rsquo;t match the end of the string. Backtrack one
character.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>3</p></td>
<td width="5%"></td>
<td width="83%">


<p>&rsquo;a&rsquo; in the regexp element &rsquo;at&rsquo;
still doesn&rsquo;t match the last letter of the string
&rsquo;t&rsquo;, so backtrack one more character.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>4</p></td>
<td width="5%"></td>
<td width="83%">


<p>Now we can match the &rsquo;a&rsquo; and the
&rsquo;t&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>5</p></td>
<td width="5%"></td>
<td width="83%">


<p>Move on to the third element &rsquo;.*&rsquo;. Since we
are at the end of the string and &rsquo;.*&rsquo; can match
0 times, assign it the empty string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>6</p></td>
<td width="5%"></td>
<td width="83%">


<p>We are done!</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Most of the
time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological
regexps, however, whose execution time exponentially grows
with the size of the string. A typical structure that blows
up in your face is of the form</p>

<pre style="margin-left:11%; margin-top: 1em">    /(a|b+)*/;</pre>


<p style="margin-left:11%; margin-top: 1em">The problem is
the nested indeterminate quantifiers. There are many
different ways of partitioning a string of length n between
the <tt>&quot;+&quot;</tt> and <tt>&quot;*&quot;</tt>: one
repetition with <tt>&quot;b+&quot;</tt> of length n, two
repetitions with the first <tt>&quot;b+&quot;</tt> length k
and the second with length n&minus;k, m repetitions whose
bits add up to length n, etc. In fact there are an
exponential number of ways to partition a string as a
function of its length. A regexp may get lucky and match
early in the process, but if there is no match, Perl will
try <i>every</i> possibility before giving up. So be careful
with nested <tt>&quot;*&quot;</tt>&rsquo;s,
<tt>&quot;{n,m}&quot;</tt>&rsquo;s, and
<tt>&quot;+&quot;</tt>&rsquo;s. The book <i>Mastering
Regular Expressions</i> by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Possessive
quantifiers</b> <br>
Backtracking during the relentless search for a match may be
a waste of time, particularly when the match is bound to
fail. Consider the simple pattern</p>

<pre style="margin-left:11%; margin-top: 1em">    /^\w+\s+\w+$/; # a word, spaces, a word</pre>


<p style="margin-left:11%; margin-top: 1em">Whenever this
is applied to a string which doesn&rsquo;t quite meet the
pattern&rsquo;s expectations such as
<tt>&quot;abc&nbsp;&nbsp;&quot;</tt> or
<tt>&quot;abc&nbsp;&nbsp;def&nbsp;&quot;</tt>, the regex
engine will backtrack, approximately once for each character
in the string. But we know that there is no way around
taking <i>all</i> of the initial word characters to match
the first repetition, that <i>all</i> spaces must be eaten
by the middle part, and the same goes for the second
word.</p>

<p style="margin-left:11%; margin-top: 1em">With the
introduction of the <i>possessive quantifiers</i> in Perl
5.10, we have a way of instructing the regex engine not to
backtrack, with the usual quantifiers with a
<tt>&quot;+&quot;</tt> appended to them. This makes them
greedy as well as stingy; once they succeed they won&rsquo;t
give anything back to permit another solution. They have the
following meanings:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;a{n,m}+&quot;</tt>
means: match at least <tt>&quot;n&quot;</tt> times, not more
than <tt>&quot;m&quot;</tt> times, as many times as
possible, and don&rsquo;t give anything up.
<tt>&quot;a?+&quot;</tt> is short for
<tt>&quot;a{0,1}+&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n,}+&quot;</tt> means: match at least
<tt>&quot;n&quot;</tt> times, but as many times as possible,
and don&rsquo;t give anything up. <tt>&quot;a*+&quot;</tt>
is short for <tt>&quot;a{0,}+&quot;</tt> and
<tt>&quot;a++&quot;</tt> is short for
<tt>&quot;a{1,}+&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;a{n}+&quot;</tt> means: match exactly
<tt>&quot;n&quot;</tt> times. It is just there for
notational consistency.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These
possessive quantifiers represent a special case of a more
general concept, the <i>independent subexpression</i>, see
below.</p>

<p style="margin-left:11%; margin-top: 1em">As an example
where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several
programming languages. The backslash is used as an escape
character that indicates that the next character is to be
taken literally, as another character for the string.
Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character
except an unescaped quote or backslash or an escaped
character.</p>

<pre style="margin-left:11%; margin-top: 1em">    /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Building a
regexp</b> <br>
At this point, we have all the basic regexp concepts
covered, so let&rsquo;s give a more involved example of a
regular expression. We will build a regexp that matches
numbers.</p>

<p style="margin-left:11%; margin-top: 1em">The first task
in building a regexp is to decide what we want to match and
what we want to exclude. In our case, we want to match both
integers and floating point numbers and we want to reject
any string that isn&rsquo;t a number.</p>

<p style="margin-left:11%; margin-top: 1em">The next task
is to break the problem down into smaller problems that are
easily converted into a regexp.</p>

<p style="margin-left:11%; margin-top: 1em">The simplest
case is integers. These consist of a sequence of digits,
with an optional sign in front. The digits we can represent
with <tt>&quot;\d+&quot;</tt> and the sign can be matched
with <tt>&quot;[+&minus;]&quot;</tt>. Thus the integer
regexp is</p>

<pre style="margin-left:11%; margin-top: 1em">    /[+&minus;]?\d+/;  # matches integers</pre>


<p style="margin-left:11%; margin-top: 1em">A floating
point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent. One or
more of these parts is optional, so we need to check out the
different possibilities. Floating point numbers which are in
proper form include 123., 0.345, .34, &minus;1e6, and
25.4E&minus;72. As with integers, the sign out front is
completely optional and can be matched by
<tt>&quot;[+&minus;]?&quot;</tt>. We can see that if there
is no exponent, floating point numbers must have a decimal
point, otherwise they are integers. We might be tempted to
model these with <tt>&quot;\d*\.\d*&quot;</tt>, but this
would also match just a single decimal point, which is not a
number. So the three cases of floating point number without
exponent are</p>

<pre style="margin-left:11%; margin-top: 1em">   /[+&minus;]?\d+\./;  # 1., 321., etc.
   /[+&minus;]?\.\d+/;  # .1, .234, etc.
   /[+&minus;]?\d+\.\d+/;  # 1.0, 30.56, etc.</pre>


<p style="margin-left:11%; margin-top: 1em">These can be
combined into a single regexp with a three-way
alternation:</p>

<pre style="margin-left:11%; margin-top: 1em">   /[+&minus;]?(\d+\.\d+|\d+\.|\.\d+)/;  # floating point, no exponent</pre>


<p style="margin-left:11%; margin-top: 1em">In this
alternation, it is important to put <tt>'\d+\.\d+'</tt>
before <tt>'\d+\.'</tt>. If <tt>'\d+\.'</tt> were first, the
regexp would happily match that and ignore the fractional
part of the number.</p>

<p style="margin-left:11%; margin-top: 1em">Now consider
floating point numbers with exponents. The key observation
here is that <i>both</i> integers and numbers with decimal
points are allowed in front of an exponent. Then exponents,
like the overall sign, are independent of whether we are
matching numbers with or without decimal points, and can be
&rsquo;decoupled&rsquo; from the mantissa. The overall form
of the regexp now becomes clear:</p>

<pre style="margin-left:11%; margin-top: 1em">    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;</pre>


<p style="margin-left:11%; margin-top: 1em">The exponent is
an <tt>&quot;e&quot;</tt> or <tt>&quot;E&quot;</tt>,
followed by an integer. So the exponent regexp is</p>

<pre style="margin-left:11%; margin-top: 1em">   /[eE][+&minus;]?\d+/;  # exponent</pre>


<p style="margin-left:11%; margin-top: 1em">Putting all the
parts together, we get a regexp that matches numbers:</p>

<pre style="margin-left:11%; margin-top: 1em">   /^[+&minus;]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+&minus;]?\d+)?$/;  # Ta da!</pre>


<p style="margin-left:11%; margin-top: 1em">Long regexps
like this may impress your friends, but can be hard to
decipher. In complex situations like this, the
<tt>&quot;//x&quot;</tt> modifier for a match is invaluable.
It allows one to put nearly arbitrary whitespace and
comments into a regexp without affecting their meaning.
Using it, we can rewrite our &rsquo;extended&rsquo; regexp
in the more pleasing form</p>

<pre style="margin-left:11%; margin-top: 1em">   /^
      [+&minus;]?         # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+&minus;]?\d+)?  # finally, optionally match an exponent
   $/x;</pre>


<p style="margin-left:11%; margin-top: 1em">If whitespace
is mostly irrelevant, how does one include space characters
in an extended regexp? The answer is to backslash it
<tt>'\&nbsp;'</tt> or put it in a character class
<tt>&quot;[&nbsp;]&quot;</tt>. The same thing goes for pound
signs: use <tt>&quot;\#&quot;</tt> or
<tt>&quot;[#]&quot;</tt>. For instance, Perl allows a space
between the sign and the mantissa or integer, and we could
add this to our regexp as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">   /^
      [+&minus;]?\ *      # first, match an optional sign *and space*
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+&minus;]?\d+)?  # finally, optionally match an exponent
   $/x;</pre>


<p style="margin-left:11%; margin-top: 1em">In this form,
it is easier to see a way to simplify the alternation.
Alternatives 1, 2, and 4 all start with
<tt>&quot;\d+&quot;</tt>, so it could be factored out:</p>

<pre style="margin-left:11%; margin-top: 1em">   /^
      [+&minus;]?\ *      # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ([eE][+&minus;]?\d+)?  # finally, optionally match an exponent
   $/x;</pre>


<p style="margin-left:11%; margin-top: 1em">or written in
the compact form,</p>

<pre style="margin-left:11%; margin-top: 1em">    /^[+&minus;]?\ *(\d+(\.\d*)?|\.\d+)([eE][+&minus;]?\d+)?$/;</pre>


<p style="margin-left:11%; margin-top: 1em">This is our
final regexp. To recap, we built a regexp by</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="69%">


<p style="margin-top: 1em">specifying the task in
detail,</p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="69%">


<p>breaking down the problem into smaller parts,</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="69%">


<p>translating the small parts into regexps,</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="69%">


<p>combining the regexps,</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="69%">


<p>and optimizing the final combined regexp.</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These are also
the typical steps involved in writing a computer program.
This makes perfect sense, because regular expressions are
essentially programs written in a little computer language
that specifies patterns.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
regular expressions in Perl</b> <br>
The last topic of Part 1 briefly covers how regexps are used
in Perl programs. Where do they fit into Perl syntax?</p>

<p style="margin-left:11%; margin-top: 1em">We have already
introduced the matching operator in its default
<tt>&quot;/regexp/&quot;</tt> and arbitrary delimiter
<tt>&quot;m!regexp!&quot;</tt> forms. We have used the
binding operator <tt>&quot;=~&quot;</tt> and its negation
<tt>&quot;!~&quot;</tt> to test for string matches.
Associated with the matching operator, we have discussed the
single line <tt>&quot;//s&quot;</tt>, multi-line
<tt>&quot;//m&quot;</tt>, case-insensitive
<tt>&quot;//i&quot;</tt> and extended
<tt>&quot;//x&quot;</tt> modifiers. There are a few more
things you might want to know about matching operators.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Prohibiting
substitution</i></p>

<p style="margin-left:11%; margin-top: 1em">If you change
<tt>$pattern</tt> after the first substitution happens, Perl
will ignore it. If you don&rsquo;t want any substitutions at
all, use the special delimiter <tt>&quot;m''&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    @pattern = ('Seuss');
    while (&lt;&gt;) {
        print if m'@pattern';  # matches literal '@pattern', not 'Seuss'
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Similar to
strings, <tt>&quot;m''&quot;</tt> acts like apostrophes on a
regexp; all other <tt>&quot;m&quot;</tt> delimiters act like
quotes. If the regexp evaluates to the empty string, the
regexp in the <i>last successful match</i> is used instead.
So we have</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;dog&quot; =~ /d/;  # 'd' matches
    &quot;dogbert =~ //;  # this matches the 'd' regexp used before</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Global
matching</i></p>

<p style="margin-left:11%; margin-top: 1em">The final two
modifiers we will discuss here, <tt>&quot;//g&quot;</tt> and
<tt>&quot;//c&quot;</tt>, concern multiple matches. The
modifier <tt>&quot;//g&quot;</tt> stands for global matching
and allows the matching operator to match within a string as
many times as possible. In scalar context, successive
invocations against a string will have
<tt>&quot;//g&quot;</tt> jump from match to match, keeping
track of position in the string as it goes along. You can
get or set the position with the <tt>&quot;pos()&quot;</tt>
function.</p>

<p style="margin-left:11%; margin-top: 1em">The use of
<tt>&quot;//g&quot;</tt> is shown in the following example.
Suppose we have a string that consists of words separated by
spaces. If we know how many words there are in advance, we
could extract the words using groupings:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;cat dog house&quot;; # 3 words
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # matches,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'</pre>


<p style="margin-left:11%; margin-top: 1em">But what if we
had an indeterminate number of words? This is the sort of
task <tt>&quot;//g&quot;</tt> was made for. To extract all
words, form the simple regexp <tt>&quot;(\w+)&quot;</tt> and
loop over all matches with
<tt>&quot;/(\w+)/g&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    while ($x =~ /(\w+)/g) {
        print &quot;Word is $1, ends at position &quot;, pos $x, &quot;\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">prints</p>

<pre style="margin-left:11%; margin-top: 1em">    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13</pre>


<p style="margin-left:11%; margin-top: 1em">A failed match
or changing the target string resets the position. If you
don&rsquo;t want the position reset after failure to match,
add the <tt>&quot;//c&quot;</tt>, as in
<tt>&quot;/regexp/gc&quot;</tt>. The current position in the
string is associated with the string, not the regexp. This
means that different strings have different positions and
their respective positions can be set or read
independently.</p>

<p style="margin-left:11%; margin-top: 1em">In list
context, <tt>&quot;//g&quot;</tt> returns a list of matched
groupings, or if there are no groupings, a list of matches
to the whole regexp. So if we wanted just the words, we
could use</p>

<pre style="margin-left:11%; margin-top: 1em">    @words = ($x =~ /(\w+)/g);  # matches,
                                # $words[0] = 'cat'
                                # $words[1] = 'dog'
                                # $words[2] = 'house'</pre>


<p style="margin-left:11%; margin-top: 1em">Closely
associated with the <tt>&quot;//g&quot;</tt> modifier is the
<tt>&quot;\G&quot;</tt> anchor. The <tt>&quot;\G&quot;</tt>
anchor matches at the point where the previous
<tt>&quot;//g&quot;</tt> match left off.
<tt>&quot;\G&quot;</tt> allows us to easily do
context-sensitive matching:</p>

<pre style="margin-left:11%; margin-top: 1em">    $metric = 1;  # use metric units
    ...
    $x = &lt;FILE&gt;;  # read in measurement
    $x =~ /^([+&minus;]?\d+)\s*/g;  # get magnitude
    $weight = $1;
    if ($metric) { # error checking
        print &quot;Units error!&quot; unless $x =~ /\Gkg\./g;
    }
    else {
        print &quot;Units error!&quot; unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # continue processing</pre>


<p style="margin-left:11%; margin-top: 1em">The combination
of <tt>&quot;//g&quot;</tt> and <tt>&quot;\G&quot;</tt>
allows us to process the string a bit at a time and use
arbitrary Perl logic to decide what to do next. Currently,
the <tt>&quot;\G&quot;</tt> anchor is only fully supported
when used to anchor to the start of the pattern.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\G&quot;</tt>
is also invaluable in processing fixed-length records with
regexps. Suppose we have a snippet of coding region
<small>DNA</small> , encoded as base pair letters
<tt>&quot;ATCGTTGAAT...&quot;</tt> and we want to find all
the stop codons <tt>&quot;TGA&quot;</tt>. In a coding
region, codons are 3&minus;letter sequences, so we can think
of the <small>DNA</small> snippet as a sequence of
3&minus;letter records. The naive regexp</p>

<pre style="margin-left:11%; margin-top: 1em">    # expanded, this is &quot;ATC GTT GAA TGC AAA TGA CAT GAC&quot;
    $dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;;
    $dna =~ /TGA/;</pre>


<p style="margin-left:11%; margin-top: 1em">doesn&rsquo;t
work; it may match a <tt>&quot;TGA&quot;</tt>, but there is
no guarantee that the match is aligned with codon
boundaries, e.g., the substring
<tt>&quot;GTT&nbsp;GAA&quot;</tt> gives a match. A better
solution is</p>

<pre style="margin-left:11%; margin-top: 1em">    while ($dna =~ /(\w\w\w)*?TGA/g) {  # note the minimal *?
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">which
prints</p>

<pre style="margin-left:11%; margin-top: 1em">    Got a TGA stop codon at position 18
    Got a TGA stop codon at position 23</pre>


<p style="margin-left:11%; margin-top: 1em">Position 18 is
good, but position 23 is bogus. What happened?</p>

<p style="margin-left:11%; margin-top: 1em">The answer is
that our regexp works well until we get past the last real
match. Then the regexp will fail to match a synchronized
<tt>&quot;TGA&quot;</tt> and start stepping ahead one
character position at a time, not what we want. The solution
is to use <tt>&quot;\G&quot;</tt> to anchor the match to the
codon alignment:</p>

<pre style="margin-left:11%; margin-top: 1em">    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">This prints</p>

<pre style="margin-left:11%; margin-top: 1em">    Got a TGA stop codon at position 18</pre>


<p style="margin-left:11%; margin-top: 1em">which is the
correct answer. This example illustrates that it is
important not only to match what is desired, but to reject
what is not desired.</p>

<p style="margin-left:11%; margin-top: 1em">(There are
other regexp modifiers that are available, such as
<tt>&quot;//o&quot;</tt>, but their specialized uses are
beyond the scope of this introduction. )</p>

<p style="margin-left:11%; margin-top: 1em"><i>Search and
replace</i></p>

<p style="margin-left:11%; margin-top: 1em">Regular
expressions also play a big role in <i>search and
replace</i> operations in Perl. Search and replace is
accomplished with the <tt>&quot;s///&quot;</tt> operator.
The general form is
<tt>&quot;s/regexp/replacement/modifiers&quot;</tt>, with
everything we know about regexps and modifiers applying in
this case as well. The <tt>&quot;replacement&quot;</tt> is a
Perl double-quoted string that replaces in the string
whatever is matched with the <tt>&quot;regexp&quot;</tt>.
The operator <tt>&quot;=~&quot;</tt> is also used here to
associate a string with <tt>&quot;s///&quot;</tt>. If
matching against <tt>$_</tt>, the
<tt>&quot;$_&nbsp;=~&quot;</tt> can be dropped. If there is
a match, <tt>&quot;s///&quot;</tt> returns the number of
substitutions made; otherwise it returns false. Here are a
few examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Time to feed the cat!&quot;;
    $x =~ s/cat/hacker/;   # $x contains &quot;Time to feed the hacker!&quot;
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = &quot;'quoted words'&quot;;
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains &quot;quoted words&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">In the last
example, the whole string was matched, but only the part
inside the single quotes was grouped. With the
<tt>&quot;s///&quot;</tt> operator, the matched variables
<tt>$1</tt>, <tt>$2</tt>, etc. are immediately available for
use in the replacement expression, so we use <tt>$1</tt> to
replace the quoted string with just what was quoted. With
the global modifier, <tt>&quot;s///g&quot;</tt> will search
and replace all occurrences of the regexp in the string:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/;   # doesn't do it all:
                       # $x contains &quot;I batted four for 4&quot;
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/g;  # does it all:
                       # $x contains &quot;I batted four for four&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">If you prefer
&rsquo;regex&rsquo; over &rsquo;regexp&rsquo; in this
tutorial, you could use the following program to replace
it:</p>

<pre style="margin-left:11%; margin-top: 1em">    % cat &gt; simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (&lt;&gt;) {
        s/$regexp/$replacement/g;
        print;
    }
    ^D
    % simple_replace regexp regex perlretut.pod</pre>


<p style="margin-left:11%; margin-top: 1em">In
<tt>&quot;simple_replace&quot;</tt> we used the
<tt>&quot;s///g&quot;</tt> modifier to replace all
occurrences of the regexp on each line. (Even though the
regular expression appears in a loop, Perl is smart enough
to compile it only once.) As with
<tt>&quot;simple_grep&quot;</tt>, both the
<tt>&quot;print&quot;</tt> and the
<tt>&quot;s/$regexp/$replacement/g&quot;</tt> use
<tt>$_</tt> implicitly.</p>

<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t want <tt>&quot;s///&quot;</tt> to change your
original variable you can use the non-destructive substitute
modifier, <tt>&quot;s///r&quot;</tt>. This changes the
behavior so that <tt>&quot;s///r&quot;</tt> returns the
final substituted string (instead of the number of
substitutions):</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/dogs/cats/r;
    print &quot;$x $y\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">That example
will print &quot;I like dogs. I like cats&quot;. Notice the
original <tt>$x</tt> variable has not been affected. The
overall result of the substitution is instead stored in
<tt>$y</tt>. If the substitution doesn&rsquo;t affect
anything then the original string is returned:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/elephants/cougars/r;
    print &quot;$x $y\n&quot;; # prints &quot;I like dogs. I like dogs.&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">One other
interesting thing that the <tt>&quot;s///r&quot;</tt> flag
allows is chaining substitutions:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Cats are great.&quot;;
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, &quot;\n&quot;;
    # prints &quot;Hedgehogs are great.&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">A modifier
available specifically to search and replace is the
<tt>&quot;s///e&quot;</tt> evaluation modifier.
<tt>&quot;s///e&quot;</tt> treats the replacement text as
Perl code, rather than a double-quoted string. The value
that the code returns is substituted for the matched
substring. <tt>&quot;s///e&quot;</tt> is useful if you need
to do a bit of computation in the process of replacing text.
This example counts character frequencies in a line:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Bill the cat&quot;;
    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
    print &quot;frequency of '$_' is $chars{$_}\n&quot;
        foreach (sort {$chars{$b} &lt;=&gt; $chars{$a}} keys %chars);</pre>


<p style="margin-left:11%; margin-top: 1em">This prints</p>

<pre style="margin-left:11%; margin-top: 1em">    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1</pre>


<p style="margin-left:11%; margin-top: 1em">As with the
match <tt>&quot;m//&quot;</tt> operator,
<tt>&quot;s///&quot;</tt> can use other delimiters, such as
<tt>&quot;s!!!&quot;</tt> and <tt>&quot;s{}{}&quot;</tt>,
and even <tt>&quot;s{}//&quot;</tt>. If single quotes are
used <tt>&quot;s'''&quot;</tt>, then the regexp and
replacement are treated as single-quoted strings and there
are no variable substitutions. <tt>&quot;s///&quot;</tt> in
list context returns the same thing as in scalar context,
i.e., the number of matches.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The split
function</i></p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;split()&quot;</tt> function is another place where
a regexp is used. <tt>&quot;split /regexp/, string,
limit&quot;</tt> separates the <tt>&quot;string&quot;</tt>
operand into a list of substrings and returns that list. The
regexp must be designed to match whatever constitutes the
separators for the desired substrings. The
<tt>&quot;limit&quot;</tt>, if present, constrains splitting
into no more than <tt>&quot;limit&quot;</tt> number of
strings. For example, to split a string into words, use</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;Calvin and Hobbes&quot;;
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'</pre>


<p style="margin-left:11%; margin-top: 1em">If the empty
regexp <tt>&quot;//&quot;</tt> is used, the regexp always
matches and the string is split into individual characters.
If the regexp has groupings, then the resulting list
contains the matched substrings from the groupings as well.
For instance,</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;/usr/bin/perl&quot;;
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'</pre>


<p style="margin-left:11%; margin-top: 1em">Since the first
character of <tt>$x</tt> matched the regexp,
<tt>&quot;split&quot;</tt> prepended an empty initial
element to the list.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide
range of text processing problems. If this is your first
time through the tutorial, why not stop here and play around
with regexps a while.... Part&nbsp;2 concerns the more
esoteric aspects of regular expressions and those concepts
certainly aren&rsquo;t needed right at the start.</p>

<h2>Part 2: Power tools
<a name="Part 2: Power tools"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>OK</small>
, you know the basics of regexps and you want to know more.
If matching regular expressions is analogous to a walk in
the woods, then the tools discussed in Part 1 are analogous
to topo maps and a compass, basic tools we use all the time.
Most of the tools in part 2 are analogous to flare guns and
satellite phones. They aren&rsquo;t used too often on a
hike, but when we are stuck, they can be invaluable.</p>

<p style="margin-left:11%; margin-top: 1em">What follows
are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps. In Part 2, we will assume you
are comfortable with the basics and concentrate on the
advanced features.</p>

<p style="margin-left:11%; margin-top: 1em"><b>More on
characters, strings, and character classes</b> <br>
There are a number of escape sequences and character classes
that we haven&rsquo;t covered yet.</p>

<p style="margin-left:11%; margin-top: 1em">There are
several escape sequences that convert characters or strings
between upper and lower case, and they are also available
within patterns. <tt>&quot;\l&quot;</tt> and
<tt>&quot;\u&quot;</tt> convert the next character to lower
or upper case, respectively:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;perl&quot;;
    $string =~ /\u$x/;  # matches 'Perl' in $string
    $x = &quot;M(rs?|s)\\.&quot;; # note the double backslash
    $string =~ /\l$x/;  # matches 'mr.', 'mrs.', and 'ms.',</pre>


<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;\L&quot;</tt> or <tt>&quot;\U&quot;</tt> indicates
a lasting conversion of case, until terminated by
<tt>&quot;\E&quot;</tt> or thrown over by another
<tt>&quot;\U&quot;</tt> or <tt>&quot;\L&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;This word is in lower case:\L SHOUT\E&quot;;
    $x =~ /shout/;       # matches
    $x = &quot;I STILL KEYPUNCH CARDS FOR MY 360&quot;
    $x =~ /\Ukeypunch/;  # matches punch card string</pre>


<p style="margin-left:11%; margin-top: 1em">If there is no
<tt>&quot;\E&quot;</tt>, case is converted until the end of
the string. The regexps <tt>&quot;\L\u$word&quot;</tt> or
<tt>&quot;\u\L$word&quot;</tt> convert the first character
of <tt>$word</tt> to uppercase and the rest of the
characters to lowercase.</p>

<p style="margin-left:11%; margin-top: 1em">Control
characters can be escaped with <tt>&quot;\c&quot;</tt>, so
that a control-Z character would be matched with
<tt>&quot;\cZ&quot;</tt>. The escape sequence
<tt>&quot;\Q&quot;</tt>...<tt>&quot;\E&quot;</tt> quotes, or
protects most non-alphabetic characters. For instance,</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;\QThat !^*&amp;%~&amp; cat!&quot;;
    $x =~ /\Q!^*&amp;%~&amp;\E/;  # check for rough language</pre>


<p style="margin-left:11%; margin-top: 1em">It does not
protect <tt>&quot;$&quot;</tt> or <tt>&quot;@&quot;</tt>, so
that variables can still be substituted.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\Q&quot;</tt>,
<tt>&quot;\L&quot;</tt>, <tt>&quot;\l&quot;</tt>,
<tt>&quot;\U&quot;</tt>, <tt>&quot;\u&quot;</tt> and
<tt>&quot;\E&quot;</tt> are actually part of double-quotish
syntax, and not part of regexp syntax proper. They will work
if they appear in a regular expression embedded directly in
a program, but not when contained in a string that is
interpolated in a pattern.</p>

<p style="margin-left:11%; margin-top: 1em">With the advent
of 5.6.0, Perl regexps can handle more than just the
standard <small>ASCII</small> character set. Perl now
supports <i>Unicode</i>, a standard for representing the
alphabets from virtually all of the world&rsquo;s written
languages, and a host of symbols. Perl&rsquo;s text strings
are Unicode strings, so they can contain characters with a
value (codepoint or character number) higher than 255.</p>

<p style="margin-left:11%; margin-top: 1em">What does this
mean for regexps? Well, regexp users don&rsquo;t need to
know much about Perl&rsquo;s internal representation of
strings. But they do need to know 1) how to represent
Unicode characters in a regexp and 2) that a matching
operation will treat the string to be searched as a sequence
of characters, not bytes. The answer to 1) is that Unicode
characters greater than <tt>&quot;chr(255)&quot;</tt> are
represented using the <tt>&quot;\x{hex}&quot;</tt> notation,
because \x hex (without curly braces) doesn&rsquo;t go
further than 255. (Starting in Perl 5.14, if you&rsquo;re an
octal fan, you can also use
<tt>&quot;\o{oct}&quot;</tt>.)</p>

<pre style="margin-left:11%; margin-top: 1em">    /\x{263a}/;  # match a Unicode smiley face :)</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: In Perl 5.6.0 it used to be that one needed to say
<tt>&quot;use utf8&quot;</tt> to use any Unicode features.
This is no more the case: for almost all Unicode processing,
the explicit <tt>&quot;utf8&quot;</tt> pragma is not needed.
(The only case where it matters is if your Perl script is in
Unicode and encoded in <small>UTF&minus;8</small> , then an
explicit <tt>&quot;use utf8&quot;</tt> is needed.)</p>

<p style="margin-left:11%; margin-top: 1em">Figuring out
the hexadecimal sequence of a Unicode character you want or
deciphering someone else&rsquo;s hexadecimal Unicode regexp
is about as much fun as programming in machine code. So
another way to specify Unicode characters is to use the
<i>named character</i> escape sequence
<tt>&quot;\N{</tt><i>name</i><tt>}&quot;</tt>. <i>name</i>
is a name for the Unicode character, as specified in the
Unicode standard. For instance, if we wanted to represent or
match the astrological sign for the planet Mercury, we could
use</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;abc\N{MERCURY}def&quot;;
    $x =~ /\N{MERCURY}/;   # matches</pre>


<p style="margin-left:11%; margin-top: 1em">One can also
use &quot;short&quot; names:</p>

<pre style="margin-left:11%; margin-top: 1em">    print &quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;;
    print &quot;\N{greek:Sigma} is an upper&minus;case sigma.\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
restrict names to a certain alphabet by specifying the
charnames pragma:</p>

<pre style="margin-left:11%; margin-top: 1em">    use charnames qw(greek);
    print &quot;\N{sigma} is Greek sigma\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">An index of
character names is available on-line from the Unicode
Consortium,
&lt;http://www.unicode.org/charts/charindex.html&gt;;
explanatory material with links to other resources at
&lt;http://www.unicode.org/standard/where&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">The answer to
requirement 2) is, as of 5.6.0, that a regexp (mostly) uses
Unicode characters. (The &quot;mostly&quot; is for messy
backward compatibility reasons, but starting in Perl 5.14,
any regex compiled in the scope of a <tt>&quot;use feature
'unicode_strings'&quot;</tt> (which is automatically turned
on within the scope of a <tt>&quot;use 5.012&quot;</tt> or
higher) will turn that &quot;mostly&quot; into
&quot;always&quot;. If you want to handle Unicode properly,
you should ensure that <tt>'unicode_strings'</tt> is turned
on.) Internally, this is encoded to bytes using either
<small>UTF&minus;8</small> or a native 8 bit encoding,
depending on the history of the string, but conceptually it
is a sequence of characters, not bytes. See perlunitut for a
tutorial about that.</p>

<p style="margin-left:11%; margin-top: 1em">Let us now
discuss Unicode character classes. Just as with Unicode
characters, there are named Unicode character classes
represented by the <tt>&quot;\p{name}&quot;</tt> escape
sequence. Closely associated is the
<tt>&quot;\P{name}&quot;</tt> character class, which is the
negation of the <tt>&quot;\p{name}&quot;</tt> class. For
example, to match lower and uppercase characters,</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;BOB&quot;;
    $x =~ /^\p{IsUpper}/;   # matches, uppercase char class
    $x =~ /^\P{IsUpper}/;   # doesn't match, char class sans uppercase
    $x =~ /^\p{IsLower}/;   # doesn't match, lowercase char class
    $x =~ /^\P{IsLower}/;   # matches, char class sans lowercase</pre>


<p style="margin-left:11%; margin-top: 1em">(The
&quot;Is&quot; is optional.)</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
association between some Perl named classes and the
traditional Unicode classes:</p>

<pre style="margin-left:11%; margin-top: 1em">    Perl class name  Unicode class name or regular expression
    IsAlpha          /^[LM]/
    IsAlnum          /^[LMN]/
    IsASCII          $code &lt;= 127
    IsCntrl          /^C/
    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
    IsDigit          Nd
    IsGraph          /^([LMNPS]|Co)/
    IsLower          Ll
    IsPrint          /^([LMNPS]|Co|Zs)/
    IsPunct          /^P/
    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
    IsUpper          /^L[ut]/
    IsWord           /^[LMN]/ || $code eq &quot;005F&quot;
    IsXDigit         $code =~ /^00(3[0&minus;9]|[46][1&minus;6])$/</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
use the official Unicode class names with
<tt>&quot;\p&quot;</tt> and <tt>&quot;\P&quot;</tt>, like
<tt>&quot;\p{L}&quot;</tt> for Unicode
&rsquo;letters&rsquo;, <tt>&quot;\p{Lu}&quot;</tt> for
uppercase letters, or <tt>&quot;\P{Nd}&quot;</tt> for
non-digits. If a <tt>&quot;name&quot;</tt> is just one
letter, the braces can be dropped. For instance,
<tt>&quot;\pM&quot;</tt> is the character class of Unicode
&rsquo;marks&rsquo;, for example accent marks. For the full
list see perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode has
also been separated into various sets of characters which
you can test with <tt>&quot;\p{...}&quot;</tt> (in) and
<tt>&quot;\P{...}&quot;</tt> (not in). To test whether a
character is (or is not) an element of a script you would
use the script name, for example
<tt>&quot;\p{Latin}&quot;</tt>,
<tt>&quot;\p{Greek}&quot;</tt>, or
<tt>&quot;\P{Katakana}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">What we have
described so far is the single form of the
<tt>&quot;\p{...}&quot;</tt> character classes. There is
also a compound form which you may run into. These look like
<tt>&quot;\p{name=value}&quot;</tt> or
<tt>&quot;\p{name:value}&quot;</tt> (the equals sign and
colon can be used interchangeably). These are more general
than the single form, and in fact most of the single forms
are just Perl-defined shortcuts for common compound forms.
For example, the script examples in the previous paragraph
could be written equivalently as
<tt>&quot;\p{Script=Latin}&quot;</tt>,
<tt>&quot;\p{Script:Greek}&quot;</tt>, and
<tt>&quot;\P{script=katakana}&quot;</tt> (case is irrelevant
between the <tt>&quot;{}&quot;</tt> braces). You may never
have to use the compound forms, but sometimes it is
necessary, and their use can make your code easier to
understand.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;\X&quot;</tt>
is an abbreviation for a character class that comprises a
Unicode <i>extended grapheme cluster</i>. This represents a
&quot;logical character&quot;: what appears to be a single
character, but may be represented internally by more than
one. As an example, using the Unicode full names, e.g.,
<tt>&quot;A&nbsp;+&nbsp;COMBINING&nbsp;RING&quot;</tt> is a
grapheme cluster with base character <tt>&quot;A&quot;</tt>
and combining character
<tt>&quot;COMBINING&nbsp;RING&quot;</tt>, which translates
in Danish to A with the circle atop it, as in the word
Angstrom.</p>

<p style="margin-left:11%; margin-top: 1em">For the full
and latest information about Unicode see the latest Unicode
standard, or the Unicode Consortium&rsquo;s website
&lt;http://www.unicode.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">As if all those
classes weren&rsquo;t enough, Perl also defines POSIX-style
character classes. These have the form
<tt>&quot;[:name:]&quot;</tt>, with
<tt>&quot;name&quot;</tt> the name of the
<small>POSIX</small> class. The <small>POSIX</small> classes
are <tt>&quot;alpha&quot;</tt>, <tt>&quot;alnum&quot;</tt>,
<tt>&quot;ascii&quot;</tt>, <tt>&quot;cntrl&quot;</tt>,
<tt>&quot;digit&quot;</tt>, <tt>&quot;graph&quot;</tt>,
<tt>&quot;lower&quot;</tt>, <tt>&quot;print&quot;</tt>,
<tt>&quot;punct&quot;</tt>, <tt>&quot;space&quot;</tt>,
<tt>&quot;upper&quot;</tt>, and <tt>&quot;xdigit&quot;</tt>,
and two extensions, <tt>&quot;word&quot;</tt> (a Perl
extension to match <tt>&quot;\w&quot;</tt>), and
<tt>&quot;blank&quot;</tt> (a <small>GNU</small> extension).
The <tt>&quot;//a&quot;</tt> modifier restricts these to
matching just in the <small>ASCII</small> range; otherwise
they can match the same as their corresponding Perl Unicode
classes: <tt>&quot;[:upper:]&quot;</tt> is the same as
<tt>&quot;\p{IsUpper}&quot;</tt>, etc. (There are some
exceptions and gotchas with this; see perlrecharclass for a
full discussion.) The <tt>&quot;[:digit:]&quot;</tt>,
<tt>&quot;[:word:]&quot;</tt>, and
<tt>&quot;[:space:]&quot;</tt> correspond to the familiar
<tt>&quot;\d&quot;</tt>, <tt>&quot;\w&quot;</tt>, and
<tt>&quot;\s&quot;</tt> character classes. To negate a
<small>POSIX</small> class, put a <tt>&quot;^&quot;</tt> in
front of the name, so that, e.g.,
<tt>&quot;[:^digit:]&quot;</tt> corresponds to
<tt>&quot;\D&quot;</tt> and, under Unicode,
<tt>&quot;\P{IsDigit}&quot;</tt>. The Unicode and
<small>POSIX</small> character classes can be used just like
<tt>&quot;\d&quot;</tt>, with the exception that
<small>POSIX</small> character classes can only be used
inside of a character class:</p>

<pre style="margin-left:11%; margin-top: 1em">    /\s+[abc[:digit:]xyz]\s*/;  # match a,b,c,x,y,z, or a digit
    /^=item\s[[:digit:]]/;      # match '=item',
                                # followed by a space and a digit
    /\s+[abc\p{IsDigit}xyz]\s+/;  # match a,b,c,x,y,z, or a digit
    /^=item\s\p{IsDigit}/;        # match '=item',
                                  # followed by a space and a digit</pre>


<p style="margin-left:11%; margin-top: 1em">Whew! That is
all the rest of the characters and character classes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compiling
and saving regular expressions</b> <br>
In Part 1 we mentioned that Perl compiles a regexp into a
compact sequence of opcodes. Thus, a compiled regexp is a
data structure that can be stored once and used again and
again. The regexp quote <tt>&quot;qr//&quot;</tt> does
exactly that: <tt>&quot;qr/string/&quot;</tt> compiles the
<tt>&quot;string&quot;</tt> as a regexp and transforms the
result into a form that can be assigned to a variable:</p>

<pre style="margin-left:11%; margin-top: 1em">    $reg = qr/foo+bar?/;  # reg contains a compiled regexp</pre>


<p style="margin-left:11%; margin-top: 1em">Then
<tt>$reg</tt> can be used as a regexp:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;fooooba&quot;;
    $x =~ $reg;     # matches, just like /foo+bar?/
    $x =~ /$reg/;   # same thing, alternate form</pre>


<p style="margin-left:11%; margin-top: 1em">$reg can also
be interpolated into a larger regexp:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(abc)?$reg/;  # still matches</pre>


<p style="margin-left:11%; margin-top: 1em">As with the
matching operator, the regexp quote can use different
delimiters, e.g., <tt>&quot;qr!!&quot;</tt>,
<tt>&quot;qr{}&quot;</tt> or <tt>&quot;qr~~&quot;</tt>.
Apostrophes as delimiters (<tt>&quot;qr''&quot;</tt>)
inhibit any interpolation.</p>

<p style="margin-left:11%; margin-top: 1em">Pre-compiled
regexps are useful for creating dynamic matches that
don&rsquo;t need to be recompiled each time they are
encountered. Using pre-compiled regexps, we write a
<tt>&quot;grep_step&quot;</tt> program which greps for a
sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.</p>

<pre style="margin-left:11%; margin-top: 1em">    % cat &gt; grep_step
    #!/usr/bin/perl
    # grep_step &minus; match &lt;number&gt; regexps, one after the other
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number&minus;1);
    @compiled = map qr/$_/, @regexp;
    while ($line = &lt;&gt;) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D
    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;</pre>


<p style="margin-left:11%; margin-top: 1em">Storing
pre-compiled regexps in an array <tt>@compiled</tt> allows
us to simply loop through the regexps without any
recompilation, thus gaining flexibility without sacrificing
speed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Composing
regular expressions at runtime</b> <br>
Backtracking is more efficient than repeated tries with
different regular expressions. If there are several regular
expressions and a match with any of them is acceptable, then
it is possible to combine them into a set of alternatives.
If the individual expressions are input data, this can be
done by programming a join operation. We&rsquo;ll exploit
this idea in an improved version of the
<tt>&quot;simple_grep&quot;</tt> program: a program that
matches multiple patterns:</p>

<pre style="margin-left:11%; margin-top: 1em">    % cat &gt; multi_grep
    #!/usr/bin/perl
    # multi_grep &minus; match any of &lt;number&gt; regexps
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number&minus;1);
    $pattern = join '|', @regexp;
    while ($line = &lt;&gt;) {
        print $line if $line =~ /$pattern/;
    }
    ^D
    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number&minus;1);</pre>


<p style="margin-left:11%; margin-top: 1em">Sometimes it is
advantageous to construct a pattern from the <i>input</i>
that is to be analyzed and use the permissible values on the
left hand side of the matching operations. As an example for
this somewhat paradoxical situation, let&rsquo;s assume that
our input contains a command verb which should match one out
of a set of available command verbs, with the additional
twist that commands may be abbreviated as long as the given
string is unique. The program below demonstrates the basic
algorithm.</p>

<pre style="margin-left:11%; margin-top: 1em">    % cat &gt; keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $command = &lt;&gt; ){
        $command =~ s/^\s+|\s+$//g;  # trim leading and trailing spaces
        if( ( @matches = $kwds =~ /\b$command\w*/g ) == 1 ){
            print &quot;command: '@matches'\n&quot;;
        } elsif( @matches == 0 ){
            print &quot;no such command: '$command'\n&quot;;
        } else {
            print &quot;not unique: '$command' (could be one of: @matches)\n&quot;;
        }
    }
    ^D
    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'</pre>


<p style="margin-left:11%; margin-top: 1em">Rather than
trying to match the input against the keywords, we match the
combined set of keywords against the input. The pattern
matching operation
<tt>&quot;$kwds&nbsp;=~&nbsp;/\b($command\w*)/g&quot;</tt>
does several things at the same time. It makes sure that the
given command begins where a keyword begins
(<tt>&quot;\b&quot;</tt>). It tolerates abbreviations due to
the added <tt>&quot;\w*&quot;</tt>. It tells us the number
of matches (<tt>&quot;scalar @matches&quot;</tt>) and all
the keywords that were actually matched. You could hardly
ask for more.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Embedding
comments and modifiers in a regular expression</b> <br>
Starting with this section, we will be discussing
Perl&rsquo;s set of <i>extended patterns</i>. These are
extensions to the traditional regular expression syntax that
provide powerful new tools for pattern matching. We have
already seen extensions in the form of the minimal matching
constructs <tt>&quot;??&quot;</tt>, <tt>&quot;*?&quot;</tt>,
<tt>&quot;+?&quot;</tt>, <tt>&quot;{n,m}?&quot;</tt>, and
<tt>&quot;{n,}?&quot;</tt>. Most of the extensions below
have the form <tt>&quot;(?char...)&quot;</tt>, where the
<tt>&quot;char&quot;</tt> is a character that determines the
type of extension.</p>

<p style="margin-left:11%; margin-top: 1em">The first
extension is an embedded comment
<tt>&quot;(?#text)&quot;</tt>. This embeds a comment into
the regular expression without affecting its meaning. The
comment should not have any closing parentheses in the text.
An example is</p>

<pre style="margin-left:11%; margin-top: 1em">    /(?# Match an integer:)[+&minus;]?\d+/;</pre>


<p style="margin-left:11%; margin-top: 1em">This style of
commenting has been largely superseded by the raw, freeform
commenting that is allowed with the <tt>&quot;//x&quot;</tt>
modifier.</p>

<p style="margin-left:11%; margin-top: 1em">Most modifiers,
such as <tt>&quot;//i&quot;</tt>, <tt>&quot;//m&quot;</tt>,
<tt>&quot;//s&quot;</tt> and <tt>&quot;//x&quot;</tt> (or
any combination thereof) can also be embedded in a regexp
using <tt>&quot;(?i)&quot;</tt>, <tt>&quot;(?m)&quot;</tt>,
<tt>&quot;(?s)&quot;</tt>, and <tt>&quot;(?x)&quot;</tt>.
For instance,</p>

<pre style="margin-left:11%; margin-top: 1em">    /(?i)yes/;  # match 'yes' case insensitively
    /yes/i;     # same thing
    /(?x)(          # freeform version of an integer regexp
             [+&minus;]?  # match an optional sign
             \d+    # match a sequence of digits
         )
    /x;</pre>


<p style="margin-left:11%; margin-top: 1em">Embedded
modifiers can have two important advantages over the usual
modifiers. Embedded modifiers allow a custom set of
modifiers to <i>each</i> regexp pattern. This is great for
matching an array of regexps that must have different
modifiers:</p>

<pre style="margin-left:11%; margin-top: 1em">    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (&lt;&gt;) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The second
advantage is that embedded modifiers (except
<tt>&quot;//p&quot;</tt>, which modifies the entire regexp)
only affect the regexp inside the group the embedded
modifier is contained in. So grouping can be used to
localize the modifier&rsquo;s effects:</p>

<pre style="margin-left:11%; margin-top: 1em">    /Answer: ((?i)yes)/;  # matches 'Answer: yes', 'Answer: YES', etc.</pre>


<p style="margin-left:11%; margin-top: 1em">Embedded
modifiers can also turn off any modifiers already present by
using, e.g., <tt>&quot;(?&minus;i)&quot;</tt>. Modifiers can
also be combined into a single expression, e.g.,
<tt>&quot;(?s&minus;i)&quot;</tt> turns on single line mode
and turns off case insensitivity.</p>

<p style="margin-left:11%; margin-top: 1em">Embedded
modifiers may also be added to a non-capturing grouping.
<tt>&quot;(?i&minus;m:regexp)&quot;</tt> is a non-capturing
grouping that matches <tt>&quot;regexp&quot;</tt> case
insensitively and turns off multi-line mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Looking
ahead and looking behind</b> <br>
This section concerns the lookahead and lookbehind
assertions. First, a little background.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl regular
expressions, most regexp elements &rsquo;eat up&rsquo; a
certain amount of string when they match. For instance, the
regexp element <tt>&quot;[abc}]&quot;</tt> eats up one
character of the string when it matches, in the sense that
Perl moves to the next character position in the string
after the match. There are some elements, however, that
don&rsquo;t eat up characters (advance the character
position) if they match. The examples we have seen so far
are the anchors. The anchor <tt>&quot;^&quot;</tt> matches
the beginning of the line, but doesn&rsquo;t eat any
characters. Similarly, the word boundary anchor
<tt>&quot;\b&quot;</tt> matches wherever a character
matching <tt>&quot;\w&quot;</tt> is next to a character that
doesn&rsquo;t, but it doesn&rsquo;t eat up any characters
itself. Anchors are examples of <i>zero-width
assertions</i>: zero-width, because they consume no
characters, and assertions, because they test some property
of the string. In the context of our walk in the woods
analogy to regexp matching, most regexp elements move us
along a trail, but anchors have us stop a moment and check
our surroundings. If the local environment checks out, we
can proceed forward. But if the local environment
doesn&rsquo;t satisfy us, we must backtrack.</p>

<p style="margin-left:11%; margin-top: 1em">Checking the
environment entails either looking ahead on the trail,
looking behind, or both. <tt>&quot;^&quot;</tt> looks
behind, to see that there are no characters before.
<tt>&quot;$&quot;</tt> looks ahead, to see that there are no
characters after. <tt>&quot;\b&quot;</tt> looks both ahead
and behind, to see if the characters on either side differ
in their &quot;word-ness&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The lookahead
and lookbehind assertions are generalizations of the anchor
concept. Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.
The lookahead assertion is denoted by
<tt>&quot;(?=regexp)&quot;</tt> and the lookbehind assertion
is denoted by
<tt>&quot;(?&lt;=fixed&minus;regexp)&quot;</tt>. Some
examples are</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;I catch the housecat 'Tom&minus;cat' with catnip&quot;;
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?&lt;=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom&minus;cat'
    $x =~ /(?&lt;=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
parentheses in <tt>&quot;(?=regexp)&quot;</tt> and
<tt>&quot;(?&lt;=regexp)&quot;</tt> are non-capturing, since
these are zero-width assertions. Thus in the second regexp,
the substrings captured are those of the whole regexp
itself. Lookahead <tt>&quot;(?=regexp)&quot;</tt> can match
arbitrary regexps, but lookbehind
<tt>&quot;(?&lt;=fixed&minus;regexp)&quot;</tt> only works
for regexps of fixed width, i.e., a fixed number of
characters long. Thus <tt>&quot;(?&lt;=(ab|bc))&quot;</tt>
is fine, but <tt>&quot;(?&lt;=(ab)*)&quot;</tt> is not. The
negated versions of the lookahead and lookbehind assertions
are denoted by <tt>&quot;(?!regexp)&quot;</tt> and
<tt>&quot;(?&lt;!fixed&minus;regexp)&quot;</tt>
respectively. They evaluate true if the regexps do
<i>not</i> match:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;foobar&quot;;
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?&lt;!\s)foo/;  # matches, there is no \s before 'foo'</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;\C&quot;</tt> is unsupported in lookbehind,
because the already treacherous definition of
<tt>&quot;\C&quot;</tt> would become even more so when going
backwards.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example where a string containing blank-separated words,
numbers and single dashes is to be split into its
components. Using <tt>&quot;/\s+/&quot;</tt> alone
won&rsquo;t work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split
are established by looking ahead and behind:</p>

<pre style="margin-left:11%; margin-top: 1em">    $str = &quot;one two &minus; &minus;&minus;6&minus;8&quot;;
    @toks = split / \s+              # a run of spaces
                  | (?&lt;=\S) (?=&minus;)    # any non&minus;space followed by '&minus;'
                  | (?&lt;=&minus;)  (?=\S)   # a '&minus;' followed by any non&minus;space
                  /x, $str;          # @toks = qw(one two &minus; &minus; &minus; 6 &minus; 8)</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Using
independent subexpressions to prevent backtracking</b>
<i><br>
Independent subexpressions</i> are regular expressions, in
the context of a larger regular expression, that function
independently of the larger regular expression. That is,
they consume as much or as little of the string as they wish
without regard for the ability of the larger regexp to
match. Independent subexpressions are represented by
<tt>&quot;(?&gt;regexp)&quot;</tt>. We can illustrate their
behavior by first considering an ordinary regexp:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;ab&quot;;
    $x =~ /a*ab/;  # matches</pre>


<p style="margin-left:11%; margin-top: 1em">This obviously
matches, but in the process of matching, the subexpression
<tt>&quot;a*&quot;</tt> first grabbed the
<tt>&quot;a&quot;</tt>. Doing so, however, wouldn&rsquo;t
allow the whole regexp to match, so after backtracking,
<tt>&quot;a*&quot;</tt> eventually gave back the
<tt>&quot;a&quot;</tt> and matched the empty string. Here,
what <tt>&quot;a*&quot;</tt> matched was <i>dependent</i> on
what the rest of the regexp matched.</p>

<p style="margin-left:11%; margin-top: 1em">Contrast that
with an independent subexpression:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(?&gt;a*)ab/;  # doesn't match!</pre>


<p style="margin-left:11%; margin-top: 1em">The independent
subexpression <tt>&quot;(?&gt;a*)&quot;</tt> doesn&rsquo;t
care about the rest of the regexp, so it sees an
<tt>&quot;a&quot;</tt> and grabs it. Then the rest of the
regexp <tt>&quot;ab&quot;</tt> cannot match. Because
<tt>&quot;(?&gt;a*)&quot;</tt> is independent, there is no
backtracking and the independent subexpression does not give
up its <tt>&quot;a&quot;</tt>. Thus the match of the regexp
as a whole fails. A similar behavior occurs with completely
independent regexps:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;ab&quot;;
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available</pre>


<p style="margin-left:11%; margin-top: 1em">Here
<tt>&quot;//g&quot;</tt> and <tt>&quot;\G&quot;</tt> create
a &rsquo;tag team&rsquo; handoff of the string from one
regexp to the other. Regexps with an independent
subexpression are much like this, with a handoff of the
string to the independent subexpression, and a handoff of
the string back to the enclosing regexp.</p>

<p style="margin-left:11%; margin-top: 1em">The ability of
an independent subexpression to prevent backtracking can be
quite useful. Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep. Then the
following regexp matches:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;abc(de(fg)h&quot;;  # unbalanced parentheses
    $x =~ /\( ( [^()]+ | \([^()]*\) )+ \)/x;</pre>


<p style="margin-left:11%; margin-top: 1em">The regexp
matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis. The alternation is
two-way, with the first alternative
<tt>&quot;[^()]+&quot;</tt> matching a substring with no
parentheses and the second alternative
<tt>&quot;\([^()]*\)&quot;</tt> matching a substring
delimited by parentheses. The problem with this regexp is
that it is pathological: it has nested indeterminate
quantifiers of the form <tt>&quot;(a+|b)+&quot;</tt>. We
discussed in Part 1 how nested quantifiers like this could
take an exponentially long time to execute if there was no
match possible. To prevent the exponential blowup, we need
to prevent useless backtracking at some point. This can be
done by enclosing the inner quantifier as an independent
subexpression:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /\( ( (?&gt;[^()]+) | \([^()]*\) )+ \)/x;</pre>


<p style="margin-left:11%; margin-top: 1em">Here,
<tt>&quot;(?&gt;[^()]+)&quot;</tt> breaks the degeneracy of
string partitioning by gobbling up as much of the string as
possible and keeping it. Then match failures fail much more
quickly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Conditional
expressions</b> <br>
A <i>conditional expression</i> is a form of if-then-else
statement that allows one to choose which patterns are to be
matched, based on some condition. There are two types of
conditional expression:
<tt>&quot;(?(condition)yes&minus;regexp)&quot;</tt> and
<tt>&quot;(?(condition)yes&minus;regexp|no&minus;regexp)&quot;</tt>.
<tt>&quot;(?(condition)yes&minus;regexp)&quot;</tt> is like
an <tt>'if&nbsp;()&nbsp;{}'</tt> statement in Perl. If the
<tt>&quot;condition&quot;</tt> is true, the
<tt>&quot;yes&minus;regexp&quot;</tt> will be matched. If
the <tt>&quot;condition&quot;</tt> is false, the
<tt>&quot;yes&minus;regexp&quot;</tt> will be skipped and
Perl will move onto the next regexp element. The second form
is like an <tt>'if&nbsp;()&nbsp;{}&nbsp;else&nbsp;{}'</tt>
statement in Perl. If the <tt>&quot;condition&quot;</tt> is
true, the <tt>&quot;yes&minus;regexp&quot;</tt> will be
matched, otherwise the <tt>&quot;no&minus;regexp&quot;</tt>
will be matched.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;condition&quot;</tt> can have several forms. The
first form is simply an integer in parentheses
<tt>&quot;(integer)&quot;</tt>. It is true if the
corresponding backreference <tt>&quot;\integer&quot;</tt>
matched earlier in the regexp. The same thing can be done
with a name associated with a capture group, written as
<tt>&quot;(&lt;name&gt;)&quot;</tt> or
<tt>&quot;('name')&quot;</tt>. The second form is a bare
zero-width assertion <tt>&quot;(?...)&quot;</tt>, either a
lookahead, a lookbehind, or a code assertion (discussed in
the next section). The third set of forms provides tests
that return true if the expression is executed within a
recursion (<tt>&quot;(R)&quot;</tt>) or is being called from
some capturing group, referenced either by number
(<tt>&quot;(R1)&quot;</tt>, <tt>&quot;(R2)&quot;</tt>,...)
or by name (<tt>&quot;(R&amp;name)&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">The integer or
name form of the <tt>&quot;condition&quot;</tt> allows us to
choose, with more flexibility, what to match based on what
matched earlier in the regexp. This searches for words of
the form <tt>&quot;$x$x&quot;</tt> or
<tt>&quot;$x$y$y$x&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    % simple_grep '^(\w+)(\w+)?(?(2)\g2\g1|\g1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu</pre>


<p style="margin-left:11%; margin-top: 1em">The lookbehind
<tt>&quot;condition&quot;</tt> allows, along with
backreferences, an earlier part of the match to influence a
later part of the match. For instance,</p>

<pre style="margin-left:11%; margin-top: 1em">    /[ATGC]+(?(?&lt;=AA)G|C)$/;</pre>


<p style="margin-left:11%; margin-top: 1em">matches a
<small>DNA</small> sequence such that it either ends in
<tt>&quot;AAG&quot;</tt>, or some other base pair
combination and <tt>&quot;C&quot;</tt>. Note that the form
is <tt>&quot;(?(?&lt;=AA)G|C)&quot;</tt> and not
<tt>&quot;(?((?&lt;=AA))G|C)&quot;</tt>; for the lookahead,
lookbehind or code assertions, the parentheses around the
conditional are not needed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Defining
named patterns</b> <br>
Some regular expressions use identical subpatterns in
several places. Starting with Perl 5.10, it is possible to
define named subpatterns in a section of the pattern so that
they can be called up by name anywhere in the pattern. This
syntactic pattern for this definition group is
<tt>&quot;(?(DEFINE)(?&lt;name&gt;pattern)...)&quot;</tt>.
An insertion of a named pattern is written as
<tt>&quot;(?&amp;name)&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The example
below illustrates this feature using the pattern for
floating point numbers that was presented earlier on. The
three subpatterns that are used more than once are the
optional sign, the digit sequence for an integer and the
decimal fraction. The <small>DEFINE</small> group at the end
of the pattern contains their definition. Notice that the
decimal fraction pattern is the first place where we can
reuse the integer pattern.</p>

<pre style="margin-left:11%; margin-top: 1em">   /^ (?&amp;osg)\ * ( (?&amp;int)(?&amp;dec)? | (?&amp;dec) )
      (?: [eE](?&amp;osg)(?&amp;int) )?
    $
    (?(DEFINE)
      (?&lt;osg&gt;[&minus;+]?)         # optional sign
      (?&lt;int&gt;\d++)          # integer
      (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction
    )/x</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Recursive
patterns</b> <br>
This feature (introduced in Perl 5.10) significantly extends
the power of Perl&rsquo;s pattern matching. By referring to
some other capture group anywhere in the pattern with the
construct <tt>&quot;(?group&minus;ref)&quot;</tt>, the
<i>pattern</i> within the referenced group is used as an
independent subpattern in place of the group reference
itself. Because the group reference may be contained
<i>within</i> the group it refers to, it is now possible to
apply pattern matching to tasks that hitherto required a
recursive parser.</p>

<p style="margin-left:11%; margin-top: 1em">To illustrate
this feature, we&rsquo;ll design a pattern that matches if a
string contains a palindrome. (This is a word or a sentence
that, while ignoring spaces, interpunctuation and case,
reads the same backwards as forwards. We begin by observing
that the empty string or a string containing just one word
character is a palindrome. Otherwise it must have a word
character up front and the same at its end, with another
palindrome in between.</p>

<pre style="margin-left:11%; margin-top: 1em">    /(?: (\w) (?...Here be a palindrome...) \g{&minus;1} | \w? )/x</pre>


<p style="margin-left:11%; margin-top: 1em">Adding
<tt>&quot;\W*&quot;</tt> at either end to eliminate what is
to be ignored, we already have the full pattern:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $pp = qr/^(\W* (?: (\w) (?1) \g{&minus;1} | \w? ) \W*)$/ix;
    for $s ( &quot;saippuakauppias&quot;, &quot;A man, a plan, a canal: Panama!&quot; ){
        print &quot;'$s' is a palindrome\n&quot; if $s =~ /$pp/;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">In
<tt>&quot;(?...)&quot;</tt> both absolute and relative
backreferences may be used. The entire pattern can be
reinserted with <tt>&quot;(?R)&quot;</tt> or
<tt>&quot;(?0)&quot;</tt>. If you prefer to name your
groups, you can use <tt>&quot;(?&amp;name)&quot;</tt> to
recurse into that group.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A bit of
magic: executing Perl code in a regular expression</b> <br>
Normally, regexps are a part of Perl expressions. <i>Code
evaluation</i> expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp. A code
evaluation expression is denoted
<tt>&quot;(?{code})&quot;</tt>, with <i>code</i> a string of
Perl statements.</p>

<p style="margin-left:11%; margin-top: 1em">Be warned that
this feature is considered experimental, and may be changed
without notice.</p>

<p style="margin-left:11%; margin-top: 1em">Code
expressions are zero-width assertions, and the value they
return depends on their environment. There are two
possibilities: either the code expression is used as a
conditional in a conditional expression
<tt>&quot;(?(condition)...)&quot;</tt>, or it is not. If the
code expression is a conditional, the code is evaluated and
the result (i.e., the result of the last statement) is used
to determine truth or falsehood. If the code expression is
not used as a conditional, the assertion always evaluates
true and the result is put into the special variable
<tt>$^R</tt>. The variable <tt>$^R</tt> can then be used in
code expressions later in the regexp. Here are some silly
examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;abcdef&quot;;
    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; # doesn't match,
                                         # no 'Hi Mom!'</pre>


<p style="margin-left:11%; margin-top: 1em">Pay careful
attention to the next example:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?</pre>


<p style="margin-left:11%; margin-top: 1em">At first
glance, you&rsquo;d think that it shouldn&rsquo;t print,
because obviously the <tt>&quot;ddd&quot;</tt> isn&rsquo;t
going to match the target string. But look at this
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})[dD]dd/; # doesn't match,
                                            # but _does_ print</pre>


<p style="margin-left:11%; margin-top: 1em">Hmm. What
happened here? If you&rsquo;ve been following along, you
know that the above pattern should be effectively (almost)
the same as the last one; enclosing the
<tt>&quot;d&quot;</tt> in a character class isn&rsquo;t
going to change what it matches. So why does the first not
print while the second one does?</p>

<p style="margin-left:11%; margin-top: 1em">The answer lies
in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside
from the <tt>&quot;?{}&quot;</tt> construct). It&rsquo;s
smart enough to realize that the string &rsquo;ddd&rsquo;
doesn&rsquo;t occur in our target string before actually
running the pattern through. But in the second case,
we&rsquo;ve tricked it into thinking that our pattern is
more complicated. It takes a look, sees our character class,
and decides that it will have to actually run the pattern to
determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that
we don&rsquo;t have a match.</p>

<p style="margin-left:11%; margin-top: 1em">To take a
closer look at how the engine does optimizations, see the
section &quot;Pragmas and debugging&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">More fun with
<tt>&quot;?{}&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x =~ /(?{print &quot;Hi Mom!&quot;;})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print &quot;$c&quot;;})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print &quot;$^R&quot;;})/; # matches,
                                           # prints '1'</pre>


<p style="margin-left:11%; margin-top: 1em">The bit of
magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match. If the
regexp backtracks over a code expression and if the
variables used within are localized using
<tt>&quot;local&quot;</tt>, the changes in the variables
produced by the code expression are undone! Thus, if we
wanted to count how many times a character got matched
inside a group, we could use, e.g.,</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;aaaa&quot;;
    $count = 0;  # initialize 'a' count
    $c = &quot;bob&quot;;  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print &quot;'a' count is $count, \$c variable is '$c'\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">This prints</p>

<pre style="margin-left:11%; margin-top: 1em">    'a' count is 2, $c variable is 'bob'</pre>


<p style="margin-left:11%; margin-top: 1em">If we replace
the
<tt>&quot;&nbsp;(?{local&nbsp;$c&nbsp;=&nbsp;$c&nbsp;+&nbsp;1;})&quot;</tt>
with
<tt>&quot;&nbsp;(?{$c&nbsp;=&nbsp;$c&nbsp;+&nbsp;1;})&quot;</tt>,
the variable changes are <i>not</i> undone during
backtracking, and we get</p>

<pre style="margin-left:11%; margin-top: 1em">    'a' count is 4, $c variable is 'bob'</pre>


<p style="margin-left:11%; margin-top: 1em">Note that only
localized variable changes are undone. Other side effects of
code expression execution are permanent. Thus</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;aaaa&quot;;
    $x =~ /(a(?{print &quot;Yow\n&quot;;}))*aa/;</pre>


<p style="margin-left:11%; margin-top: 1em">produces</p>

<pre style="margin-left:11%; margin-top: 1em">   Yow
   Yow
   Yow
   Yow</pre>


<p style="margin-left:11%; margin-top: 1em">The result
<tt>$^R</tt> is automatically localized, so that it will
behave properly in the presence of backtracking.</p>

<p style="margin-left:11%; margin-top: 1em">This example
uses a code expression in a conditional to match a definite
article, either &rsquo;the&rsquo; in English or
&rsquo;der|die|das&rsquo; in German:</p>

<pre style="margin-left:11%; margin-top: 1em">    $lang = 'DE';  # use German
    ...
    $text = &quot;das&quot;;
    print &quot;matched\n&quot;
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
syntax here is
<tt>&quot;(?(?{...})yes&minus;regexp|no&minus;regexp)&quot;</tt>,
not
<tt>&quot;(?((?{...}))yes&minus;regexp|no&minus;regexp)&quot;</tt>.
In other words, in the case of a code expression, we
don&rsquo;t need the extra parentheses around the
conditional.</p>

<p style="margin-left:11%; margin-top: 1em">If you try to
use code expressions with interpolating variables, Perl may
surprise you:</p>

<pre style="margin-left:11%; margin-top: 1em">    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compile error!
    /foo${pat}bar/;      # compile error!
    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok</pre>


<p style="margin-left:11%; margin-top: 1em">If a regexp has
(1) code expressions and interpolating variables, or (2) a
variable that interpolates a code expression, Perl treats
the regexp as an error. If the code expression is
precompiled into a variable, however, interpolating is ok.
The question is, why is this an error?</p>

<p style="margin-left:11%; margin-top: 1em">The reason is
that variable interpolation and code expressions together
pose a security risk. The combination is dangerous because
many programmers who write search engines often take user
input and plug it directly into a regexp:</p>

<pre style="margin-left:11%; margin-top: 1em">    $regexp = &lt;&gt;;       # read user&minus;supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp</pre>


<p style="margin-left:11%; margin-top: 1em">If the
<tt>$regexp</tt> variable contains a code expression, the
user could then execute arbitrary Perl code. For instance,
some joker could search for
<tt>&quot;system('rm&nbsp;&minus;rf&nbsp;*');&quot;</tt> to
erase your files. In this sense, the combination of
interpolation and code expressions <i>taints</i> your
regexp. So by default, using both interpolation and code
expressions in the same regexp is not allowed. If
you&rsquo;re not concerned about malicious users, it is
possible to bypass this security check by invoking
<tt>&quot;use&nbsp;re&nbsp;'eval'&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ 1 })$bar/;   # compiles ok
    /foo${pat}bar/;      # compiles ok</pre>


<p style="margin-left:11%; margin-top: 1em">Another form of
code expression is the <i>pattern code expression</i>. The
pattern code expression is like a regular code expression,
except that the result of the code evaluation is treated as
a regular expression and matched immediately. A simple
example is</p>

<pre style="margin-left:11%; margin-top: 1em">    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'</pre>


<p style="margin-left:11%; margin-top: 1em">This final
example contains both ordinary and pattern code expressions.
It detects whether a binary string <tt>1101010010001...</tt>
has a Fibonacci spacing 0,1,1,2,3,5,... of the
<tt>1</tt>&rsquo;s:</p>

<pre style="margin-left:11%; margin-top: 1em">    $x = &quot;1101010010001000001&quot;;
    $z0 = ''; $z1 = '0';   # initial conditions
    print &quot;It is a Fibonacci sequence\n&quot;
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
                       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf &quot;Largest sequence matched was %d\n&quot;, length($z1)&minus;length($z0);</pre>


<p style="margin-left:11%; margin-top: 1em">Remember that
<tt>$^N</tt> is set to whatever was matched by the last
completed capture group. This prints</p>

<pre style="margin-left:11%; margin-top: 1em">    It is a Fibonacci sequence
    Largest sequence matched was 5</pre>


<p style="margin-left:11%; margin-top: 1em">Ha! Try that
with your garden variety regexp package...</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
variables <tt>$z0</tt> and <tt>$z1</tt> are not substituted
when the regexp is compiled, as happens for ordinary
variables outside a code expression. Rather, the code
expressions are evaluated when Perl encounters them during
the search for a match.</p>

<p style="margin-left:11%; margin-top: 1em">The regexp
without the <tt>&quot;//x&quot;</tt> modifier is</p>

<pre style="margin-left:11%; margin-top: 1em">    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/</pre>


<p style="margin-left:11%; margin-top: 1em">which shows
that spaces are still possible in the code parts.
Nevertheless, when working with code and conditional
expressions, the extended form of regexps is almost
necessary in creating and debugging regexps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Backtracking
control verbs</b> <br>
Perl 5.10 introduced a number of control verbs intended to
provide detailed control over the backtracking process, by
directly influencing the regexp engine and by providing
monitoring techniques. As all the features in this group are
experimental and subject to change or removal in a future
version of Perl, the interested reader is referred to
&quot;Special Backtracking Control Verbs&quot; in perlre for
a detailed description.</p>

<p style="margin-left:11%; margin-top: 1em">Below is just
one example, illustrating the control verb
<tt>&quot;(*FAIL)&quot;</tt>, which may be abbreviated as
<tt>&quot;(*F)&quot;</tt>. If this is inserted in a regexp
it will cause it to fail, just as it would at some mismatch
between the pattern and the string. Processing of the regexp
continues as it would after any &quot;normal&quot; failure,
so that, for instance, the next position in the string or
another alternative will be tried. As failing to match
doesn&rsquo;t preserve capture groups or produce results, it
may be necessary to use this in combination with embedded
code.</p>

<pre style="margin-left:11%; margin-top: 1em">   %count = ();
   &quot;supercalifragilisticexpialidocious&quot; =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
   printf &quot;%3d '%s'\n&quot;, $count{$_}, $_ for (sort keys %count);</pre>


<p style="margin-left:11%; margin-top: 1em">The pattern
begins with a class matching a subset of letters. Whenever
this matches, a statement like
<tt>&quot;$count{'a'}++;&quot;</tt> is executed,
incrementing the letter&rsquo;s counter. Then
<tt>&quot;(*FAIL)&quot;</tt> does what it says, and the
regexp engine proceeds according to the book: as long as the
end of the string hasn&rsquo;t been reached, the position is
advanced before looking for another vowel. Thus, match or no
match makes no difference, and the regexp engine proceeds
until the entire string has been inspected. (It&rsquo;s
remarkable that an alternative solution using something
like</p>

<pre style="margin-left:11%; margin-top: 1em">   $count{lc($_)}++ for split('', &quot;supercalifragilisticexpialidocious&quot;);
   printf &quot;%3d '%s'\n&quot;, $count2{$_}, $_ for ( qw{ a e i o u } );</pre>


<p style="margin-left:11%; margin-top: 1em">is considerably
slower.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pragmas and
debugging</b> <br>
Speaking of debugging, there are several pragmas available
to control and debug regexps in Perl. We have already
encountered one pragma in the previous section,
<tt>&quot;use&nbsp;re&nbsp;'eval';&quot;</tt>, that allows
variable interpolation and code expressions to coexist in a
regexp. The other pragmas are</p>

<pre style="margin-left:11%; margin-top: 1em">    use re 'taint';
    $tainted = &lt;&gt;;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;taint&quot;</tt> pragma causes any substrings from
a match with a tainted variable to be tainted as well. This
is not normally the case, as regexps are often used to
extract the safe bits from a tainted variable. Use
<tt>&quot;taint&quot;</tt> when you are not extracting safe
bits, but are performing some other processing. Both
<tt>&quot;taint&quot;</tt> and <tt>&quot;eval&quot;</tt>
pragmas are lexically scoped, which means they are in effect
only until the end of the block enclosing the pragmas.</p>

<pre style="margin-left:11%; margin-top: 1em">    use re '/m';  # or any other flags
    $multiline_string =~ /^foo/; # /m is implied</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;re '/flags'&quot;</tt> pragma (introduced in Perl
5.14) turns on the given regular expression flags until the
end of the lexical scope. See &quot;&rsquo;/flags&rsquo;
mode&quot; in re for more detail.</p>

<pre style="margin-left:11%; margin-top: 1em">    use re 'debug';
    /^(.*)$/s;       # output debugging info
    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color</pre>


<p style="margin-left:11%; margin-top: 1em">The global
<tt>&quot;debug&quot;</tt> and
<tt>&quot;debugcolor&quot;</tt> pragmas allow one to get
detailed debugging info about regexp compilation and
execution. <tt>&quot;debugcolor&quot;</tt> is the same as
debug, except the debugging information is displayed in
color on terminals that can display termcap color sequences.
Here is example output:</p>

<pre style="margin-left:11%; margin-top: 1em">    % perl &minus;e 'use re &quot;debug&quot;; &quot;abc&quot; =~ /a*b+c/;'
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;             |  1:  STAR
                               EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;             |  4:    PLUS
                               EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;             |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'</pre>


<p style="margin-left:11%; margin-top: 1em">If you have
gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.
The first part</p>

<pre style="margin-left:11%; margin-top: 1em">    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)</pre>


<p style="margin-left:11%; margin-top: 1em">describes the
compilation stage. <tt>STAR(4)</tt> means that there is a
starred object, in this case <tt>'a'</tt>, and if it
matches, goto line 4, i.e., <tt>PLUS(7)</tt>. The middle
lines describe some heuristics and optimizations performed
before a match:</p>

<pre style="margin-left:11%; margin-top: 1em">    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0</pre>


<p style="margin-left:11%; margin-top: 1em">Then the match
is executed and the remaining lines describe the
process:</p>

<pre style="margin-left:11%; margin-top: 1em">    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;             |  1:  STAR
                               EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;             |  4:    PLUS
                               EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;             |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'</pre>


<p style="margin-left:11%; margin-top: 1em">Each step is of
the form
<tt>&quot;n&nbsp;&lt;x&gt;&nbsp;&lt;y&gt;&quot;</tt>, with
<tt>&quot;&lt;x&gt;&quot;</tt> the part of the string
matched and <tt>&quot;&lt;y&gt;&quot;</tt> the part not yet
matched. The
<tt>&quot;|&nbsp;&nbsp;1:&nbsp;&nbsp;STAR&quot;</tt> says
that Perl is at line number 1 in the compilation list above.
See &quot;Debugging Regular Expressions&quot; in perldebguts
for much more detail.</p>

<p style="margin-left:11%; margin-top: 1em">An alternative
method of debugging regexps is to embed
<tt>&quot;print&quot;</tt> statements within the regexp.
This provides a blow-by-blow account of the backtracking in
an alternation:</p>

<pre style="margin-left:11%; margin-top: 1em">    &quot;that this&quot; =~ m@(?{print &quot;Start at position &quot;, pos, &quot;\n&quot;;})
                     t(?{print &quot;t1\n&quot;;})
                     h(?{print &quot;h1\n&quot;;})
                     i(?{print &quot;i1\n&quot;;})
                     s(?{print &quot;s1\n&quot;;})
                         |
                     t(?{print &quot;t2\n&quot;;})
                     h(?{print &quot;h2\n&quot;;})
                     a(?{print &quot;a2\n&quot;;})
                     t(?{print &quot;t2\n&quot;;})
                     (?{print &quot;Done at position &quot;, pos, &quot;\n&quot;;})
                    @x;</pre>


<p style="margin-left:11%; margin-top: 1em">prints</p>

<pre style="margin-left:11%; margin-top: 1em">    Start at position 0
    t1
    h1
    t2
    h2
    a2
    t2
    Done at position 4</pre>


<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Code
expressions, conditional expressions, and independent
expressions are <i>experimental</i>. Don&rsquo;t use them in
production code. Yet.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is just a
tutorial. For the full story on Perl regular expressions,
see the perlre regular expressions reference page.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information on the matching <tt>&quot;m//&quot;</tt> and
substitution <tt>&quot;s///&quot;</tt> operators, see
&quot;Regexp Quote-Like Operators&quot; in perlop. For
information on the <tt>&quot;split&quot;</tt> operation, see
&quot;split&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">For an
excellent all-around resource on the care and feeding of
regular expressions, see the book <i>Mastering Regular
Expressions</i> by Jeffrey Friedl (published by
O&rsquo;Reilly, <small>ISBN</small>
1556592&minus;257&minus;3).</p>

<h2>AUTHOR AND COPYRIGHT
<a name="AUTHOR AND COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2000 Mark Kvale All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This document
may be distributed under the same terms as Perl itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Acknowledgments</b>
<br>
The inspiration for the stop codon <small>DNA</small>
example came from the <small>ZIP</small> code example in
chapter 7 of <i>Mastering Regular Expressions</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The author
would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their
helpful comments.</p>
<hr>
</body>
</html>
