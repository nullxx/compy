<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:20 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLOBJ</title>

</head>
<body>

<h1 align="center">PERLOBJ</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlobj &minus;
Perl object reference</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
provides a reference for Perl&rsquo;s object orientation
features. If you&rsquo;re looking for an introduction to
object-oriented programming in Perl, please see
perlootut.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
understand Perl objects, you first need to understand
references in Perl. See perlref for details.</p>

<p style="margin-left:11%; margin-top: 1em">This document
describes all of Perl&rsquo;s object-oriented (
<small>OO</small> ) features from the ground up. If
you&rsquo;re just looking to write some object-oriented code
of your own, you are probably better served by using one of
the object systems from <small>CPAN</small> described in
perlootut.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
looking to write your own object system, or you need to
maintain code which implements objects from scratch then
this document will help you understand exactly how Perl does
object orientation.</p>

<p style="margin-left:11%; margin-top: 1em">There are a few
basic principles which define object oriented Perl:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>An object is simply a data structure that knows to which
class it belongs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A class is simply a package. A class provides methods
that expect to operate on objects.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A method is simply a subroutine that expects a reference
to an object (or a package name, for class methods) as the
first argument.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
look at each of these principles in depth.</p>

<p style="margin-left:11%; margin-top: 1em"><b>An Object is
Simply a Data Structure</b> <br>
Unlike many other languages which support object
orientation, Perl does not provide any special syntax for
constructing an object. Objects are merely Perl data
structures (hashes, arrays, scalars, filehandles, etc.) that
have been explicitly associated with a particular class.</p>

<p style="margin-left:11%; margin-top: 1em">That explicit
association is created by the built-in
<tt>&quot;bless&quot;</tt> function, which is typically used
within the <i>constructor</i> subroutine of the class.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
simple constructor:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  sub new {
      my $class = shift;
      return bless {}, $class;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The name
<tt>&quot;new&quot;</tt> isn&rsquo;t special. We could name
our constructor something else:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  sub load {
      my $class = shift;
      return bless {}, $class;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The modern
convention for <small>OO</small> modules is to always use
<tt>&quot;new&quot;</tt> as the name for the constructor,
but there is no requirement to do so. Any subroutine that
blesses a data structure into a class is a valid constructor
in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">In the previous
examples, the <tt>&quot;{}&quot;</tt> code creates a
reference to an empty anonymous hash. The
<tt>&quot;bless&quot;</tt> function then takes that
reference and associates the hash with the class in
<tt>$class</tt>. In the simplest case, the <tt>$class</tt>
variable will end up containing the string
&quot;File&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">We can also use
a variable to store a reference to the data structure that
is being blessed as our object:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
      return $self;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Once
we&rsquo;ve blessed the hash referred to by <tt>$self</tt>
we can start calling methods on it. This is useful if you
want to put object initialization in its own separate
method:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
      $self&minus;&gt;_initialize();
      return $self;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Since the
object is also a hash, you can treat it as one, using it to
store data associated with the object. Typically, code
inside the class can treat the hash as an accessible data
structure, while code outside the class should always treat
the object as opaque. This is called <b>encapsulation</b>.
Encapsulation means that the user of an object does not have
to know how it is implemented. The user simply calls
documented methods on the object.</p>

<p style="margin-left:11%; margin-top: 1em">Note, however,
that (unlike most other <small>OO</small> languages) Perl
does not ensure or enforce encapsulation in any way. If you
want objects to actually <i>be</i> opaque you need to
arrange for that yourself. This can be done in a varierty of
ways, including using &quot;Inside-Out objects&quot; or
modules from <small>CPAN</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><i>Objects Are
Blessed; Variables Are Not</i></p>

<p style="margin-left:11%; margin-top: 1em">When we bless
something, we are not blessing the variable which contains a
reference to that thing, nor are we blessing the reference
that the variable stores; we are blessing the thing that the
variable refers to (sometimes known as the <i>referent</i>).
This is best demonstrated with this code:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Scalar::Util 'blessed';
  my $foo = {};
  my $bar = $foo;
  bless $foo, 'Class';
  print blessed( $bar );      # prints &quot;Class&quot;
  $bar = &quot;some other value&quot;;
  print blessed( $bar );      # prints undef</pre>


<p style="margin-left:11%; margin-top: 1em">When we call
<tt>&quot;bless&quot;</tt> on a variable, we are actually
blessing the underlying data structure that the variable
refers to. We are not blessing the reference itself, nor the
variable that contains that reference. That&rsquo;s why the
second call to <tt>&quot;blessed( $bar )&quot;</tt> returns
false. At that point <tt>$bar</tt> is no longer storing a
reference to an object.</p>

<p style="margin-left:11%; margin-top: 1em">You will
sometimes see older books or documentation mention
&quot;blessing a reference&quot; or describe an object as a
&quot;blessed reference&quot;, but this is incorrect. It
isn&rsquo;t the reference that is blessed as an object;
it&rsquo;s the thing the reference refers to (i.e. the
referent).</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Class is
Simply a Package</b> <br>
Perl does not provide any special syntax for class
definitions. A package is simply a namespace containing
variables and subroutines. The only difference is that in a
class, the subroutines may expect a reference to an object
or the name of a class as the first argument. This is purely
a matter of convention, so a class may contain both methods
and subroutines which <i>don&rsquo;t</i> operate on an
object or class.</p>

<p style="margin-left:11%; margin-top: 1em">Each package
contains a special array called <tt>@ISA</tt>. The
<tt>@ISA</tt> array contains a list of that class&rsquo;s
parent classes, if any. This array is examined when Perl
does method resolution, which we will cover later.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to manually set <tt>@ISA</tt>, and you may see this in older
Perl code. Much older code also uses the base pragma. For
new code, we recommend that you use the parent pragma to
declare your parents. This pragma will take care of setting
<tt>@ISA</tt>. It will also load the parent classes and make
sure that the package doesn&rsquo;t inherit from itself.</p>

<p style="margin-left:11%; margin-top: 1em">However the
parent classes are set, the package&rsquo;s <tt>@ISA</tt>
variable will contain a list of those parents. This is
simply a list of scalars, each of which is a string that
corresponds to a package name.</p>

<p style="margin-left:11%; margin-top: 1em">All classes
inherit from the <small>UNIVERSAL</small> class implicitly.
The <small>UNIVERSAL</small> class is implemented by the
Perl core, and provides several default methods, such as
<tt>&quot;isa()&quot;</tt>, <tt>&quot;can()&quot;</tt>, and
<tt>&quot;VERSION()&quot;</tt>. The
<tt>&quot;UNIVERSAL&quot;</tt> class will <i>never</i>
appear in a package&rsquo;s <tt>@ISA</tt> variable.</p>

<p style="margin-left:11%; margin-top: 1em">Perl
<i>only</i> provides method inheritance as a built-in
feature. Attribute inheritance is left up the class to
implement. See the &quot;Writing Accessors&quot; section for
details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Method is
Simply a Subroutine</b> <br>
Perl does not provide any special syntax for defining a
method. A method is simply a regular subroutine, and is
declared with <tt>&quot;sub&quot;</tt>. What makes a method
special is that it expects to receive either an object or a
class name as its first argument.</p>

<p style="margin-left:11%; margin-top: 1em">Perl
<i>does</i> provide special syntax for method invocation,
the <tt>&quot;&minus;&gt;&quot;</tt> operator. We will cover
this in more detail later.</p>

<p style="margin-left:11%; margin-top: 1em">Most methods
you write will expect to operate on objects:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub save {
      my $self = shift;
      open my $fh, '&gt;', $self&minus;&gt;path() or die $!;
      print {$fh} $self&minus;&gt;data()       or die $!;
      close $fh                       or die $!;
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Method
Invocation</b> <br>
Calling a method on an object is written as
<tt>&quot;$object&minus;&gt;method&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The left hand
side of the method invocation (or arrow) operator is the
object (or class name), and the right hand side is the
method name.</p>

<pre style="margin-left:11%; margin-top: 1em">  my $pod = File&minus;&gt;new( 'perlobj.pod', $data );
  $pod&minus;&gt;save();</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;&minus;&gt;&quot;</tt> syntax is also used when
dereferencing a reference. It looks like the same operator,
but these are two different operations.</p>

<p style="margin-left:11%; margin-top: 1em">When you call a
method, the thing on the left side of the arrow is passed as
the first argument to the method. That means when we call
<tt>&quot;Critter&minus;&gt;new()&quot;</tt>, the
<tt>&quot;new()&quot;</tt> method receives the string
<tt>&quot;Critter&quot;</tt> as its first argument. When we
call <tt>&quot;$fred&minus;&gt;speak()&quot;</tt>, the
<tt>$fred</tt> variable is passed as the first argument to
<tt>&quot;speak()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Just as with
any Perl subroutine, all of the arguments passed in
<tt>@_</tt> are aliases to the original argument. This
includes the object itself. If you assign directly to
<tt>$_[0]</tt> you will change the contents of the variable
that holds the reference to the object. We recommend that
you don&rsquo;t do this unless you know exactly what
you&rsquo;re doing.</p>

<p style="margin-left:11%; margin-top: 1em">Perl knows what
package the method is in by looking at the left side of the
arrow. If the left hand side is a package name, it looks for
the method in that package. If the left hand side is an
object, then Perl looks for the method in the package that
the object has been blessed into.</p>

<p style="margin-left:11%; margin-top: 1em">If the left
hand side is neither a package name nor an object, then the
method call will cause an error, but see the section on
&quot;Method Call Variations&quot; for more nuances.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Inheritance</b>
<br>
We already talked about the special <tt>@ISA</tt> array and
the parent pragma.</p>

<p style="margin-left:11%; margin-top: 1em">When a class
inherits from another class, any methods defined in the
parent class are available to the child class. If you
attempt to call a method on an object that isn&rsquo;t
defined in its own class, Perl will also look for that
method in any parent classes it may have.</p>

<pre style="margin-left:11%; margin-top: 1em">  package File::MP3;
  use parent 'File';    # sets @File::MP3::ISA = ('File');
  my $mp3 = File::MP3&minus;&gt;new( 'Andvari.mp3', $data );
  $mp3&minus;&gt;save();</pre>


<p style="margin-left:11%; margin-top: 1em">Since we
didn&rsquo;t define a <tt>&quot;save()&quot;</tt> method in
the <tt>&quot;File::MP3&quot;</tt> class, Perl will look at
the <tt>&quot;File::MP3&quot;</tt> class&rsquo;s parent
classes to find the <tt>&quot;save()&quot;</tt> method. If
Perl cannot find a <tt>&quot;save()&quot;</tt> method
anywhere in the inheritance hierarchy, it will die.</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
it finds a <tt>&quot;save()&quot;</tt> method in the
<tt>&quot;File&quot;</tt> class. Note that the object passed
to <tt>&quot;save()&quot;</tt> in this case is still a
<tt>&quot;File::MP3&quot;</tt> object, even though the
method is found in the <tt>&quot;File&quot;</tt> class.</p>

<p style="margin-left:11%; margin-top: 1em">We can override
a parent&rsquo;s method in a child class. When we do so, we
can still call the parent class&rsquo;s method with the
<tt>&quot;SUPER&quot;</tt> pseudo-class.</p>

<pre style="margin-left:11%; margin-top: 1em">  sub save {
      my $self = shift;
      say 'Prepare to rock';
      $self&minus;&gt;SUPER::save();
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;SUPER&quot;</tt> modifier can <i>only</i> be used
for method calls. You can&rsquo;t use it for regular
subroutine calls or class methods:</p>

<pre style="margin-left:11%; margin-top: 1em">  SUPER::save($thing);     # FAIL: looks for save() sub in package SUPER
  SUPER&minus;&gt;save($thing);     # FAIL: looks for save() method in class
                           #       SUPER
  $thing&minus;&gt;SUPER::save();   # Okay: looks for save() method in parent
                           #       classes</pre>


<p style="margin-left:11%; margin-top: 1em"><i>How
<small>SUPER</small> is Resolved</i></p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;SUPER&quot;</tt> pseudo-class is resolved from the
package where the call is made. It is <i>not</i> resolved
based on the object&rsquo;s class. This is important,
because it lets methods at different levels within a deep
inheritance hierarchy each correctly call their respective
parent methods.</p>

<pre style="margin-left:11%; margin-top: 1em">  package A;
  sub new {
      return bless {}, shift;
  }
  sub speak {
      my $self = shift;
      $self&minus;&gt;SUPER::speak();
      say 'A';
  }
  package B;
  use parent 'A';
  sub speak {
      my $self = shift;
      $self&minus;&gt;SUPER::speak();
      say 'B';
  }
  package C;
  use parent 'B';
  sub speak {
      my $self = shift;
      $self&minus;&gt;SUPER::speak();
      say 'C';
  }
  my $c = C&minus;&gt;new();
  $c&minus;&gt;speak();</pre>


<p style="margin-left:11%; margin-top: 1em">In this
example, we will get the following output:</p>

<pre style="margin-left:11%; margin-top: 1em">  A
  B
  C</pre>


<p style="margin-left:11%; margin-top: 1em">This
demonstrates how <tt>&quot;SUPER&quot;</tt> is resolved.
Even though the object is blessed into the
<tt>&quot;C&quot;</tt> class, the
<tt>&quot;speak()&quot;</tt> method in the
<tt>&quot;B&quot;</tt> class can still call
<tt>&quot;SUPER::speak()&quot;</tt> and expect it to
correctly look in the parent class of <tt>&quot;B&quot;</tt>
(i.e the class the method call is in), not in the parent
class of <tt>&quot;C&quot;</tt> (i.e. the class the object
belongs to).</p>

<p style="margin-left:11%; margin-top: 1em">There are rare
cases where this package-based resolution can be a problem.
If you copy a subroutine from one package to another,
<tt>&quot;SUPER&quot;</tt> resolution will be done based on
the original package.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Multiple
Inheritance</i></p>

<p style="margin-left:11%; margin-top: 1em">Multiple
inheritance often indicates a design problem, but Perl
always gives you enough rope to hang yourself with if you
ask for it.</p>

<p style="margin-left:11%; margin-top: 1em">To declare
multiple parents, you simply need to pass multiple class
names to <tt>&quot;use parent&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  package MultiChild;
  use parent 'Parent1', 'Parent2';</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Method
Resolution Order</i></p>

<p style="margin-left:11%; margin-top: 1em">Method
resolution order only matters in the case of multiple
inheritance. In the case of single inheritance, Perl simply
looks up the inheritance chain to find a method:</p>

<pre style="margin-left:11%; margin-top: 1em">  Grandparent
    |
  Parent
    |
  Child</pre>


<p style="margin-left:11%; margin-top: 1em">If we call a
method on a <tt>&quot;Child&quot;</tt> object and that
method is not defined in the <tt>&quot;Child&quot;</tt>
class, Perl will look for that method in the
<tt>&quot;Parent&quot;</tt> class and then, if necessary, in
the <tt>&quot;Grandparent&quot;</tt> class.</p>

<p style="margin-left:11%; margin-top: 1em">If Perl cannot
find the method in any of these classes, it will die with an
error message.</p>

<p style="margin-left:11%; margin-top: 1em">When a class
has multiple parents, the method lookup order becomes more
complicated.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Perl does a depth-first left-to-right search for a method.
That means it starts with the first parent in the
<tt>@ISA</tt> array, and then searches all of its parents,
grandparents, etc. If it fails to find the method, it then
goes to the next parent in the original class&rsquo;s
<tt>@ISA</tt> array and searches from there.</p>

<pre style="margin-left:11%; margin-top: 1em">            SharedGreatGrandParent
            /                    \
  PaternalGrandparent       MaternalGrandparent
            \                    /
             Father        Mother
                   \      /
                    Child</pre>


<p style="margin-left:11%; margin-top: 1em">So given the
diagram above, Perl will search <tt>&quot;Child&quot;</tt>,
<tt>&quot;Father&quot;</tt>,
<tt>&quot;PaternalGrandparent&quot;</tt>,
<tt>&quot;SharedGreatGrandParent&quot;</tt>,
<tt>&quot;Mother&quot;</tt>, and finally
<tt>&quot;MaternalGrandparent&quot;</tt>. This may be a
problem because now we&rsquo;re looking in
<tt>&quot;SharedGreatGrandParent&quot;</tt> <i>before</i>
we&rsquo;ve checked all its derived classes (i.e. before we
tried <tt>&quot;Mother&quot;</tt> and
<tt>&quot;MaternalGrandparent&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to ask for a different method resolution order with the mro
pragma.</p>

<pre style="margin-left:11%; margin-top: 1em">  package Child;
  use mro 'c3';
  use parent 'Father', 'Mother';</pre>


<p style="margin-left:11%; margin-top: 1em">This pragma
lets you switch to the &quot;C3&quot; resolution order. In
simple terms, &quot;C3&quot; order ensures that shared
parent classes are never searched before child classes, so
Perl will now search: <tt>&quot;Child&quot;</tt>,
<tt>&quot;Father&quot;</tt>,
<tt>&quot;PaternalGrandparent&quot;</tt>,
<tt>&quot;Mother&quot; &quot;MaternalGrandparent&quot;</tt>,
and finally <tt>&quot;SharedGreatGrandParent&quot;</tt>.
Note however that this is not &quot;breadth-first&quot;
searching: All the <tt>&quot;Father&quot;</tt> ancestors
(except the common ancestor) are searched before any of the
<tt>&quot;Mother&quot;</tt> ancestors are considered.</p>

<p style="margin-left:11%; margin-top: 1em">The C3 order
also lets you call methods in sibling classes with the
<tt>&quot;next&quot;</tt> pseudo-class. See the mro
documentation for more details on this feature.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Method
Resolution Caching</i></p>

<p style="margin-left:11%; margin-top: 1em">When Perl
searches for a method, it caches the lookup so that future
calls to the method do not need to search for it again.
Changing a class&rsquo;s parent class or adding subroutines
to a class will invalidate the cache for that class.</p>

<p style="margin-left:11%; margin-top: 1em">The mro pragma
provides some functions for manipulating the method cache
directly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
Constructors</b> <br>
As we mentioned earlier, Perl provides no special
constructor syntax. This means that a class must implement
its own constructor. A constructor is simply a class method
that returns a reference to a new object.</p>

<p style="margin-left:11%; margin-top: 1em">The constructor
can also accept additional parameters that define the
object. Let&rsquo;s write a real constructor for the
<tt>&quot;File&quot;</tt> class we used earlier:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  sub new {
      my $class = shift;
      my ( $path, $data ) = @_;
      my $self = bless {
          path =&gt; $path,
          data =&gt; $data,
      }, $class;
      return $self;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">As you can see,
we&rsquo;ve stored the path and file data in the object
itself. Remember, under the hood, this object is still just
a hash. Later, we&rsquo;ll write accessors to manipulate
this data.</p>

<p style="margin-left:11%; margin-top: 1em">For our
File::MP3 class, we can check to make sure that the path
we&rsquo;re given ends with &quot;.mp3&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File::MP3;
  sub new {
      my $class = shift;
      my ( $path, $data ) = @_;
      die &quot;You cannot create a File::MP3 without an mp3 extension\n&quot;
          unless $path =~ /\.mp3\z/;
      return $class&minus;&gt;SUPER::new(@_);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This
constructor lets its parent class do the actual object
construction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Attributes</b>
<br>
An attribute is a piece of data belonging to a particular
object. Unlike most object-oriented languages, Perl provides
no special syntax or support for declaring and manipulating
attributes.</p>

<p style="margin-left:11%; margin-top: 1em">Attributes are
often stored in the object itself. For example, if the
object is an anonymous hash, we can store the attribute
values in the hash using the attribute name as the key.</p>

<p style="margin-left:11%; margin-top: 1em">While
it&rsquo;s possible to refer directly to these hash keys
outside of the class, it&rsquo;s considered a best practice
to wrap all access to the attribute with accessor
methods.</p>

<p style="margin-left:11%; margin-top: 1em">This has
several advantages. Accessors make it easier to change the
implementation of an object later while still preserving the
original <small>API</small> .</p>

<p style="margin-left:11%; margin-top: 1em">An accessor
lets you add additional code around attribute access. For
example, you could apply a default to an attribute that
wasn&rsquo;t set in the constructor, or you could validate
that a new value for the attribute is acceptable.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, using
accessors makes inheritance much simpler. Subclasses can use
the accessors rather than having to know how a parent class
is implemented internally.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Writing
Accessors</i></p>

<p style="margin-left:11%; margin-top: 1em">As with
constructors, Perl provides no special accessor declaration
syntax, so classes must provide explicitly written accessor
methods. There are two common types of accessors, read-only
and read-write.</p>

<p style="margin-left:11%; margin-top: 1em">A simple
read-only accessor simply gets the value of a single
attribute:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub path {
      my $self = shift;
      return $self&minus;&gt;{path};
  }</pre>


<p style="margin-left:11%; margin-top: 1em">A read-write
accessor will allow the caller to set the value as well as
get it:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub path {
      my $self = shift;
      if (@_) {
          $self&minus;&gt;{path} = shift;
      }
      return $self&minus;&gt;{path};
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>An Aside
About Smarter and Safer Code</b> <br>
Our constructor and accessors are not very smart. They
don&rsquo;t check that a <tt>$path</tt> is defined, nor do
they check that a <tt>$path</tt> is a valid filesystem
path.</p>

<p style="margin-left:11%; margin-top: 1em">Doing these
checks by hand can quickly become tedious. Writing a bunch
of accessors by hand is also incredibly tedious. There are a
lot of modules on <small>CPAN</small> that can help you
write safer and more concise code, including the modules we
recommend in perlootut.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Method Call
Variations</b> <br>
Perl supports several other ways to call methods besides the
<tt>&quot;$object&minus;&gt;method()&quot;</tt> usage
we&rsquo;ve seen so far.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Method Names
as Strings</i></p>

<p style="margin-left:11%; margin-top: 1em">Perl lets you
use a scalar variable containing a string as a method
name:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $file = File&minus;&gt;new( $path, $data );
  my $method = 'save';
  $file&minus;&gt;$method();</pre>


<p style="margin-left:11%; margin-top: 1em">This works
exactly like calling
<tt>&quot;$file&minus;&gt;save()&quot;</tt>. This can be
very useful for writing dynamic code. For example, it allows
you to pass a method name to be called as a parameter to
another method.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Class Names
as Strings</i></p>

<p style="margin-left:11%; margin-top: 1em">Perl also lets
you use a scalar containing a string as a class name:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $class = 'File';
  my $file = $class&minus;&gt;new( $path, $data );</pre>


<p style="margin-left:11%; margin-top: 1em">Again, this
allows for very dynamic code.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Subroutine
References as Methods</i></p>

<p style="margin-left:11%; margin-top: 1em">You can also
use a subroutine reference as a method:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $sub = sub {
      my $self = shift;
      $self&minus;&gt;save();
  };
  $file&minus;&gt;$sub();</pre>


<p style="margin-left:11%; margin-top: 1em">This is exactly
equivalent to writing
<tt>&quot;$sub&minus;&gt;($file)&quot;</tt>. You may see
this idiom in the wild combined with a call to
<tt>&quot;can&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  if ( my $meth = $object&minus;&gt;can('foo') ) {
      $object&minus;&gt;$meth();
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Deferencing
Method Call</i></p>

<p style="margin-left:11%; margin-top: 1em">Perl also lets
you use a dereferenced scalar reference in a method call.
That&rsquo;s a mouthful, so let&rsquo;s look at some
code:</p>

<pre style="margin-left:11%; margin-top: 1em">  $file&minus;&gt;${ \'save' };
  $file&minus;&gt;${ returns_scalar_ref() };
  $file&minus;&gt;${ \( returns_scalar() ) };
  $file&minus;&gt;${ returns_sub_ref() };</pre>


<p style="margin-left:11%; margin-top: 1em">This works if
the dereference produces a string <i>or</i> a subroutine
reference.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Method Calls
on Filehandles</i></p>

<p style="margin-left:11%; margin-top: 1em">Under the hood,
Perl filehandles are instances of the
<tt>&quot;IO::Handle&quot;</tt> or
<tt>&quot;IO::File&quot;</tt> class. Once you have an open
filehandle, you can call methods on it. Additionally, you
can call methods on the <tt>&quot;STDIN&quot;</tt>,
<tt>&quot;STDOUT&quot;</tt>, and <tt>&quot;STDERR&quot;</tt>
filehandles.</p>

<pre style="margin-left:11%; margin-top: 1em">  open my $fh, '&gt;', 'path/to/file';
  $fh&minus;&gt;autoflush();
  $fh&minus;&gt;print('content');
  STDOUT&minus;&gt;autoflush();</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Invoking
Class Methods</b> <br>
Because Perl allows you to use barewords for package names
and subroutine names, it sometimes interprets a
bareword&rsquo;s meaning incorrectly. For example, the
construct <tt>&quot;Class&minus;&gt;new()&quot;</tt> can be
interpreted as either
<tt>&quot;'Class'&minus;&gt;new()&quot;</tt> or
<tt>&quot;Class()&minus;&gt;new()&quot;</tt>. In English,
that second interpretation reads as &quot;call a subroutine
named <i>Class()</i>, then call <i>new()</i> as a method on
the return value of <i>Class()</i>&quot;. If there is a
subroutine named <tt>&quot;Class()&quot;</tt> in the current
namespace, Perl will always interpret
<tt>&quot;Class&minus;&gt;new()&quot;</tt> as the second
alternative: a call to <tt>&quot;new()&quot;</tt> on the
object returned by a call to
<tt>&quot;Class()&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">You can force
Perl to use the first interpretation (i.e. as a method call
on the class named &quot;Class&quot;) in two ways. First,
you can append a <tt>&quot;::&quot;</tt> to the class
name:</p>

<pre style="margin-left:11%; margin-top: 1em">    Class::&minus;&gt;new()</pre>


<p style="margin-left:11%; margin-top: 1em">Perl will
always interpret this as a method call.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
you can quote the class name:</p>

<pre style="margin-left:11%; margin-top: 1em">    'Class'&minus;&gt;new()</pre>


<p style="margin-left:11%; margin-top: 1em">Of course, if
the class name is in a scalar Perl will do the right thing
as well:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $class = 'Class';
    $class&minus;&gt;new();</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Indirect
Object Syntax</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>Outside of
the file handle case, use of this syntax is discouraged, as
it can confuse the Perl interpreter. See below for more
details.</b></p>

<p style="margin-left:11%; margin-top: 1em">Perl suports
another method invocation syntax called &quot;indirect
object&quot; notation. This syntax is called
&quot;indirect&quot; because the method comes before the
object it is being invoked on.</p>

<p style="margin-left:11%; margin-top: 1em">This syntax can
be used with any class or object method:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $file = new File $path, $data;
    save $file;</pre>


<p style="margin-left:11%; margin-top: 1em">We recommend
that you avoid this syntax, for several reasons.</p>

<p style="margin-left:11%; margin-top: 1em">First, it can
be confusing to read. In the above example, it&rsquo;s not
clear if <tt>&quot;save&quot;</tt> is a method provided by
the <tt>&quot;File&quot;</tt> class or simply a subroutine
that expects a file object as its first argument.</p>

<p style="margin-left:11%; margin-top: 1em">When used with
class methods, the problem is even worse. Because Perl
allows subroutine names to be written as barewords, Perl has
to guess whether the bareword after the method is a class
name or subroutine name. In other words, Perl can resolve
the syntax as either <tt>&quot;File&minus;&gt;new( $path,
$data )&quot;</tt> <b>or</b> <tt>&quot;new( File( $path,
$data ) )&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To parse this
code, Perl uses a heuristic based on what package names it
has seen, what subroutines exist in the current package,
what barewords it has previously seen, and other input.
Needless to say, heuristics can produce very surprising
results!</p>

<p style="margin-left:11%; margin-top: 1em">Older
documentation (and some <small>CPAN</small> modules)
encouraged this syntax, particularly for constructors, so
you may still find it in the wild. However, we encourage you
to avoid using it in new code.</p>

<p style="margin-left:11%; margin-top: 1em">You can force
Perl to interpret the bareword as a class name by appending
&quot;::&quot; to it, like we saw earlier:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $file = new File:: $path, $data;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;bless&quot;,
&quot;blessed&quot;, and &quot;ref&quot;</b> <br>
As we saw earlier, an object is simply a data structure that
has been blessed into a class via the
<tt>&quot;bless&quot;</tt> function. The
<tt>&quot;bless&quot;</tt> function can take either one or
two arguments:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $object = bless {}, $class;
  my $object = bless {};</pre>


<p style="margin-left:11%; margin-top: 1em">In the first
form, the anonymous hash is being blessed into the class in
<tt>$class</tt>. In the second form, the anonymous hash is
blessed into the current package.</p>

<p style="margin-left:11%; margin-top: 1em">The second form
is strongly discouraged, because it breaks the ability of a
subclass to reuse the parent&rsquo;s constructor, but you
may still run across it in existing code.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
know whether a particular scalar refers to an object, you
can use the <tt>&quot;blessed&quot;</tt> function exported
by Scalar::Util, which is shipped with the Perl core.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Scalar::Util 'blessed';
  if ( defined blessed($thing) ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If
<tt>$thing</tt> refers to an object, then this function
returns the name of the package the object has been blessed
into. If <tt>$thing</tt> doesn&rsquo;t contain a reference
to a blessed object, the <tt>&quot;blessed&quot;</tt>
function returns <tt>&quot;undef&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<tt>&quot;blessed($thing)&quot;</tt> will also return false
if <tt>$thing</tt> has been blessed into a class named
&quot;0&quot;. This is a possible, but quite pathological.
Don&rsquo;t create a class named &quot;0&quot; unless you
know what you&rsquo;re doing.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
Perl&rsquo;s built-in <tt>&quot;ref&quot;</tt> function
treats a reference to a blessed object specially. If you
call <tt>&quot;ref($thing)&quot;</tt> and <tt>$thing</tt>
holds a reference to an object, it will return the name of
the class that the object has been blessed into.</p>

<p style="margin-left:11%; margin-top: 1em">If you simply
want to check that a variable contains an object reference,
we recommend that you use <tt>&quot;defined
blessed($object)&quot;</tt>, since <tt>&quot;ref&quot;</tt>
returns true values for all references, not just
objects.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
<small>UNIVERSAL</small> Class</b> <br>
All classes automatically inherit from the
<small>UNIVERSAL</small> class, which is built-in to the
Perl core. This class provides a number of methods, all of
which can be called on either a class or an object. You can
also choose to override some of these methods in your class.
If you do so, we recommend that you follow the built-in
semantics described below. <br>
isa($class)</p>

<p style="margin-left:17%;">The <tt>&quot;isa&quot;</tt>
method returns <i>true</i> if the object is a member of the
class in <tt>$class</tt>, or a member of a subclass of
<tt>$class</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If you override
this method, it should never throw an exception.</p>

<p style="margin-left:11%;"><small>DOES</small> ($role)</p>

<p style="margin-left:17%;">The <tt>&quot;DOES&quot;</tt>
method returns <i>true</i> if its object claims to perform
the role <tt>$role</tt>. By default, this is equivalent to
<tt>&quot;isa&quot;</tt>. This method is provided for use by
object system extensions that implement roles, like
<tt>&quot;Moose&quot;</tt> and
<tt>&quot;Role::Tiny&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
override <tt>&quot;DOES&quot;</tt> directly in your own
classes. If you override this method, it should never throw
an exception.</p>

<p style="margin-left:11%;">can($method)</p>

<p style="margin-left:17%;">The <tt>&quot;can&quot;</tt>
method checks to see if the class or object it was called on
has a method named <tt>$method</tt>. This checks for the
method in the class and all of its parents. If the method
exists, then a reference to the subroutine is returned. If
it does not then <tt>&quot;undef&quot;</tt> is returned.</p>

<p style="margin-left:17%; margin-top: 1em">If your class
responds to method calls via <tt>&quot;AUTOLOAD&quot;</tt>,
you may want to overload <tt>&quot;can&quot;</tt> to return
a subroutine reference for methods which your
<tt>&quot;AUTOLOAD&quot;</tt> method handles.</p>

<p style="margin-left:17%; margin-top: 1em">If you override
this method, it should never throw an exception.</p>

<p style="margin-left:11%;"><small>VERSION</small>
($need)</p>

<p style="margin-left:17%;">The
<tt>&quot;VERSION&quot;</tt> method returns the version
number of the class (package).</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>$need</tt> argument is given then it will check that the
current version (as defined by the <tt>$VERSION</tt>
variable in the package) is greater than or equal to
<tt>$need</tt>; it will die if this is not the case. This
method is called automatically by the
<tt>&quot;VERSION&quot;</tt> form of
<tt>&quot;use&quot;</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">    use Package 1.2 qw(some imported subs);
    # implies:
    Package&minus;&gt;VERSION(1.2);</pre>


<p style="margin-left:17%; margin-top: 1em">We recommend
that you use this method to access another package&rsquo;s
version, rather than looking directly at
<tt>$Package::VERSION</tt>. The package you are looking at
could have overridden the <tt>&quot;VERSION&quot;</tt>
method.</p>

<p style="margin-left:17%; margin-top: 1em">We also
recommend using this method to check whether a module has a
sufficient version. The internal implementation uses the
version module to make sure that different types of version
numbers are compared correctly.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>AUTOLOAD</small></b>
<br>
If you call a method that doesn&rsquo;t exist in a class,
Perl will throw an error. However, if that class or any of
its parent classes defines an <tt>&quot;AUTOLOAD&quot;</tt>
method, that <tt>&quot;AUTOLOAD&quot;</tt> method is called
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;AUTOLOAD&quot;</tt>
is called as a regular method, and the caller will not know
the difference. Whatever value your
<tt>&quot;AUTOLOAD&quot;</tt> method returns is returned to
the caller.</p>

<p style="margin-left:11%; margin-top: 1em">The fully
qualified method name that was called is available in the
<tt>$AUTOLOAD</tt> package global for your class. Since this
is a global, if you want to refer to do it without a package
name prefix under <tt>&quot;strict 'vars'&quot;</tt>, you
need to declare it.</p>

<pre style="margin-left:11%; margin-top: 1em">  # XXX &minus; this is a terrible way to implement accessors, but it makes
  # for a simple example.
  our $AUTOLOAD;
  sub AUTOLOAD {
      my $self = shift;
      # Remove qualifier from original method name...
      my $called =  $AUTOLOAD =~ s/.*:://r;
      # Is there an attribute of that name?
      die &quot;No such attribute: $called&quot;
          unless exists $self&minus;&gt;{$called};
      # If so, return it...
      return $self&minus;&gt;{$called};
  }
  sub DESTROY { } # see below</pre>


<p style="margin-left:11%; margin-top: 1em">Without the
<tt>&quot;our $AUTOLOAD&quot;</tt> declaration, this code
will not compile under the strict pragma.</p>

<p style="margin-left:11%; margin-top: 1em">As the comment
says, this is not a good way to implement accessors.
It&rsquo;s slow and too clever by far. However, you may see
this as a way to provide accessors in older Perl code. See
perlootut for recommendations on <small>OO</small> coding in
Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If your class
does have an <tt>&quot;AUTOLOAD&quot;</tt> method, we
strongly recommend that you override
<tt>&quot;can&quot;</tt> in your class as well. Your
overridden <tt>&quot;can&quot;</tt> method should return a
subroutine reference for any method that your
<tt>&quot;AUTOLOAD&quot;</tt> responds to.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Destructors</b>
<br>
When the last reference to an object goes away, the object
is destroyed. If you only have one reference to an object
stored in a lexical scalar, the object is destroyed when
that scalar goes out of scope. If you store the object in a
package global, that object may not go out of scope until
the program exits.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
do something when the object is destroyed, you can define a
<tt>&quot;DESTROY&quot;</tt> method in your class. This
method will always be called by Perl at the appropriate
time, unless the method is empty.</p>

<p style="margin-left:11%; margin-top: 1em">This is called
just like any other method, with the object as the first
argument. It does not receive any additional arguments.
However, the <tt>$_[0]</tt> variable will be read-only in
the destructor, so you cannot assign a value to it.</p>

<p style="margin-left:11%; margin-top: 1em">If your
<tt>&quot;DESTROY&quot;</tt> method throws an error, this
error will be ignored. It will not be sent to
<tt>&quot;STDERR&quot;</tt> and it will not cause the
program to die. However, if your destructor is running
inside an <tt>&quot;eval {}&quot;</tt> block, then the error
will change the value of <tt>$@</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Because
<tt>&quot;DESTROY&quot;</tt> methods can be called at any
time, you should localize any global variables you might
update in your <tt>&quot;DESTROY&quot;</tt>. In particular,
if you use <tt>&quot;eval {}&quot;</tt> you should localize
<tt>$@</tt>, and if you use <tt>&quot;system&quot;</tt> or
backticks, you should localize <tt>$?</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you define
an <tt>&quot;AUTOLOAD&quot;</tt> in your class, then Perl
will call your <tt>&quot;AUTOLOAD&quot;</tt> to handle the
<tt>&quot;DESTROY&quot;</tt> method. You can prevent this by
defining an empty <tt>&quot;DESTROY&quot;</tt>, like we did
in the autoloading example. You can also check the value of
<tt>$AUTOLOAD</tt> and return without doing anything when
called to handle <tt>&quot;DESTROY&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Global
Destruction</i></p>

<p style="margin-left:11%; margin-top: 1em">The order in
which objects are destroyed during the global destruction
before the program exits is unpredictable. This means that
any objects contained by your object may already have been
destroyed. You should check that a contained object is
defined before calling a method on it:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub DESTROY {
      my $self = shift;
      $self&minus;&gt;{handle}&minus;&gt;close() if $self&minus;&gt;{handle};
  }</pre>


<p style="margin-left:11%; margin-top: 1em">You can use the
<tt>&quot;${^GLOBAL_PHASE}&quot;</tt> variable to detect if
you are currently in the global destruction phase:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub DESTROY {
      my $self = shift;
      return if ${^GLOBAL_PHASE} eq 'DESTRUCT';
      $self&minus;&gt;{handle}&minus;&gt;close();
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that this
variable was added in Perl 5.14.0. If you want to detect the
global destruction phase on older versions of Perl, you can
use the <tt>&quot;Devel::GlobalDestruction&quot;</tt> module
on <small>CPAN</small> .</p>

<p style="margin-left:11%; margin-top: 1em">If your
<tt>&quot;DESTROY&quot;</tt> method issues a warning during
global destruction, the Perl interpreter will append the
string &quot; during global destruction&quot; the
warning.</p>

<p style="margin-left:11%; margin-top: 1em">During global
destruction, Perl will always garbage collect objects before
unblessed references. See &quot;
<small>PERL_DESTRUCT_LEVEL</small> &quot; in perlhacktips
for more information about global destruction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Non-Hash
Objects</b> <br>
All the examples so far have shown objects based on a
blessed hash. However, it&rsquo;s possible to bless any type
of data structure or referent, including scalars, globs, and
subroutines. You may see this sort of thing when looking at
code in the wild.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example of a module as a blessed scalar:</p>

<pre style="margin-left:11%; margin-top: 1em">  package Time;
  use strict;
  use warnings;
  sub new {
      my $class = shift;
      my $time = time;
      return bless \$time, $class;
  }
  sub epoch {
      my $self = shift;
      return ${ $self };
  }
  my $time = Time&minus;&gt;new();
  print $time&minus;&gt;epoch();</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Inside-Out
objects</b> <br>
In the past, the Perl community experimented with a
technique called &quot;inside-out objects&quot;. An
inside-out object stores its data outside of the
object&rsquo;s reference, indexed on a unique property of
the object, such as its memory address, rather than in the
object itself. This has the advantage of enforcing the
encapsulation of object attributes, since their data is not
stored in the object itself.</p>

<p style="margin-left:11%; margin-top: 1em">This technique
was popular for a while (and was recommended in Damian
Conway&rsquo;s <i>Perl Best Practices</i>), but never
achieved universal adoption. The Object::InsideOut module on
<small>CPAN</small> provides a comprehensive implementation
of this technique, and you may see it or other inside-out
modules in the wild.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
simple example of the technique, using the
Hash::Util::FieldHash core module. This module was added to
the core to support inside-out object implementations.</p>

<pre style="margin-left:11%; margin-top: 1em">  package Time;
  use strict;
  use warnings;
  use Hash::Util::FieldHash 'fieldhash';
  fieldhash my %time_for;
  sub new {
      my $class = shift;
      my $self = bless \( my $object ), $class;
      $time_for{$self} = time;
      return $self;
  }
  sub epoch {
      my $self = shift;
      return $time_for{$self};
  }
  my $time = Time&minus;&gt;new;
  print $time&minus;&gt;epoch;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Pseudo-hashes</b>
<br>
The pseudo-hash feature was an experimental feature
introduced in earlier versions of Perl and removed in
5.10.0. A pseudo-hash is an array reference which can be
accessed using named keys like a hash. You may run in to
some code in the wild which uses it. See the fields pragma
for more information.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A kinder,
gentler tutorial on object-oriented programming in Perl can
be found in perlootut. You should also check out perlmodlib
for some style guides on constructing both modules and
classes.</p>
<hr>
</body>
</html>
