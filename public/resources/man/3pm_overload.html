<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:51 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>overload</title>

</head>
<body>

<h1 align="center">overload</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#IMPLEMENTATION">IMPLEMENTATION</a><br>
<a href="#COOKBOOK">COOKBOOK</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#BUGS AND PITFALLS">BUGS AND PITFALLS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">overload
&minus; Package for overloading Perl operations</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    package SomeThing;
    use overload
        '+' =&gt; \&amp;myadd,
        '&minus;' =&gt; \&amp;mysub;
        # etc
    ...
    package main;
    $a = SomeThing&minus;&gt;new( 57 );
    $b = 5 + $a;
    ...
    if (overload::Overloaded $b) {...}
    ...
    $strval = overload::StrVal $b;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This pragma
allows overloading of Perl&rsquo;s operators for a class. To
overload built-in functions, see &quot;Overriding Built-in
Functions&quot; in perlsub instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Fundamentals</b>
<i><br>
Declaration</i></p>

<p style="margin-left:11%; margin-top: 1em">Arguments of
the <tt>&quot;use overload&quot;</tt> directive are (key,
value) pairs. For the full set of legal keys, see
&quot;Overloadable Operations&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">Operator
implementations (the values) can be subroutines, references
to subroutines, or anonymous subroutines &minus; in other
words, anything legal inside a <tt>&quot;&amp;{ ...
}&quot;</tt> call. Values specified as strings are
interpreted as method names. Thus</p>

<pre style="margin-left:11%; margin-top: 1em">    package Number;
    use overload
        &quot;&minus;&quot; =&gt; &quot;minus&quot;,
        &quot;*=&quot; =&gt; \&amp;muas,
        '&quot;&quot;' =&gt; sub { ...; };</pre>


<p style="margin-left:11%; margin-top: 1em">declares that
subtraction is to be implemented by method
<tt>&quot;minus()&quot;</tt> in the class
<tt>&quot;Number&quot;</tt> (or one of its base classes),
and that the function <tt>&quot;Number::muas()&quot;</tt> is
to be used for the assignment form of multiplication,
<tt>&quot;*=&quot;</tt>. It also defines an anonymous
subroutine to implement stringification: this is called
whenever an object blessed into the package
<tt>&quot;Number&quot;</tt> is used in a string context
(this subroutine might, for example, return the number as a
Roman numeral).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Calling
Conventions and Magic Autogeneration</i></p>

<p style="margin-left:11%; margin-top: 1em">The following
sample implementation of <tt>&quot;minus()&quot;</tt> (which
assumes that <tt>&quot;Number&quot;</tt> objects are simply
blessed references to scalars) illustrates the calling
conventions:</p>

<pre style="margin-left:11%; margin-top: 1em">    package Number;
    sub minus {
        my ($self, $other, $swap) = @_;
        my $result = $$self &minus; $other;         # *
        $result = &minus;$result if $swap;
        ref $result ? $result : bless \$result;
    }
    # * may recurse once &minus; see table below</pre>


<p style="margin-left:11%; margin-top: 1em">Three arguments
are passed to all subroutines specified in the <tt>&quot;use
overload&quot;</tt> directive (with one exception &minus;
see &quot;nomethod&quot;). The first of these is the operand
providing the overloaded operator implementation &minus; in
this case, the object whose <tt>&quot;minus()&quot;</tt>
method is being called.</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument is the other operand, or <tt>&quot;undef&quot;</tt>
in the case of a unary operator.</p>

<p style="margin-left:11%; margin-top: 1em">The third
argument is set to <small>TRUE</small> if (and only if) the
two operands have been swapped. Perl may do this to ensure
that the first argument (<tt>$self</tt>) is an object
implementing the overloaded operation, in line with general
object calling conventions. For example, if <tt>$x</tt> and
<tt>$y</tt> are <tt>&quot;Number&quot;</tt>s:</p>

<pre style="margin-left:11%; margin-top: 1em">    operation   |   generates a call to
    ============|======================
    $x &minus; $y     |   minus($x, $y, '')
    $x &minus; 7      |   minus($x, 7, '')
    7 &minus; $x      |   minus($x, 7, 1)</pre>


<p style="margin-left:11%; margin-top: 1em">Perl may also
use <tt>&quot;minus()&quot;</tt> to implement other
operators which have not been specified in the <tt>&quot;use
overload&quot;</tt> directive, according to the rules for
&quot;Magic Autogeneration&quot; described later. For
example, the <tt>&quot;use overload&quot;</tt> above
declared no subroutine for any of the operators
<tt>&quot;&minus;&minus;&quot;</tt>,
<tt>&quot;neg&quot;</tt> (the overload key for unary minus),
or <tt>&quot;&minus;=&quot;</tt>. Thus</p>

<pre style="margin-left:11%; margin-top: 1em">    operation   |   generates a call to
    ============|======================
    &minus;$x         |   minus($x, 0, 1)
    $x&minus;&minus;        |   minus($x, 1, undef)
    $x &minus;= 3     |   minus($x, 3, undef)</pre>


<p style="margin-left:11%; margin-top: 1em">Note the
<tt>&quot;undef&quot;</tt>s: where autogeneration results in
the method for a standard operator which does not change
either of its operands, such as
<tt>&quot;&minus;&quot;</tt>, being used to implement an
operator which changes the operand (&quot;mutators&quot;:
here, <tt>&quot;&minus;&minus;&quot;</tt> and
<tt>&quot;&minus;=&quot;</tt>), Perl passes undef as the
third argument. This still evaluates as <small>FALSE</small>
, consistent with the fact that the operands have not been
swapped, but gives the subroutine a chance to alter its
behaviour in these cases.</p>

<p style="margin-left:11%; margin-top: 1em">In all the
above examples, <tt>&quot;minus()&quot;</tt> is required
only to return the result of the subtraction: Perl takes
care of the assignment to <tt>$x</tt>. In fact, such methods
should <i>not</i> modify their operands, even if
<tt>&quot;undef&quot;</tt> is passed as the third argument
(see &quot;Overloadable Operations&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The same is not
true of implementations of <tt>&quot;++&quot;</tt> and
<tt>&quot;&minus;&minus;&quot;</tt>: these are expected to
modify their operand. An appropriate implementation of
<tt>&quot;&minus;&minus;&quot;</tt> might look like</p>

<pre style="margin-left:11%; margin-top: 1em">    use overload '&minus;&minus;' =&gt; &quot;decr&quot;,
        # ...
    sub decr { &minus;&minus;${$_[0]}; }</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Mathemagic,
Mutators, and Copy Constructors</i></p>

<p style="margin-left:11%; margin-top: 1em">The term
&rsquo;mathemagic&rsquo; describes the overloaded
implementation of mathematical operators. Mathemagical
operations raise an issue. Consider the code:</p>

<pre style="margin-left:11%; margin-top: 1em">    $a = $b;
    &minus;&minus;$a;</pre>


<p style="margin-left:11%; margin-top: 1em">If <tt>$a</tt>
and <tt>$b</tt> are scalars then after these statements</p>

<pre style="margin-left:11%; margin-top: 1em">    $a == $b &minus; 1</pre>


<p style="margin-left:11%; margin-top: 1em">An object,
however, is a reference to blessed data, so if <tt>$a</tt>
and <tt>$b</tt> are objects then the assignment <tt>&quot;$a
= $b&quot;</tt> copies only the reference, leaving
<tt>$a</tt> and <tt>$b</tt> referring to the same object
data. One might therefore expect the operation
<tt>&quot;&minus;&minus;$a&quot;</tt> to decrement
<tt>$b</tt> as well as <tt>$a</tt>. However, this would not
be consistent with how we expect the mathematical operators
to work.</p>

<p style="margin-left:11%; margin-top: 1em">Perl resolves
this dilemma by transparently calling a copy constructor
before calling a method defined to implement a mutator
(<tt>&quot;&minus;&minus;&quot;</tt>,
<tt>&quot;+=&quot;</tt>, and so on.). In the above example,
when Perl reaches the decrement statement, it makes a copy
of the object data in <tt>$a</tt> and assigns to <tt>$a</tt>
a reference to the copied data. Only then does it call
<tt>&quot;decr()&quot;</tt>, which alters the copied data,
leaving <tt>$b</tt> unchanged. Thus the object metaphor is
preserved as far as possible, while mathemagical operations
still work according to the arithmetic metaphor.</p>

<p style="margin-left:11%; margin-top: 1em">Note: the
preceding paragraph describes what happens when Perl
autogenerates the copy constructor for an object based on a
scalar. For other cases, see &quot;Copy
Constructor&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Overloadable
Operations</b> <br>
The complete list of keys that can be specified in the
<tt>&quot;use overload&quot;</tt> directive are given,
separated by spaces, in the values of the hash
<tt>%overload::ops</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em"> with_assign      =&gt; '+ &minus; * / % ** &lt;&lt; &gt;&gt; x .',
 assign           =&gt; '+= &minus;= *= /= %= **= &lt;&lt;= &gt;&gt;= x= .=',
 num_comparison   =&gt; '&lt; &lt;= &gt; &gt;= == !=',
 '3way_comparison'=&gt; '&lt;=&gt; cmp',
 str_comparison   =&gt; 'lt le gt ge eq ne',
 binary           =&gt; '&amp; &amp;= | |= ^ ^=',
 unary            =&gt; 'neg ! ~',
 mutators         =&gt; '++ &minus;&minus;',
 func             =&gt; 'atan2 cos sin exp abs log sqrt int',
 conversion       =&gt; 'bool &quot;&quot; 0+ qr',
 iterators        =&gt; '&lt;&gt;',
 filetest         =&gt; '&minus;X',
 dereferencing    =&gt; '${} @{} %{} &amp;{} *{}',
 matching         =&gt; '~~',
 special          =&gt; 'nomethod fallback ='</pre>


<p style="margin-left:11%; margin-top: 1em">Most of the
overloadable operators map one-to-one to these keys.
Exceptions, including additional overloadable operations not
apparent from this hash, are included in the notes which
follow.</p>

<p style="margin-left:11%; margin-top: 1em">A warning is
issued if an attempt is made to register an operator not
found above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p><tt>&quot;not&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The operator
<tt>&quot;not&quot;</tt> is not a valid key for
<tt>&quot;use overload&quot;</tt>. However, if the operator
<tt>&quot;!&quot;</tt> is overloaded then the same
implementation will be used for <tt>&quot;not&quot;</tt>
(since the two operators differ only in precedence).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;neg&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
<tt>&quot;neg&quot;</tt> is used for unary minus to
disambiguate it from binary
<tt>&quot;&minus;&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="16%">


<p style="margin-top: 1em"><tt>&quot;++&quot;</tt>,
<tt>&quot;&minus;&minus;&quot;</tt></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Assuming they
are to behave analogously to Perl&rsquo;s
<tt>&quot;++&quot;</tt> and
<tt>&quot;&minus;&minus;&quot;</tt>, overloaded
implementations of these operators are required to mutate
their operands.</p>

<p style="margin-left:18%; margin-top: 1em">No distinction
is made between prefix and postfix forms of the increment
and decrement operators: these differ only in the point at
which Perl calls the associated subroutine when evaluating
an expression.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="17%">


<p style="margin-top: 1em"><i>Assignments</i></p></td>
<td width="65%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    +=  &minus;=  *=  /=  %=  **=  &lt;&lt;=  &gt;&gt;=  x=  .=
    &amp;=  |=  ^=</pre>


<p style="margin-left:18%; margin-top: 1em">Simple
assignment is not overloadable (the <tt>'='</tt> key is used
for the &quot;Copy Constructor&quot;). Perl does have a way
to make assignments to an object do whatever you want, but
this involves using <i>tie()</i>, not overload &minus; see
&quot;tie&quot; in perlfunc and the &quot;
<small>COOKBOOK</small> &quot; examples below.</p>

<p style="margin-left:18%; margin-top: 1em">The subroutine
for the assignment variant of an operator is required only
to return the result of the operation. It is permitted to
change the value of its operand (this is safe because Perl
calls the copy constructor first), but this is optional
since Perl assigns the returned value to the left-hand
operand anyway.</p>

<p style="margin-left:18%; margin-top: 1em">An object that
overloads an assignment operator does so only in respect of
assignments to that object. In other words, Perl never calls
the corresponding methods with the third argument (the
&quot;swap&quot; argument) set to <small>TRUE</small> . For
example, the operation</p>

<pre style="margin-left:18%; margin-top: 1em">    $a *= $b</pre>


<p style="margin-left:18%; margin-top: 1em">cannot lead to
<tt>$b</tt>&rsquo;s implementation of
<tt>&quot;*=&quot;</tt> being called, even if <tt>$a</tt> is
a scalar. (It can, however, generate a call to
<tt>$b</tt>&rsquo;s method for <tt>&quot;*&quot;</tt>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="54%">


<p style="margin-top: 1em"><i>Non-mutators with a mutator
variant</i></p> </td>
<td width="28%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">     +  &minus;  *  /  %  **  &lt;&lt;  &gt;&gt;  x  .
     &amp;  |  ^</pre>


<p style="margin-left:18%; margin-top: 1em">As described
above, Perl may call methods for operators like
<tt>&quot;+&quot;</tt> and <tt>&quot;&amp;&quot;</tt> in the
course of implementing missing operations like
<tt>&quot;++&quot;</tt>, <tt>&quot;+=&quot;</tt>, and
<tt>&quot;&amp;=&quot;</tt>. While these methods may detect
this usage by testing the definedness of the third argument,
they should in all cases avoid changing their operands. This
is because Perl does not call the copy constructor before
invoking these methods.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;int&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Traditionally,
the Perl function <tt>&quot;int&quot;</tt> rounds to 0 (see
&quot;int&quot; in perlfunc), and so for floating-point-like
types one should follow the same semantic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="74%">


<p style="margin-top: 1em"><i>String, numeric, boolean, and
regexp conversions</i></p></td>
<td width="8%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    &quot;&quot;  0+  bool</pre>


<p style="margin-left:18%; margin-top: 1em">These
conversions are invoked according to context as necessary.
For example, the subroutine for <tt>'&quot;&quot;'</tt>
(stringify) may be used where the overloaded object is
passed as an argument to <tt>&quot;print&quot;</tt>, and
that for <tt>'bool'</tt> where it is tested in the condition
of a flow control statement (like
<tt>&quot;while&quot;</tt>) or the ternary
<tt>&quot;?:&quot;</tt> operation.</p>

<p style="margin-left:18%; margin-top: 1em">Of course, in
contexts like, for example, <tt>&quot;$obj + 1&quot;</tt>,
Perl will invoke <tt>$obj</tt>&rsquo;s implementation of
<tt>&quot;+&quot;</tt> rather than (in this example)
converting <tt>$obj</tt> to a number using the numify method
<tt>'0+'</tt> (an exception to this is when no method has
been provided for <tt>'+'</tt> and &quot;fallback&quot; is
set to <small>TRUE</small> ).</p>

<p style="margin-left:18%; margin-top: 1em">The subroutines
for <tt>'&quot;&quot;'</tt>, <tt>'0+'</tt>, and
<tt>'bool'</tt> can return any arbitrary Perl value. If the
corresponding operation for this value is overloaded too,
the operation will be called again with this value.</p>

<p style="margin-left:18%; margin-top: 1em">As a special
case if the overload returns the object itself then it will
be used directly. An overloaded conversion returning the
object is probably a bug, because you&rsquo;re likely to get
something that looks like
<tt>&quot;YourPackage=HASH(0x8172b34)&quot;</tt>.</p>
<pre style="margin-left:18%; margin-top: 1em">    qr</pre>

<p style="margin-left:18%; margin-top: 1em">The subroutine
for <tt>'qr'</tt> is used wherever the object is
interpolated into or used as a regexp, including when it
appears on the <small>RHS</small> of a
<tt>&quot;=~&quot;</tt> or <tt>&quot;!~&quot;</tt>
operator.</p>


<p style="margin-left:18%; margin-top: 1em"><tt>&quot;qr&quot;</tt>
must return a compiled regexp, or a ref to a compiled regexp
(such as <tt>&quot;qr//&quot;</tt> returns), and any further
overloading on the return value will be ignored.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>Iteration</i></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If
<tt>&quot;&lt;&gt;&quot;</tt> is overloaded then the same
implementation is used for both the <i>read-filehandle</i>
syntax <tt>&quot;&lt;$var&gt;&quot;</tt> and <i>globbing</i>
syntax <tt>&quot;&lt;${var}&gt;&quot;</tt>.</p>


<p style="margin-left:18%; margin-top: 1em"><b><small>BUGS</small></b>
Even in list context, the iterator is currently called only
once and with scalar context.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="16%">


<p style="margin-top: 1em"><i>File tests</i></p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
<tt>'&minus;X'</tt> is used to specify a subroutine to
handle all the filetest operators
(<tt>&quot;&minus;f&quot;</tt>,
<tt>&quot;&minus;x&quot;</tt>, and so on: see
&quot;&minus;X&quot; in perlfunc for the full list); it is
not possible to overload any filetest operator individually.
To distinguish them, the letter following the
&rsquo;&minus;&rsquo; is passed as the second argument (that
is, in the slot that for binary operators is used to pass
the second operand).</p>

<p style="margin-left:18%; margin-top: 1em">Calling an
overloaded filetest operator does not affect the stat value
associated with the special filehandle
<tt>&quot;_&quot;</tt>. It still refers to the result of the
last <tt>&quot;stat&quot;</tt>, <tt>&quot;lstat&quot;</tt>
or unoverloaded filetest.</p>

<p style="margin-left:18%; margin-top: 1em">This overload
was introduced in Perl 5.12.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="13%">


<p style="margin-top: 1em"><i>Matching</i></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
<tt>&quot;~~&quot;</tt> allows you to override the smart
matching logic used by the <tt>&quot;~~&quot;</tt> operator
and the switch construct
(<tt>&quot;given&quot;</tt>/<tt>&quot;when&quot;</tt>). See
&quot;Switch Statements&quot; in perlsyn and feature.</p>

<p style="margin-left:18%; margin-top: 1em">Unusually, the
overloaded implementation of the smart match operator does
not get full control of the smart match behaviour. In
particular, in the following code:</p>

<pre style="margin-left:18%; margin-top: 1em">    package Foo;
    use overload '~~' =&gt; 'match';
    my $obj =  Foo&minus;&gt;new();
    $obj ~~ [ 1,2,3 ];</pre>


<p style="margin-left:18%; margin-top: 1em">the smart match
does <i>not</i> invoke the method call like this:</p>

<pre style="margin-left:18%; margin-top: 1em">    $obj&minus;&gt;match([1,2,3],0);</pre>


<p style="margin-left:18%; margin-top: 1em">rather, the
smart match distributive rule takes precedence, so
<tt>$obj</tt> is smart matched against each array element in
turn until a match is found, so you may see between one and
three of these calls instead:</p>

<pre style="margin-left:18%; margin-top: 1em">    $obj&minus;&gt;match(1,0);
    $obj&minus;&gt;match(2,0);
    $obj&minus;&gt;match(3,0);</pre>


<p style="margin-left:18%; margin-top: 1em">Consult the
match table in &quot;Smartmatch Operator&quot; in perlop for
details of when overloading is invoked.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="20%">


<p style="margin-top: 1em"><i>Dereferencing</i></p></td>
<td width="62%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    ${}  @{}  %{}  &amp;{}  *{}</pre>


<p style="margin-left:18%; margin-top: 1em">If these
operators are not explicitly overloaded then they work in
the normal way, yielding the underlying scalar, array, or
whatever stores the object data (or the appropriate error
message if the dereference operator doesn&rsquo;t match it).
Defining a catch-all <tt>'nomethod'</tt> (see below) makes
no difference to this as the catch-all function will not be
called to implement a missing dereference operator.</p>

<p style="margin-left:18%; margin-top: 1em">If a
dereference operator is overloaded then it must return a
<i>reference</i> of the appropriate type (for example, the
subroutine for key <tt>'${}'</tt> should return a reference
to a scalar, not a scalar), or another object which
overloads the operator: that is, the subroutine only
determines what is dereferenced and the actual dereferencing
is left to Perl. As a special case, if the subroutine
returns the object itself then it will not be called again
&minus; avoiding infinite recursion.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="11%">


<p style="margin-top: 1em"><i>Special</i></p></td>
<td width="71%">
</td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    nomethod  fallback  =</pre>


<p style="margin-left:18%; margin-top: 1em">See
&quot;Special Keys for <tt>&quot;use
overload&quot;</tt>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Magic
Autogeneration</b> <br>
If a method for an operation is not found then Perl tries to
autogenerate a substitute implementation from the operations
that have been defined.</p>

<p style="margin-left:11%; margin-top: 1em">Note: the
behaviour described in this section can be disabled by
setting <tt>&quot;fallback&quot;</tt> to
<small>FALSE</small> (see &quot;fallback&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">In the
following tables, numbers indicate priority. For example,
the table below states that, if no implementation for
<tt>'!'</tt> has been defined then Perl will implement it
using <tt>'bool'</tt> (that is, by inverting the value
returned by the method for <tt>'bool'</tt>); if boolean
conversion is also unimplemented then Perl will use
<tt>'0+'</tt> or, failing that, <tt>'&quot;&quot;'</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    operator | can be autogenerated from
             |
             | 0+   &quot;&quot;   bool   .   x
    =========|==========================
       0+    |       1     2
       &quot;&quot;    |  1          2
       bool  |  1    2
       int   |  1    2     3
       !     |  2    3     1
       qr    |  2    1     3
       .     |  2    1     3
       x     |  2    1     3
       .=    |  3    2     4    1
       x=    |  3    2     4        1
       &lt;&gt;    |  2    1     3
       &minus;X    |  2    1     3</pre>


<p style="margin-left:11%; margin-top: 1em">Note: The
iterator (<tt>'&lt;&gt;'</tt>) and file test
(<tt>'&minus;X'</tt>) operators work as normal: if the
operand is not a blessed glob or <small>IO</small> reference
then it is converted to a string (using the method for
<tt>'&quot;&quot;'</tt>, <tt>'0+'</tt>, or <tt>'bool'</tt>)
to be interpreted as a glob or filename.</p>

<pre style="margin-left:11%; margin-top: 1em">    operator | can be autogenerated from
             |
             |  &lt;   &lt;=&gt;   neg   &minus;=    &minus;
    =========|==========================
       neg   |                        1
       &minus;=    |                        1
       &minus;&minus;    |                   1    2
       abs   | a1    a2    b1        b2    [*]
       &lt;     |        1
       &lt;=    |        1
       &gt;     |        1
       &gt;=    |        1
       ==    |        1
       !=    |        1
    * one from [a1, a2] and one from [b1, b2]</pre>


<p style="margin-left:11%; margin-top: 1em">Just as numeric
comparisons can be autogenerated from the method for
<tt>'&lt;=&gt;'</tt>, string comparisons can be
autogenerated from that for <tt>'cmp'</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">     operators          |  can be autogenerated from
    ====================|===========================
     lt gt le ge eq ne  |  cmp</pre>


<p style="margin-left:11%; margin-top: 1em">Similarly,
autogeneration for keys <tt>'+='</tt> and <tt>'++'</tt> is
analogous to <tt>'&minus;='</tt> and
<tt>'&minus;&minus;'</tt> above:</p>

<pre style="margin-left:11%; margin-top: 1em">    operator | can be autogenerated from
             |
             |  +=    +
    =========|==========================
        +=   |        1
        ++   |   1    2</pre>


<p style="margin-left:11%; margin-top: 1em">And other
assignment variations are analogous to <tt>'+='</tt> and
<tt>'&minus;='</tt> (and similar to <tt>'.='</tt> and
<tt>'x='</tt> above):</p>

<pre style="margin-left:11%; margin-top: 1em">              operator ||  *= /= %= **= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
    &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;||&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
    autogenerated from ||  *  /  %  **  &lt;&lt;  &gt;&gt;  &amp;  ^  |</pre>


<p style="margin-left:11%; margin-top: 1em">Note also that
the copy constructor (key <tt>'='</tt>) may be
autogenerated, but only for objects based on scalars. See
&quot;Copy Constructor&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Minimal Set
of Overloaded Operations</i></p>

<p style="margin-left:11%; margin-top: 1em">Since some
operations can be automatically generated from others, there
is a minimal set of operations that need to be overloaded in
order to have the complete set of overloaded operations at
one&rsquo;s disposal. Of course, the autogenerated
operations may not do exactly what the user expects. The
minimal set is:</p>

<pre style="margin-left:11%; margin-top: 1em">    + &minus; * / % ** &lt;&lt; &gt;&gt; x
    &lt;=&gt; cmp
    &amp; | ^ ~
    atan2 cos sin exp log sqrt int
    &quot;&quot; 0+ bool
    ~~</pre>


<p style="margin-left:11%; margin-top: 1em">Of the
conversions, only one of string, boolean or numeric is
needed because each can be generated from either of the
other two.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Special Keys
for &quot;use overload&quot;</b> <i><br>
&quot;nomethod&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>'nomethod'</tt> key is used to specify a catch-all
function to be called for any operator that is not
individually overloaded. The specified function will be
passed four parameters. The first three arguments coincide
with those that would have been passed to the corresponding
method if it had been defined. The fourth argument is the
<tt>&quot;use overload&quot;</tt> key for that missing
method.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
<tt>$a</tt> is an object blessed into a package
declaring</p>

<pre style="margin-left:11%; margin-top: 1em">    use overload 'nomethod' =&gt; 'catch_all', # ...</pre>


<p style="margin-left:11%; margin-top: 1em">then the
operation</p>

<pre style="margin-left:11%; margin-top: 1em">    3 + $a</pre>


<p style="margin-left:11%; margin-top: 1em">could (unless a
method is specifically declared for the key <tt>'+'</tt>)
result in a call</p>

<pre style="margin-left:11%; margin-top: 1em">    catch_all($a, 3, 1, '+')</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;How
Perl Chooses an Operator Implementation&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;fallback&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">The value
assigned to the key <tt>'fallback'</tt> tells Perl how hard
it should try to find an alternative way to implement a
missing operator.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">defined, but
<small>FALSE</small></p> </td>
<td width="55%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    use overload &quot;fallback&quot; =&gt; 0, # ... ;</pre>


<p style="margin-left:17%; margin-top: 1em">This disables
&quot;Magic Autogeneration&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;undef&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In the default
case where no value is explicitly assigned to
<tt>&quot;fallback&quot;</tt>, magic autogeneration is
enabled.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>TRUE</small></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The same as for
<tt>&quot;undef&quot;</tt>, but if a missing operator cannot
be autogenerated then, instead of issuing an error message,
Perl is allowed to revert to what it would have done for
that operator if there had been no <tt>&quot;use
overload&quot;</tt> directive.</p>

<p style="margin-left:17%; margin-top: 1em">Note: in most
cases, particularly the &quot;Copy Constructor&quot;, this
is unlikely to be appropriate behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;How
Perl Chooses an Operator Implementation&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Copy
Constructor</i></p>

<p style="margin-left:11%; margin-top: 1em">As mentioned
above, this operation is called when a mutator is applied to
a reference that shares its object with some other
reference. For example, if <tt>$b</tt> is mathemagical, and
<tt>'++'</tt> is overloaded with <tt>'incr'</tt>, and
<tt>'='</tt> is overloaded with <tt>'clone'</tt>, then the
code</p>

<pre style="margin-left:11%; margin-top: 1em">    $a = $b;
    # ... (other code which does not modify $a or $b) ...
    ++$b;</pre>


<p style="margin-left:11%; margin-top: 1em">would be
executed in a manner equivalent to</p>

<pre style="margin-left:11%; margin-top: 1em">    $a = $b;
    # ...
    $b = $b&minus;&gt;clone(undef, &quot;&quot;);
    $b&minus;&gt;incr(undef, &quot;&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">Note:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The subroutine for <tt>'='</tt>
does not overload the Perl assignment operator: it is used
only to allow mutators to work as described here. (See
&quot;Assignments&quot; above.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>As for other operations, the subroutine implementing
&rsquo;=&rsquo; is passed three arguments, though the last
two are always <tt>&quot;undef&quot;</tt> and
<tt>''</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The copy constructor is called only before a call to a
function declared to implement a mutator, for example, if
<tt>&quot;++$b;&quot;</tt> in the code above is effected via
a method declared for key <tt>'++'</tt> (or
&rsquo;nomethod&rsquo;, passed <tt>'++'</tt> as the fourth
argument) or, by autogeneration, <tt>'+='</tt>. It is not
called if the increment operation is effected by a call to
the method for <tt>'+'</tt> since, in the equivalent
code,</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    $a = $b;
    $b = $b + 1;</pre>


<p style="margin-left:17%; margin-top: 1em">the data
referred to by <tt>$a</tt> is unchanged by the assignment to
<tt>$b</tt> of a reference to new object data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The copy constructor is not
called if Perl determines that it is unnecessary because
there is no other reference to the data being modified.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If <tt>'fallback'</tt> is undefined or
<small>TRUE</small> then a copy constructor can be
autogenerated, but only for objects based on scalars. In
other cases it needs to be defined explicitly. Where an
object&rsquo;s data is stored as, for example, an array of
scalars, the following might be appropriate:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    use overload '=' =&gt; sub { bless [ @{$_[0]} ] },  # ...</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If <tt>'fallback'</tt> is
<small>TRUE</small> and no copy constructor is defined then,
for objects not based on scalars, Perl may silently fall
back on simple assignment &minus; that is, assignment of the
object reference. In effect, this disables the copy
constructor mechanism since no new copy of the object data
is created. This is almost certainly not what you want. (It
is, however, consistent: for example, Perl&rsquo;s fallback
for the <tt>&quot;++&quot;</tt> operator is to increment the
reference itself.)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>How Perl
Chooses an Operator Implementation</b> <br>
Which is checked first, <tt>&quot;nomethod&quot;</tt> or
<tt>&quot;fallback&quot;</tt>? If the two operands of an
operator are of different types and both overload the
operator, which implementation is used? The following are
the precedence rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the first operand has
declared a subroutine to overload the operator then use that
implementation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Otherwise, if fallback is <small>TRUE</small> or
undefined for the first operand then see if the rules for
autogeneration allows another of its operators to be used
instead.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Unless the operator is an assignment
(<tt>&quot;+=&quot;</tt>, <tt>&quot;&minus;=&quot;</tt>,
etc.), repeat step (1) in respect of the second operand.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Repeat Step (2) in respect of the second operand.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the first operand has a &quot;nomethod&quot; method
then use that.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the second operand has a &quot;nomethod&quot; method
then use that.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If <tt>&quot;fallback&quot;</tt> is <small>TRUE</small>
for both operands then perform the usual operation for the
operator, treating the operands as numbers, strings, or
booleans as appropriate for the operator (see note).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Nothing worked &minus; die.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Where there is
only one operand (or only one operand with overloading) the
checks in respect of the other operand above are
skipped.</p>

<p style="margin-left:11%; margin-top: 1em">There are
exceptions to the above rules for dereference operations
(which, if Step 1 fails, always fall back to the normal,
built-in implementations &minus; see Dereferencing), and for
<tt>&quot;~~&quot;</tt> (which has its own set of rules
&minus; see <tt>&quot;Matching&quot;</tt> under
&quot;Overloadable Operations&quot; above).</p>

<p style="margin-left:11%; margin-top: 1em">Note on Step 7:
some operators have a different semantic depending on the
type of their operands. As there is no way to instruct Perl
to treat the operands as, e.g., numbers instead of strings,
the result here may not be what you expect. See &quot;
<small>BUGS AND PITFALLS</small> &quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Losing
Overloading</b> <br>
The restriction for the comparison operation is that even
if, for example, <tt>&quot;cmp&quot;</tt> should return a
blessed reference, the autogenerated <tt>&quot;lt&quot;</tt>
function will produce only a standard logical value based on
the numerical value of the result of
<tt>&quot;cmp&quot;</tt>. In particular, a working numeric
conversion is needed in this case (possibly expressed in
terms of other conversions).</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
<tt>&quot;.=&quot;</tt> and <tt>&quot;x=&quot;</tt>
operators lose their mathemagical properties if the string
conversion substitution is applied.</p>

<p style="margin-left:11%; margin-top: 1em">When you
<i>chop()</i> a mathemagical object it is promoted to a
string and its mathemagical properties are lost. The same
can happen with other operations as well.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Inheritance
and Overloading</b> <br>
Overloading respects inheritance via the <tt>@ISA</tt>
hierarchy. Inheritance interacts with overloading in two
ways. <br>
Method names in the &quot;use overload&quot; directive</p>

<p style="margin-left:17%;">If <tt>&quot;value&quot;</tt>
in</p>

<pre style="margin-left:17%; margin-top: 1em">  use overload key =&gt; value;</pre>


<p style="margin-left:17%; margin-top: 1em">is a string, it
is interpreted as a method name &minus; which may (in the
usual way) be inherited from another class.</p>

<p style="margin-left:11%;">Overloading of an operation is
inherited by derived classes</p>

<p style="margin-left:17%;">Any class derived from an
overloaded class is also overloaded and inherits its
operator implementations. If the same operator is overloaded
in more than one ancestor then the implementation is
determined by the usual inheritance rules.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
<tt>&quot;A&quot;</tt> inherits from <tt>&quot;B&quot;</tt>
and <tt>&quot;C&quot;</tt> (in that order),
<tt>&quot;B&quot;</tt> overloads <tt>&quot;+&quot;</tt> with
<tt>&quot;\&amp;D::plus_sub&quot;</tt>, and
<tt>&quot;C&quot;</tt> overloads <tt>&quot;+&quot;</tt> by
<tt>&quot;plus_meth&quot;</tt>, then the subroutine
<tt>&quot;D::plus_sub&quot;</tt> will be called to implement
operation <tt>&quot;+&quot;</tt> for an object in package
<tt>&quot;A&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that since
the value of the <tt>&quot;fallback&quot;</tt> key is not a
subroutine, its inheritance is not governed by the above
rules. In the current implementation, the value of
<tt>&quot;fallback&quot;</tt> in the first overloaded
ancestor is used, but this is accidental and subject to
change.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Run-time
Overloading</b> <br>
Since all <tt>&quot;use&quot;</tt> directives are executed
at compile-time, the only way to change overloading during
run-time is to</p>

<pre style="margin-left:11%; margin-top: 1em">    eval 'use overload &quot;+&quot; =&gt; \&amp;addmethod';</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
use</p>

<pre style="margin-left:11%; margin-top: 1em">    eval 'no overload &quot;+&quot;, &quot;&minus;&minus;&quot;, &quot;&lt;=&quot;';</pre>


<p style="margin-left:11%; margin-top: 1em">though the use
of these constructs during run-time is questionable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Functions</b> <br>
Package <tt>&quot;overload.pm&quot;</tt> provides the
following public functions: <br>
overload::StrVal(arg)</p>

<p style="margin-left:18%;">Gives the string value of
<tt>&quot;arg&quot;</tt> as in the absence of stringify
overloading. If you are using this to get the address of a
reference (useful for checking if two references point to
the same thing) then you may be better off using
<tt>&quot;Scalar::Util::refaddr()&quot;</tt>, which is
faster.</p>

<p style="margin-left:11%;">overload::Overloaded(arg)</p>

<p style="margin-left:18%;">Returns true if
<tt>&quot;arg&quot;</tt> is subject to overloading of some
operations.</p>

<p style="margin-left:11%;">overload::Method(obj,op)</p>

<p style="margin-left:18%;">Returns
<tt>&quot;undef&quot;</tt> or a reference to the method that
implements <tt>&quot;op&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Overloading
Constants</b> <br>
For some applications, the Perl parser mangles constants too
much. It is possible to hook into this process via
<tt>&quot;overload::constant()&quot;</tt> and
<tt>&quot;overload::remove_constant()&quot;</tt>
functions.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
take a hash as an argument. The recognized keys of this hash
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>integer</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload integer constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>float</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload floating point constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>binary</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload octal and hexadecimal constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>q</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload <tt>&quot;q&quot;</tt>&minus;quoted strings,
constant pieces of <tt>&quot;qq&quot;</tt>&minus; and
<tt>&quot;qx&quot;</tt>&minus;quoted strings and
here-documents,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>qr</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload constant pieces of regular expressions.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
corresponding values are references to functions which take
three arguments: the first one is the <i>initial</i> string
form of the constant, the second one is how Perl interprets
this constant, the third one is how the constant is used.
Note that the initial string form does not contain string
delimiters, and has backslashes in backslash-delimiter
combinations stripped (thus the value of delimiter is not
relevant for processing of this string). The return value of
this function is how this constant is going to be
interpreted by Perl. The third argument is undefined unless
for overloaded <tt>&quot;q&quot;</tt>&minus; and
<tt>&quot;qr&quot;</tt>&minus; constants, it is
<tt>&quot;q&quot;</tt> in single-quote context (comes from
strings, regular expressions, and single-quote
<small>HERE</small> documents), it is
<tt>&quot;tr&quot;</tt> for arguments of
<tt>&quot;tr&quot;</tt>/<tt>&quot;y&quot;</tt> operators, it
is <tt>&quot;s&quot;</tt> for right-hand side of
<tt>&quot;s&quot;</tt>&minus;operator, and it is
<tt>&quot;qq&quot;</tt> otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Since an
expression <tt>&quot;ab$cd,,&quot;</tt> is just a shortcut
for <tt>'ab' . $cd . ',,'</tt>, it is expected that
overloaded constant strings are equipped with reasonable
overloaded catenation operator, otherwise absurd results
will result. Similarly, negative numbers are considered as
negations of positive constants.</p>

<p style="margin-left:11%; margin-top: 1em">Note that it is
probably meaningless to call the functions
<i>overload::constant()</i> and
<i>overload::remove_constant()</i> from anywhere but
<i>import()</i> and <i>unimport()</i> methods. From these
methods they may be called as</p>

<pre style="margin-left:11%; margin-top: 1em">    sub import {
       shift;
       return unless @_;
       die &quot;unknown import: @_&quot; unless @_ == 1 and $_[0] eq ':constant';
       overload::constant integer =&gt; sub {Math::BigInt&minus;&gt;new(shift)};
    }</pre>


<h2>IMPLEMENTATION
<a name="IMPLEMENTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">What follows is
subject to change <small>RSN</small> .</p>

<p style="margin-left:11%; margin-top: 1em">The table of
methods for all operations is cached in magic for the symbol
table hash for the package. The cache is invalidated during
processing of <tt>&quot;use overload&quot;</tt>,
<tt>&quot;no overload&quot;</tt>, new function definitions,
and changes in <tt>@ISA</tt>. However, this invalidation
remains unprocessed until the next
<tt>&quot;bless&quot;</tt>ing into the package. Hence if you
want to change overloading structure dynamically,
you&rsquo;ll need an additional (fake)
<tt>&quot;bless&quot;</tt>ing to update the table.</p>

<p style="margin-left:11%; margin-top: 1em">(Every SVish
thing has a magic queue, and magic is an entry in that
queue. This is how a single variable may participate in
multiple forms of magic simultaneously. For instance,
environment variables regularly have two forms at once:
their <tt>%ENV</tt> magic and their taint magic. However,
the magic which implements overloading is applied to the
stashes, which are rarely used directly, thus should not
slow down Perl.)</p>

<p style="margin-left:11%; margin-top: 1em">If an object
belongs to a package using overload, it carries a special
flag. Thus the only speed penalty during arithmetic
operations without overloading is the checking of this
flag.</p>

<p style="margin-left:11%; margin-top: 1em">In fact, if
<tt>&quot;use overload&quot;</tt> is not present, there is
almost no overhead for overloadable operations, so most
programs should not suffer measurable performance penalties.
A considerable effort was made to minimize the overhead when
overload is used in some package, but the arguments in
question do not belong to packages using overload. When in
doubt, test your speed with <tt>&quot;use
overload&quot;</tt> and without it. So far there have been
no reports of substantial speed degradation if Perl is
compiled with optimization turned on.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
size penalty for data if overload is not used. The only size
penalty if overload is used in some package is that
<i>all</i> the packages acquire a magic during the next
<tt>&quot;bless&quot;</tt>ing into the package. This magic
is three-words-long for packages without overloading, and
carries the cache table if the package is overloaded.</p>

<p style="margin-left:11%; margin-top: 1em">It is expected
that arguments to methods that are not explicitly supposed
to be changed are constant (but this is not enforced).</p>

<h2>COOKBOOK
<a name="COOKBOOK"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please add
examples to what follows!</p>

<p style="margin-left:11%; margin-top: 1em"><b>Two-face
Scalars</b> <br>
Put this in <i>two_face.pm</i> in your Perl library
directory:</p>

<pre style="margin-left:11%; margin-top: 1em">  package two_face;             # Scalars with separate string and
                                # numeric values.
  sub new { my $p = shift; bless [@_], $p }
  use overload '&quot;&quot;' =&gt; \&amp;str, '0+' =&gt; \&amp;num, fallback =&gt; 1;
  sub num {shift&minus;&gt;[1]}
  sub str {shift&minus;&gt;[0]}</pre>


<p style="margin-left:11%; margin-top: 1em">Use it as
follows:</p>

<pre style="margin-left:11%; margin-top: 1em">  require two_face;
  my $seven = two_face&minus;&gt;new(&quot;vii&quot;, 7);
  printf &quot;seven=$seven, seven=%d, eight=%d\n&quot;, $seven, $seven+1;
  print &quot;seven contains 'i'\n&quot; if $seven =~ /i/;</pre>


<p style="margin-left:11%; margin-top: 1em">(The second
line creates a scalar which has both a string value, and a
numeric value.) This prints:</p>

<pre style="margin-left:11%; margin-top: 1em">  seven=vii, seven=7, eight=8
  seven contains 'i'</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Two-face
References</b> <br>
Suppose you want to create an object which is accessible as
both an array reference and a hash reference.</p>

<pre style="margin-left:11%; margin-top: 1em">  package two_refs;
  use overload '%{}' =&gt; \&amp;gethash, '@{}' =&gt; sub { $ {shift()} };
  sub new {
    my $p = shift;
    bless \ [@_], $p;
  }
  sub gethash {
    my %h;
    my $self = shift;
    tie %h, ref $self, $self;
    \%h;
  }
  sub TIEHASH { my $p = shift; bless \ shift, $p }
  my %fields;
  my $i = 0;
  $fields{$_} = $i++ foreach qw{zero one two three};
  sub STORE {
    my $self = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $$self&minus;&gt;[$key] = shift;
  }
  sub FETCH {
    my $self = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $$self&minus;&gt;[$key];
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Now one can
access an object using both the array and hash syntax:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $bar = two_refs&minus;&gt;new(3,4,5,6);
  $bar&minus;&gt;[2] = 11;
  $bar&minus;&gt;{two} == 11 or die 'bad hash fetch';</pre>


<p style="margin-left:11%; margin-top: 1em">Note several
important features of this example. First of all, the
<i>actual</i> type of <tt>$bar</tt> is a scalar reference,
and we do not overload the scalar dereference. Thus we can
get the <i>actual</i> non-overloaded contents of
<tt>$bar</tt> by just using <tt>$$bar</tt> (what we do in
functions which overload dereference). Similarly, the object
returned by the <i><small>TIEHASH</small> ()</i> method is a
scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">Second, we
create a new tied hash each time the hash syntax is used.
This allows us not to worry about a possibility of a
reference loop, which would lead to a memory leak.</p>

<p style="margin-left:11%; margin-top: 1em">Both these
problems can be cured. Say, if we want to overload hash
dereference on a reference to an object which is
<i>implemented</i> as a hash itself, the only problem one
has to circumvent is how to access this <i>actual</i> hash
(as opposed to the <i>virtual</i> hash exhibited by the
overloaded dereference operator). Here is one possible
fetching routine:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub access_hash {
    my ($self, $key) = (shift, shift);
    my $class = ref $self;
    bless $self, 'overload::dummy'; # Disable overloading of %{}
    my $out = $self&minus;&gt;{$key};
    bless $self, $class;        # Restore overloading
    $out;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">To remove
creation of the tied hash on each access, one may an extra
level of indirection which allows a non-circular structure
of references:</p>

<pre style="margin-left:11%; margin-top: 1em">  package two_refs1;
  use overload '%{}' =&gt; sub { ${shift()}&minus;&gt;[1] },
               '@{}' =&gt; sub { ${shift()}&minus;&gt;[0] };
  sub new {
    my $p = shift;
    my $a = [@_];
    my %h;
    tie %h, $p, $a;
    bless \ [$a, \%h], $p;
  }
  sub gethash {
    my %h;
    my $self = shift;
    tie %h, ref $self, $self;
    \%h;
  }
  sub TIEHASH { my $p = shift; bless \ shift, $p }
  my %fields;
  my $i = 0;
  $fields{$_} = $i++ foreach qw{zero one two three};
  sub STORE {
    my $a = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $a&minus;&gt;[$key] = shift;
  }
  sub FETCH {
    my $a = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $a&minus;&gt;[$key];
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Now if
<tt>$baz</tt> is overloaded like this, then <tt>$baz</tt> is
a reference to a reference to the intermediate array, which
keeps a reference to an actual array, and the access hash.
The <i>tie()</i>ing object for the access hash is a
reference to a reference to the actual array, so</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">There are no loops of
references.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Both &quot;objects&quot; which are blessed into the
class <tt>&quot;two_refs1&quot;</tt> are references to a
reference to an array, thus references to a <i>scalar</i>.
Thus the accessor expression
<tt>&quot;$$foo&minus;&gt;[$ind]&quot;</tt> involves no
overloaded operations.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Symbolic
Calculator</b> <br>
Put this in <i>symbolic.pm</i> in your Perl library
directory:</p>

<pre style="margin-left:11%; margin-top: 1em">  package symbolic;             # Primitive symbolic calculator
  use overload nomethod =&gt; \&amp;wrap;
  sub new { shift; bless ['n', @_] }
  sub wrap {
    my ($obj, $other, $inv, $meth) = @_;
    ($obj, $other) = ($other, $obj) if $inv;
    bless [$meth, $obj, $other];
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This module is
very unusual as overloaded modules go: it does not provide
any usual overloaded operators, instead it provides an
implementation for <tt>&quot;nomethod&quot;</tt>. In this
example the <tt>&quot;nomethod&quot;</tt> subroutine returns
an object which encapsulates operations done over the
objects: <tt>&quot;symbolic&minus;&gt;new(3)&quot;</tt>
contains <tt>&quot;['n', 3]&quot;</tt>, <tt>&quot;2 +
symbolic&minus;&gt;new(3)&quot;</tt> contains
<tt>&quot;['+', 2, ['n', 3]]&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of the script which &quot;calculates&quot; the side
of circumscribed octagon using the above package:</p>

<pre style="margin-left:11%; margin-top: 1em">  require symbolic;
  my $iter = 1;                 # 2**($iter+2) = 8
  my $side = symbolic&minus;&gt;new(1);
  my $cnt = $iter;
  while ($cnt&minus;&minus;) {
    $side = (sqrt(1 + $side**2) &minus; 1)/$side;
  }
  print &quot;OK\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The value of
<tt>$side</tt> is</p>

<pre style="margin-left:11%; margin-top: 1em">  ['/', ['&minus;', ['sqrt', ['+', 1, ['**', ['n', 1], 2]],
                       undef], 1], ['n', 1]]</pre>


<p style="margin-left:11%; margin-top: 1em">Note that while
we obtained this value using a nice little script, there is
no simple way to <i>use</i> this value. In fact this value
may be inspected in debugger (see perldebug), but only if
<tt>&quot;bareStringify&quot;</tt> <b>O</b>ption is set, and
not via <tt>&quot;p&quot;</tt> command.</p>

<p style="margin-left:11%; margin-top: 1em">If one attempts
to print this value, then the overloaded operator
<tt>&quot;&quot;</tt> will be called, which will call
<tt>&quot;nomethod&quot;</tt> operator. The result of this
operator will be stringified again, but this result is again
of type <tt>&quot;symbolic&quot;</tt>, which will lead to an
infinite loop.</p>

<p style="margin-left:11%; margin-top: 1em">Add a
pretty-printer method to the module <i>symbolic.pm</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub pretty {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    $b = 'u' unless defined $b;
    $a = $a&minus;&gt;pretty if ref $a;
    $b = $b&minus;&gt;pretty if ref $b;
    &quot;[$meth $a $b]&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Now one can
finish the script by</p>

<pre style="margin-left:11%; margin-top: 1em">  print &quot;side = &quot;, $side&minus;&gt;pretty, &quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The method
<tt>&quot;pretty&quot;</tt> is doing object-to-string
conversion, so it is natural to overload the operator
<tt>&quot;&quot;</tt> using this method. However, inside
such a method it is not necessary to pretty-print the
<i>components</i> <tt>$a</tt> and <tt>$b</tt> of an object.
In the above subroutine <tt>&quot;[$meth $a $b]&quot;</tt>
is a catenation of some strings and components <tt>$a</tt>
and <tt>$b</tt>. If these components use overloading, the
catenation operator will look for an overloaded operator
<tt>&quot;.&quot;</tt>; if not present, it will look for an
overloaded operator <tt>&quot;&quot;</tt>. Thus it is enough
to use</p>

<pre style="margin-left:11%; margin-top: 1em">  use overload nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str;
  sub str {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    $b = 'u' unless defined $b;
    &quot;[$meth $a $b]&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Now one can
change the last line of the script to</p>

<pre style="margin-left:11%; margin-top: 1em">  print &quot;side = $side\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">which
outputs</p>

<pre style="margin-left:11%; margin-top: 1em">  side = [/ [&minus; [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]</pre>


<p style="margin-left:11%; margin-top: 1em">and one can
inspect the value in debugger using all the possible
methods.</p>

<p style="margin-left:11%; margin-top: 1em">Something is
still amiss: consider the loop variable <tt>$cnt</tt> of the
script. It was a number, not an object. We cannot make this
value of type <tt>&quot;symbolic&quot;</tt>, since then the
loop will not terminate.</p>

<p style="margin-left:11%; margin-top: 1em">Indeed, to
terminate the cycle, the <tt>$cnt</tt> should become false.
However, the operator <tt>&quot;bool&quot;</tt> for checking
falsity is overloaded (this time via overloaded
<tt>&quot;&quot;</tt>), and returns a long string, thus any
object of type <tt>&quot;symbolic&quot;</tt> is true. To
overcome this, we need a way to compare an object to 0. In
fact, it is easier to write a numeric conversion
routine.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
text of <i>symbolic.pm</i> with such a routine added (and
slightly modified <i>str()</i>):</p>

<pre style="margin-left:11%; margin-top: 1em">  package symbolic;             # Primitive symbolic calculator
  use overload
    nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str, '0+' =&gt; \&amp;num;
  sub new { shift; bless ['n', @_] }
  sub wrap {
    my ($obj, $other, $inv, $meth) = @_;
    ($obj, $other) = ($other, $obj) if $inv;
    bless [$meth, $obj, $other];
  }
  sub str {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    if (defined $b) {
      &quot;[$meth $a $b]&quot;;
    } else {
      &quot;[$meth $a]&quot;;
    }
  }
  my %subr = ( n =&gt; sub {$_[0]},
               sqrt =&gt; sub {sqrt $_[0]},
               '&minus;' =&gt; sub {shift() &minus; shift()},
               '+' =&gt; sub {shift() + shift()},
               '/' =&gt; sub {shift() / shift()},
               '*' =&gt; sub {shift() * shift()},
               '**' =&gt; sub {shift() ** shift()},
             );
  sub num {
    my ($meth, $a, $b) = @{+shift};
    my $subr = $subr{$meth}
      or die &quot;Do not know how to ($meth) in symbolic&quot;;
    $a = $a&minus;&gt;num if ref $a eq __PACKAGE__;
    $b = $b&minus;&gt;num if ref $b eq __PACKAGE__;
    $subr&minus;&gt;($a,$b);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">All the work of
numeric conversion is done in <tt>%subr</tt> and
<i>num()</i>. Of course, <tt>%subr</tt> is not complete, it
contains only operators used in the example below. Here is
the extra-credit question: why do we need an explicit
recursion in <i>num()</i>? (Answer is at the end of this
section.)</p>

<p style="margin-left:11%; margin-top: 1em">Use this module
like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  require symbolic;
  my $iter = symbolic&minus;&gt;new(2);  # 16&minus;gon
  my $side = symbolic&minus;&gt;new(1);
  my $cnt = $iter;
  while ($cnt) {
    $cnt = $cnt &minus; 1;            # Mutator '&minus;&minus;' not implemented
    $side = (sqrt(1 + $side**2) &minus; 1)/$side;
  }
  printf &quot;%s=%f\n&quot;, $side, $side;
  printf &quot;pi=%f\n&quot;, $side*(2**($iter+2));</pre>


<p style="margin-left:11%; margin-top: 1em">It prints
(without so many line breaks)</p>

<pre style="margin-left:11%; margin-top: 1em">  [/ [&minus; [sqrt [+ 1 [** [/ [&minus; [sqrt [+ 1 [** [n 1] 2]]] 1]
                          [n 1]] 2]]] 1]
     [/ [&minus; [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
  pi=3.182598</pre>


<p style="margin-left:11%; margin-top: 1em">The above
module is very primitive. It does not implement mutator
methods (<tt>&quot;++&quot;</tt>,
<tt>&quot;&minus;=&quot;</tt> and so on), does not do deep
copying (not required without mutators!), and implements
only those arithmetic operations which are used in the
example.</p>

<p style="margin-left:11%; margin-top: 1em">To implement
most arithmetic operations is easy; one should just use the
tables of operations, and change the code which fills
<tt>%subr</tt> to</p>

<pre style="margin-left:11%; margin-top: 1em">  my %subr = ( 'n' =&gt; sub {$_[0]} );
  foreach my $op (split &quot; &quot;, $overload::ops{with_assign}) {
    $subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  my @bins = qw(binary 3way_comparison num_comparison str_comparison);
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{ @bins }&quot;) {
    $subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{qw(unary func)}&quot;) {
    print &quot;defining '$op'\n&quot;;
    $subr{$op} = eval &quot;sub {$op shift()}&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Since
subroutines implementing assignment operators are not
required to modify their operands (see &quot;Overloadable
Operations&quot; above), we do not need anything special to
make <tt>&quot;+=&quot;</tt> and friends work, besides
adding these operators to <tt>%subr</tt> and defining a copy
constructor (needed since Perl has no way to know that the
implementation of <tt>'+='</tt> does not mutate the argument
&minus; see &quot;Copy Constructor&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">To implement a
copy constructor, add <tt>&quot;'=' =&gt;
\&amp;cpy&quot;</tt> to <tt>&quot;use overload&quot;</tt>
line, and code (this code assumes that mutators change
things one level deep only, so recursive copying is not
needed):</p>

<pre style="margin-left:11%; margin-top: 1em">  sub cpy {
    my $self = shift;
    bless [@$self], ref $self;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">To make
<tt>&quot;++&quot;</tt> and
<tt>&quot;&minus;&minus;&quot;</tt> work, we need to
implement actual mutators, either directly, or in
<tt>&quot;nomethod&quot;</tt>. We continue to do things
inside <tt>&quot;nomethod&quot;</tt>, thus add</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($meth eq '++' or $meth eq '&minus;&minus;') {
      @$obj = ($meth, (bless [@$obj]), 1); # Avoid circular reference
      return $obj;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">after the first
line of <i>wrap()</i>. This is not a most effective
implementation, one may consider</p>

<pre style="margin-left:11%; margin-top: 1em">  sub inc { $_[0] = bless ['++', shift, 1]; }</pre>


<p style="margin-left:11%; margin-top: 1em">instead.</p>

<p style="margin-left:11%; margin-top: 1em">As a final
remark, note that one can fill <tt>%subr</tt> by</p>

<pre style="margin-left:11%; margin-top: 1em">  my %subr = ( 'n' =&gt; sub {$_[0]} );
  foreach my $op (split &quot; &quot;, $overload::ops{with_assign}) {
    $subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  my @bins = qw(binary 3way_comparison num_comparison str_comparison);
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{ @bins }&quot;) {
    $subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{qw(unary func)}&quot;) {
    $subr{$op} = eval &quot;sub {$op shift()}&quot;;
  }
  $subr{'++'} = $subr{'+'};
  $subr{'&minus;&minus;'} = $subr{'&minus;'};</pre>


<p style="margin-left:11%; margin-top: 1em">This finishes
implementation of a primitive symbolic calculator in 50
lines of Perl code. Since the numeric values of
subexpressions are not cached, the calculator is very
slow.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
answer for the exercise: In the case of <i>str()</i>, we
need no explicit recursion since the overloaded
<tt>&quot;.&quot;</tt>&minus;operator will fall back to an
existing overloaded operator <tt>&quot;&quot;</tt>.
Overloaded arithmetic operators <i>do not</i> fall back to
numeric conversion if <tt>&quot;fallback&quot;</tt> is not
explicitly requested. Thus without an explicit recursion
<i>num()</i> would convert <tt>&quot;['+', $a,
$b]&quot;</tt> to <tt>&quot;$a + $b&quot;</tt>, which would
just rebuild the argument of <i>num()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If you wonder
why defaults for conversion are different for <i>str()</i>
and <i>num()</i>, note how easy it was to write the symbolic
calculator. This simplicity is due to an appropriate choice
of defaults. One extra note: due to the explicit recursion
<i>num()</i> is more fragile than <i>sym()</i>: we need to
explicitly check for the type of <tt>$a</tt> and
<tt>$b</tt>. If components <tt>$a</tt> and <tt>$b</tt>
happen to be of some related type, this may lead to
problems.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Really</i>
<b>Symbolic Calculator</b> <br>
One may wonder why we call the above calculator symbolic.
The reason is that the actual calculation of the value of
expression is postponed until the value is <i>used</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To see it in
action, add a method</p>

<pre style="margin-left:11%; margin-top: 1em">  sub STORE {
    my $obj = shift;
    $#$obj = 1;
    @$obj&minus;&gt;[0,1] = ('=', shift);
  }</pre>


<p style="margin-left:11%; margin-top: 1em">to the package
<tt>&quot;symbolic&quot;</tt>. After this change one can
do</p>

<pre style="margin-left:11%; margin-top: 1em">  my $a = symbolic&minus;&gt;new(3);
  my $b = symbolic&minus;&gt;new(4);
  my $c = sqrt($a**2 + $b**2);</pre>


<p style="margin-left:11%; margin-top: 1em">and the numeric
value of <tt>$c</tt> becomes 5. However, after calling</p>

<pre style="margin-left:11%; margin-top: 1em">  $a&minus;&gt;STORE(12);  $b&minus;&gt;STORE(5);</pre>


<p style="margin-left:11%; margin-top: 1em">the numeric
value of <tt>$c</tt> becomes 13. There is no doubt now that
the module symbolic provides a <i>symbolic</i> calculator
indeed.</p>

<p style="margin-left:11%; margin-top: 1em">To hide the
rough edges under the hood, provide a <i>tie()</i>d
interface to the package <tt>&quot;symbolic&quot;</tt>. Add
methods</p>

<pre style="margin-left:11%; margin-top: 1em">  sub TIESCALAR { my $pack = shift; $pack&minus;&gt;new(@_) }
  sub FETCH { shift }
  sub nop {  }          # Around a bug</pre>


<p style="margin-left:11%; margin-top: 1em">(the bug, fixed
in Perl 5.14, is described in &quot; <small>BUGS</small>
&quot;). One can use this new interface as</p>

<pre style="margin-left:11%; margin-top: 1em">  tie $a, 'symbolic', 3;
  tie $b, 'symbolic', 4;
  $a&minus;&gt;nop;  $b&minus;&gt;nop;    # Around a bug
  my $c = sqrt($a**2 + $b**2);</pre>


<p style="margin-left:11%; margin-top: 1em">Now numeric
value of <tt>$c</tt> is 5. After <tt>&quot;$a = 12; $b =
5&quot;</tt> the numeric value of <tt>$c</tt> becomes 13. To
insulate the user of the module add a method</p>

<pre style="margin-left:11%; margin-top: 1em">  sub vars { my $p = shift; tie($_, $p), $_&minus;&gt;nop foreach @_; }</pre>


<p style="margin-left:11%; margin-top: 1em">Now</p>

<pre style="margin-left:11%; margin-top: 1em">  my ($a, $b);
  symbolic&minus;&gt;vars($a, $b);
  my $c = sqrt($a**2 + $b**2);
  $a = 3; $b = 4;
  printf &quot;c5  %s=%f\n&quot;, $c, $c;
  $a = 12; $b = 5;
  printf &quot;c13  %s=%f\n&quot;, $c, $c;</pre>


<p style="margin-left:11%; margin-top: 1em">shows that the
numeric value of <tt>$c</tt> follows changes to the values
of <tt>$a</tt> and <tt>$b</tt>.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Ilya
Zakharevich
&lt;<i>ilya@math.mps.ohio&minus;state.edu</i>&gt;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;overloading&quot;</tt> pragma can be used to
enable or disable overloaded operations within a lexical
scope &minus; see overloading.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When Perl is
run with the <b>&minus;Do</b> switch or its equivalent,
overloading induces diagnostic messages.</p>

<p style="margin-left:11%; margin-top: 1em">Using the
<tt>&quot;m&quot;</tt> command of Perl debugger (see
perldebug) one can deduce which operations are overloaded
(and which ancestor triggers this overloading). Say, if
<tt>&quot;eq&quot;</tt> is overloaded, then the method
<tt>&quot;(eq&quot;</tt> is shown by debugger. The method
<tt>&quot;()&quot;</tt> corresponds to the
<tt>&quot;fallback&quot;</tt> key (in fact a presence of
this method shows that this package has overloading enabled,
and it is what is used by the
<tt>&quot;Overloaded&quot;</tt> function of module
<tt>&quot;overload&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">The module
might issue the following warnings: <br>
Odd number of arguments for overload::constant</p>

<p style="margin-left:17%;">(W) The call to
overload::constant contained an odd number of arguments. The
arguments should come in pairs.</p>

<p style="margin-left:11%;">&rsquo;%s&rsquo; is not an
overloadable type</p>

<p style="margin-left:17%;">(W) You tried to overload a
constant type the overload package is unaware of.</p>

<p style="margin-left:11%;">&rsquo;%s&rsquo; is not a code
reference</p>

<p style="margin-left:17%;">(W) The second (fourth, sixth,
...) argument of overload::constant needs to be a code
reference. Either an anonymous subroutine, or a reference to
a subroutine.</p>

<p style="margin-left:11%;">overload arg &rsquo;%s&rsquo;
is invalid</p>

<p style="margin-left:17%;">(W) <tt>&quot;use
overload&quot;</tt> was passed an argument it did not
recognize. Did you mistype an operator?</p>

<h2>BUGS AND PITFALLS
<a name="BUGS AND PITFALLS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">No warning is issued for invalid
<tt>&quot;use overload&quot;</tt> keys. Such errors are not
always obvious:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">        use overload &quot;+0&quot; =&gt; sub { ...; },   # should be &quot;0+&quot;
            &quot;not&quot; =&gt; sub { ...; };           # should be &quot;!&quot;</pre>


<p style="margin-left:17%; margin-top: 1em">(Bug
#74098)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A pitfall when fallback is
<small>TRUE</small> and Perl resorts to a built-in
implementation of an operator is that some operators have
more than one semantic, for example
<tt>&quot;|&quot;</tt>:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">        use overload '0+' =&gt; sub { $_[0]&minus;&gt;{n}; },
            fallback =&gt; 1;
        my $x = bless { n =&gt; 4 }, &quot;main&quot;;
        my $y = bless { n =&gt; 8 }, &quot;main&quot;;
        print $x | $y, &quot;\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">You might
expect this to output &quot;12&quot;. In fact, it prints
&quot;&lt;&quot;: the <small>ASCII</small> result of
treating &quot;|&quot; as a bitwise string operator &minus;
that is, the result of treating the operands as the strings
&quot;4&quot; and &quot;8&quot; rather than numbers. The
fact that numify (<tt>&quot;0+&quot;</tt>) is implemented
but stringify (<tt>&quot;&quot;</tt>) isn&rsquo;t makes no
difference since the latter is simply autogenerated from the
former.</p>

<p style="margin-left:17%; margin-top: 1em">The only way to
change this is to provide your own subroutine for
<tt>'|'</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Magic autogeneration increases
the potential for inadvertently creating self-referential
structures. Currently Perl will not free self-referential
structures until cycles are explicitly broken. For
example,</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    use overload '+' =&gt; 'add';
    sub add { bless [ \$_[0], \$_[1] ] };</pre>


<p style="margin-left:17%; margin-top: 1em">is asking for
trouble, since</p>

<pre style="margin-left:17%; margin-top: 1em">    $obj += $y;</pre>


<p style="margin-left:17%; margin-top: 1em">will
effectively become</p>

<pre style="margin-left:17%; margin-top: 1em">    $obj = add($obj, $y, undef);</pre>


<p style="margin-left:17%; margin-top: 1em">with the same
result as</p>

<pre style="margin-left:17%; margin-top: 1em">    $obj = [\$obj, \$foo];</pre>


<p style="margin-left:17%; margin-top: 1em">Even if no
<i>explicit</i> assignment-variants of operators are present
in the script, they may be generated by the optimizer. For
example,</p>

<pre style="margin-left:17%; margin-top: 1em">    &quot;obj = $obj\n&quot;</pre>


<p style="margin-left:17%; margin-top: 1em">may be
optimized to</p>

<pre style="margin-left:17%; margin-top: 1em">    my $tmp = 'obj = ' . $obj;  $tmp .= &quot;\n&quot;;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Because it is used for
overloading, the per-package hash <tt>%OVERLOAD</tt> now has
a special meaning in Perl. The symbol table is filled with
names looking like line-noise.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>For the purpose of inheritance every overloaded package
behaves as if <tt>&quot;fallback&quot;</tt> is present
(possibly undefined). This may create interesting effects if
some package is not overloaded, but inherits from two
overloaded packages.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Before Perl 5.14, the relation between overloading and
<i>tie()</i>ing was broken. Overloading was triggered or not
based on the <i>previous</i> class of the <i>tie()</i>d
variable.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This happened
because the presence of overloading was checked too early,
before any <i>tie()</i>d access was attempted. If the class
of the value <i><small>FETCH</small> ()</i>ed from the tied
variable does not change, a simple workaround for code that
is to run on older Perl versions is to access the value (via
<tt>&quot;() = $foo&quot;</tt> or some such) immediately
after <i>tie()</i>ing, so that after this call the
<i>previous</i> class coincides with the current one.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Barewords are not covered by
overloaded string constants.</p></td></tr>
 </table>
<hr>
</body>
</html>
