<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:53 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_LimitCheck</title>

</head>
<body>

<h1 align="center">Tcl_LimitCheck</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#LIMIT CHECKING API">LIMIT CHECKING API</a><br>
<a href="#LIMIT CONFIGURATION">LIMIT CONFIGURATION</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_LimitAddHandler,
Tcl_LimitCheck, Tcl_LimitExceeded, Tcl_LimitGetCommands,
Tcl_LimitGetGranularity, Tcl_LimitGetTime, Tcl_LimitReady,
Tcl_LimitRemoveHandler, Tcl_LimitSetCommands,
Tcl_LimitSetGranularity, Tcl_LimitSetTime,
Tcl_LimitTypeEnabled, Tcl_LimitTypeExceeded,
Tcl_LimitTypeReset, Tcl_LimitTypeSet &minus; manage and
check resource limits on interpreters</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitCheck</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitReady</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitExceeded</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitTypeExceeded</b>(<i>interp, type</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitTypeEnabled</b>(<i>interp, type</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitTypeSet</b>(<i>interp, type</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitTypeReset</b>(<i>interp, type</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitGetCommands</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitSetCommands</b>(<i>interp, commandLimit</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitGetTime</b>(<i>interp, timeLimitPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitSetTime</b>(<i>interp, timeLimitPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_LimitGetGranularity</b>(<i>interp, type</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitSetGranularity</b>(<i>interp, type,
granularity</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitAddHandler</b>(<i>interp, type, handlerProc,
clientData, deleteProc</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_LimitRemoveHandler</b>(<i>interp, type, handlerProc,
clientData</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p style="margin-top: 1em">Tcl_Interp <i>*interp</i>
(in)</p> </td>
<td width="17%"></td>
<td width="6%">


<p style="margin-top: 1em">Interpreter that the limit being
managed applies to or that will have its limits checked.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>int <i>type</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>The type of limit that the operation refers to. This
must be either <b>TCL_LIMIT_COMMANDS</b> or
<b>TCL_LIMIT_TIME</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>int <i>commandLimit</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>The maximum number of commands (as reported by <b>info
cmdcount</b>) that may be executed in the interpreter.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>Tcl_Time <i>*timeLimitPtr</i> (in/out)</p></td>
<td width="17%"></td>
<td width="6%">


<p>A pointer to a structure that will either have the new
time limit read from (<b>Tcl_LimitSetTime</b>) or the
current time limit written to (<b>Tcl_LimitGetTime</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>int <i>granularity</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>Divisor that indicates how often a particular limit
should really be checked. Must be at least 1.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>Tcl_LimitHandlerProc <i>*handlerProc</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>Function to call when a particular limit is exceeded. If
the <i>handlerProc</i> removes or raises the limit during
its processing, the limited interpreter will be permitted to
continue to process after the handler returns. Many handlers
may be attached to the same interpreter limit; their order
of execution is not defined, and they must be identified by
<i>handlerProc</i> and <i>clientData</i> when they are
deleted.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>ClientData <i>clientData</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>Arbitrary pointer-sized word used to pass some context
to the <i>handlerProc</i> function.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p>Tcl_LimitHandlerDeleteProc <i>*deleteProc</i> (in)</p></td>
<td width="17%"></td>
<td width="6%">


<p>Function to call whenever a handler is deleted. May be
NULL if the <i>clientData</i> requires no deletion.</p></td></tr>
</table>


<p style="margin-left:94%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl&rsquo;s
interpreter resource limit subsystem allows for close
control over how much computation time a script may use, and
is useful for cases where a program is divided into multiple
pieces where some parts are more trusted than others (e.g.
web application servers).</p>

<p style="margin-left:11%; margin-top: 1em">Every
interpreter may have a limit on the wall-time for execution,
and a limit on the number of commands that the interpreter
may execute. Since checking of these limits is potentially
expensive (especially the time limit), each limit also has a
checking granularity, which is a divisor for an internal
count of the number of points in the core where a check may
be performed (which is immediately before executing a
command and at an unspecified frequency between running
commands, which can happen in empty-bodied <b>while</b>
loops).</p>

<p style="margin-left:11%; margin-top: 1em">The final
component of the limit engine is a callback scheme which
allows for notifications of when a limit has been exceeded.
These callbacks can just provide logging, or may allocate
more resources to the interpreter to permit it to continue
processing longer.</p>

<p style="margin-left:11%; margin-top: 1em">When a limit is
exceeded (and the callbacks have run; the order of execution
of the callbacks is unspecified) execution in the limited
interpreter is stopped by raising an error and setting a
flag that prevents the <b>catch</b> command in that
interpreter from trapping that error. It is up to the
context that started execution in that interpreter
(typically a master interpreter) to handle the error.</p>

<h2>LIMIT CHECKING API
<a name="LIMIT CHECKING API"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To check the
resource limits for an interpreter, call
<b>Tcl_LimitCheck</b>, which returns <b>TCL_OK</b> if the
limit was not exceeded (after processing callbacks) and
<b>TCL_ERROR</b> if the limit was exceeded (in which case an
error message is also placed in the interpreter result).
That function should only be called when
<b>Tcl_LimitReady</b> returns non-zero so that granularity
policy is enforced. This API is designed to be similar in
usage to <b>Tcl_AsyncReady</b> and
<b>Tcl_AsyncInvoke</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When writing
code that may behave like <b>catch</b> in respect of errors,
you should only trap an error if <b>Tcl_LimitExceeded</b>
returns zero. If it returns non-zero, the interpreter is in
a limit-exceeded state and errors should be allowed to
propagate to the calling context. You can also check whether
a particular type of limit has been exceeded using
<b>Tcl_LimitTypeExceeded</b>.</p>

<h2>LIMIT CONFIGURATION
<a name="LIMIT CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To check
whether a limit has been set (but not whether it has
actually been exceeded) on an interpreter, call
<b>Tcl_LimitTypeEnabled</b> with the type of limit you want
to check. To enable a particular limit call
<b>Tcl_LimitTypeSet</b>, and to disable a limit call
<b>Tcl_LimitTypeReset</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The level of a
command limit may be set using <b>Tcl_LimitSetCommands</b>,
and retrieved using <b>Tcl_LimitGetCommands</b>. Similarly
for a time limit with <b>Tcl_LimitSetTime</b> and
<b>Tcl_LimitGetTime</b> respectively, but with that API the
time limit is copied from and to the Tcl_Time structure that
the <i>timeLimitPtr</i> argument points to.</p>

<p style="margin-left:11%; margin-top: 1em">The checking
granularity for a particular limit may be set using
<b>Tcl_LimitSetGranularity</b> and retrieved using
<b>Tcl_LimitGetGranularity</b>. Note that granularities must
always be positive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIMIT
CALLBACKS</b> <br>
To add a handler callback to be invoked when a limit is
exceeded, call <b>Tcl_LimitAddHandler</b>. The
<i>handlerProc</i> argument describes the function that will
actually be called; it should have the following
prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_LimitHandlerProc( <br>
ClientData <i>clientData</i>, <br>
Tcl_Interp *<i>interp</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>clientData</i> argument to the handler will be whatever
is passed to the <i>clientData</i> argument to
<b>Tcl_LimitAddHandler</b>, and the <i>interp</i> is the
interpreter that had its limit exceeded.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>deleteProc</i> argument to <b>Tcl_LimitAddHandler</b> is
a function to call to delete the <i>clientData</i> value. It
may be <b>TCL_STATIC</b> or NULL if no deletion action is
necessary, or <b>TCL_DYNAMIC</b> if all that is necessary is
to free the structure with <b>Tcl_Free</b>. Otherwise, it
should refer to a function with the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_LimitHandlerDeleteProc( <br>
ClientData <i>clientData</i>);</p>

<p style="margin-left:11%; margin-top: 1em">A limit handler
may be deleted using <b>Tcl_LimitRemoveHandler</b>; the
handler removed will be the first one found (out of the
handlers added with <b>Tcl_LimitAddHandler</b>) with exactly
matching <i>type</i>, <i>handlerProc</i> and
<i>clientData</i> arguments. This function always invokes
the <i>deleteProc</i> on the <i>clientData</i> (unless the
<i>deleteProc</i> was NULL or <b>TCL_STATIC</b>).</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">interpreter,
resource, limit, commands, time, callback</p>
<hr>
</body>
</html>
