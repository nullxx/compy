<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:09:11 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PCREAPI</title>

</head>
<body>

<h1 align="center">PCREAPI</h1>

<a href="#NAME">NAME</a><br>
<a href="#PCRE NATIVE API BASIC FUNCTIONS">PCRE NATIVE API BASIC FUNCTIONS</a><br>
<a href="#PCRE NATIVE API STRING EXTRACTION FUNCTIONS">PCRE NATIVE API STRING EXTRACTION FUNCTIONS</a><br>
<a href="#PCRE NATIVE API AUXILIARY FUNCTIONS">PCRE NATIVE API AUXILIARY FUNCTIONS</a><br>
<a href="#PCRE NATIVE API INDIRECTED FUNCTIONS">PCRE NATIVE API INDIRECTED FUNCTIONS</a><br>
<a href="#PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES">PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</a><br>
<a href="#PCRE API OVERVIEW">PCRE API OVERVIEW</a><br>
<a href="#NEWLINES">NEWLINES</a><br>
<a href="#MULTITHREADING">MULTITHREADING</a><br>
<a href="#SAVING PRECOMPILED PATTERNS FOR LATER USE">SAVING PRECOMPILED PATTERNS FOR LATER USE</a><br>
<a href="#CHECKING BUILD-TIME OPTIONS">CHECKING BUILD-TIME OPTIONS</a><br>
<a href="#COMPILING A PATTERN">COMPILING A PATTERN</a><br>
<a href="#COMPILATION ERROR CODES">COMPILATION ERROR CODES</a><br>
<a href="#STUDYING A PATTERN">STUDYING A PATTERN</a><br>
<a href="#LOCALE SUPPORT">LOCALE SUPPORT</a><br>
<a href="#INFORMATION ABOUT A PATTERN">INFORMATION ABOUT A PATTERN</a><br>
<a href="#REFERENCE COUNTS">REFERENCE COUNTS</a><br>
<a href="#MATCHING A PATTERN: THE TRADITIONAL FUNCTION">MATCHING A PATTERN: THE TRADITIONAL FUNCTION</a><br>
<a href="#EXTRACTING CAPTURED SUBSTRINGS BY NUMBER">EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</a><br>
<a href="#EXTRACTING CAPTURED SUBSTRINGS BY NAME">EXTRACTING CAPTURED SUBSTRINGS BY NAME</a><br>
<a href="#DUPLICATE SUBPATTERN NAMES">DUPLICATE SUBPATTERN NAMES</a><br>
<a href="#FINDING ALL POSSIBLE MATCHES">FINDING ALL POSSIBLE MATCHES</a><br>
<a href="#OBTAINING AN ESTIMATE OF STACK USAGE">OBTAINING AN ESTIMATE OF STACK USAGE</a><br>
<a href="#MATCHING A PATTERN: THE ALTERNATIVE FUNCTION">MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#REVISION">REVISION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PCRE -
Perl-compatible regular expressions</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;pcre.h&gt;</b></p>

<h2>PCRE NATIVE API BASIC FUNCTIONS
<a name="PCRE NATIVE API BASIC FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b><small>pcre
*pcre_compile(const char
*</small></b><small><i>pattern</i><b>, int</b>
<i>options</i><b>,</b></small> <b><br>
const char **</b><i>errptr</i><b>, int
*</b><i>erroffset</i><b>, <br>
const unsigned char *</b><i>tableptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pcre
*pcre_compile2(const char *</b><i>pattern</i><b>, int</b>
<i>options</i><b>, <br>
int *</b><i>errorcodeptr</i><b>, <br>
const char **</b><i>errptr</i><b>, int
*</b><i>erroffset</i><b>, <br>
const unsigned char *</b><i>tableptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pcre_extra
*pcre_study(const pcre *</b><i>code</i><b>, int</b>
<i>options</i><b>, <br>
const char **</b><i>errptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pcre_free_study(pcre_extra *</b><i>extra</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_exec(const pcre *</b><i>code</i><b>, const pcre_extra
*</b><i>extra</i><b>, <br>
const char *</b><i>subject</i><b>, int</b> <i>length</i><b>,
int</b> <i>startoffset</i><b>, <br>
int</b> <i>options</i><b>, int *</b><i>ovector</i><b>,
int</b> <i>ovecsize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_dfa_exec(const pcre *</b><i>code</i><b>, const
pcre_extra *</b><i>extra</i><b>, <br>
const char *</b><i>subject</i><b>, int</b> <i>length</i><b>,
int</b> <i>startoffset</i><b>, <br>
int</b> <i>options</i><b>, int *</b><i>ovector</i><b>,
int</b> <i>ovecsize</i><b>, <br>
int *</b><i>workspace</i><b>, int</b>
<i>wscount</i><b>);</b></p>

<h2>PCRE NATIVE API STRING EXTRACTION FUNCTIONS
<a name="PCRE NATIVE API STRING EXTRACTION FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_copy_named_substring(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, const char
*</b><i>stringname</i><b>, <br>
char *</b><i>buffer</i><b>, int</b>
<i>buffersize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_copy_substring(const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, int</b>
<i>stringnumber</i><b>, char *</b><i>buffer</i><b>, <br>
int</b> <i>buffersize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_named_substring(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, const char
*</b><i>stringname</i><b>, <br>
const char **</b><i>stringptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_stringnumber(const pcre *</b><i>code</i><b>, <br>
const char *</b><i>name</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_stringtable_entries(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>name</i><b>, char **</b><i>first</i><b>,
char **</b><i>last</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_substring(const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, int</b>
<i>stringnumber</i><b>, <br>
const char **</b><i>stringptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_substring_list(const char *</b><i>subject</i><b>,
<br>
int *</b><i>ovector</i><b>, int</b> <i>stringcount</i><b>,
const char ***</b><i>listptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pcre_free_substring(const char
*</b><i>stringptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pcre_free_substring_list(const char
**</b><i>stringptr</i><b>);</b></p>

<h2>PCRE NATIVE API AUXILIARY FUNCTIONS
<a name="PCRE NATIVE API AUXILIARY FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_jit_exec(const pcre *</b><i>code</i><b>, const
pcre_extra *</b><i>extra</i><b>, <br>
const char *</b><i>subject</i><b>, int</b> <i>length</i><b>,
int</b> <i>startoffset</i><b>, <br>
int</b> <i>options</i><b>, int *</b><i>ovector</i><b>,
int</b> <i>ovecsize</i><b>, <br>
pcre_jit_stack *</b><i>jstack</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>pcre_jit_stack
*pcre_jit_stack_alloc(int</b> <i>startsize</i><b>, int</b>
<i>maxsize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pcre_jit_stack_free(pcre_jit_stack
*</b><i>stack</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pcre_assign_jit_stack(pcre_extra *</b><i>extra</i><b>, <br>
pcre_jit_callback</b> <i>callback</i><b>, void
*</b><i>data</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const
unsigned char *pcre_maketables(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_fullinfo(const pcre *</b><i>code</i><b>, const
pcre_extra *</b><i>extra</i><b>, <br>
int</b> <i>what</i><b>, void *</b><i>where</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_refcount(pcre *</b><i>code</i><b>, int</b>
<i>adjust</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_config(int</b> <i>what</i><b>, void
*</b><i>where</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*pcre_version(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_pattern_to_host_byte_order(pcre *</b><i>code</i><b>,
<br>
pcre_extra *</b><i>extra</i><b>, const unsigned char
*</b><i>tables</i><b>);</b></p>

<h2>PCRE NATIVE API INDIRECTED FUNCTIONS
<a name="PCRE NATIVE API INDIRECTED FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>void
*(*pcre_malloc)(size_t);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
(*pcre_free)(void *);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*(*pcre_stack_malloc)(size_t);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
(*pcre_stack_free)(void *);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
(*pcre_callout)(pcre_callout_block *);</b></p>

<h2>PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES
<a name="PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As well as
support for 8-bit character strings, PCRE also supports
16-bit strings (from release 8.30) and 32-bit strings (from
release 8.32), by means of two additional libraries. They
can be built as well as, or instead of, the 8-bit library.
To avoid too much complication, this document describes the
8-bit versions of the functions, with only occasional
references to the 16-bit and 32-bit libraries.</p>

<p style="margin-left:11%; margin-top: 1em">The 16-bit and
32-bit functions operate in the same way as their 8-bit
counterparts; they just use different data types for their
arguments and results, and their names start with
<b>pcre16_</b> or <b>pcre32_</b> instead of <b>pcre_</b>.
For every option that has UTF8 in its name (for example,
PCRE_UTF8), there are corresponding 16-bit and 32-bit names
with UTF8 replaced by UTF16 or UTF32, respectively. This
facility is in fact just cosmetic; the 16-bit and 32-bit
option names define the same bit values.</p>

<p style="margin-left:11%; margin-top: 1em">References to
bytes and UTF-8 in this document should be read as
references to 16-bit data quantities and UTF-16 when using
the 16-bit library, or 32-bit data quantities and UTF-32
when using the 32-bit library, unless specified otherwise.
More details of the specific differences for the 16-bit and
32-bit libraries are given in the <b>pcre16</b> and
<b>pcre32</b> pages.</p>

<h2>PCRE API OVERVIEW
<a name="PCRE API OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PCRE has its
own native API, which is described in this document. There
are also some wrapper functions (for the 8-bit library only)
that correspond to the POSIX regular expression API, but
they do not give access to all the functionality. They are
described in the <b>pcreposix</b> documentation. Both of
these APIs define a set of C function calls. A C++ wrapper
(again for the 8-bit library only) is also distributed with
PCRE. It is documented in the <b>pcrecpp</b> page.</p>

<p style="margin-left:11%; margin-top: 1em">The native API
C function prototypes are defined in the header file
<b>pcre.h</b>, and on Unix-like systems the (8-bit) library
itself is called <b>libpcre</b>. It can normally be accessed
by adding <b>-lpcre</b> to the command for linking an
application that uses PCRE. The header file defines the
macros PCRE_MAJOR and PCRE_MINOR to contain the major and
minor release numbers for the library. Applications can use
these to include support for different releases of PCRE.</p>

<p style="margin-left:11%; margin-top: 1em">In a Windows
environment, if you want to statically link an application
program against a non-dll <b>pcre.a</b> file, you must
define PCRE_STATIC before including <b>pcre.h</b> or
<b>pcrecpp.h</b>, because otherwise the <b>pcre_malloc()</b>
and <b>pcre_free()</b> exported functions will be declared
<b>__declspec(dllimport)</b>, with unwanted results.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>pcre_compile()</b>, <b>pcre_compile2()</b>,
<b>pcre_study()</b>, and <b>pcre_exec()</b> are used for
compiling and matching regular expressions in a
Perl-compatible manner. A sample program that demonstrates
the simplest way of using them is provided in the file
called <i>pcredemo.c</i> in the PCRE source distribution. A
listing of this program is given in the <b>pcredemo</b>
documentation, and the <b>pcresample</b> documentation
describes how to compile and run it.</p>

<p style="margin-left:11%; margin-top: 1em">Just-in-time
compiler support is an optional feature of PCRE that can be
built in appropriate hardware environments. It greatly
speeds up the matching performance of many patterns. Simple
programs can easily request that it be used if available, by
setting an option that is ignored when it is not relevant.
More complicated programs might need to make use of the
functions <b>pcre_jit_stack_alloc()</b>,
<b>pcre_jit_stack_free()</b>, and
<b>pcre_assign_jit_stack()</b> in order to control the JIT
code&rsquo;s memory usage.</p>

<p style="margin-left:11%; margin-top: 1em">From release
8.32 there is also a direct interface for JIT execution,
which gives improved performance. The JIT-specific functions
are discussed in the <b>pcrejit</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">A second
matching function, <b>pcre_dfa_exec()</b>, which is not
Perl-compatible, is also provided. This uses a different
algorithm for the matching. The alternative algorithm finds
all possible matches (at a given point in the subject), and
scans the subject just once (unless there are lookbehind
assertions). However, this algorithm does not return
captured substrings. A description of the two matching
algorithms and their advantages and disadvantages is given
in the <b>pcrematching</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the main compiling and matching functions, there are
convenience functions for extracting captured substrings
from a subject string that is matched by <b>pcre_exec()</b>.
They are:</p>


<p style="margin-left:11%; margin-top: 1em"><b>pcre_copy_substring()
<br>
pcre_copy_named_substring() <br>
pcre_get_substring() <br>
pcre_get_named_substring() <br>
pcre_get_substring_list() <br>
pcre_get_stringnumber() <br>
pcre_get_stringtable_entries()</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>pcre_free_substring()</b>
and <b>pcre_free_substring_list()</b> are also provided, to
free the memory used for extracted strings.</p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_maketables()</b> is used to build a set of character
tables in the current locale for passing to
<b>pcre_compile()</b>, <b>pcre_exec()</b>, or
<b>pcre_dfa_exec()</b>. This is an optional facility that is
provided for specialist use. Most commonly, no special
tables are passed, in which case internal tables that are
generated when PCRE is built are used.</p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_fullinfo()</b> is used to find out information about
a compiled pattern. The function <b>pcre_version()</b>
returns a pointer to a string containing the version of PCRE
and its date of release.</p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_refcount()</b> maintains a reference count in a data
block containing a compiled pattern. This is provided for
the benefit of object-oriented applications.</p>

<p style="margin-left:11%; margin-top: 1em">The global
variables <b>pcre_malloc</b> and <b>pcre_free</b> initially
contain the entry points of the standard <b>malloc()</b> and
<b>free()</b> functions, respectively. PCRE calls the memory
management functions via these variables, so a calling
program can replace them if it wishes to intercept the
calls. This should be done before calling any PCRE
functions.</p>

<p style="margin-left:11%; margin-top: 1em">The global
variables <b>pcre_stack_malloc</b> and
<b>pcre_stack_free</b> are also indirections to memory
management functions. These special functions are used only
when PCRE is compiled to use the heap for remembering data,
instead of recursive function calls, when running the
<b>pcre_exec()</b> function. See the <b>pcrebuild</b>
documentation for details of how to do this. It is a
non-standard way of building PCRE, for use in environments
that have limited stacks. Because of the greater use of
memory management, it runs more slowly. Separate functions
are provided so that special-purpose external code can be
used for this case. When used, these functions are always
called in a stack-like manner (last obtained, first freed),
and always for memory blocks of the same size. There is a
discussion about PCRE&rsquo;s stack usage in the
<b>pcrestack</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The global
variable <b>pcre_callout</b> initially contains NULL. It can
be set by the caller to a &quot;callout&quot; function,
which PCRE will then call at specified points during a
matching operation. Details are given in the
<b>pcrecallout</b> documentation.</p>

<h2>NEWLINES
<a name="NEWLINES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PCRE supports
five different conventions for indicating line breaks in
strings: a single CR (carriage return) character, a single
LF (linefeed) character, the two-character sequence CRLF,
any of the three preceding, or any Unicode newline sequence.
The Unicode newline sequences are the three just mentioned,
plus the single characters VT (vertical tab, U+000B), FF
(form feed, U+000C), NEL (next line, U+0085), LS (line
separator, U+2028), and PS (paragraph separator,
U+2029).</p>

<p style="margin-left:11%; margin-top: 1em">Each of the
first three conventions is used by at least one operating
system as its standard newline sequence. When PCRE is built,
a default can be specified. The default default is LF, which
is the Unix standard. When PCRE is run, the default can be
overridden, either when a pattern is compiled, or when it is
matched.</p>

<p style="margin-left:11%; margin-top: 1em">At compile
time, the newline convention can be specified by the
<i>options</i> argument of <b>pcre_compile()</b>, or it can
be specified by special text at the start of the pattern
itself; this overrides any other settings. See the
<b>pcrepattern</b> page for details of the special character
sequences.</p>

<p style="margin-left:11%; margin-top: 1em">In the PCRE
documentation the word &quot;newline&quot; is used to mean
&quot;the character or pair of characters that indicate a
line break&quot;. The choice of newline convention affects
the handling of the dot, circumflex, and dollar
metacharacters, the handling of #-comments in /x mode, and,
when CRLF is a recognized line ending sequence, the match
position advancement for a non-anchored pattern. There is
more detail about this in the section on <b>pcre_exec()</b>
options below.</p>

<p style="margin-left:11%; margin-top: 1em">The choice of
newline convention does not affect the interpretation of the
\n or \r escape sequences, nor does it affect what \R
matches, which is controlled in a similar way, but by
separate options.</p>

<h2>MULTITHREADING
<a name="MULTITHREADING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The PCRE
functions can be used in multi-threading applications, with
the proviso that the memory management functions pointed to
by <b>pcre_malloc</b>, <b>pcre_free</b>,
<b>pcre_stack_malloc</b>, and <b>pcre_stack_free</b>, and
the callout function pointed to by <b>pcre_callout</b>, are
shared by all threads.</p>

<p style="margin-left:11%; margin-top: 1em">The compiled
form of a regular expression is not altered during matching,
so the same compiled pattern can safely be used by several
threads at once.</p>

<p style="margin-left:11%; margin-top: 1em">If the
just-in-time optimization feature is being used, it needs
separate memory stack areas for each thread. See the
<b>pcrejit</b> documentation for more details.</p>

<h2>SAVING PRECOMPILED PATTERNS FOR LATER USE
<a name="SAVING PRECOMPILED PATTERNS FOR LATER USE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The compiled
form of a regular expression can be saved and re-used at a
later time, possibly by a different program, and even on a
host other than the one on which it was compiled. Details
are given in the <b>pcreprecompile</b> documentation, which
includes a description of the
<b>pcre_pattern_to_host_byte_order()</b> function. However,
compiling a regular expression with one version of PCRE for
use with a different version is not guaranteed to work and
may cause crashes.</p>

<h2>CHECKING BUILD-TIME OPTIONS
<a name="CHECKING BUILD-TIME OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_config(int</b> <i>what</i><b>, void
*</b><i>where</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_config()</b> makes it possible for a PCRE client to
discover which optional features have been compiled into the
PCRE library. The <b>pcrebuild</b> documentation has more
details about these optional features.</p>

<p style="margin-left:11%; margin-top: 1em">The first
argument for <b>pcre_config()</b> is an integer, specifying
which information is required; the second argument is a
pointer to a variable into which the information is placed.
The returned value is zero on success, or the negative error
code PCRE_ERROR_BADOPTION if the value in the first argument
is not recognized. The following information is
available:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_UTF8</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if UTF-8 support is available;
otherwise it is set to zero. This value should normally be
given to the 8-bit version of this function,
<b>pcre_config()</b>. If it is given to the 16-bit or 32-bit
version of this function, the result is
PCRE_ERROR_BADOPTION.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_UTF16</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if UTF-16 support is
available; otherwise it is set to zero. This value should
normally be given to the 16-bit version of this function,
<b>pcre16_config()</b>. If it is given to the 8-bit or
32-bit version of this function, the result is
PCRE_ERROR_BADOPTION.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_UTF32</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if UTF-32 support is
available; otherwise it is set to zero. This value should
normally be given to the 32-bit version of this function,
<b>pcre32_config()</b>. If it is given to the 8-bit or
16-bit version of this function, the result is
PCRE_ERROR_BADOPTION.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_UNICODE_PROPERTIES</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if support for Unicode
character properties is available; otherwise it is set to
zero.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_JIT</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if support for just-in-time
compiling is available; otherwise it is set to zero.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_JITTARGET</p>

<p style="margin-left:11%; margin-top: 1em">The output is a
pointer to a zero-terminated &quot;const char *&quot;
string. If JIT support is available, the string contains the
name of the architecture for which the JIT compiler is
configured, for example &quot;x86 32bit (little endian +
unaligned)&quot;. If JIT support is not available, the
result is NULL.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_NEWLINE</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer whose value specifies the default character
sequence that is recognized as meaning &quot;newline&quot;.
The values that are supported in ASCII/Unicode environments
are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for ANYCRLF,
and -1 for ANY. In EBCDIC environments, CR, ANYCRLF, and ANY
yield the same values. However, the value for LF is normally
21, though some EBCDIC environments use 37. The
corresponding values for CRLF are 3349 and 3365. The default
should normally correspond to the standard sequence for your
operating system.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_BSR</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer whose value indicates what character sequences
the \R escape sequence matches by default. A value of 0
means that \R matches any Unicode line ending sequence; a
value of 1 means that \R matches only CR, LF, or CRLF. The
default can be overridden when a pattern is compiled or
matched.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_LINK_SIZE</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that contains the number of bytes used for
internal linkage in compiled regular expressions. For the
8-bit library, the value can be 2, 3, or 4. For the 16-bit
library, the value is either 2 or 4 and is still a number of
bytes. For the 32-bit library, the value is either 2 or 4
and is still a number of bytes. The default value of 2 is
sufficient for all but the most massive patterns, since it
allows the compiled pattern to be up to 64K in size. Larger
values allow larger regular expressions to be compiled, at
the expense of slower matching.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_POSIX_MALLOC_THRESHOLD</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that contains the threshold above which the POSIX
interface uses <b>malloc()</b> for output vectors. Further
details are given in the <b>pcreposix</b> documentation.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_MATCH_LIMIT</p>

<p style="margin-left:11%; margin-top: 1em">The output is a
long integer that gives the default limit for the number of
internal matching function calls in a <b>pcre_exec()</b>
execution. Further details are given with <b>pcre_exec()</b>
below.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_MATCH_LIMIT_RECURSION</p>

<p style="margin-left:11%; margin-top: 1em">The output is a
long integer that gives the default limit for the depth of
recursion when calling the internal matching function in a
<b>pcre_exec()</b> execution. Further details are given with
<b>pcre_exec()</b> below.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CONFIG_STACKRECURSE</p>

<p style="margin-left:11%; margin-top: 1em">The output is
an integer that is set to one if internal recursion when
running <b>pcre_exec()</b> is implemented by recursive
function calls that use the stack to remember their state.
This is the usual way that PCRE is compiled. The output is
zero if PCRE was compiled to use blocks of data on the heap
instead of recursive function calls. In this case,
<b>pcre_stack_malloc</b> and <b>pcre_stack_free</b> are
called to manage memory blocks on the heap, thus avoiding
the use of the stack.</p>

<h2>COMPILING A PATTERN
<a name="COMPILING A PATTERN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>pcre
*pcre_compile(const char *</b><i>pattern</i><b>, int</b>
<i>options</i><b>, <br>
const char **</b><i>errptr</i><b>, int
*</b><i>erroffset</i><b>, <br>
const unsigned char *</b><i>tableptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pcre
*pcre_compile2(const char *</b><i>pattern</i><b>, int</b>
<i>options</i><b>, <br>
int *</b><i>errorcodeptr</i><b>, <br>
const char **</b><i>errptr</i><b>, int
*</b><i>erroffset</i><b>, <br>
const unsigned char *</b><i>tableptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">Either of the
functions <b>pcre_compile()</b> or <b>pcre_compile2()</b>
can be called to compile a pattern into an internal form.
The only difference between the two interfaces is that
<b>pcre_compile2()</b> has an additional argument,
<i>errorcodeptr</i>, via which a numerical error code can be
returned. To avoid too much repetition, we refer just to
<b>pcre_compile()</b> below, but the information applies
equally to <b>pcre_compile2()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The pattern is
a C string terminated by a binary zero, and is passed in the
<i>pattern</i> argument. A pointer to a single block of
memory that is obtained via <b>pcre_malloc</b> is returned.
This contains the compiled code and related data. The
<b>pcre</b> type is defined for the returned block; this is
a typedef for a structure whose contents are not externally
defined. It is up to the caller to free the memory (via
<b>pcre_free</b>) when it is no longer required.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
compiled code of a PCRE regex is relocatable, that is, it
does not depend on memory location, the complete <b>pcre</b>
data block is not fully relocatable, because it may contain
a copy of the <i>tableptr</i> argument, which is an address
(see below).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>options</i> argument contains various bit settings that
affect the compilation. It should be zero if no options are
required. The available options are described below. Some of
them (in particular, those that are compatible with Perl,
but some others as well) can also be set and unset from
within the pattern (see the detailed description in the
<b>pcrepattern</b> documentation). For those options that
can be different in different parts of the pattern, the
contents of the <i>options</i> argument specifies their
settings at the start of compilation and execution. The
PCRE_ANCHORED, PCRE_BSR_<i>xxx</i>, PCRE_NEWLINE_<i>xxx</i>,
PCRE_NO_UTF8_CHECK, and PCRE_NO_START_OPTIMIZE options can
be set at the time of matching as well as at compile
time.</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>errptr</i> is NULL, <b>pcre_compile()</b> returns NULL
immediately. Otherwise, if compilation of a pattern fails,
<b>pcre_compile()</b> returns NULL, and sets the variable
pointed to by <i>errptr</i> to point to a textual error
message. This is a static string that is part of the
library. You must not try to free it. Normally, the offset
from the start of the pattern to the byte that was being
processed when the error was discovered is placed in the
variable pointed to by <i>erroffset</i>, which must not be
NULL (if it is, an immediate error is given). However, for
an invalid UTF-8 string, the offset is that of the first
byte of the failing character.</p>

<p style="margin-left:11%; margin-top: 1em">Some errors are
not detected until the whole pattern has been scanned; in
these cases, the offset passed back is the length of the
pattern. Note that the offset is in bytes, not characters,
even in UTF-8 mode. It may sometimes point into the middle
of a UTF-8 character.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>pcre_compile2()</b> is used instead of
<b>pcre_compile()</b>, and the <i>errorcodeptr</i> argument
is not NULL, a non-zero error code number is returned via
this argument in the event of an error. This is in addition
to the textual error message. Error codes and messages are
listed below.</p>

<p style="margin-left:11%; margin-top: 1em">If the final
argument, <i>tableptr</i>, is NULL, PCRE uses a default set
of character tables that are built when PCRE is compiled,
using the default C locale. Otherwise, <i>tableptr</i> must
be an address that is the result of a call to
<b>pcre_maketables()</b>. This value is stored with the
compiled pattern, and used again by <b>pcre_exec()</b>,
unless another table pointer is passed to it. For more
discussion, see the section on locale support below.</p>

<p style="margin-left:11%; margin-top: 1em">This code
fragment shows a typical straightforward call to
<b>pcre_compile()</b>:</p>

<p style="margin-left:11%; margin-top: 1em">pcre *re; <br>
const char *error; <br>
int erroffset; <br>
re = pcre_compile( <br>
&quot;^A.*Z&quot;, /* the pattern */ <br>
0, /* default options */ <br>
&amp;error, /* for error message */ <br>
&amp;erroffset, /* for error offset */ <br>
NULL); /* use default character tables */</p>

<p style="margin-left:11%; margin-top: 1em">The following
names for option bits are defined in the <b>pcre.h</b>
header file:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ANCHORED</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, the pattern is forced to be &quot;anchored&quot;, that
is, it is constrained to match only at the first matching
point in the string that is being searched (the
&quot;subject string&quot;). This effect can also be
achieved by appropriate constructs in the pattern itself,
which is the only way to do it in Perl.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_AUTO_CALLOUT</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, <b>pcre_compile()</b> automatically inserts callout
items, all with number 255, before each pattern item. For
discussion of the callout facility, see the
<b>pcrecallout</b> documentation.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_BSR_ANYCRLF
<br>
PCRE_BSR_UNICODE</p>

<p style="margin-left:11%; margin-top: 1em">These options
(which are mutually exclusive) control what the \R escape
sequence matches. The choice is either to match only CR, LF,
or CRLF, or to match any Unicode newline sequence. The
default is specified when PCRE is built. It can be
overridden from within the pattern, or by setting an option
when a compiled pattern is matched.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_CASELESS</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, letters in the pattern match both upper and lower case
letters. It is equivalent to Perl&rsquo;s /i option, and it
can be changed within a pattern by a (?i) option setting. In
UTF-8 mode, PCRE always understands the concept of case for
characters whose values are less than 128, so caseless
matching is always possible. For characters with higher
values, the concept of case is supported if PCRE is compiled
with Unicode property support, but not otherwise. If you
want to use caseless matching for characters 128 and above,
you must ensure that PCRE is compiled with Unicode property
support as well as with UTF-8 support.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_DOLLAR_ENDONLY</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, a dollar metacharacter in the pattern matches only at
the end of the subject string. Without this option, a dollar
also matches immediately before a newline at the end of the
string (but not before any other newlines). The
PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is
set. There is no equivalent to this option in Perl, and no
way to set it within a pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_DOTALL</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, a dot metacharacter in the pattern matches a character
of any value, including one that indicates a newline.
However, it only ever matches one character, even if
newlines are coded as CRLF. Without this option, a dot does
not match when the current position is at a newline. This
option is equivalent to Perl&rsquo;s /s option, and it can
be changed within a pattern by a (?s) option setting. A
negative class such as [^a] always matches newline
characters, independent of the setting of this option.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_DUPNAMES</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, names used to identify capturing subpatterns need not
be unique. This can be helpful for certain types of pattern
when it is known that only one instance of the named
subpattern can ever be matched. There are more details of
named subpatterns below; see also the <b>pcrepattern</b>
documentation.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_EXTENDED</p>

<p style="margin-left:11%; margin-top: 1em">If this bit is
set, white space data characters in the pattern are totally
ignored except when escaped or inside a character class.
White space does not include the VT character (code 11). In
addition, characters between an unescaped # outside a
character class and the next newline, inclusive, are also
ignored. This is equivalent to Perl&rsquo;s /x option, and
it can be changed within a pattern by a (?x) option
setting.</p>

<p style="margin-left:11%; margin-top: 1em">Which
characters are interpreted as newlines is controlled by the
options passed to <b>pcre_compile()</b> or by a special
sequence at the start of the pattern, as described in the
section entitled &quot;Newline conventions&quot; in the
<b>pcrepattern</b> documentation. Note that the end of this
type of comment is a literal newline sequence in the
pattern; escape sequences that happen to represent a newline
do not count.</p>

<p style="margin-left:11%; margin-top: 1em">This option
makes it possible to include comments inside complicated
patterns. Note, however, that this applies only to data
characters. White space characters may never appear within
special character sequences in a pattern, for example within
the sequence (?( that introduces a conditional
subpattern.</p>

<p style="margin-left:11%; margin-top: 1em">PCRE_EXTRA</p>

<p style="margin-left:11%; margin-top: 1em">This option was
invented in order to turn on additional functionality of
PCRE that is incompatible with Perl, but it is currently of
very little use. When set, any backslash in a pattern that
is followed by a letter that has no special meaning causes
an error, thus reserving these combinations for future
expansion. By default, as in Perl, a backslash followed by a
letter with no special meaning is treated as a literal.
(Perl can, however, be persuaded to give an error for this,
by running it with the -w option.) There are at present no
other features controlled by this option. It can also be set
by a (?X) option setting within a pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_FIRSTLINE</p>

<p style="margin-left:11%; margin-top: 1em">If this option
is set, an unanchored pattern is required to match before or
at the first newline in the subject string, though the
matched text may continue over the newline.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_JAVASCRIPT_COMPAT</p>

<p style="margin-left:11%; margin-top: 1em">If this option
is set, PCRE&rsquo;s behaviour is changed in some ways so
that it is compatible with JavaScript rather than Perl. The
changes are as follows:</p>

<p style="margin-left:11%; margin-top: 1em">(1) A lone
closing square bracket in a pattern causes a compile-time
error, because this is illegal in JavaScript (by default it
is treated as a data character). Thus, the pattern AB]CD
becomes illegal when this option is set.</p>

<p style="margin-left:11%; margin-top: 1em">(2) At run
time, a back reference to an unset subpattern group matches
an empty string (by default this causes the current matching
alternative to fail). A pattern such as (\1)(a) succeeds
when this option is set (assuming it can find an
&quot;a&quot; in the subject), whereas it fails by default,
for Perl compatibility.</p>

<p style="margin-left:11%; margin-top: 1em">(3) \U matches
an upper case &quot;U&quot; character; by default \U causes
a compile time error (Perl uses \U to upper case subsequent
characters).</p>

<p style="margin-left:11%; margin-top: 1em">(4) \u matches
a lower case &quot;u&quot; character unless it is followed
by four hexadecimal digits, in which case the hexadecimal
number defines the code point to match. By default, \u
causes a compile time error (Perl uses it to upper case the
following character).</p>

<p style="margin-left:11%; margin-top: 1em">(5) \x matches
a lower case &quot;x&quot; character unless it is followed
by two hexadecimal digits, in which case the hexadecimal
number defines the code point to match. By default, as in
Perl, a hexadecimal number is always expected after \x, but
it may have zero, one, or two digits (so, for example, \xz
matches a binary zero character followed by z).</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_MULTILINE</p>

<p style="margin-left:11%; margin-top: 1em">By default,
PCRE treats the subject string as consisting of a single
line of characters (even if it actually contains newlines).
The &quot;start of line&quot; metacharacter (^) matches only
at the start of the string, while the &quot;end of
line&quot; metacharacter ($) matches only at the end of the
string, or before a terminating newline (unless
PCRE_DOLLAR_ENDONLY is set). This is the same as Perl.</p>

<p style="margin-left:11%; margin-top: 1em">When
PCRE_MULTILINE it is set, the &quot;start of line&quot; and
&quot;end of line&quot; constructs match immediately
following or immediately before internal newlines in the
subject string, respectively, as well as at the very start
and end. This is equivalent to Perl&rsquo;s /m option, and
it can be changed within a pattern by a (?m) option setting.
If there are no newlines in a subject string, or no
occurrences of ^ or $ in a pattern, setting PCRE_MULTILINE
has no effect.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NEWLINE_CR
<br>
PCRE_NEWLINE_LF <br>
PCRE_NEWLINE_CRLF <br>
PCRE_NEWLINE_ANYCRLF <br>
PCRE_NEWLINE_ANY</p>

<p style="margin-left:11%; margin-top: 1em">These options
override the default newline definition that was chosen when
PCRE was built. Setting the first or the second specifies
that a newline is indicated by a single character (CR or LF,
respectively). Setting PCRE_NEWLINE_CRLF specifies that a
newline is indicated by the two-character CRLF sequence.
Setting PCRE_NEWLINE_ANYCRLF specifies that any of the three
preceding sequences should be recognized. Setting
PCRE_NEWLINE_ANY specifies that any Unicode newline sequence
should be recognized.</p>

<p style="margin-left:11%; margin-top: 1em">In an
ASCII/Unicode environment, the Unicode newline sequences are
the three just mentioned, plus the single characters VT
(vertical tab, U+000B), FF (form feed, U+000C), NEL (next
line, U+0085), LS (line separator, U+2028), and PS
(paragraph separator, U+2029). For the 8-bit library, the
last two are recognized only in UTF-8 mode.</p>

<p style="margin-left:11%; margin-top: 1em">When PCRE is
compiled to run in an EBCDIC (mainframe) environment, the
code for CR is 0x0d, the same as ASCII. However, the
character code for LF is normally 0x15, though in some
EBCDIC environments 0x25 is used. Whichever of these is not
LF is made to correspond to Unicode&rsquo;s NEL character.
EBCDIC codes are all less than 256. For more details, see
the <b>pcrebuild</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The newline
setting in the options word uses three bits that are treated
as a number, giving eight possibilities. Currently only six
are used (default plus the five values above). This means
that if you set more than one newline option, the
combination may or may not be sensible. For example,
PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent to
PCRE_NEWLINE_CRLF, but other combinations may yield unused
numbers and cause an error.</p>

<p style="margin-left:11%; margin-top: 1em">The only time
that a line break in a pattern is specially recognized when
compiling is when PCRE_EXTENDED is set. CR and LF are white
space characters, and so are ignored in this mode. Also, an
unescaped # outside a character class indicates a comment
that lasts until after the next line break sequence. In
other circumstances, line break sequences in patterns are
treated as literal data.</p>

<p style="margin-left:11%; margin-top: 1em">The newline
option that is set at compile time becomes the default that
is used for <b>pcre_exec()</b> and <b>pcre_dfa_exec()</b>,
but it can be overridden.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NO_AUTO_CAPTURE</p>

<p style="margin-left:11%; margin-top: 1em">If this option
is set, it disables the use of numbered capturing
parentheses in the pattern. Any opening parenthesis that is
not followed by ? behaves as if it were followed by ?: but
named parentheses can still be used for capturing (and they
acquire numbers in the usual way). There is no equivalent of
this option in Perl.</p>


<p style="margin-left:11%; margin-top: 1em">NO_START_OPTIMIZE</p>

<p style="margin-left:11%; margin-top: 1em">This is an
option that acts at matching time; that is, it is really an
option for <b>pcre_exec()</b> or <b>pcre_dfa_exec()</b>. If
it is set at compile time, it is remembered with the
compiled pattern and assumed at matching time. For details
see the discussion of PCRE_NO_START_OPTIMIZE below.</p>

<p style="margin-left:11%; margin-top: 1em">PCRE_UCP</p>

<p style="margin-left:11%; margin-top: 1em">This option
changes the way PCRE processes \B, \b, \D, \d, \S, \s, \W,
\w, and some of the POSIX character classes. By default,
only ASCII characters are recognized, but if PCRE_UCP is
set, Unicode properties are used instead to classify
characters. More details are given in the section on generic
character types in the <b>pcrepattern</b> page. If you set
PCRE_UCP, matching one of the items it affects takes much
longer. The option is available only if PCRE has been
compiled with Unicode property support.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UNGREEDY</p>

<p style="margin-left:11%; margin-top: 1em">This option
inverts the &quot;greediness&quot; of the quantifiers so
that they are not greedy by default, but become greedy if
followed by &quot;?&quot;. It is not compatible with Perl.
It can also be set by a (?U) option setting within the
pattern.</p>

<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8</p>

<p style="margin-left:11%; margin-top: 1em">This option
causes PCRE to regard both the pattern and the subject as
strings of UTF-8 characters instead of single-byte strings.
However, it is available only when PCRE is built to include
UTF support. If not, the use of this option provokes an
error. Details of how this option changes the behaviour of
PCRE are given in the <b>pcreunicode</b> page.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NO_UTF8_CHECK</p>

<p style="margin-left:11%; margin-top: 1em">When PCRE_UTF8
is set, the validity of the pattern as a UTF-8 string is
automatically checked. There is a discussion about the
validity of UTF-8 strings in the <b>pcreunicode</b> page. If
an invalid UTF-8 sequence is found, <b>pcre_compile()</b>
returns an error. If you already know that your pattern is
valid, and you want to skip this check for performance
reasons, you can set the PCRE_NO_UTF8_CHECK option. When it
is set, the effect of passing an invalid UTF-8 string as a
pattern is undefined. It may cause your program to crash.
Note that this option can also be passed to
<b>pcre_exec()</b> and <b>pcre_dfa_exec()</b>, to suppress
the validity checking of subject strings only. If the same
string is being matched many times, the option can be safely
set for the second and subsequent matchings to improve
performance.</p>

<h2>COMPILATION ERROR CODES
<a name="COMPILATION ERROR CODES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
table lists the error codes than may be returned by
<b>pcre_compile2()</b>, along with the error messages that
may be returned by both compiling functions. Note that error
messages are always 8-bit ASCII strings, even in 16-bit or
32-bit mode. As PCRE has developed, some error codes have
fallen out of use. To avoid confusion, they have not been
re-used.</p>

<p style="margin-left:11%; margin-top: 1em">0 no error <br>
1 \ at end of pattern <br>
2 \c at end of pattern <br>
3 unrecognized character follows \ <br>
4 numbers out of order in {} quantifier <br>
5 number too big in {} quantifier <br>
6 missing terminating ] for character class <br>
7 invalid escape sequence in character class <br>
8 range out of order in character class <br>
9 nothing to repeat <br>
10 [this code is not in use] <br>
11 internal error: unexpected repeat <br>
12 unrecognized character after (? or (?- <br>
13 POSIX named classes are supported only within a class
<br>
14 missing ) <br>
15 reference to non-existent subpattern <br>
16 erroffset passed as NULL <br>
17 unknown option bit(s) set <br>
18 missing ) after comment <br>
19 [this code is not in use] <br>
20 regular expression is too large <br>
21 failed to get memory <br>
22 unmatched parentheses <br>
23 internal error: code overflow <br>
24 unrecognized character after (?&lt; <br>
25 lookbehind assertion is not fixed length <br>
26 malformed number or name after (?( <br>
27 conditional group contains more than two branches <br>
28 assertion expected after (?( <br>
29 (?R or (?[+-]digits must be followed by ) <br>
30 unknown POSIX class name <br>
31 POSIX collating elements are not supported <br>
32 this version of PCRE is compiled without UTF support <br>
33 [this code is not in use] <br>
34 character value in \x{...} sequence is too large <br>
35 invalid condition (?(0) <br>
36 \C not allowed in lookbehind assertion <br>
37 PCRE does not support \L, \l, \N{name}, \U, or \u <br>
38 number after (?C is &gt; 255 <br>
39 closing ) for (?C expected <br>
40 recursive call could loop indefinitely <br>
41 unrecognized character after (?P <br>
42 syntax error in subpattern name (missing terminator) <br>
43 two named subpatterns have the same name <br>
44 invalid UTF-8 string (specifically UTF-8) <br>
45 support for \P, \p, and \X has not been compiled <br>
46 malformed \P or \p sequence <br>
47 unknown property name after \P or \p <br>
48 subpattern name is too long (maximum 32 characters) <br>
49 too many named subpatterns (maximum 10000) <br>
50 [this code is not in use] <br>
51 octal value is greater than \377 in 8-bit non-UTF-8 mode
<br>
52 internal error: overran compiling workspace <br>
53 internal error: previously-checked referenced subpattern
<br>
not found <br>
54 DEFINE group contains more than one branch <br>
55 repeating a DEFINE group is not allowed <br>
56 inconsistent NEWLINE options <br>
57 \g is not followed by a braced, angle-bracketed, or
quoted <br>
name/number or by a plain number <br>
58 a numbered reference must not be zero <br>
59 an argument is not allowed for (*ACCEPT), (*FAIL), or
(*COMMIT) <br>
60 (*VERB) not recognized <br>
61 number is too big <br>
62 subpattern name expected <br>
63 digit expected after (?+ <br>
64 ] is an invalid data character in JavaScript
compatibility mode <br>
65 different names for subpatterns of the same number are
<br>
not allowed <br>
66 (*MARK) must have an argument <br>
67 this version of PCRE is not compiled with Unicode
property <br>
support <br>
68 \c must be followed by an ASCII character <br>
69 \k is not followed by a braced, angle-bracketed, or
quoted name <br>
70 internal error: unknown opcode in find_fixedlength() <br>
71 \N is not supported in a class <br>
72 too many forward references <br>
73 disallowed Unicode code point (&gt;= 0xd800 &amp;&amp;
&lt;= 0xdfff) <br>
74 invalid UTF-16 string (specifically UTF-16) <br>
75 name is too long in (*MARK), (*PRUNE), (*SKIP), or
(*THEN) <br>
76 character value in \u.... sequence is too large <br>
77 invalid UTF-32 string (specifically UTF-32)</p>

<p style="margin-left:11%; margin-top: 1em">The numbers 32
and 10000 in errors 48 and 49 are defaults; different values
may be used if the limits were changed when PCRE was
built.</p>

<h2>STUDYING A PATTERN
<a name="STUDYING A PATTERN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>pcre_extra
*pcre_study(const pcre *</b><i>code</i><b>, int</b>
<i>options</i> <b><br>
const char **</b><i>errptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">If a compiled
pattern is going to be used several times, it is worth
spending more time analyzing it in order to speed up the
time taken for matching. The function <b>pcre_study()</b>
takes a pointer to a compiled pattern as its first argument.
If studying the pattern produces additional information that
will help speed up matching, <b>pcre_study()</b> returns a
pointer to a <b>pcre_extra</b> block, in which the
<i>study_data</i> field points to the results of the
study.</p>

<p style="margin-left:11%; margin-top: 1em">The returned
value from <b>pcre_study()</b> can be passed directly to
<b>pcre_exec()</b> or <b>pcre_dfa_exec()</b>. However, a
<b>pcre_extra</b> block also contains other fields that can
be set by the caller before the block is passed; these are
described below in the section on matching a pattern.</p>

<p style="margin-left:11%; margin-top: 1em">If studying the
pattern does not produce any useful information,
<b>pcre_study()</b> returns NULL by default. In that
circumstance, if the calling program wants to pass any of
the other fields to <b>pcre_exec()</b> or
<b>pcre_dfa_exec()</b>, it must set up its own
<b>pcre_extra</b> block. However, if <b>pcre_study()</b> is
called with the PCRE_STUDY_EXTRA_NEEDED option, it returns a
<b>pcre_extra</b> block even if studying did not find any
additional information. It may still return NULL, however,
if an error occurs in <b>pcre_study()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument of <b>pcre_study()</b> contains option bits. There
are three further options in addition to
PCRE_STUDY_EXTRA_NEEDED:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_STUDY_JIT_COMPILE
<br>
PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE <br>
PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE</p>

<p style="margin-left:11%; margin-top: 1em">If any of these
are set, and the just-in-time compiler is available, the
pattern is further compiled into machine code that executes
much faster than the <b>pcre_exec()</b> interpretive
matching function. If the just-in-time compiler is not
available, these options are ignored. All undefined bits in
the <i>options</i> argument must be zero.</p>

<p style="margin-left:11%; margin-top: 1em">JIT compilation
is a heavyweight optimization. It can take some time for
patterns to be analyzed, and for one-off matches and simple
patterns the benefit of faster execution might be offset by
a much slower study time. Not all patterns can be optimized
by the JIT compiler. For those that cannot be handled,
matching automatically falls back to the <b>pcre_exec()</b>
interpreter. For more details, see the <b>pcrejit</b>
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The third
argument for <b>pcre_study()</b> is a pointer for an error
message. If studying succeeds (even if no data is returned),
the variable it points to is set to NULL. Otherwise it is
set to point to a textual error message. This is a static
string that is part of the library. You must not try to free
it. You should test the error pointer for NULL after calling
<b>pcre_study()</b>, to be sure that it has run
successfully.</p>

<p style="margin-left:11%; margin-top: 1em">When you are
finished with a pattern, you can free the memory used for
the study data by calling <b>pcre_free_study()</b>. This
function was added to the API for release 8.20. For earlier
versions, the memory could be freed with <b>pcre_free()</b>,
just like the pattern itself. This will still work in cases
where JIT optimization is not used, but it is advisable to
change to the new function when convenient.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical way in which <b>pcre_study</b>() is used (except
that in a real application there should be tests for
errors):</p>

<p style="margin-left:11%; margin-top: 1em">int rc; <br>
pcre *re; <br>
pcre_extra *sd; <br>
re = pcre_compile(&quot;pattern&quot;, 0, &amp;error,
&amp;erroroffset, NULL); <br>
sd = pcre_study( <br>
re, /* result of pcre_compile() */ <br>
0, /* no options */ <br>
&amp;error); /* set to NULL or points to a message */ <br>
rc = pcre_exec( /* see below for details of pcre_exec()
options */ <br>
re, sd, &quot;subject&quot;, 7, 0, 0, ovector, 30); <br>
... <br>
pcre_free_study(sd); <br>
pcre_free(re);</p>

<p style="margin-left:11%; margin-top: 1em">Studying a
pattern does two things: first, a lower bound for the length
of subject string that is needed to match the pattern is
computed. This does not mean that there are any strings of
that length that match, but it does guarantee that no
shorter strings match. The value is used to avoid wasting
time by trying to match strings that are shorter than the
lower bound. You can find out the value in a calling program
via the <b>pcre_fullinfo()</b> function.</p>

<p style="margin-left:11%; margin-top: 1em">Studying a
pattern is also useful for non-anchored patterns that do not
have a single fixed starting character. A bitmap of possible
starting bytes is created. This speeds up finding a position
in the subject at which to start matching. (In 16-bit mode,
the bitmap is used for 16-bit values less than 256. In
32-bit mode, the bitmap is used for 32-bit values less than
256.)</p>

<p style="margin-left:11%; margin-top: 1em">These two
optimizations apply to both <b>pcre_exec()</b> and
<b>pcre_dfa_exec()</b>, and the information is also used by
the JIT compiler. The optimizations can be disabled by
setting the PCRE_NO_START_OPTIMIZE option when calling
<b>pcre_exec()</b> or <b>pcre_dfa_exec()</b>, but if this is
done, JIT execution is also disabled. You might want to do
this if your pattern contains callouts or (*MARK) and you
want to make use of these facilities in cases where matching
fails. See the discussion of PCRE_NO_START_OPTIMIZE
below.</p>

<h2>LOCALE SUPPORT
<a name="LOCALE SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PCRE handles
caseless matching, and determines whether characters are
letters, digits, or whatever, by reference to a set of
tables, indexed by character value. When running in UTF-8
mode, this applies only to characters with codes less than
128. By default, higher-valued codes never match escapes
such as \w or \d, but they can be tested with \p if PCRE is
built with Unicode character property support.
Alternatively, the PCRE_UCP option can be set at compile
time; this causes \w and friends to use Unicode property
support instead of built-in tables. The use of locales with
Unicode is discouraged. If you are handling characters with
codes greater than 128, you should either use UTF-8 and
Unicode, or use locales, but not try to mix the two.</p>

<p style="margin-left:11%; margin-top: 1em">PCRE contains
an internal set of tables that are used when the final
argument of <b>pcre_compile()</b> is NULL. These are
sufficient for many applications. Normally, the internal
tables recognize only ASCII characters. However, when PCRE
is built, it is possible to cause the internal tables to be
rebuilt in the default &quot;C&quot; locale of the local
system, which may cause them to be different.</p>

<p style="margin-left:11%; margin-top: 1em">The internal
tables can always be overridden by tables supplied by the
application that calls PCRE. These may be created in a
different locale from the default. As more and more
applications change to using Unicode, the need for this
locale support is expected to die away.</p>

<p style="margin-left:11%; margin-top: 1em">External tables
are built by calling the <b>pcre_maketables()</b> function,
which has no arguments, in the relevant locale. The result
can then be passed to <b>pcre_compile()</b> or
<b>pcre_exec()</b> as often as necessary. For example, to
build and use tables that are appropriate for the French
locale (where accented characters with values greater than
128 are treated as letters), the following code could be
used:</p>


<p style="margin-left:11%; margin-top: 1em">setlocale(LC_CTYPE,
&quot;fr_FR&quot;); <br>
tables = pcre_maketables(); <br>
re = pcre_compile(..., tables);</p>

<p style="margin-left:11%; margin-top: 1em">The locale name
&quot;fr_FR&quot; is used on Linux and other Unix-like
systems; if you are using Windows, the name for the French
locale is &quot;french&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_maketables()</b> runs, the tables are built in
memory that is obtained via <b>pcre_malloc</b>. It is the
caller&rsquo;s responsibility to ensure that the memory
containing the tables remains available for as long as it is
needed.</p>

<p style="margin-left:11%; margin-top: 1em">The pointer
that is passed to <b>pcre_compile()</b> is saved with the
compiled pattern, and the same tables are used via this
pointer by <b>pcre_study()</b> and normally also by
<b>pcre_exec()</b>. Thus, by default, for any single
pattern, compilation, studying and matching all happen in
the same locale, but different patterns can be compiled in
different locales.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to pass a table pointer or NULL (indicating the use of the
internal tables) to <b>pcre_exec()</b>. Although not
intended for this purpose, this facility could be used to
match a pattern in a different locale from the one in which
it was compiled. Passing table pointers at run time is
discussed below in the section on matching a pattern.</p>

<h2>INFORMATION ABOUT A PATTERN
<a name="INFORMATION ABOUT A PATTERN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_fullinfo(const pcre *</b><i>code</i><b>, const
pcre_extra *</b><i>extra</i><b>, <br>
int</b> <i>what</i><b>, void *</b><i>where</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>pcre_fullinfo()</b> function returns information about a
compiled pattern. It replaces the <b>pcre_info()</b>
function, which was removed from the library at version
8.30, after more than 10 years of obsolescence.</p>

<p style="margin-left:11%; margin-top: 1em">The first
argument for <b>pcre_fullinfo()</b> is a pointer to the
compiled pattern. The second argument is the result of
<b>pcre_study()</b>, or NULL if the pattern was not studied.
The third argument specifies which piece of information is
required, and the fourth argument is a pointer to a variable
to receive the data. The yield of the function is zero for
success, or one of the following negative numbers:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NULL
the argument <i>code</i> was NULL <br>
the argument <i>where</i> was NULL <br>
PCRE_ERROR_BADMAGIC the &quot;magic number&quot; was not
found <br>
PCRE_ERROR_BADENDIANNESS the pattern was compiled with
different <br>
endianness <br>
PCRE_ERROR_BADOPTION the value of <i>what</i> was
invalid</p>

<p style="margin-left:11%; margin-top: 1em">The &quot;magic
number&quot; is placed at the start of each compiled pattern
as an simple check against passing an arbitrary memory
pointer. The endianness error can occur if a compiled
pattern is saved and reloaded on a different host. Here is a
typical call of <b>pcre_fullinfo()</b>, to obtain the length
of the compiled pattern:</p>

<p style="margin-left:11%; margin-top: 1em">int rc; <br>
size_t length; <br>
rc = pcre_fullinfo( <br>
re, /* result of pcre_compile() */ <br>
sd, /* result of pcre_study(), or NULL */ <br>
PCRE_INFO_SIZE, /* what is required */ <br>
&amp;length); /* where to put the data */</p>

<p style="margin-left:11%; margin-top: 1em">The possible
values for the third argument are defined in <b>pcre.h</b>,
and are as follows:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_BACKREFMAX</p>

<p style="margin-left:11%; margin-top: 1em">Return the
number of the highest back reference in the pattern. The
fourth argument should point to an <b>int</b> variable. Zero
is returned if there are no back references.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_CAPTURECOUNT</p>

<p style="margin-left:11%; margin-top: 1em">Return the
number of capturing subpatterns in the pattern. The fourth
argument should point to an <b>int</b> variable.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_DEFAULT_TABLES</p>

<p style="margin-left:11%; margin-top: 1em">Return a
pointer to the internal default character tables within
PCRE. The fourth argument should point to an <b>unsigned
char *</b> variable. This information call is provided for
internal use by the <b>pcre_study()</b> function. External
callers can cause PCRE to use its internal tables by passing
a NULL table pointer.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_FIRSTBYTE</p>

<p style="margin-left:11%; margin-top: 1em">Return
information about the first data unit of any matched string,
for a non-anchored pattern. (The name of this option refers
to the 8-bit library, where data units are bytes.) The
fourth argument should point to an <b>int</b> variable.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
fixed first value, for example, the letter &quot;c&quot;
from a pattern such as (cat|cow|coyote), its value is
returned. In the 8-bit library, the value is always less
than 256. In the 16-bit library the value can be up to
0xffff. In the 32-bit library the value can be up to
0x10ffff.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
fixed first value, and if either</p>

<p style="margin-left:11%; margin-top: 1em">(a) the pattern
was compiled with the PCRE_MULTILINE option, and every
branch starts with &quot;^&quot;, or</p>

<p style="margin-left:11%; margin-top: 1em">(b) every
branch of the pattern starts with &quot;.*&quot; and
PCRE_DOTALL is not set (if it were set, the pattern would be
anchored),</p>

<p style="margin-left:11%; margin-top: 1em">-1 is returned,
indicating that the pattern matches only at the start of a
subject string or after any newline within the string.
Otherwise -2 is returned. For anchored patterns, -2 is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">Since for the
32-bit library using the non-UTF-32 mode, this function is
unable to return the full 32-bit range of the character,
this value is deprecated; instead the
PCRE_INFO_FIRSTCHARACTERFLAGS and PCRE_INFO_FIRSTCHARACTER
values should be used.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_FIRSTTABLE</p>

<p style="margin-left:11%; margin-top: 1em">If the pattern
was studied, and this resulted in the construction of a
256-bit table indicating a fixed set of values for the first
data unit in any matching string, a pointer to the table is
returned. Otherwise NULL is returned. The fourth argument
should point to an <b>unsigned char *</b> variable.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_HASCRORLF</p>

<p style="margin-left:11%; margin-top: 1em">Return 1 if the
pattern contains any explicit matches for CR or LF
characters, otherwise 0. The fourth argument should point to
an <b>int</b> variable. An explicit match is either a
literal CR or LF character, or \r or \n.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_JCHANGED</p>

<p style="margin-left:11%; margin-top: 1em">Return 1 if the
(?J) or (?-J) option setting is used in the pattern,
otherwise 0. The fourth argument should point to an
<b>int</b> variable. (?J) and (?-J) set and unset the local
PCRE_DUPNAMES option, respectively.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_JIT</p>

<p style="margin-left:11%; margin-top: 1em">Return 1 if the
pattern was studied with one of the JIT options, and
just-in-time compiling was successful. The fourth argument
should point to an <b>int</b> variable. A return value of 0
means that JIT support is not available in this version of
PCRE, or that the pattern was not studied with a JIT option,
or that the JIT compiler could not handle this particular
pattern. See the <b>pcrejit</b> documentation for details of
what can and cannot be handled.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_JITSIZE</p>

<p style="margin-left:11%; margin-top: 1em">If the pattern
was successfully studied with a JIT option, return the size
of the JIT compiled code, otherwise return zero. The fourth
argument should point to a <b>size_t</b> variable.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_LASTLITERAL</p>

<p style="margin-left:11%; margin-top: 1em">Return the
value of the rightmost literal data unit that must exist in
any matched string, other than at its start, if such a value
has been recorded. The fourth argument should point to an
<b>int</b> variable. If there is no such value, -1 is
returned. For anchored patterns, a last literal value is
recorded only if it follows something of variable length.
For example, for the pattern /^a\d+z\d+/ the returned value
is &quot;z&quot;, but for /^a\dz\d/ the returned value is
-1.</p>

<p style="margin-left:11%; margin-top: 1em">Since for the
32-bit library using the non-UTF-32 mode, this function is
unable to return the full 32-bit range of the character,
this value is deprecated; instead the
PCRE_INFO_REQUIREDCHARFLAGS and PCRE_INFO_REQUIREDCHAR
values should be used.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_MAXLOOKBEHIND</p>

<p style="margin-left:11%; margin-top: 1em">Return the
number of characters (NB not bytes) in the longest
lookbehind assertion in the pattern. Note that the simple
assertions \b and \B require a one-character lookbehind.
This information is useful when doing multi-segment matching
using the partial matching facilities.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_MINLENGTH</p>

<p style="margin-left:11%; margin-top: 1em">If the pattern
was studied and a minimum length for matching subject
strings was computed, its value is returned. Otherwise the
returned value is -1. The value is a number of characters,
which in UTF-8 mode may be different from the number of
bytes. The fourth argument should point to an <b>int</b>
variable. A non-negative value is a lower bound to the
length of any matching string. There may not be any strings
of that length that do actually match, but every string that
does match is at least that long.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_NAMECOUNT
<br>
PCRE_INFO_NAMEENTRYSIZE <br>
PCRE_INFO_NAMETABLE</p>

<p style="margin-left:11%; margin-top: 1em">PCRE supports
the use of named as well as numbered capturing parentheses.
The names are just an additional way of identifying the
parentheses, which still acquire numbers. Several
convenience functions such as
<b>pcre_get_named_substring()</b> are provided for
extracting captured substrings by name. It is also possible
to extract the data directly, by first converting the name
to a number in order to access the correct pointers in the
output vector (described with <b>pcre_exec()</b> below). To
do the conversion, you need to use the name-to-number map,
which is described by these three values.</p>

<p style="margin-left:11%; margin-top: 1em">The map
consists of a number of fixed-size entries.
PCRE_INFO_NAMECOUNT gives the number of entries, and
PCRE_INFO_NAMEENTRYSIZE gives the size of each entry; both
of these return an <b>int</b> value. The entry size depends
on the length of the longest name. PCRE_INFO_NAMETABLE
returns a pointer to the first entry of the table. This is a
pointer to <b>char</b> in the 8-bit library, where the first
two bytes of each entry are the number of the capturing
parenthesis, most significant byte first. In the 16-bit
library, the pointer points to 16-bit data units, the first
of which contains the parenthesis number. In the 32-bit
library, the pointer points to 32-bit data units, the first
of which contains the parenthesis number. The rest of the
entry is the corresponding name, zero terminated.</p>

<p style="margin-left:11%; margin-top: 1em">The names are
in alphabetical order. Duplicate names may appear if (?| is
used to create multiple groups with the same number, as
described in the section on duplicate subpattern numbers in
the <b>pcrepattern</b> page. Duplicate names for subpatterns
with different numbers are permitted only if PCRE_DUPNAMES
is set. In all cases of duplicate names, they appear in the
table in the order in which they were found in the pattern.
In the absence of (?| this is the order of increasing
number; when (?| is used this is not necessarily the case
because later subpatterns may have lower numbers.</p>

<p style="margin-left:11%; margin-top: 1em">As a simple
example of the name/number table, consider the following
pattern after compilation by the 8-bit library (assume
PCRE_EXTENDED is set, so white space - including newlines -
is ignored):</p>

<p style="margin-left:11%; margin-top: 1em">(?&lt;date&gt;
(?&lt;year&gt;(\d\d)?\d\d) - <br>
(?&lt;month&gt;\d\d) - (?&lt;day&gt;\d\d) )</p>

<p style="margin-left:11%; margin-top: 1em">There are four
named subpatterns, so the table has four entries, and each
entry in the table is eight bytes long. The table is as
follows, with non-printing bytes shows in hexadecimal, and
undefined bytes shown as ??:</p>

<p style="margin-left:11%; margin-top: 1em">00 01 d a t e
00 ?? <br>
00 05 d a y 00 ?? ?? <br>
00 04 m o n t h 00 <br>
00 02 y e a r 00 ??</p>

<p style="margin-left:11%; margin-top: 1em">When writing
code to extract data from named subpatterns using the
name-to-number map, remember that the length of the entries
is likely to be different for each compiled pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_OKPARTIAL</p>

<p style="margin-left:11%; margin-top: 1em">Return 1 if the
pattern can be used for partial matching with
<b>pcre_exec()</b>, otherwise 0. The fourth argument should
point to an <b>int</b> variable. From release 8.00, this
always returns 1, because the restrictions that previously
applied to partial matching have been lifted. The
<b>pcrepartial</b> documentation gives details of partial
matching.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_OPTIONS</p>

<p style="margin-left:11%; margin-top: 1em">Return a copy
of the options with which the pattern was compiled. The
fourth argument should point to an <b>unsigned long int</b>
variable. These option bits are those specified in the call
to <b>pcre_compile()</b>, modified by any top-level option
settings at the start of the pattern itself. In other words,
they are the options that will be in force when matching
starts. For example, if the pattern /(?im)abc(?-i)d/ is
compiled with the PCRE_EXTENDED option, the result is
PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.</p>

<p style="margin-left:11%; margin-top: 1em">A pattern is
automatically anchored by PCRE if all of its top-level
alternatives begin with one of the following:</p>

<p style="margin-left:11%; margin-top: 1em">^ unless
PCRE_MULTILINE is set <br>
\A always <br>
\G always <br>
.* if PCRE_DOTALL is set and there are no back <br>
references to the subpattern in which .* appears</p>

<p style="margin-left:11%; margin-top: 1em">For such
patterns, the PCRE_ANCHORED bit is set in the options
returned by <b>pcre_fullinfo()</b>.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_SIZE</p>

<p style="margin-left:11%; margin-top: 1em">Return the size
of the compiled pattern in bytes (for both libraries). The
fourth argument should point to a <b>size_t</b> variable.
This value does not include the size of the <b>pcre</b>
structure that is returned by <b>pcre_compile()</b>. The
value that is passed as the argument to <b>pcre_malloc()</b>
when <b>pcre_compile()</b> is getting memory in which to
place the compiled data is the value returned by this option
plus the size of the <b>pcre</b> structure. Studying a
compiled pattern, with or without JIT, does not alter the
value returned by this option.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_STUDYSIZE</p>

<p style="margin-left:11%; margin-top: 1em">Return the size
in bytes of the data block pointed to by the
<i>study_data</i> field in a <b>pcre_extra</b> block. If
<b>pcre_extra</b> is NULL, or there is no study data, zero
is returned. The fourth argument should point to a
<b>size_t</b> variable. The <i>study_data</i> field is set
by <b>pcre_study()</b> to record information that will speed
up matching (see the section entitled &quot;Studying a
pattern&quot; above). The format of the <i>study_data</i>
block is private, but its length is made available via this
option so that it can be saved and restored (see the
<b>pcreprecompile</b> documentation for details).</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_FIRSTCHARACTERFLAGS</p>

<p style="margin-left:11%; margin-top: 1em">Return
information about the first data unit of any matched string,
for a non-anchored pattern. The fourth argument should point
to an <b>int</b> variable.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
fixed first value, for example, the letter &quot;c&quot;
from a pattern such as (cat|cow|coyote), 1 is returned, and
the character value can be retrieved using
PCRE_INFO_FIRSTCHARACTER.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
fixed first value, and if either</p>

<p style="margin-left:11%; margin-top: 1em">(a) the pattern
was compiled with the PCRE_MULTILINE option, and every
branch starts with &quot;^&quot;, or</p>

<p style="margin-left:11%; margin-top: 1em">(b) every
branch of the pattern starts with &quot;.*&quot; and
PCRE_DOTALL is not set (if it were set, the pattern would be
anchored),</p>

<p style="margin-left:11%; margin-top: 1em">2 is returned,
indicating that the pattern matches only at the start of a
subject string or after any newline within the string.
Otherwise 0 is returned. For anchored patterns, 0 is
returned.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_FIRSTCHARACTER</p>

<p style="margin-left:11%; margin-top: 1em">Return the
fixed first character value, if
PCRE_INFO_FIRSTCHARACTERFLAGS returned 1; otherwise returns
0. The fourth argument should point to an <b>uint_t</b>
variable.</p>

<p style="margin-left:11%; margin-top: 1em">In the 8-bit
library, the value is always less than 256. In the 16-bit
library the value can be up to 0xffff. In the 32-bit library
in UTF-32 mode the value can be up to 0x10ffff, and up to
0xffffffff when not using UTF-32 mode.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
fixed first value, and if either</p>

<p style="margin-left:11%; margin-top: 1em">(a) the pattern
was compiled with the PCRE_MULTILINE option, and every
branch starts with &quot;^&quot;, or</p>

<p style="margin-left:11%; margin-top: 1em">(b) every
branch of the pattern starts with &quot;.*&quot; and
PCRE_DOTALL is not set (if it were set, the pattern would be
anchored),</p>

<p style="margin-left:11%; margin-top: 1em">-1 is returned,
indicating that the pattern matches only at the start of a
subject string or after any newline within the string.
Otherwise -2 is returned. For anchored patterns, -2 is
returned.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_REQUIREDCHARFLAGS</p>

<p style="margin-left:11%; margin-top: 1em">Returns 1 if
there is a rightmost literal data unit that must exist in
any matched string, other than at its start. The fourth
argument should point to an <b>int</b> variable. If there is
no such value, 0 is returned. If returning 1, the character
value itself can be retrieved using
PCRE_INFO_REQUIREDCHAR.</p>

<p style="margin-left:11%; margin-top: 1em">For anchored
patterns, a last literal value is recorded only if it
follows something of variable length. For example, for the
pattern /^a\d+z\d+/ the returned value 1 (with &quot;z&quot;
returned from PCRE_INFO_REQUIREDCHAR), but for /^a\dz\d/ the
returned value is 0.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_INFO_REQUIREDCHAR</p>

<p style="margin-left:11%; margin-top: 1em">Return the
value of the rightmost literal data unit that must exist in
any matched string, other than at its start, if such a value
has been recorded. The fourth argument should point to an
<b>uint32_t</b> variable. If there is no such value, 0 is
returned.</p>

<h2>REFERENCE COUNTS
<a name="REFERENCE COUNTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_refcount(pcre *</b><i>code</i><b>, int</b>
<i>adjust</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>pcre_refcount()</b> function is used to maintain a
reference count in the data block that contains a compiled
pattern. It is provided for the benefit of applications that
operate in an object-oriented manner, where different parts
of the application may be using the same compiled pattern,
but you want to free the block when they are all done.</p>

<p style="margin-left:11%; margin-top: 1em">When a pattern
is compiled, the reference count field is initialized to
zero. It is changed only by calling this function, whose
action is to add the <i>adjust</i> value (which may be
positive or negative) to it. The yield of the function is
the new value. However, the value of the count is
constrained to lie between 0 and 65535, inclusive. If the
new value is outside these limits, it is forced to the
appropriate limit value.</p>

<p style="margin-left:11%; margin-top: 1em">Except when it
is zero, the reference count is not correctly preserved if a
pattern is compiled on one host and then transferred to a
host whose byte-order is different. (This seems a highly
unlikely scenario.)</p>

<h2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION
<a name="MATCHING A PATTERN: THE TRADITIONAL FUNCTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_exec(const pcre *</b><i>code</i><b>, const pcre_extra
*</b><i>extra</i><b>, <br>
const char *</b><i>subject</i><b>, int</b> <i>length</i><b>,
int</b> <i>startoffset</i><b>, <br>
int</b> <i>options</i><b>, int *</b><i>ovector</i><b>,
int</b> <i>ovecsize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_exec()</b> is called to match a subject string
against a compiled pattern, which is passed in the
<i>code</i> argument. If the pattern was studied, the result
of the study should be passed in the <i>extra</i> argument.
You can call <b>pcre_exec()</b> with the same <i>code</i>
and <i>extra</i> arguments as many times as you like, in
order to match different subject strings with the same
pattern.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is the main matching facility of the library, and it
operates in a Perl-like manner. For specialist use there is
also an alternative matching function, which is described
below in the section about the <b>pcre_dfa_exec()</b>
function.</p>

<p style="margin-left:11%; margin-top: 1em">In most
applications, the pattern will have been compiled (and
optionally studied) in the same process that calls
<b>pcre_exec()</b>. However, it is possible to save compiled
patterns and study data, and then use them later in
different processes, possibly even on different hosts. For a
discussion about this, see the <b>pcreprecompile</b>
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of a simple call to <b>pcre_exec()</b>:</p>

<p style="margin-left:11%; margin-top: 1em">int rc; <br>
int ovector[30]; <br>
rc = pcre_exec( <br>
re, /* result of pcre_compile() */ <br>
NULL, /* we didn&rsquo;t study the pattern */ <br>
&quot;some string&quot;, /* the subject string */ <br>
11, /* the length of the subject string */ <br>
0, /* start at offset 0 in the subject */ <br>
0, /* default options */ <br>
ovector, /* vector of integers for substring information */
<br>
30); /* number of elements (NOT size in bytes) */</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extra data
for pcre_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>extra</i> argument is not NULL, it must point to a
<b>pcre_extra</b> data block. The <b>pcre_study()</b>
function returns such a block (when it doesn&rsquo;t return
NULL), but you can also create one for yourself, and pass
additional information in it. The <b>pcre_extra</b> block
contains the following fields (not necessarily in this
order):</p>

<p style="margin-left:11%; margin-top: 1em">unsigned long
int <i>flags</i>; <br>
void *<i>study_data</i>; <br>
void *<i>executable_jit</i>; <br>
unsigned long int <i>match_limit</i>; <br>
unsigned long int <i>match_limit_recursion</i>; <br>
void *<i>callout_data</i>; <br>
const unsigned char *<i>tables</i>; <br>
unsigned char **<i>mark</i>;</p>

<p style="margin-left:11%; margin-top: 1em">In the 16-bit
version of this structure, the <i>mark</i> field has type
&quot;PCRE_UCHAR16 **&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In the 32-bit
version of this structure, the <i>mark</i> field has type
&quot;PCRE_UCHAR32 **&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> field is used to specify which of the other
fields are set. The flag bits are:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_EXTRA_CALLOUT_DATA
<br>
PCRE_EXTRA_EXECUTABLE_JIT <br>
PCRE_EXTRA_MARK <br>
PCRE_EXTRA_MATCH_LIMIT <br>
PCRE_EXTRA_MATCH_LIMIT_RECURSION <br>
PCRE_EXTRA_STUDY_DATA <br>
PCRE_EXTRA_TABLES</p>

<p style="margin-left:11%; margin-top: 1em">Other flag bits
should be set to zero. The <i>study_data</i> field and
sometimes the <i>executable_jit</i> field are set in the
<b>pcre_extra</b> block that is returned by
<b>pcre_study()</b>, together with the appropriate flag
bits. You should not set these yourself, but you may add to
the block by setting other fields and their corresponding
flag bits.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>match_limit</i> field provides a means of preventing PCRE
from using up a vast amount of resources when running
patterns that are not going to match, but which have a very
large number of possibilities in their search trees. The
classic example is a pattern that uses nested unlimited
repeats.</p>

<p style="margin-left:11%; margin-top: 1em">Internally,
<b>pcre_exec()</b> uses a function called <b>match()</b>,
which it calls repeatedly (sometimes recursively). The limit
set by <i>match_limit</i> is imposed on the number of times
this function is called during a match, which has the effect
of limiting the amount of backtracking that can take place.
For patterns that are not anchored, the count restarts from
zero for each position in the subject string.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_exec()</b> is called with a pattern that was
successfully studied with a JIT option, the way that the
matching is executed is entirely different. However, there
is still the possibility of runaway matching that goes on
for a very long time, and so the <i>match_limit</i> value is
also used in this case (but in a different way) to limit how
long the matching can continue.</p>

<p style="margin-left:11%; margin-top: 1em">The default
value for the limit can be set when PCRE is built; the
default default is 10 million, which handles all but the
most extreme cases. You can override the default by suppling
<b>pcre_exec()</b> with a <b>pcre_extra</b> block in which
<i>match_limit</i> is set, and PCRE_EXTRA_MATCH_LIMIT is set
in the <i>flags</i> field. If the limit is exceeded,
<b>pcre_exec()</b> returns PCRE_ERROR_MATCHLIMIT.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>match_limit_recursion</i> field is similar to
<i>match_limit</i>, but instead of limiting the total number
of times that <b>match()</b> is called, it limits the depth
of recursion. The recursion depth is a smaller number than
the total number of calls, because not all calls to
<b>match()</b> are recursive. This limit is of use only if
it is set smaller than <i>match_limit</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Limiting the
recursion depth limits the amount of machine stack that can
be used, or, when PCRE has been compiled to use memory on
the heap instead of the stack, the amount of heap memory
that can be used. This limit is not relevant, and is
ignored, when matching is done using JIT compiled code.</p>

<p style="margin-left:11%; margin-top: 1em">The default
value for <i>match_limit_recursion</i> can be set when PCRE
is built; the default default is the same value as the
default for <i>match_limit</i>. You can override the default
by suppling <b>pcre_exec()</b> with a <b>pcre_extra</b>
block in which <i>match_limit_recursion</i> is set, and
PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the <i>flags</i>
field. If the limit is exceeded, <b>pcre_exec()</b> returns
PCRE_ERROR_RECURSIONLIMIT.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>callout_data</i> field is used in conjunction with the
&quot;callout&quot; feature, and is described in the
<b>pcrecallout</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>tables</i> field is used to pass a character tables
pointer to <b>pcre_exec()</b>; this overrides the value that
is stored with the compiled pattern. A non-NULL value is
stored with the compiled pattern only if custom tables were
supplied to <b>pcre_compile()</b> via its <i>tableptr</i>
argument. If NULL is passed to <b>pcre_exec()</b> using this
mechanism, it forces PCRE&rsquo;s internal tables to be
used. This facility is helpful when re-using patterns that
have been saved after compiling with an external set of
tables, because the external tables might be at a different
address when <b>pcre_exec()</b> is called. See the
<b>pcreprecompile</b> documentation for a discussion of
saving compiled patterns for later use.</p>

<p style="margin-left:11%; margin-top: 1em">If
PCRE_EXTRA_MARK is set in the <i>flags</i> field, the
<i>mark</i> field must be set to point to a suitable
variable. If the pattern contains any backtracking control
verbs such as (*MARK:NAME), and the execution ends up with a
name to pass back, a pointer to the name string (zero
terminated) is placed in the variable pointed to by the
<i>mark</i> field. The names are within the compiled
pattern; if you wish to retain such a name you must copy it
before freeing the memory of a compiled pattern. If there is
no name to pass back, the variable pointed to by the
<i>mark</i> field is set to NULL. For details of the
backtracking control verbs, see the section entitled
&quot;Backtracking control&quot; in the <b>pcrepattern</b>
documentation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Option bits
for pcre_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">The unused bits
of the <i>options</i> argument for <b>pcre_exec()</b> must
be zero. The only bits that may be set are PCRE_ANCHORED,
PCRE_NEWLINE_<i>xxx</i>, PCRE_NOTBOL, PCRE_NOTEOL,
PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_START_OPTIMIZE, PCRE_NO_UTF8_CHECK,
PCRE_PARTIAL_HARD, and PCRE_PARTIAL_SOFT.</p>

<p style="margin-left:11%; margin-top: 1em">If the pattern
was successfully studied with one of the just-in-time (JIT)
compile options, the only supported options for JIT
execution are PCRE_NO_UTF8_CHECK, PCRE_NOTBOL, PCRE_NOTEOL,
PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and
PCRE_PARTIAL_SOFT. If an unsupported option is used, JIT
execution is disabled and the normal interpretive code in
<b>pcre_exec()</b> is run.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ANCHORED</p>

<p style="margin-left:11%; margin-top: 1em">The
PCRE_ANCHORED option limits <b>pcre_exec()</b> to matching
at the first matching position. If a pattern was compiled
with PCRE_ANCHORED, or turned out to be anchored by virtue
of its contents, it cannot be made unachored at matching
time.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_BSR_ANYCRLF
<br>
PCRE_BSR_UNICODE</p>

<p style="margin-left:11%; margin-top: 1em">These options
(which are mutually exclusive) control what the \R escape
sequence matches. The choice is either to match only CR, LF,
or CRLF, or to match any Unicode newline sequence. These
options override the choice that was made or defaulted when
the pattern was compiled.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NEWLINE_CR
<br>
PCRE_NEWLINE_LF <br>
PCRE_NEWLINE_CRLF <br>
PCRE_NEWLINE_ANYCRLF <br>
PCRE_NEWLINE_ANY</p>

<p style="margin-left:11%; margin-top: 1em">These options
override the newline definition that was chosen or defaulted
when the pattern was compiled. For details, see the
description of <b>pcre_compile()</b> above. During matching,
the newline choice affects the behaviour of the dot,
circumflex, and dollar metacharacters. It may also alter the
way the match position is advanced after a match failure for
an unanchored pattern.</p>

<p style="margin-left:11%; margin-top: 1em">When
PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or PCRE_NEWLINE_ANY
is set, and a match attempt for an unanchored pattern fails
when the current position is at a CRLF sequence, and the
pattern contains no explicit matches for CR or LF
characters, the match position is advanced by two characters
instead of one, in other words, to after the CRLF.</p>

<p style="margin-left:11%; margin-top: 1em">The above rule
is a compromise that makes the most common cases work as
expected. For example, if the pattern is .+A (and the
PCRE_DOTALL option is not set), it does not match the string
&quot;\r\nA&quot; because, after failing at the start, it
skips both the CR and the LF before retrying. However, the
pattern [\r\n]A does match that string, because it contains
an explicit CR or LF reference, and so advances only by one
character after the first failure.</p>

<p style="margin-left:11%; margin-top: 1em">An explicit
match for CR of LF is either a literal appearance of one of
those characters, or one of the \r or \n escape sequences.
Implicit matches such as [^X] do not count, nor does \s
(which includes CR and LF in the characters that it
matches).</p>


<p style="margin-left:11%; margin-top: 1em">Notwithstanding
the above, anomalous effects may still occur when CRLF is a
valid newline sequence and explicit \r or \n escapes appear
in the pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NOTBOL</p>

<p style="margin-left:11%; margin-top: 1em">This option
specifies that first character of the subject string is not
the beginning of a line, so the circumflex metacharacter
should not match before it. Setting this without
PCRE_MULTILINE (at compile time) causes circumflex never to
match. This option affects only the behaviour of the
circumflex metacharacter. It does not affect \A.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NOTEOL</p>

<p style="margin-left:11%; margin-top: 1em">This option
specifies that the end of the subject string is not the end
of a line, so the dollar metacharacter should not match it
nor (except in multiline mode) a newline immediately before
it. Setting this without PCRE_MULTILINE (at compile time)
causes dollar never to match. This option affects only the
behaviour of the dollar metacharacter. It does not affect \Z
or \z.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NOTEMPTY</p>

<p style="margin-left:11%; margin-top: 1em">An empty string
is not considered to be a valid match if this option is set.
If there are alternatives in the pattern, they are tried. If
all the alternatives match the empty string, the entire
match fails. For example, if the pattern</p>

<p style="margin-left:11%; margin-top: 1em">a?b?</p>

<p style="margin-left:11%; margin-top: 1em">is applied to a
string not beginning with &quot;a&quot; or &quot;b&quot;, it
matches an empty string at the start of the subject. With
PCRE_NOTEMPTY set, this match is not valid, so PCRE searches
further into the string for occurrences of &quot;a&quot; or
&quot;b&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NOTEMPTY_ATSTART</p>

<p style="margin-left:11%; margin-top: 1em">This is like
PCRE_NOTEMPTY, except that an empty string match that is not
at the start of the subject is permitted. If the pattern is
anchored, such a match can occur only if the pattern
contains \K.</p>

<p style="margin-left:11%; margin-top: 1em">Perl has no
direct equivalent of PCRE_NOTEMPTY or PCRE_NOTEMPTY_ATSTART,
but it does make a special case of a pattern match of the
empty string within its <b>split()</b> function, and when
using the /g modifier. It is possible to emulate
Perl&rsquo;s behaviour after matching a null string by first
trying the match again at the same offset with
PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED, and then if that
fails, by advancing the starting offset (see below) and
trying an ordinary match again. There is some code that
demonstrates how to do this in the <b>pcredemo</b> sample
program. In the most general case, you have to check to see
if the newline convention recognizes CRLF as a newline, and
if so, and the current character is CR followed by LF,
advance the starting offset by two characters instead of
one.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NO_START_OPTIMIZE</p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of optimizations that <b>pcre_exec()</b> uses at the
start of a match, in order to speed up the process. For
example, if it is known that an unanchored match must start
with a specific character, it searches the subject for that
character, and fails immediately if it cannot find it,
without actually running the main matching function. This
means that a special item such as (*COMMIT) at the start of
a pattern is not considered until after a suitable starting
point for the match has been found. When callouts or (*MARK)
items are in use, these &quot;start-up&quot; optimizations
can cause them to be skipped if the pattern is never
actually used. The start-up optimizations are in effect a
pre-scan of the subject that takes place before the pattern
is run.</p>

<p style="margin-left:11%; margin-top: 1em">The
PCRE_NO_START_OPTIMIZE option disables the start-up
optimizations, possibly causing performance to suffer, but
ensuring that in cases where the result is &quot;no
match&quot;, the callouts do occur, and that items such as
(*COMMIT) and (*MARK) are considered at every possible
starting position in the subject string. If
PCRE_NO_START_OPTIMIZE is set at compile time, it cannot be
unset at matching time. The use of PCRE_NO_START_OPTIMIZE
disables JIT execution; when it is set, matching is always
done using interpretively.</p>

<p style="margin-left:11%; margin-top: 1em">Setting
PCRE_NO_START_OPTIMIZE can change the outcome of a matching
operation. Consider the pattern</p>


<p style="margin-left:11%; margin-top: 1em">(*COMMIT)ABC</p>

<p style="margin-left:11%; margin-top: 1em">When this is
compiled, PCRE records the fact that a match must start with
the character &quot;A&quot;. Suppose the subject string is
&quot;DEFABC&quot;. The start-up optimization scans along
the subject, finds &quot;A&quot; and runs the first match
attempt from there. The (*COMMIT) item means that the
pattern must match the current starting position, which in
this case, it does. However, if the same match is run with
PCRE_NO_START_OPTIMIZE set, the initial scan along the
subject string does not happen. The first match attempt is
run starting from &quot;D&quot; and when this fails,
(*COMMIT) prevents any further matches being tried, so the
overall result is &quot;no match&quot;. If the pattern is
studied, more start-up optimizations may be used. For
example, a minimum length for the subject may be recorded.
Consider the pattern</p>


<p style="margin-left:11%; margin-top: 1em">(*MARK:A)(X|Y)</p>

<p style="margin-left:11%; margin-top: 1em">The minimum
length for a match is one character. If the subject is
&quot;ABC&quot;, there will be attempts to match
&quot;ABC&quot;, &quot;BC&quot;, &quot;C&quot;, and then
finally an empty string. If the pattern is studied, the
final attempt does not take place, because PCRE knows that
the subject is too short, and so the (*MARK) is never
encountered. In this case, studying the pattern does not
affect the overall match result, which is still &quot;no
match&quot;, but it does affect the auxiliary information
that is returned.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_NO_UTF8_CHECK</p>

<p style="margin-left:11%; margin-top: 1em">When PCRE_UTF8
is set at compile time, the validity of the subject as a
UTF-8 string is automatically checked when
<b>pcre_exec()</b> is subsequently called. The entire string
is checked before any other processing takes place. The
value of <i>startoffset</i> is also checked to ensure that
it points to the start of a UTF-8 character. There is a
discussion about the validity of UTF-8 strings in the
<b>pcreunicode</b> page. If an invalid sequence of bytes is
found, <b>pcre_exec()</b> returns the error
PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is set and the
problem is a truncated character at the end of the subject,
PCRE_ERROR_SHORTUTF8. In both cases, information about the
precise nature of the error may also be returned (see the
descriptions of these errors in the section entitled
<i>Error return values from</i> <b>pcre_exec()</b> below).
If <i>startoffset</i> contains a value that does not point
to the start of a UTF-8 character (or to the end of the
subject), PCRE_ERROR_BADUTF8_OFFSET is returned.</p>

<p style="margin-left:11%; margin-top: 1em">If you already
know that your subject is valid, and you want to skip these
checks for performance reasons, you can set the
PCRE_NO_UTF8_CHECK option when calling <b>pcre_exec()</b>.
You might want to do this for the second and subsequent
calls to <b>pcre_exec()</b> if you are making repeated calls
to find all the matches in a single subject string. However,
you should be sure that the value of <i>startoffset</i>
points to the start of a character (or the end of the
subject). When PCRE_NO_UTF8_CHECK is set, the effect of
passing an invalid string as a subject or an invalid value
of <i>startoffset</i> is undefined. Your program may
crash.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_PARTIAL_HARD
<br>
PCRE_PARTIAL_SOFT</p>

<p style="margin-left:11%; margin-top: 1em">These options
turn on the partial matching feature. For backwards
compatibility, PCRE_PARTIAL is a synonym for
PCRE_PARTIAL_SOFT. A partial match occurs if the end of the
subject string is reached successfully, but there are not
enough subject characters to complete the match. If this
happens when PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD)
is set, matching continues by testing any remaining
alternatives. Only if no complete match can be found is
PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH.
In other words, PCRE_PARTIAL_SOFT says that the caller is
prepared to handle a partial match, but only if no complete
match can be found.</p>

<p style="margin-left:11%; margin-top: 1em">If
PCRE_PARTIAL_HARD is set, it overrides PCRE_PARTIAL_SOFT. In
this case, if a partial match is found, <b>pcre_exec()</b>
immediately returns PCRE_ERROR_PARTIAL, without considering
any other alternatives. In other words, when
PCRE_PARTIAL_HARD is set, a partial match is considered to
be more important that an alternative complete match.</p>

<p style="margin-left:11%; margin-top: 1em">In both cases,
the portion of the string that was inspected when the
partial match was found is set as the first matching string.
There is a more detailed discussion of partial and
multi-segment matching, with examples, in the
<b>pcrepartial</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The string
to be matched by pcre_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">The subject
string is passed to <b>pcre_exec()</b> as a pointer in
<i>subject</i>, a length in bytes in <i>length</i>, and a
starting byte offset in <i>startoffset</i>. If this is
negative or greater than the length of the subject,
<b>pcre_exec()</b> returns PCRE_ERROR_BADOFFSET. When the
starting offset is zero, the search for a match starts at
the beginning of the subject, and this is by far the most
common case. In UTF-8 mode, the byte offset must point to
the start of a UTF-8 character (or the end of the subject).
Unlike the pattern string, the subject may contain binary
zero bytes.</p>

<p style="margin-left:11%; margin-top: 1em">A non-zero
starting offset is useful when searching for another match
in the same subject by calling <b>pcre_exec()</b> again
after a previous success. Setting <i>startoffset</i> differs
from just passing over a shortened string and setting
PCRE_NOTBOL in the case of a pattern that begins with any
kind of lookbehind. For example, consider the pattern</p>

<p style="margin-left:11%; margin-top: 1em">\Biss\B</p>

<p style="margin-left:11%; margin-top: 1em">which finds
occurrences of &quot;iss&quot; in the middle of words. (\B
matches only if the current position in the subject is not a
word boundary.) When applied to the string
&quot;Mississipi&quot; the first call to <b>pcre_exec()</b>
finds the first occurrence. If <b>pcre_exec()</b> is called
again with just the remainder of the subject, namely
&quot;issipi&quot;, it does not match, because \B is always
false at the start of the subject, which is deemed to be a
word boundary. However, if <b>pcre_exec()</b> is passed the
entire string again, but with <i>startoffset</i> set to 4,
it finds the second occurrence of &quot;iss&quot; because it
is able to look behind the starting point to discover that
it is preceded by a letter.</p>

<p style="margin-left:11%; margin-top: 1em">Finding all the
matches in a subject is tricky when the pattern can match an
empty string. It is possible to emulate Perl&rsquo;s /g
behaviour by first trying the match again at the same
offset, with the PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED
options, and then if that fails, advancing the starting
offset and trying an ordinary match again. There is some
code that demonstrates how to do this in the <b>pcredemo</b>
sample program. In the most general case, you have to check
to see if the newline convention recognizes CRLF as a
newline, and if so, and the current character is CR followed
by LF, advance the starting offset by two characters instead
of one.</p>

<p style="margin-left:11%; margin-top: 1em">If a non-zero
starting offset is passed when the pattern is anchored, one
attempt to match at the given offset is made. This can only
succeed if the pattern does not require the match to be at
the start of the subject.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How
pcre_exec() returns captured substrings</b></p>

<p style="margin-left:11%; margin-top: 1em">In general, a
pattern matches a certain portion of the subject, and in
addition, further substrings from the subject may be picked
out by parts of the pattern. Following the usage in Jeffrey
Friedl&rsquo;s book, this is called &quot;capturing&quot; in
what follows, and the phrase &quot;capturing
subpattern&quot; is used for a fragment of a pattern that
picks out a substring. PCRE supports several other kinds of
parenthesized subpattern that do not cause substrings to be
captured.</p>

<p style="margin-left:11%; margin-top: 1em">Captured
substrings are returned to the caller via a vector of
integers whose address is passed in <i>ovector</i>. The
number of elements in the vector is passed in
<i>ovecsize</i>, which must be a non-negative number.
<b>Note</b>: this argument is NOT the size of <i>ovector</i>
in bytes.</p>

<p style="margin-left:11%; margin-top: 1em">The first
two-thirds of the vector is used to pass back captured
substrings, each substring using a pair of integers. The
remaining third of the vector is used as workspace by
<b>pcre_exec()</b> while matching capturing subpatterns, and
is not available for passing back information. The number
passed in <i>ovecsize</i> should always be a multiple of
three. If it is not, it is rounded down.</p>

<p style="margin-left:11%; margin-top: 1em">When a match is
successful, information about captured substrings is
returned in pairs of integers, starting at the beginning of
<i>ovector</i>, and continuing up to two-thirds of its
length at the most. The first element of each pair is set to
the byte offset of the first character in a substring, and
the second is set to the byte offset of the first character
after the end of a substring. <b>Note</b>: these values are
always byte offsets, even in UTF-8 mode. They are not
character counts.</p>

<p style="margin-left:11%; margin-top: 1em">The first pair
of integers, <i>ovector[0]</i> and <i>ovector[1]</i>,
identify the portion of the subject string matched by the
entire pattern. The next pair is used for the first
capturing subpattern, and so on. The value returned by
<b>pcre_exec()</b> is one more than the highest numbered
pair that has been set. For example, if two substrings have
been captured, the returned value is 3. If there are no
capturing subpatterns, the return value from a successful
match is 1, indicating that just the first pair of offsets
has been set.</p>

<p style="margin-left:11%; margin-top: 1em">If a capturing
subpattern is matched repeatedly, it is the last portion of
the string that it matched that is returned.</p>

<p style="margin-left:11%; margin-top: 1em">If the vector
is too small to hold all the captured substring offsets, it
is used as far as possible (up to two-thirds of its length),
and the function returns a value of zero. If neither the
actual string matched nor any captured substrings are of
interest, <b>pcre_exec()</b> may be called with
<i>ovector</i> passed as NULL and <i>ovecsize</i> as zero.
However, if the pattern contains back references and the
<i>ovector</i> is not big enough to remember the related
substrings, PCRE has to get additional memory for use during
matching. Thus it is usually advisable to supply an
<i>ovector</i> of reasonable size.</p>

<p style="margin-left:11%; margin-top: 1em">There are some
cases where zero is returned (indicating vector overflow)
when in fact the vector is exactly the right size for the
final match. For example, consider the pattern</p>


<p style="margin-left:11%; margin-top: 1em">(a)(?:(b)c|bd)</p>

<p style="margin-left:11%; margin-top: 1em">If a vector of
6 elements (allowing for only 1 captured substring) is given
with subject string &quot;abd&quot;, <b>pcre_exec()</b> will
try to set the second captured string, thereby recording a
vector overflow, before failing to match &quot;c&quot; and
backing up to try the second alternative. The zero return,
however, does correctly indicate that the maximum number of
slots (namely 2) have been filled. In similar cases where
there is temporary overflow, but the final number of used
slots is actually less than the maximum, a non-zero value is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>pcre_fullinfo()</b> function can be used to find out how
many capturing subpatterns there are in a compiled pattern.
The smallest size for <i>ovector</i> that will allow for
<i>n</i> captured substrings, in addition to the offsets of
the substring matched by the whole pattern, is
(<i>n</i>+1)*3.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
for capturing subpattern number <i>n+1</i> to match some
part of the subject when subpattern <i>n</i> has not been
used at all. For example, if the string &quot;abc&quot; is
matched against the pattern (a|(z))(bc) the return from the
function is 4, and subpatterns 1 and 3 are matched, but 2 is
not. When this happens, both values in the offset pairs
corresponding to unused subpatterns are set to -1.</p>

<p style="margin-left:11%; margin-top: 1em">Offset values
that correspond to unused subpatterns at the end of the
expression are also set to -1. For example, if the string
&quot;abc&quot; is matched against the pattern
(abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The
return from the function is 2, because the highest used
capturing subpattern number is 1, and the offsets for for
the second and third capturing subpatterns (assuming the
vector is large enough, of course) are set to -1.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note</b>:
Elements in the first two-thirds of <i>ovector</i> that do
not correspond to capturing parentheses in the pattern are
never changed. That is, if a pattern contains <i>n</i>
capturing parentheses, no more than <i>ovector[0]</i> to
<i>ovector[2n+1]</i> are set by <b>pcre_exec()</b>. The
other elements (in the first two-thirds) retain whatever
values they previously had.</p>

<p style="margin-left:11%; margin-top: 1em">Some
convenience functions are provided for extracting the
captured substrings as separate strings. These are described
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Error return
values from pcre_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">If
<b>pcre_exec()</b> fails, it returns a negative number. The
following are defined in the header file:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOMATCH
(-1)</p>

<p style="margin-left:11%; margin-top: 1em">The subject
string did not match the pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NULL
(-2)</p>

<p style="margin-left:11%; margin-top: 1em">Either
<i>code</i> or <i>subject</i> was passed as NULL, or
<i>ovector</i> was NULL and <i>ovecsize</i> was not
zero.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADOPTION
(-3)</p>

<p style="margin-left:11%; margin-top: 1em">An unrecognized
bit was set in the <i>options</i> argument.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADMAGIC
(-4)</p>

<p style="margin-left:11%; margin-top: 1em">PCRE stores a
4-byte &quot;magic number&quot; at the start of the compiled
code, to catch the case when it is passed a junk pointer and
to detect when a pattern that was compiled in an environment
of one endianness is run in an environment with the other
endianness. This is the error that PCRE gives when the magic
number is not present.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_UNKNOWN_OPCODE
(-5)</p>

<p style="margin-left:11%; margin-top: 1em">While running
the pattern match, an unknown item was encountered in the
compiled pattern. This error could be caused by a bug in
PCRE or by overwriting of the compiled pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOMEMORY
(-6)</p>

<p style="margin-left:11%; margin-top: 1em">If a pattern
contains back references, but the <i>ovector</i> that is
passed to <b>pcre_exec()</b> is not big enough to remember
the referenced substrings, PCRE gets a block of memory at
the start of matching to use for this purpose. If the call
via <b>pcre_malloc()</b> fails, this error is given. The
memory is automatically freed at the end of matching.</p>

<p style="margin-left:11%; margin-top: 1em">This error is
also given if <b>pcre_stack_malloc()</b> fails in
<b>pcre_exec()</b>. This can happen only when PCRE has been
compiled with <b>--disable-stack-for-recursion</b>.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOSUBSTRING
(-7)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
used by the <b>pcre_copy_substring()</b>,
<b>pcre_get_substring()</b>, and
<b>pcre_get_substring_list()</b> functions (see below). It
is never returned by <b>pcre_exec()</b>.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_MATCHLIMIT
(-8)</p>

<p style="margin-left:11%; margin-top: 1em">The
backtracking limit, as specified by the <i>match_limit</i>
field in a <b>pcre_extra</b> structure (or defaulted) was
reached. See the description above.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_CALLOUT
(-9)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
never generated by <b>pcre_exec()</b> itself. It is provided
for use by callout functions that want to yield a
distinctive error code. See the <b>pcrecallout</b>
documentation for details.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADUTF8
(-10)</p>

<p style="margin-left:11%; margin-top: 1em">A string that
contains an invalid UTF-8 byte sequence was passed as a
subject, and the PCRE_NO_UTF8_CHECK option was not set. If
the size of the output vector (<i>ovecsize</i>) is at least
2, the byte offset to the start of the the invalid UTF-8
character is placed in the first element, and a reason code
is placed in the second element. The reason codes are listed
in the following section. For backward compatibility, if
PCRE_PARTIAL_HARD is set and the problem is a truncated
UTF-8 character at the end of the subject (reason codes 1 to
5), PCRE_ERROR_SHORTUTF8 is returned instead of
PCRE_ERROR_BADUTF8.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADUTF8_OFFSET
(-11)</p>

<p style="margin-left:11%; margin-top: 1em">The UTF-8 byte
sequence that was passed as a subject was checked and found
to be valid (the PCRE_NO_UTF8_CHECK option was not set), but
the value of <i>startoffset</i> did not point to the
beginning of a UTF-8 character or the end of the
subject.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_PARTIAL
(-12)</p>

<p style="margin-left:11%; margin-top: 1em">The subject
string did not match, but it did match partially. See the
<b>pcrepartial</b> documentation for details of partial
matching.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADPARTIAL
(-13)</p>

<p style="margin-left:11%; margin-top: 1em">This code is no
longer in use. It was formerly returned when the
PCRE_PARTIAL option was used with a compiled pattern
containing items that were not supported for partial
matching. From release 8.00 onwards, there are no
restrictions on partial matching.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_INTERNAL
(-14)</p>

<p style="margin-left:11%; margin-top: 1em">An unexpected
internal error has occurred. This error could be caused by a
bug in PCRE or by overwriting of the compiled pattern.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADCOUNT
(-15)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
given if the value of the <i>ovecsize</i> argument is
negative.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_RECURSIONLIMIT
(-21)</p>

<p style="margin-left:11%; margin-top: 1em">The internal
recursion limit, as specified by the
<i>match_limit_recursion</i> field in a <b>pcre_extra</b>
structure (or defaulted) was reached. See the description
above.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADNEWLINE
(-23)</p>

<p style="margin-left:11%; margin-top: 1em">An invalid
combination of PCRE_NEWLINE_<i>xxx</i> options was
given.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADOFFSET
(-24)</p>

<p style="margin-left:11%; margin-top: 1em">The value of
<i>startoffset</i> was negative or greater than the length
of the subject, that is, the value in <i>length</i>.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_SHORTUTF8
(-25)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
returned instead of PCRE_ERROR_BADUTF8 when the subject
string ends with a truncated UTF-8 character and the
PCRE_PARTIAL_HARD option is set. Information about the
failure is returned as for PCRE_ERROR_BADUTF8. It is in fact
sufficient to detect this case, but this special error code
for PCRE_PARTIAL_HARD precedes the implementation of
returned information; it is retained for backwards
compatibility.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_RECURSELOOP
(-26)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
returned when <b>pcre_exec()</b> detects a recursion loop
within the pattern. Specifically, it means that either the
whole pattern or a subpattern has been called recursively
for the second time at the same position in the subject
string. Some simple patterns that might do this are detected
and faulted at compile time, but more complicated cases, in
particular mutual recursions between two different
subpatterns, cannot be detected until run time.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_JIT_STACKLIMIT
(-27)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
returned when a pattern that was successfully studied using
a JIT compile option is being matched, but the memory
available for the just-in-time processing stack is not large
enough. See the <b>pcrejit</b> documentation for more
details.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADMODE
(-28)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
given if a pattern that was compiled by the 8-bit library is
passed to a 16-bit or 32-bit library function, or vice
versa.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADENDIANNESS
(-29)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
given if a pattern that was compiled and saved is reloaded
on a host with different endianness. The utility function
<b>pcre_pattern_to_host_byte_order()</b> can be used to
convert such a pattern so that it runs on the new host.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_JIT_BADOPTION</p>

<p style="margin-left:11%; margin-top: 1em">This error is
returned when a pattern that was successfully studied using
a JIT compile option is being matched, but the matching mode
(partial or complete match) does not correspond to any JIT
compilation mode. When the JIT fast path function is used,
this error may be also given for invalid options. See the
<b>pcrejit</b> documentation for more details.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_BADLENGTH
(-32)</p>

<p style="margin-left:11%; margin-top: 1em">This error is
given if <b>pcre_exec()</b> is called with a negative value
for the <i>length</i> argument.</p>

<p style="margin-left:11%; margin-top: 1em">Error numbers
-16 to -20, -22, and 30 are not used by
<b>pcre_exec()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reason codes
for invalid UTF-8 strings</b></p>

<p style="margin-left:11%; margin-top: 1em">This section
applies only to the 8-bit library. The corresponding
information for the 16-bit and 32-bit libraries is given in
the <b>pcre16</b> and <b>pcre32</b> pages.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_exec()</b> returns either PCRE_ERROR_BADUTF8 or
PCRE_ERROR_SHORTUTF8, and the size of the output vector
(<i>ovecsize</i>) is at least 2, the offset of the start of
the invalid UTF-8 character is placed in the first output
vector element (<i>ovector[0]</i>) and a reason code is
placed in the second element (<i>ovector[1]</i>). The reason
codes are given names in the <b>pcre.h</b> header file:</p>

<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR1
<br>
PCRE_UTF8_ERR2 <br>
PCRE_UTF8_ERR3 <br>
PCRE_UTF8_ERR4 <br>
PCRE_UTF8_ERR5</p>

<p style="margin-left:11%; margin-top: 1em">The string ends
with a truncated UTF-8 character; the code specifies how
many bytes are missing (1 to 5). Although RFC 3629 restricts
UTF-8 characters to be no longer than 4 bytes, the encoding
scheme (originally defined by RFC 2279) allows for up to 6
bytes, and this is checked first; hence the possibility of 4
or 5 missing bytes.</p>

<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR6
<br>
PCRE_UTF8_ERR7 <br>
PCRE_UTF8_ERR8 <br>
PCRE_UTF8_ERR9 <br>
PCRE_UTF8_ERR10</p>

<p style="margin-left:11%; margin-top: 1em">The two most
significant bits of the 2nd, 3rd, 4th, 5th, or 6th byte of
the character do not have the binary value 0b10 (that is,
either the most significant bit is 0, or the next bit is
1).</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR11
<br>
PCRE_UTF8_ERR12</p>

<p style="margin-left:11%; margin-top: 1em">A character
that is valid by the RFC 2279 rules is either 5 or 6 bytes
long; these code points are excluded by RFC 3629.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR13</p>

<p style="margin-left:11%; margin-top: 1em">A 4-byte
character has a value greater than 0x10fff; these code
points are excluded by RFC 3629.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR14</p>

<p style="margin-left:11%; margin-top: 1em">A 3-byte
character has a value in the range 0xd800 to 0xdfff; this
range of code points are reserved by RFC 3629 for use with
UTF-16, and so are excluded from UTF-8.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR15
<br>
PCRE_UTF8_ERR16 <br>
PCRE_UTF8_ERR17 <br>
PCRE_UTF8_ERR18 <br>
PCRE_UTF8_ERR19</p>

<p style="margin-left:11%; margin-top: 1em">A 2-, 3-, 4-,
5-, or 6-byte character is &quot;overlong&quot;, that is, it
codes for a value that can be represented by fewer bytes,
which is invalid. For example, the two bytes 0xc0, 0xae give
the value 0x2e, whose correct coding uses just one byte.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR20</p>

<p style="margin-left:11%; margin-top: 1em">The two most
significant bits of the first byte of a character have the
binary value 0b10 (that is, the most significant bit is 1
and the second is 0). Such a byte can only validly occur as
the second or subsequent byte of a multi-byte character.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR21</p>

<p style="margin-left:11%; margin-top: 1em">The first byte
of a character has the value 0xfe or 0xff. These values can
never occur in a valid UTF-8 string.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_UTF8_ERR2</p>

<p style="margin-left:11%; margin-top: 1em">Non-character.
These are the last two characters in each plane (0xfffe,
0xffff, 0x1fffe, 0x1ffff .. 0x10fffe, 0x10ffff), and the
characters 0xfdd0..0xfdef.</p>

<h2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER
<a name="EXTRACTING CAPTURED SUBSTRINGS BY NUMBER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_copy_substring(const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, int</b>
<i>stringnumber</i><b>, char *</b><i>buffer</i><b>, <br>
int</b> <i>buffersize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_substring(const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, int</b>
<i>stringnumber</i><b>, <br>
const char **</b><i>stringptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_substring_list(const char *</b><i>subject</i><b>,
<br>
int *</b><i>ovector</i><b>, int</b> <i>stringcount</i><b>,
const char ***</b><i>listptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">Captured
substrings can be accessed directly by using the offsets
returned by <b>pcre_exec()</b> in <i>ovector</i>. For
convenience, the functions <b>pcre_copy_substring()</b>,
<b>pcre_get_substring()</b>, and
<b>pcre_get_substring_list()</b> are provided for extracting
captured substrings as new, separate, zero-terminated
strings. These functions identify substrings by number. The
next section describes functions for extracting named
substrings.</p>

<p style="margin-left:11%; margin-top: 1em">A substring
that contains a binary zero is correctly extracted and has a
further zero added on the end, but the result is not, of
course, a C string. However, you can process such a string
by referring to the length that is returned by
<b>pcre_copy_substring()</b> and
<b>pcre_get_substring()</b>. Unfortunately, the interface to
<b>pcre_get_substring_list()</b> is not adequate for
handling strings containing binary zeros, because the end of
the final string is not independently indicated.</p>

<p style="margin-left:11%; margin-top: 1em">The first three
arguments are the same for all three of these functions:
<i>subject</i> is the subject string that has just been
successfully matched, <i>ovector</i> is a pointer to the
vector of integer offsets that was passed to
<b>pcre_exec()</b>, and <i>stringcount</i> is the number of
substrings that were captured by the match, including the
substring that matched the entire regular expression. This
is the value returned by <b>pcre_exec()</b> if it is greater
than zero. If <b>pcre_exec()</b> returned zero, indicating
that it ran out of space in <i>ovector</i>, the value passed
as <i>stringcount</i> should be the number of elements in
the vector divided by three.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>pcre_copy_substring()</b> and <b>pcre_get_substring()</b>
extract a single substring, whose number is given as
<i>stringnumber</i>. A value of zero extracts the substring
that matched the entire pattern, whereas higher values
extract the captured substrings. For
<b>pcre_copy_substring()</b>, the string is placed in
<i>buffer</i>, whose length is given by <i>buffersize</i>,
while for <b>pcre_get_substring()</b> a new block of memory
is obtained via <b>pcre_malloc</b>, and its address is
returned via <i>stringptr</i>. The yield of the function is
the length of the string, not including the terminating
zero, or one of these error codes:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOMEMORY
(-6)</p>

<p style="margin-left:11%; margin-top: 1em">The buffer was
too small for <b>pcre_copy_substring()</b>, or the attempt
to get memory failed for <b>pcre_get_substring()</b>.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOSUBSTRING
(-7)</p>

<p style="margin-left:11%; margin-top: 1em">There is no
substring whose number is <i>stringnumber</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>pcre_get_substring_list()</b> function extracts all
available substrings and builds a list of pointers to them.
All this is done in a single block of memory that is
obtained via <b>pcre_malloc</b>. The address of the memory
block is returned via <i>listptr</i>, which is also the
start of the list of string pointers. The end of the list is
marked by a NULL pointer. The yield of the function is zero
if all went well, or the error code</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_NOMEMORY
(-6)</p>

<p style="margin-left:11%; margin-top: 1em">if the attempt
to get the memory block failed.</p>

<p style="margin-left:11%; margin-top: 1em">When any of
these functions encounter a substring that is unset, which
can happen when capturing subpattern number <i>n+1</i>
matches some part of the subject, but subpattern <i>n</i>
has not been used at all, they return an empty string. This
can be distinguished from a genuine zero-length substring by
inspecting the appropriate offset in <i>ovector</i>, which
is negative for unset substrings.</p>

<p style="margin-left:11%; margin-top: 1em">The two
convenience functions <b>pcre_free_substring()</b> and
<b>pcre_free_substring_list()</b> can be used to free the
memory returned by a previous call of
<b>pcre_get_substring()</b> or
<b>pcre_get_substring_list()</b>, respectively. They do
nothing more than call the function pointed to by
<b>pcre_free</b>, which of course could be called directly
from a C program. However, PCRE is used in some situations
where it is linked via a special interface to another
programming language that cannot use <b>pcre_free</b>
directly; it is for these cases that the functions are
provided.</p>

<h2>EXTRACTING CAPTURED SUBSTRINGS BY NAME
<a name="EXTRACTING CAPTURED SUBSTRINGS BY NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_stringnumber(const pcre *</b><i>code</i><b>, <br>
const char *</b><i>name</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_copy_named_substring(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, const char
*</b><i>stringname</i><b>, <br>
char *</b><i>buffer</i><b>, int</b>
<i>buffersize</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_named_substring(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>subject</i><b>, int
*</b><i>ovector</i><b>, <br>
int</b> <i>stringcount</i><b>, const char
*</b><i>stringname</i><b>, <br>
const char **</b><i>stringptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">To extract a
substring by name, you first have to find associated number.
For example, for this pattern</p>


<p style="margin-left:11%; margin-top: 1em">(a+)b(?&lt;xxx&gt;\d+)...</p>

<p style="margin-left:11%; margin-top: 1em">the number of
the subpattern called &quot;xxx&quot; is 2. If the name is
known to be unique (PCRE_DUPNAMES was not set), you can find
the number from the name by calling
<b>pcre_get_stringnumber()</b>. The first argument is the
compiled pattern, and the second is the name. The yield of
the function is the subpattern number, or
PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of
that name.</p>

<p style="margin-left:11%; margin-top: 1em">Given the
number, you can extract the substring directly, or use one
of the functions described in the previous section. For
convenience, there are also two functions that do the whole
job.</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
arguments of <b>pcre_copy_named_substring()</b> and
<b>pcre_get_named_substring()</b> are the same as those for
the similarly named functions that extract by number. As
these are described in the previous section, they are not
re-described here. There are just two differences:</p>

<p style="margin-left:11%; margin-top: 1em">First, instead
of a substring number, a substring name is given. Second,
there is an extra argument, given at the start, which is a
pointer to the compiled pattern. This is needed in order to
gain access to the name-to-number translation table.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
call <b>pcre_get_stringnumber()</b>, and if it succeeds,
they then call <b>pcre_copy_substring()</b> or
<b>pcre_get_substring()</b>, as appropriate. <b>NOTE:</b> If
PCRE_DUPNAMES is set and there are duplicate names, the
behaviour may not be what you want (see the next
section).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Warning:</b>
If the pattern uses the (?| feature to set up multiple
subpatterns with the same number, as described in the
section on duplicate subpattern numbers in the
<b>pcrepattern</b> page, you cannot use names to distinguish
the different subpatterns, because names are not included in
the compiled code. The matching process uses only numbers.
For this reason, the use of different names for subpatterns
of the same number causes an error at compile time.</p>

<h2>DUPLICATE SUBPATTERN NAMES
<a name="DUPLICATE SUBPATTERN NAMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_get_stringtable_entries(const pcre *</b><i>code</i><b>,
<br>
const char *</b><i>name</i><b>, char **</b><i>first</i><b>,
char **</b><i>last</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">When a pattern
is compiled with the PCRE_DUPNAMES option, names for
subpatterns are not required to be unique. (Duplicate names
are always allowed for subpatterns with the same number,
created by using the (?| feature. Indeed, if such
subpatterns are named, they are required to use the same
names.)</p>

<p style="margin-left:11%; margin-top: 1em">Normally,
patterns with duplicate names are such that in any one
match, only one of the named subpatterns participates. An
example is shown in the <b>pcrepattern</b>
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">When duplicates
are present, <b>pcre_copy_named_substring()</b> and
<b>pcre_get_named_substring()</b> return the first substring
corresponding to the given name that is set. If none are
set, PCRE_ERROR_NOSUBSTRING (-7) is returned; no data is
returned. The <b>pcre_get_stringnumber()</b> function
returns one of the numbers that are associated with the
name, but it is not defined which it is.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
get full details of all captured substrings for a given
name, you must use the <b>pcre_get_stringtable_entries()</b>
function. The first argument is the compiled pattern, and
the second is the name. The third and fourth are pointers to
variables which are updated by the function. After it has
run, they point to the first and last entries in the
name-to-number table for the given name. The function itself
returns the length of each entry, or PCRE_ERROR_NOSUBSTRING
(-7) if there are none. The format of the table is described
above in the section entitled <i>Information about a
pattern</i> above. Given all the relevant entries for the
name, you can extract each of their numbers, and hence the
captured data, if any.</p>

<h2>FINDING ALL POSSIBLE MATCHES
<a name="FINDING ALL POSSIBLE MATCHES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The traditional
matching function uses a similar algorithm to Perl, which
stops when it finds the first match, starting at a given
point in the subject. If you want to find all possible
matches, or the longest possible match, consider using the
alternative matching function (see below) instead. If you
cannot use the alternative function, but still need to find
all possible matches, you can kludge it up by making use of
the callout facility, which is described in the
<b>pcrecallout</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">What you have
to do is to insert a callout right at the end of the
pattern. When your callout function is called, extract and
save the current matched substring. Then return 1, which
forces <b>pcre_exec()</b> to backtrack and try other
alternatives. Ultimately, when it runs out of matches,
<b>pcre_exec()</b> will yield PCRE_ERROR_NOMATCH.</p>

<h2>OBTAINING AN ESTIMATE OF STACK USAGE
<a name="OBTAINING AN ESTIMATE OF STACK USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Matching
certain patterns using <b>pcre_exec()</b> can use a lot of
process stack, which in certain environments can be rather
limited in size. Some users find it helpful to have an
estimate of the amount of stack that is used by
<b>pcre_exec()</b>, to help them set recursion limits, as
described in the <b>pcrestack</b> documentation. The
estimate that is output by <b>pcretest</b> when called with
the <b>-m</b> and <b>-C</b> options is obtained by calling
<b>pcre_exec</b> with the values NULL, NULL, NULL, -999, and
-999 for its first five arguments.</p>

<p style="margin-left:11%; margin-top: 1em">Normally, if
its first argument is NULL, <b>pcre_exec()</b> immediately
returns the negative error code PCRE_ERROR_NULL, but with
this special combination of arguments, it returns instead a
negative number whose absolute value is the approximate
stack frame size in bytes. (A negative number is used so
that it is clear that no match has happened.) The value is
approximate because in some cases, recursive calls to
<b>pcre_exec()</b> occur when there are one or two
additional variables on the stack.</p>

<p style="margin-left:11%; margin-top: 1em">If PCRE has
been compiled to use the heap instead of the stack for
recursion, the value returned is the size of each block that
is obtained from the heap.</p>

<h2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION
<a name="MATCHING A PATTERN: THE ALTERNATIVE FUNCTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
pcre_dfa_exec(const pcre *</b><i>code</i><b>, const
pcre_extra *</b><i>extra</i><b>, <br>
const char *</b><i>subject</i><b>, int</b> <i>length</i><b>,
int</b> <i>startoffset</i><b>, <br>
int</b> <i>options</i><b>, int *</b><i>ovector</i><b>,
int</b> <i>ovecsize</i><b>, <br>
int *</b><i>workspace</i><b>, int</b>
<i>wscount</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The function
<b>pcre_dfa_exec()</b> is called to match a subject string
against a compiled pattern, using a matching algorithm that
scans the subject string just once, and does not backtrack.
This has different characteristics to the normal algorithm,
and is not compatible with Perl. Some of the features of
PCRE patterns are not supported. Nevertheless, there are
times when this kind of matching can be useful. For a
discussion of the two matching algorithms, and a list of
features that <b>pcre_dfa_exec()</b> does not support, see
the <b>pcrematching</b> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
for the <b>pcre_dfa_exec()</b> function are the same as for
<b>pcre_exec()</b>, plus two extras. The <i>ovector</i>
argument is used in a different way, and this is described
below. The other common arguments are used in the same way
as for <b>pcre_exec()</b>, so their description is not
repeated here.</p>

<p style="margin-left:11%; margin-top: 1em">The two
additional arguments provide workspace for the function. The
workspace vector should contain at least 20 elements. It is
used for keeping track of multiple paths through the pattern
tree. More workspace will be needed for patterns and
subjects where there are a lot of potential matches.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of a simple call to <b>pcre_dfa_exec()</b>:</p>

<p style="margin-left:11%; margin-top: 1em">int rc; <br>
int ovector[10]; <br>
int wspace[20]; <br>
rc = pcre_dfa_exec( <br>
re, /* result of pcre_compile() */ <br>
NULL, /* we didn&rsquo;t study the pattern */ <br>
&quot;some string&quot;, /* the subject string */ <br>
11, /* the length of the subject string */ <br>
0, /* start at offset 0 in the subject */ <br>
0, /* default options */ <br>
ovector, /* vector of integers for substring information */
<br>
10, /* number of elements (NOT size in bytes) */ <br>
wspace, /* working space vector */ <br>
20); /* number of elements (NOT size in bytes) */</p>

<p style="margin-left:11%; margin-top: 1em"><b>Option bits
for pcre_dfa_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">The unused bits
of the <i>options</i> argument for <b>pcre_dfa_exec()</b>
must be zero. The only bits that may be set are
PCRE_ANCHORED, PCRE_NEWLINE_<i>xxx</i>, PCRE_NOTBOL,
PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_UTF8_CHECK, PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE,
PCRE_NO_START_OPTIMIZE, PCRE_PARTIAL_HARD,
PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST, and PCRE_DFA_RESTART.
All but the last four of these are exactly the same as for
<b>pcre_exec()</b>, so their description is not repeated
here.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_PARTIAL_HARD
<br>
PCRE_PARTIAL_SOFT</p>

<p style="margin-left:11%; margin-top: 1em">These have the
same general effect as they do for <b>pcre_exec()</b>, but
the details are slightly different. When PCRE_PARTIAL_HARD
is set for <b>pcre_dfa_exec()</b>, it returns
PCRE_ERROR_PARTIAL if the end of the subject is reached and
there is still at least one matching possibility that
requires additional characters. This happens even if some
complete matches have also been found. When
PCRE_PARTIAL_SOFT is set, the return code PCRE_ERROR_NOMATCH
is converted into PCRE_ERROR_PARTIAL if the end of the
subject is reached, there have been no complete matches, but
there is still at least one matching possibility. The
portion of the string that was inspected when the longest
partial match was found is set as the first matching string
in both cases. There is a more detailed discussion of
partial and multi-segment matching, with examples, in the
<b>pcrepartial</b> documentation.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_DFA_SHORTEST</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
PCRE_DFA_SHORTEST option causes the matching algorithm to
stop as soon as it has found one match. Because of the way
the alternative algorithm works, this is necessarily the
shortest possible match at the first possible matching point
in the subject string.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_DFA_RESTART</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_dfa_exec()</b> returns a partial match, it is
possible to call it again, with additional subject
characters, and have it continue with the same match. The
PCRE_DFA_RESTART option requests this action; when it is
set, the <i>workspace</i> and <i>wscount</i> options must
reference the same vector as before because data about the
match so far is left in them after a partial match. There is
more discussion of this facility in the <b>pcrepartial</b>
documentation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Successful
returns from pcre_dfa_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_dfa_exec()</b> succeeds, it may have matched more
than one substring in the subject. Note, however, that all
the matches from one run of the function start at the same
point in the subject. The shorter matches are all initial
substrings of the longer matches. For example, if the
pattern</p>

<p style="margin-left:11%; margin-top: 1em">&lt;.*&gt;</p>

<p style="margin-left:11%; margin-top: 1em">is matched
against the string</p>

<p style="margin-left:11%; margin-top: 1em">This is
&lt;something&gt; &lt;something else&gt; &lt;something
further&gt; no more</p>

<p style="margin-left:11%; margin-top: 1em">the three
matched strings are</p>


<p style="margin-left:11%; margin-top: 1em">&lt;something&gt;
<br>
&lt;something&gt; &lt;something else&gt; <br>
&lt;something&gt; &lt;something else&gt; &lt;something
further&gt;</p>

<p style="margin-left:11%; margin-top: 1em">On success, the
yield of the function is a number greater than zero, which
is the number of matched substrings. The substrings
themselves are returned in <i>ovector</i>. Each string uses
two elements; the first is the offset to the start, and the
second is the offset to the end. In fact, all the strings
have the same start offset. (Space could have been saved by
giving this only once, but it was decided to retain some
compatibility with the way <b>pcre_exec()</b> returns data,
even though the meaning of the strings is different.)</p>

<p style="margin-left:11%; margin-top: 1em">The strings are
returned in reverse order of length; that is, the longest
matching string is given first. If there were too many
matches to fit into <i>ovector</i>, the yield of the
function is zero, and the vector is filled with the longest
matches. Unlike <b>pcre_exec()</b>, <b>pcre_dfa_exec()</b>
can use the entire <i>ovector</i> for returning matched
strings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Error
returns from pcre_dfa_exec()</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>pcre_dfa_exec()</b> function returns a negative number
when it fails. Many of the errors are the same as for
<b>pcre_exec()</b>, and these are described above. There are
in addition the following errors that are specific to
<b>pcre_dfa_exec()</b>:</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_UITEM
(-16)</p>

<p style="margin-left:11%; margin-top: 1em">This return is
given if <b>pcre_dfa_exec()</b> encounters an item in the
pattern that it does not support, for instance, the use of
\C or a back reference.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_UCOND
(-17)</p>

<p style="margin-left:11%; margin-top: 1em">This return is
given if <b>pcre_dfa_exec()</b> encounters a condition item
that uses a back reference for the condition, or a test for
recursion in a specific group. These are not supported.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_UMLIMIT
(-18)</p>

<p style="margin-left:11%; margin-top: 1em">This return is
given if <b>pcre_dfa_exec()</b> is called with an
<i>extra</i> block that contains a setting of the
<i>match_limit</i> or <i>match_limit_recursion</i> fields.
This is not supported (these fields are meaningless for DFA
matching).</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_WSSIZE
(-19)</p>

<p style="margin-left:11%; margin-top: 1em">This return is
given if <b>pcre_dfa_exec()</b> runs out of space in the
<i>workspace</i> vector.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_RECURSE
(-20)</p>

<p style="margin-left:11%; margin-top: 1em">When a
recursive subpattern is processed, the matching function
calls itself recursively, using private vectors for
<i>ovector</i> and <i>workspace</i>. This error is given if
the output vector is not large enough. This should be
extremely rare, as a vector of size 1000 is used.</p>


<p style="margin-left:11%; margin-top: 1em">PCRE_ERROR_DFA_BADRESTART
(-30)</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>pcre_dfa_exec()</b> is called with the
<b>PCRE_DFA_RESTART</b> option, some plausibility checks are
made on the contents of the workspace, which should contain
data about the previous partial match. If any of these
checks fail, this error is given.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>pcre16</b>(3),
<b>pcre32</b>(3), <b>pcrebuild</b>(3),
<b>pcrecallout</b>(3), <b>pcrecpp(3)</b>(3),
<b>pcrematching</b>(3), <b>pcrepartial</b>(3),
<b>pcreposix</b>(3), <b>pcreprecompile</b>(3),
<b>pcresample</b>(3), <b>pcrestack</b>(3).</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Philip Hazel
<br>
University Computing Service <br>
Cambridge CB2 3QH, England.</p>

<h2>REVISION
<a name="REVISION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Last updated:
08 November 2012 <br>
Copyright (c) 1997-2012 University of Cambridge.</p>
<hr>
</body>
</html>
