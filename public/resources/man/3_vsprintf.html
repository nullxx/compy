<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:10:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PRINTF</title>

</head>
<body>

<h1 align="center">PRINTF</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">printf,
fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf,
vsnprintf &minus; formatted output conversion</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;stdio.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
printf(const char *</b><i>format</i><b>, ...); <br>
int fprintf(FILE *</b><i>stream</i><b>, const char
*</b><i>format</i><b>, ...); <br>
int sprintf(char *</b><i>str</i><b>, const char
*</b><i>format</i><b>, ...); <br>
int snprintf(char *</b><i>str</i><b>, size_t</b>
<i>size</i><b>, const char *</b><i>format</i><b>,
...);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;stdarg.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
vprintf(const char *</b><i>format</i><b>, va_list</b>
<i>ap</i><b>); <br>
int vfprintf(FILE *</b><i>stream</i><b>, const char
*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>
int vsprintf(char *</b><i>str</i><b>, const char
*</b><i>format</i><b>, va_list</b> <i>ap</i><b>); <br>
int vsnprintf(char *</b><i>str</i><b>, size_t</b>
<i>size</i><b>, const char *</b><i>format</i><b>,
va_list</b> <i>ap</i><b>);</b></p>

<p style="margin-left:5%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>


<p style="margin-left:11%; margin-top: 1em"><b>snprintf</b>(),
<b>vsnprintf</b>():</p>

<p style="margin-left:17%;">_BSD_SOURCE ||
_XOPEN_SOURCE&nbsp;&gt;=&nbsp;500 || _ISOC99_SOURCE ||
_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200112L; <br>
or <i>cc -std=c99</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
in the <b>printf</b>() family produce output according to a
<i>format</i> as described below. The functions
<b>printf</b>() and <b>vprintf</b>() write output to
<i>stdout</i>, the standard output stream; <b>fprintf</b>()
and <b>vfprintf</b>() write output to the given output
<i>stream</i>; <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>() and <b>vsnprintf</b>() write to the
character string <i>str</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>snprintf</b>() and <b>vsnprintf</b>() write at most
<i>size</i> bytes (including the terminating null byte
('\0')) to <i>str</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>vprintf</b>(), <b>vfprintf</b>(), <b>vsprintf</b>(),
<b>vsnprintf</b>() are equivalent to the functions
<b>printf</b>(), <b>fprintf</b>(), <b>sprintf</b>(),
<b>snprintf</b>(), respectively, except that they are called
with a <i>va_list</i> instead of a variable number of
arguments. These functions do not call the <i>va_end</i>
macro. Because they invoke the <i>va_arg</i> macro, the
value of <i>ap</i> is undefined after the call. See
<b>stdarg</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">These eight
functions write the output under the control of a
<i>format</i> string that specifies how subsequent arguments
(or arguments accessed via the variable-length argument
facilities of <b>stdarg</b>(3)) are converted for
output.</p>

<p style="margin-left:11%; margin-top: 1em">C99 and
POSIX.1-2001 specify that the results are undefined if a
call to <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>(), or <b>vsnprintf</b>() would cause copying
to take place between objects that overlap (e.g., if the
target string array and one of the supplied input arguments
refer to the same buffer). See NOTES.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
value</b> <br>
Upon successful return, these functions return the number of
characters printed (excluding the null byte used to end
output to strings).</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>snprintf</b>() and <b>vsnprintf</b>() do not write more
than <i>size</i> bytes (including the terminating null byte
('\0')). If the output was truncated due to this limit then
the return value is the number of characters (excluding the
terminating null byte) which would have been written to the
final string if enough space had been available. Thus, a
return value of <i>size</i> or more means that the output
was truncated. (See also below under NOTES.)</p>

<p style="margin-left:11%; margin-top: 1em">If an output
error is encountered, a negative value is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Format of
the format string</b> <br>
The format string is a character string, beginning and
ending in its initial shift state, if any. The format string
is composed of zero or more directives: ordinary characters
(not <b>%</b>), which are copied unchanged to the output
stream; and conversion specifications, each of which results
in fetching zero or more subsequent arguments. Each
conversion specification is introduced by the character
<b>%</b>, and ends with a <i>conversion specifier</i>. In
between there may be (in this order) zero or more
<i>flags</i>, an optional minimum <i>field width</i>, an
optional <i>precision</i> and an optional <i>length
modifier</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
must correspond properly (after type promotion) with the
conversion specifier. By default, the arguments are used in
the order given, where each '*' and each conversion
specifier asks for the next argument (and it is an error if
insufficiently many arguments are given). One can also
specify explicitly which argument is taken, at each place
where an argument is required, by writing &quot;%m$&quot;
instead of '%' and &quot;*m$&quot; instead of '*', where the
decimal integer m denotes the position in the argument list
of the desired argument, indexed starting from 1. Thus,</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%*d&quot;,
width, num);</p>

<p style="margin-left:11%; margin-top: 1em">and</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%2$*1$d&quot;,
width, num);</p>

<p style="margin-left:11%; margin-top: 1em">are equivalent.
The second style allows repeated references to the same
argument. The C99 standard does not include the style using
'$', which comes from the Single UNIX Specification. If the
style using '$' is used, it must be used throughout for all
conversions taking an argument and all width and precision
arguments, but it may be mixed with &quot;%%&quot; formats
which do not consume an argument. There may be no gaps in
the numbers of arguments specified using '$'; for example,
if arguments 1 and 3 are specified, argument 2 must also be
specified somewhere in the format string.</p>

<p style="margin-left:11%; margin-top: 1em">For some
numeric conversions a radix character (&quot;decimal
point&quot;) or thousands&rsquo; grouping character is used.
The actual character used depends on the <b>LC_NUMERIC</b>
part of the locale. The POSIX locale uses '.' as radix
character, and does not have a grouping character. Thus,</p>


<p style="margin-left:17%; margin-top: 1em">printf(&quot;%'.2f&quot;,
1234567.89);</p>

<p style="margin-left:11%; margin-top: 1em">results in
&quot;1234567.89&quot; in the POSIX locale, in
&quot;1234567,89&quot; in the nl_NL locale, and in
&quot;1.234.567,89&quot; in the da_DK locale.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The flag
characters</b> <br>
The character % is followed by zero or more of the following
flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>#</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The value should be converted to an &quot;alternate
form&quot;. For <b>o</b> conversions, the first character of
the output string is made zero (by prefixing a 0 if it was
not zero already). For <b>x</b> and <b>X</b> conversions, a
nonzero result has the string &quot;0x&quot; (or
&quot;0X&quot; for <b>X</b> conversions) prepended to it.
For <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>,
<b>F</b>, <b>g</b>, and <b>G</b> conversions, the result
will always contain a decimal point, even if no digits
follow it (normally, a decimal point appears in the results
of those conversions only if a digit follows). For <b>g</b>
and <b>G</b> conversions, trailing zeros are not removed
from the result as they would otherwise be. For other
conversions, the result is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>0</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The value should be zero padded. For <b>d</b>, <b>i</b>,
<b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, <b>a</b>, <b>A</b>,
<b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, and
<b>G</b> conversions, the converted value is padded on the
left with zeros rather than blanks. If the <b>0</b> and
<b>&minus;</b> flags both appear, the <b>0</b> flag is
ignored. If a precision is given with a numeric conversion
(<b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, and
<b>X</b>), the <b>0</b> flag is ignored. For other
conversions, the behavior is undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The converted value is to be left adjusted on the field
boundary. (The default is right justification.) Except for
<b>n</b> conversions, the converted value is padded on the
right with blanks, rather than on the left with blanks or
zeros. A <b>&minus;</b> overrides a <b>0</b> if both are
given.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>' '</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>(a space) A blank should be left before a positive
number (or empty string) produced by a signed
conversion.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>+</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>A sign (+ or &minus;) should always be placed before a
number produced by a signed conversion. By default a sign is
used only for negative numbers. A <b>+</b> overrides a space
if both are used.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The five flag
characters above are defined in the C standard. The SUSv2
specifies one further flag character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>'</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">For decimal conversion
(<b>i</b>, <b>d</b>, <b>u</b>, <b>f</b>, <b>F</b>, <b>g</b>,
<b>G</b>) the output is to be grouped with thousands&rsquo;
grouping characters if the locale information indicates any.
Note that many versions of <b>gcc</b>(1) cannot parse this
option and will issue a warning. SUSv2 does not include
<i>%'F</i>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">glibc 2.2 adds
one further flag character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>I</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">For decimal integer conversion
(<b>i</b>, <b>d</b>, <b>u</b>) the output uses the
locale&rsquo;s alternative output digits, if any. For
example, since glibc 2.2.3 this will give Arabic-Indic
digits in the Persian (&quot;fa_IR&quot;) locale.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>The field
width</b> <br>
An optional decimal digit string (with nonzero first digit)
specifying a minimum field width. If the converted value has
fewer characters than the field width, it will be padded
with spaces on the left (or right, if the left-adjustment
flag has been given). Instead of a decimal digit string one
may write &quot;*&quot; or &quot;*m$&quot; (for some decimal
integer <i>m</i>) to specify that the field width is given
in the next argument, or in the <i>m</i>-th argument,
respectively, which must be of type <i>int</i>. A negative
field width is taken as a '&minus;' flag followed by a
positive field width. In no case does a nonexistent or small
field width cause truncation of a field; if the result of a
conversion is wider than the field width, the field is
expanded to contain the conversion result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
precision</b> <br>
An optional precision, in the form of a period ('.')
followed by an optional decimal digit string. Instead of a
decimal digit string one may write &quot;*&quot; or
&quot;*m$&quot; (for some decimal integer m) to specify that
the precision is given in the next argument, or in the m-th
argument, respectively, which must be of type <i>int</i>. If
the precision is given as just '.', or the precision is
negative, the precision is taken to be zero. This gives the
minimum number of digits to appear for <b>d</b>, <b>i</b>,
<b>o</b>, <b>u</b>, <b>x</b>, and <b>X</b> conversions, the
number of digits to appear after the radix character for
<b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, and
<b>F</b> conversions, the maximum number of significant
digits for <b>g</b> and <b>G</b> conversions, or the maximum
number of characters to be printed from a string for
<b>s</b> and <b>S</b> conversions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The length
modifier</b> <br>
Here, &quot;integer conversion&quot; stands for <b>d</b>,
<b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b>
conversion.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>hh</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">A following integer conversion
corresponds to a <i>signed char</i> or <i>unsigned char</i>
argument, or a following <b>n</b> conversion corresponds to
a pointer to a <i>signed char</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>h</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a <i>short
int</i> or <i>unsigned short int</i> argument, or a
following <b>n</b> conversion corresponds to a pointer to a
<i>short int</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>l</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>(ell) A following integer conversion corresponds to a
<i>long int</i> or <i>unsigned long int</i> argument, or a
following <b>n</b> conversion corresponds to a pointer to a
<i>long int</i> argument, or a following <b>c</b> conversion
corresponds to a <i>wint_t</i> argument, or a following
<b>s</b> conversion corresponds to a pointer to
<i>wchar_t</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>ll</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>(ell-ell). A following integer conversion corresponds to
a <i>long long int</i> or <i>unsigned long long int</i>
argument, or a following <b>n</b> conversion corresponds to
a pointer to a <i>long long int</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>L</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>,
<b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion
corresponds to a <i>long double</i> argument. (C99 allows
%LF, but SUSv2 does not.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>q</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>(&quot;quad&quot;. 4.4BSD and Linux libc5 only.
Don&rsquo;t use.) This is a synonym for <b>ll</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>j</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to an
<i>intmax_t</i> or <i>uintmax_t</i> argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a
<i>size_t</i> or <i>ssize_t</i> argument. (Linux libc5 has
<b>Z</b> with this meaning. Don&rsquo;t use it.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>t</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>A following integer conversion corresponds to a
<i>ptrdiff_t</i> argument.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The SUSv2 knows
about only the length modifiers <b>h</b> (in <b>hd</b>,
<b>hi</b>, <b>ho</b>, <b>hx</b>, <b>hX</b>, <b>hn</b>) and
<b>l</b> (in <b>ld</b>, <b>li</b>, <b>lo</b>, <b>lx</b>,
<b>lX</b>, <b>ln</b>, <b>lc</b>, <b>ls</b>) and <b>L</b> (in
<b>Le</b>, <b>LE</b>, <b>Lf</b>, <b>Lg</b>, <b>LG</b>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
conversion specifier</b> <br>
A character that specifies the type of conversion to be
applied. The conversion specifiers and their meanings
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>d</b>, <b>i</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>int</i> argument is
converted to signed decimal notation. The precision, if any,
gives the minimum number of digits that must appear; if the
converted value requires fewer digits, it is padded on the
left with zeros. The default precision is 1. When 0 is
printed with an explicit precision 0, the output is
empty.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>o</b>, <b>u</b>, <b>x</b>,
<b>X</b></p>

<p style="margin-left:22%;">The <i>unsigned int</i>
argument is converted to unsigned octal (<b>o</b>), unsigned
decimal (<b>u</b>), or unsigned hexadecimal (<b>x</b> and
<b>X</b>) notation. The letters <b>abcdef</b> are used for
<b>x</b> conversions; the letters <b>ABCDEF</b> are used for
<b>X</b> conversions. The precision, if any, gives the
minimum number of digits that must appear; if the converted
value requires fewer digits, it is padded on the left with
zeros. The default precision is 1. When 0 is printed with an
explicit precision 0, the output is empty.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>e</b>, <b>E</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>double</i> argument is rounded and converted in
the style [&minus;]d<b>.</b>ddd<b>e</b>&plusmn;dd where
there is one digit before the decimal-point character and
the number of digits after it is equal to the precision; if
the precision is missing, it is taken as 6; if the precision
is zero, no decimal-point character appears. An <b>E</b>
conversion uses the letter <b>E</b> (rather than <b>e</b>)
to introduce the exponent. The exponent always contains at
least two digits; if the value is zero, the exponent is
00.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>f</b>, <b>F</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The <i>double</i> argument is rounded and converted to
decimal notation in the style [&minus;]ddd<b>.</b>ddd, where
the number of digits after the decimal-point character is
equal to the precision specification. If the precision is
missing, it is taken as 6; if the precision is explicitly
zero, no decimal-point character appears. If a decimal point
appears, at least one digit appears before it.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(The SUSv2 does
not know about <b>F</b> and says that character string
representations for infinity and NaN may be made available.
The C99 standard specifies &quot;[&minus;]inf&quot; or
&quot;[&minus;]infinity&quot; for infinity, and a string
starting with &quot;nan&quot; for NaN, in the case of
<b>f</b> conversion, and &quot;[&minus;]INF&quot; or
&quot;[&minus;]INFINITY&quot; or &quot;NAN*&quot; in the
case of <b>F</b> conversion.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>g</b>, <b>G</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">The <i>double</i> argument is
converted in style <b>f</b> or <b>e</b> (or <b>F</b> or
<b>E</b> for <b>G</b> conversions). The precision specifies
the number of significant digits. If the precision is
missing, 6 digits are given; if the precision is zero, it is
treated as 1. Style <b>e</b> is used if the exponent from
its conversion is less than &minus;4 or greater than or
equal to the precision. Trailing zeros are removed from the
fractional part of the result; a decimal point appears only
if it is followed by at least one digit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>a</b>, <b>A</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>(C99; not in SUSv2) For <b>a</b> conversion, the
<i>double</i> argument is converted to hexadecimal notation
(using the letters abcdef) in the style
[&minus;]<b>0x</b>h<b>.</b>hhhh<b>p</b>&plusmn;; for
<b>A</b> conversion the prefix <b>0X</b>, the letters
ABCDEF, and the exponent separator <b>P</b> is used. There
is one hexadecimal digit before the decimal point, and the
number of digits after it is equal to the precision. The
default precision suffices for an exact representation of
the value if an exact representation in base 2 exists and
otherwise is sufficiently large to distinguish values of
type <i>double</i>. The digit before the decimal point is
unspecified for nonnormalized numbers, and nonzero but
otherwise unspecified for normalized numbers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>c</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>If no <b>l</b> modifier is present, the <i>int</i>
argument is converted to an <i>unsigned char</i>, and the
resulting character is written. If an <b>l</b> modifier is
present, the <i>wint_t</i> (wide character) argument is
converted to a multibyte sequence by a call to the
<b>wcrtomb</b>(3) function, with a conversion state starting
in the initial state, and the resulting multibyte string is
written.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>s</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>If no <b>l</b> modifier is present: The <i>const
char&nbsp;*</i> argument is expected to be a pointer to an
array of character type (pointer to a string). Characters
from the array are written up to (but not including) a
terminating null byte ('\0'); if a precision is specified,
no more than the number specified are written. If a
precision is given, no null byte need be present; if the
precision is not specified, or is greater than the size of
the array, the array must contain a terminating null
byte.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">If an <b>l</b>
modifier is present: The <i>const wchar_t&nbsp;*</i>
argument is expected to be a pointer to an array of wide
characters. Wide characters from the array are converted to
multibyte characters (each by a call to the
<b>wcrtomb</b>(3) function, with a conversion state starting
in the initial state before the first wide character), up to
and including a terminating null wide character. The
resulting multibyte characters are written up to (but not
including) the terminating null byte. If a precision is
specified, no more bytes than the number specified are
written, but no partial multibyte characters are written.
Note that the precision determines the number of
<i>bytes</i> written, not the number of <i>wide
characters</i> or <i>screen positions</i>. The array must
contain a terminating null wide character, unless a
precision is given and it is so small that the number of
bytes written exceeds it before the end of the array is
reached.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>C</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">(Not in C99, but in SUSv2.)
Synonym for <b>lc</b>. Don&rsquo;t use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>S</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>(Not in C99, but in SUSv2.) Synonym for <b>ls</b>.
Don&rsquo;t use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>p</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>The <i>void&nbsp;*</i> pointer argument is printed in
hexadecimal (as if by <b>%#x</b> or <b>%#lx</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>n</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>The number of characters written so far is stored into
the integer indicated by the <i>int&nbsp;*</i> (or variant)
pointer argument. No argument is converted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>m</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>(Glibc extension.) Print output of
<i>strerror(errno)</i>. No argument is required.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>%</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>A '%' is written. No argument is converted. The complete
conversion specification is '%%'.</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>fprintf</b>(), <b>printf</b>(), <b>sprintf</b>(),
<b>vprintf</b>(), <b>vfprintf</b>(), and <b>vsprintf</b>()
functions conform to C89 and C99. The <b>snprintf</b>() and
<b>vsnprintf</b>() functions conform to C99.</p>

<p style="margin-left:11%; margin-top: 1em">Concerning the
return value of <b>snprintf</b>(), SUSv2 and C99 contradict
each other: when <b>snprintf</b>() is called with
<i>size</i>=0 then SUSv2 stipulates an unspecified return
value less than 1, while C99 allows <i>str</i> to be NULL in
this case, and gives the return value (as always) as the
number of characters that would have been written in case
the output string has been large enough.</p>

<p style="margin-left:11%; margin-top: 1em">Linux libc4
knows about the five C standard flags. It knows about the
length modifiers <b>h</b>, <b>l</b>, <b>L</b>, and the
conversions <b>c</b>, <b>d</b>, <b>e</b>, <b>E</b>,
<b>f</b>, <b>F</b>, <b>g</b>, <b>G</b>, <b>i</b>, <b>n</b>,
<b>o</b>, <b>p</b>, <b>s</b>, <b>u</b>, <b>x</b>, and
<b>X</b>, where <b>F</b> is a synonym for <b>f</b>.
Additionally, it accepts <b>D</b>, <b>O</b>, and <b>U</b> as
synonyms for <b>ld</b>, <b>lo</b>, and <b>lu</b>. (This is
bad, and caused serious bugs later, when support for
<b>%D</b> disappeared.) No locale-dependent radix character,
no thousands&rsquo; separator, no NaN or infinity, no
&quot;%m$&quot; and &quot;*m$&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Linux libc5
knows about the five C standard flags and the ' flag,
locale, &quot;%m$&quot; and &quot;*m$&quot;. It knows about
the length modifiers <b>h</b>, <b>l</b>, <b>L</b>, <b>Z</b>,
and <b>q</b>, but accepts <b>L</b> and <b>q</b> both for
<i>long double</i> and for <i>long long int</i> (this is a
bug). It no longer recognizes <b>F</b>, <b>D</b>, <b>O</b>,
and <b>U</b>, but adds the conversion character <b>m</b>,
which outputs <i>strerror(errno)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">glibc 2.0 adds
conversion characters <b>C</b> and <b>S</b>.</p>

<p style="margin-left:11%; margin-top: 1em">glibc 2.1 adds
length modifiers <b>hh</b>, <b>j</b>, <b>t</b>, and <b>z</b>
and conversion characters <b>a</b> and <b>A</b>.</p>

<p style="margin-left:11%; margin-top: 1em">glibc 2.2 adds
the conversion character <b>F</b> with C99 semantics, and
the flag character <b>I</b>.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some programs
imprudently rely on code such as the following</p>

<p style="margin-left:11%; margin-top: 1em">sprintf(buf,
&quot;%s some further text&quot;, buf);</p>

<p style="margin-left:11%; margin-top: 1em">to append text
to <i>buf</i>. However, the standards explicitly note that
the results are undefined if source and destination buffers
overlap when calling <b>sprintf</b>(), <b>snprintf</b>(),
<b>vsprintf</b>(), and <b>vsnprintf</b>(). Depending on the
version of <b>gcc</b>(1) used, and the compiler options
employed, calls such as the above will <b>not</b> produce
the expected results.</p>

<p style="margin-left:11%; margin-top: 1em">The glibc
implementation of the functions <b>snprintf</b>() and
<b>vsnprintf</b>() conforms to the C99 standard, that is,
behaves as described above, since glibc version 2.1. Until
glibc 2.0.6 they would return &minus;1 when the output was
truncated.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Because
<b>sprintf</b>() and <b>vsprintf</b>() assume an arbitrarily
long string, callers must be careful not to overflow the
actual space; this is often impossible to assure. Note that
the length of the strings produced is locale-dependent and
difficult to predict. Use <b>snprintf</b>() and
<b>vsnprintf</b>() instead (or <b>asprintf</b>(3) and
<b>vasprintf</b>(3)).</p>

<p style="margin-left:11%; margin-top: 1em">Linux
libc4.[45] does not have a <b>snprintf</b>(), but provides a
libbsd that contains an <b>snprintf</b>() equivalent to
<b>sprintf</b>(), that is, one that ignores the <i>size</i>
argument. Thus, the use of <b>snprintf</b>() with early
libc4 leads to serious security problems.</p>

<p style="margin-left:11%; margin-top: 1em">Code such as
<b>printf(</b><i>foo</i><b>);</b> often indicates a bug,
since <i>foo</i> may contain a % character. If <i>foo</i>
comes from untrusted user input, it may contain <b>%n</b>,
causing the <b>printf</b>() call to write to memory and
creating a security hole.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To print
<i>Pi</i> to five decimal places:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;math.h&gt; <br>
#include &lt;stdio.h&gt; <br>
fprintf(stdout, &quot;pi = %.5f\n&quot;, 4 * atan(1.0));</p>

<p style="margin-left:11%; margin-top: 1em">To print a date
and time in the form &quot;Sunday, July 3, 10:02&quot;,
where <i>weekday</i> and <i>month</i> are pointers to
strings:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
fprintf(stdout, &quot;%s, %s %d, %.2d:%.2d\n&quot;, <br>
weekday, month, day, hour, min);</p>

<p style="margin-left:11%; margin-top: 1em">Many countries
use the day-month-year order. Hence, an internationalized
version must be able to print the arguments in an order
specified by the format:</p>

<p style="margin-left:17%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
fprintf(stdout, format, <br>
weekday, month, day, hour, min);</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>format</i> depends on locale, and may permute the
arguments. With the value:</p>

<p style="margin-left:17%; margin-top: 1em">&quot;%1$s,
%3$d. %2$s, %4$d:%5$.2d\n&quot;</p>

<p style="margin-left:11%; margin-top: 1em">one might
obtain &quot;Sonntag, 3. Juli, 10:02&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To allocate a
sufficiently large string and print into it (code correct
for both glibc 2.0 and glibc 2.1):</p>

<p style="margin-left:11%; margin-top: 1em">If truncation
occurs in glibc versions prior to 2.0.6, this is treated as
an error instead of being handled gracefully.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;stdarg.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">char * <br>
make_message(const char *fmt, ...) <br>
{ <br>
int n; <br>
int size = 100; /* Guess we need no more than 100 bytes */
<br>
char *p, *np; <br>
va_list ap;</p>

<p style="margin-left:11%; margin-top: 1em">if ((p =
malloc(size)) == NULL) <br>
return NULL;</p>

<p style="margin-left:11%; margin-top: 1em">while (1) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Try to print
in the allocated space */</p>

<p style="margin-left:11%; margin-top: 1em">va_start(ap,
fmt); <br>
n = vsnprintf(p, size, fmt, ap); <br>
va_end(ap);</p>

<p style="margin-left:11%; margin-top: 1em">/* Check error
code */</p>

<p style="margin-left:11%; margin-top: 1em">if (n &lt; 0)
<br>
return NULL;</p>

<p style="margin-left:11%; margin-top: 1em">/* If that
worked, return the string */</p>

<p style="margin-left:11%; margin-top: 1em">if (n &lt;
size) <br>
return p;</p>

<p style="margin-left:11%; margin-top: 1em">/* Else try
again with more space */</p>

<p style="margin-left:11%; margin-top: 1em">size = n + 1;
/* Precisely what is needed */</p>

<p style="margin-left:11%; margin-top: 1em">if ((np =
realloc (p, size)) == NULL) { <br>
free(p); <br>
return NULL; <br>
} else { <br>
p = np; <br>
} <br>
} <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>printf</b>(1),
<b>asprintf</b>(3), <b>dprintf</b>(3), <b>scanf</b>(3),
<b>setlocale</b>(3), <b>wcrtomb</b>(3), <b>wprintf</b>(3),
<b>locale</b>(5)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
