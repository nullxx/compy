<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:02:12 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SPLICE</title>

</head>
<body>

<h1 align="center">SPLICE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">splice &minus;
splice data to/from a pipe</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#define
_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br>
#include &lt;fcntl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ssize_t
splice(int</b> <i>fd_in</i><b>, loff_t
*</b><i>off_in</i><b>, int</b> <i>fd_out</i><b>, <br>
loff_t *</b><i>off_out</i><b>, size_t</b> <i>len</i><b>,
unsigned int</b> <i>flags</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>splice</b>()
moves data between two file descriptors without copying
between kernel address space and user address space. It
transfers up to <i>len</i> bytes of data from the file
descriptor <i>fd_in</i> to the file descriptor
<i>fd_out</i>, where one of the descriptors must refer to a
pipe.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>fd_in</i>
refers to a pipe, then <i>off_in</i> must be NULL. If
<i>fd_in</i> does not refer to a pipe and <i>off_in</i> is
NULL, then bytes are read from <i>fd_in</i> starting from
the current file offset, and the current file offset is
adjusted appropriately. If <i>fd_in</i> does not refer to a
pipe and <i>off_in</i> is not NULL, then <i>off_in</i> must
point to a buffer which specifies the starting offset from
which bytes will be read from <i>fd_in</i>; in this case,
the current file offset of <i>fd_in</i> is not changed.
Analogous statements apply for <i>fd_out</i> and
<i>off_out</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> argument is a bit mask that is composed by
ORing together zero or more of the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p><b>SPLICE_F_MOVE</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Attempt to move pages instead of copying. This is only a
hint to the kernel: pages may still be copied if the kernel
cannot move the pages from the pipe, or if the pipe buffers
don&rsquo;t refer to full pages. The initial implementation
of this flag was buggy: therefore starting in Linux 2.6.21
it is a no-op (but is still permitted in a <b>splice</b>()
call); in the future, a correct implementation may be
restored.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p><b>SPLICE_F_NONBLOCK</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Do not block on I/O. This makes the splice pipe
operations nonblocking, but <b>splice</b>() may nevertheless
block because the file descriptors that are spliced to/from
may block (unless they have the <b>O_NONBLOCK</b> flag
set).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p><b>SPLICE_F_MORE</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>More data will be coming in a subsequent splice. This is
a helpful hint when the <i>fd_out</i> refers to a socket
(see also the description of <b>MSG_MORE</b> in
<b>send</b>(2), and the description of <b>TCP_CORK</b> in
<b>tcp</b>(7))</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p><b>SPLICE_F_GIFT</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Unused for <b>splice</b>(); see <b>vmsplice</b>(2).</p></td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Upon successful
completion, <b>splice</b>() returns the number of bytes
spliced to or from the pipe. A return value of 0 means that
there was no data to transfer, and it would not make sense
to block, because there are no writers connected to the
write end of the pipe referred to by <i>fd_in</i>.</p>

<p style="margin-left:11%; margin-top: 1em">On error,
<b>splice</b>() returns &minus;1 and <i>errno</i> is set to
indicate the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">One or both file descriptors are
not valid, or do not have proper read-write mode.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Target file system doesn&rsquo;t support splicing;
target file is opened in append mode; neither of the
descriptors refers to a pipe; or offset given for
nonseekable device.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Out of memory.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ESPIPE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Either <i>off_in</i> or <i>off_out</i> was not NULL, but
the corresponding file descriptor refers to a pipe.</p></td></tr>
</table>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>splice</b>() system call first appeared in Linux 2.6.17;
library support was added to glibc in version 2.5.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This system
call is Linux-specific.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The three
system calls <b>splice</b>(), <b>vmsplice</b>(2), and
<b>tee</b>(2), provide user-space programs with full control
over an arbitrary kernel buffer, implemented within the
kernel using the same type of buffer that is used for a
pipe. In overview, these system calls perform the following
tasks:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>splice</b>()</p></td>
<td width="1%"></td>
<td width="71%">


<p style="margin-top: 1em">moves data from the buffer to an
arbitrary file descriptor, or vice versa, or from one buffer
to another.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>tee</b>(2)</p></td>
<td width="1%"></td>
<td width="71%">


<p>&quot;copies&quot; the data from one buffer to
another.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p><b>vmsplice</b>(2)</p></td>
<td width="1%"></td>
<td width="71%">


<p>&quot;copies&quot; data from user space into the
buffer.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Though we talk
of copying, actual copies are generally avoided. The kernel
does this by implementing a pipe buffer as a set of
reference-counted pointers to pages of kernel memory. The
kernel creates &quot;copies&quot; of pages in a buffer by
creating new pointers (for the output buffer) referring to
the pages, and increasing the reference counts for the
pages: only pointers are copied, not the pages of the
buffer.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>tee</b>(2).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>sendfile</b>(2),
<b>tee</b>(2), <b>vmsplice</b>(2)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
