<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:57:19 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CPUPOWER&minus;MONITOR</title>

</head>
<body>

<h1 align="center">CPUPOWER&minus;MONITOR</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Options">Options</a><br>
<a href="#MONITOR DESCRIPTIONS">MONITOR DESCRIPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#REFERENCES">REFERENCES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">cpupower&minus;monitor
&minus; Report processor frequency and idle statistics</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>cpupower
monitor</b> &minus;l</p>

<p style="margin-left:11%; margin-top: 1em"><b>cpupower
monitor</b> [<b>-c</b>]<b>[</b>&minus;m
&lt;mon1&gt;,<b>[</b>&lt;mon2&gt;,...<b>]</b>] [<b>&minus;i
seconds</b>] <b><br>
cpupower monitor</b> [<b>-c</b>][<b>&minus;m
&lt;mon1&gt;,</b>[<b>&lt;mon2&gt;,...</b>]<b>]</b>
command</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>cpupower-monitor</b>
reports processor topology, frequency and idle power state
statistics. Either <b>command</b> is forked and statistics
are printed upon its completion, or statistics are printed
periodically.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cpupower-monitor</b>
implements independent processor sleep state and frequency
counters. Some are retrieved from kernel statistics, some
are directly reading out hardware registers. Use &minus;l to
get an overview which are supported on your system.</p>

<h2>Options
<a name="Options"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&minus;l</p>

<p style="margin-left:17%;">List available monitors on your
system. Additional details about each monitor are shown:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>The name in quotation marks which can be passed to the
&minus;m parameter.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>The number of different counters the monitor supports in
brackets.</p> </td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>The amount of time in seconds the counters might
overflow, due to implementation constraints.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>The name and a description of each counter and its
processor hierarchy level coverage in square brackets:</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>[T] &minus;&gt; Thread</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>[C] &minus;&gt; Core</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>[P] &minus;&gt; Processor Package (Socket)</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="8%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="69%">


<p>[M] &minus;&gt; Machine/Platform wide counter</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">&minus;m
&lt;mon1&gt;,&lt;mon2&gt;,...</p>

<p style="margin-left:17%;">Only display specific monitors.
Use the monitor string(s) provided by &minus;l option.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;i
seconds</p>

<p style="margin-left:17%;">Measure intervall.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;c</p>

<p style="margin-left:17%;">Schedule the process on every
core before starting and ending measuring. This could be
needed for the Idle_Stats monitor when no other MSR based
monitor (has to be run on the core that is measured) is run
in parallel. This is to wake up the processors from deeper
sleep states and let the kernel re -account its cpuidle
(C-state) information before reading the cpuidle timings
from sysfs.</p>

<p style="margin-left:11%; margin-top: 1em">command</p>

<p style="margin-left:17%;">Measure idle and frequency
characteristics of an arbitrary command/workload. The
executable <b>command</b> is forked and upon its exit,
statistics gathered since it was forked are displayed.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v</p>

<p style="margin-left:17%;">Increase verbosity if the
binary was compiled with the DEBUG option set.</p>

<h2>MONITOR DESCRIPTIONS
<a name="MONITOR DESCRIPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Idle_Stats</b>
<br>
Shows statistics of the cpuidle kernel subsystem. Values are
retrieved from /sys/devices/system/cpu/cpu*/cpuidle/state*/.
The kernel updates these values every time an idle state is
entered or left. Therefore there can be some inaccuracy when
cores are in an idle state for some time when the measure
starts or ends. In worst case it can happen that one core
stayed in an idle state for the whole measure time and the
idle state usage time as exported by the kernel did not get
updated. In this case a state residency of 0 percent is
shown while it was 100.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mperf</b>
<br>
The name comes from the aperf/mperf (average and maximum)
MSR registers used which are available on recent X86
processors. It shows the average frequency (including boost
frequencies). The fact that on all recent hardware the mperf
timer stops ticking in any idle state it is also used to
show C0 (processor is active) and Cx (processor is in any
sleep state) times. These counters do not have the
inaccuracy restrictions the &quot;Idle_Stats&quot; counters
may show. May work poorly on Linux-2.6.20 through 2.6.29, as
the <b>acpi-cpufreq</b> kernel frequency driver periodically
cleared aperf/mperf registers in those kernels.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Nehalem
SandyBridge HaswellExtended</b> <br>
Intel Core and Package sleep state counters. Threads
(hyperthreaded cores) may not be able to enter deeper core
states if its sibling is utilized. Deepest package sleep
states may in reality show up as machine/platform wide sleep
states and can only be entered if all cores are idle. Look
up Intel manuals (some are provided in the References
section) for further details. The monitors are named after
the CPU family where the sleep state capabilities got
introduced and may not match exactly the CPU name of the
platform. For example an IvyBridge processor has sleep state
capabilities which got introduced in Nehalem and SandyBridge
processor families. Thus on an IvyBridge processor one will
get Nehalem and SandyBridge sleep state monitors.
HaswellExtended extra package sleep state capabilities are
available only in a specific Haswell (family 0x45) and
probably also other future processors.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Fam_12h
Fam_14h</b> <br>
AMD laptop and desktop processor (family 12h and 14h) sleep
state counters. The registers are accessed via PCI and
therefore can still be read out while cores have been
offlined.</p>

<p style="margin-left:11%; margin-top: 1em">There is one
special counter: NBP1 (North Bridge P1). This one always
returns 0 or 1, depending on whether the North Bridge P1
power state got entered at least once during measure time.
Being able to enter NBP1 state also depends on graphics
power management. Therefore this counter can be used to
verify whether the graphics&rsquo; driver power management
is working as expected.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">cpupower
monitor -l&quot; may show:</p>

<p style="margin-left:17%;">Monitor &quot;Mperf&quot; (3
states) &minus; Might overflow after 922000000 s</p>

<p style="margin-left:17%; margin-top: 1em">...</p>

<p style="margin-left:17%; margin-top: 1em">Monitor
&quot;Idle_Stats&quot; (3 states) &minus; Might overflow
after 4294967295 s</p>

<p style="margin-left:17%; margin-top: 1em">...</p>

<p style="margin-left:11%; margin-top: 1em">cpupower
monitor &minus;m &quot;Idle_Stats,Mperf&quot; scp /tmp/test
/nfs/tmp</p>

<p style="margin-left:11%; margin-top: 1em">Monitor the scp
command, show both Mperf and Idle_Stats states counter
statistics, but in exchanged order.</p>

<p style="margin-left:11%; margin-top: 1em">Be careful that
the typical command to fully utilize one CPU by doing:</p>

<p style="margin-left:11%; margin-top: 1em">cpupower
monitor cat /dev/zero &gt;/dev/null</p>

<p style="margin-left:11%; margin-top: 1em">Does not work
as expected, because the measured output is redirected to
/dev/null. This could get workarounded by putting the line
into an own, tiny shell script. Hit CTRL&minus;c to
terminate the command and get the measure output
displayed.</p>

<h2>REFERENCES
<a name="REFERENCES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&quot;BIOS and
Kernel Developer&rsquo;s Guide (BKDG) for AMD Family 14h
Processors&quot;
http://support.amd.com/us/Processor_TechDocs/43170.pdf</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Intel&reg;
Turbo Boost Technology in Intel&reg; Core&trade;
Microarchitecture (Nehalem) Based Processors&quot;
http://download.intel.com/design/processor/applnots/320354.pdf</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Intel&reg;
64 and IA-32 Architectures Software Developer&rsquo;s Manual
Volume 3B: System Programming Guide&quot;
http://www.intel.com/products/processor/manuals</p>

<h2>FILES
<a name="FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">/dev/cpu/*/msr
<br>
/sys/devices/system/cpu/cpu*/cpuidle/state*/.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">powertop(8),
msr(4), vmstat(8)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Written by
Thomas Renninger &lt;trenn@suse.de&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Nehalem,
SandyBridge monitors and command passing <br>
based on turbostat.8 from Len Brown
&lt;len.brown@intel.com&gt;</p>
<hr>
</body>
</html>
