<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:01:57 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PTRACE</title>

</head>
<body>

<h1 align="center">PTRACE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ptrace &minus;
process trace</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/ptrace.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>long
ptrace(enum __ptrace_request</b> <i>request</i><b>,
pid_t</b> <i>pid</i><b>, <br>
void *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>ptrace</b>() system call provides a means by which one
process (the &quot;tracer&quot;) may observe and control the
execution of another process (the &quot;tracee&quot;), and
examine and change the tracee&rsquo;s memory and registers.
It is primarily used to implement breakpoint debugging and
system call tracing.</p>

<p style="margin-left:11%; margin-top: 1em">A tracee first
needs to be attached to the tracer. Attachment and
subsequent commands are per thread: in a multithreaded
process, every thread can be individually attached to a
(potentially different) tracer, or left not attached and
thus not debugged. Therefore, &quot;tracee&quot; always
means &quot;(one) thread&quot;, never &quot;a (possibly
multithreaded) process&quot;. Ptrace commands are always
sent to a specific tracee using a call of the form</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_foo,
pid, ...)</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>pid</i> is the thread ID of the corresponding Linux
thread.</p>

<p style="margin-left:11%; margin-top: 1em">(Note that in
this page, a &quot;multithreaded process&quot; means a
thread group consisting of threads created using the
<b>clone</b>(2) <b>CLONE_THREAD</b> flag.)</p>

<p style="margin-left:11%; margin-top: 1em">A process can
initiate a trace by calling <b>fork</b>(2) and having the
resulting child do a <b>PTRACE_TRACEME</b>, followed
(typically) by an <b>execve</b>(2). Alternatively, one
process may commence tracing another process using
<b>PTRACE_ATTACH</b> or <b>PTRACE_SEIZE</b>.</p>

<p style="margin-left:11%; margin-top: 1em">While being
traced, the tracee will stop each time a signal is
delivered, even if the signal is being ignored. (An
exception is <b>SIGKILL</b>, which has its usual effect.)
The tracer will be notified at its next call to
<b>waitpid</b>(2) (or one of the related &quot;wait&quot;
system calls); that call will return a <i>status</i> value
containing information that indicates the cause of the stop
in the tracee. While the tracee is stopped, the tracer can
use various ptrace requests to inspect and modify the
tracee. The tracer then causes the tracee to continue,
optionally ignoring the delivered signal (or even delivering
a different signal instead).</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>PTRACE_O_TRACEEXEC</b> option is not in effect, all
successful calls to <b>execve</b>(2) by the traced process
will cause it to be sent a <b>SIGTRAP</b> signal, giving the
parent a chance to gain control before the new program
begins execution.</p>

<p style="margin-left:11%; margin-top: 1em">When the tracer
is finished tracing, it can cause the tracee to continue
executing in a normal, untraced mode via
<b>PTRACE_DETACH</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The value of
<i>request</i> determines the action to be performed:
<b><br>
PTRACE_TRACEME</b></p>

<p style="margin-left:22%;">Indicate that this process is
to be traced by its parent. A process probably
shouldn&rsquo;t make this request if its parent isn&rsquo;t
expecting to trace it. (<i>pid</i>, <i>addr</i>, and
<i>data</i> are ignored.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PTRACE_TRACEME</b> request is used only by the tracee;
the remaining requests are used only by the tracer. In the
following requests, <i>pid</i> specifies the thread ID of
the tracee to be acted on. For requests other than
<b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>,
<b>PTRACE_INTERRUPT</b> and <b>PTRACE_KILL</b>, the tracee
must be stopped. <b><br>
PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b></p>

<p style="margin-left:22%;">Read a word at the address
<i>addr</i> in the tracee&rsquo;s memory, returning the word
as the result of the <b>ptrace</b>() call. Linux does not
have separate text and data address spaces, so these two
requests are currently equivalent. (<i>data</i> is
ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_PEEKUSER</b></p>

<p style="margin-left:22%;">Read a word at offset
<i>addr</i> in the tracee&rsquo;s USER area, which holds the
registers and other information about the process (see
<i>&lt;sys/user.h&gt;</i>). The word is returned as the
result of the <b>ptrace</b>() call. Typically, the offset
must be word-aligned, though this might vary by
architecture. See NOTES. (<i>data</i> is ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_POKETEXT</b>,
<b>PTRACE_POKEDATA</b></p>

<p style="margin-left:22%;">Copy the word <i>data</i> to
the address <i>addr</i> in the tracee&rsquo;s memory. As for
<b>PTRACE_PEEKTEXT</b> and <b>PTRACE_PEEKDATA</b>, these two
requests are currently equivalent.</p>

<p style="margin-left:11%;"><b>PTRACE_POKEUSER</b></p>

<p style="margin-left:22%;">Copy the word <i>data</i> to
offset <i>addr</i> in the tracee&rsquo;s USER area. As for
<b>PTRACE_PEEKUSER</b>, the offset must typically be
word-aligned. In order to maintain the integrity of the
kernel, some modifications to the USER area are
disallowed.</p>

<p style="margin-left:11%;"><b>PTRACE_GETREGS</b>,
<b>PTRACE_GETFPREGS</b></p>

<p style="margin-left:22%;">Copy the tracee&rsquo;s
general-purpose or floating-point registers, respectively,
to the address <i>data</i> in the tracer. See
<i>&lt;sys/user.h&gt;</i> for information on the format of
this data. (<i>addr</i> is ignored.) Note that SPARC systems
have the meaning of <i>data</i> and <i>addr</i> reversed;
that is, <i>data</i> is ignored and the registers are copied
to the address <i>addr</i>. <b>PTRACE_GETREGS</b> and
<b>PTRACE_GETFPREGS</b> are not present on all
architectures.</p>

<p style="margin-left:11%;"><b>PTRACE_GETREGSET</b> (since
Linux 2.6.34)</p>

<p style="margin-left:22%;">Read the tracee&rsquo;s
registers. <i>addr</i> specifies, in an
architecture-dependent way, the type of registers to be
read. <b>NT_PRSTATUS</b> (with numerical value 1) usually
results in reading of general-purpose registers. If the CPU
has, for example, floating-point and/or vector registers,
they can be retrieved by setting <i>addr</i> to the
corresponding <b>NT_foo</b> constant. <i>data</i> points to
a <b>struct iovec</b>, which describes the destination
buffer&rsquo;s location and length. On return, the kernel
modifies <b>iov.len</b> to indicate the actual number of
bytes returned.</p>

<p style="margin-left:11%;"><b>PTRACE_SETREGS</b>,
<b>PTRACE_SETFPREGS</b></p>

<p style="margin-left:22%;">Modify the tracee&rsquo;s
general-purpose or floating-point registers, respectively,
from the address <i>data</i> in the tracer. As for
<b>PTRACE_POKEUSER</b>, some general-purpose register
modifications may be disallowed. (<i>addr</i> is ignored.)
Note that SPARC systems have the meaning of <i>data</i> and
<i>addr</i> reversed; that is, <i>data</i> is ignored and
the registers are copied from the address <i>addr</i>.
<b>PTRACE_SETREGS</b> and <b>PTRACE_SETFPREGS</b> are not
present on all architectures.</p>

<p style="margin-left:11%;"><b>PTRACE_SETREGSET</b> (since
Linux 2.6.34)</p>

<p style="margin-left:22%;">Modify the tracee&rsquo;s
registers. The meaning of <i>addr</i> and <i>data</i> is
analogous to <b>PTRACE_GETREGSET</b>.</p>

<p style="margin-left:11%;"><b>PTRACE_GETSIGINFO</b> (since
Linux 2.3.99-pre6)</p>

<p style="margin-left:22%;">Retrieve information about the
signal that caused the stop. Copy a <i>siginfo_t</i>
structure (see <b>sigaction</b>(2)) from the tracee to the
address <i>data</i> in the tracer. (<i>addr</i> is
ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_SETSIGINFO</b> (since
Linux 2.3.99-pre6)</p>

<p style="margin-left:22%;">Set signal information: copy a
<i>siginfo_t</i> structure from the address <i>data</i> in
the tracer to the tracee. This will affect only signals that
would normally be delivered to the tracee and were caught by
the tracer. It may be difficult to tell these normal signals
from synthetic signals generated by <b>ptrace</b>() itself.
(<i>addr</i> is ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_SETOPTIONS</b> (since
Linux 2.4.6; see BUGS for caveats)</p>

<p style="margin-left:22%;">Set ptrace options from
<i>data</i>. (<i>addr</i> is ignored.) <i>data</i> is
interpreted as a bit mask of options, which are specified by
the following flags: <b><br>
PTRACE_O_EXITKILL</b> (since Linux 3.8)</p>

<p style="margin-left:32%;">If a tracer sets this flag, a
<b>SIGKILL</b> signal will be sent to every tracee if the
tracer exits. This option is useful for ptrace jailers that
want to ensure that tracees can never escape the
tracer&rsquo;s control.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACECLONE</b>
(since Linux 2.5.46)</p>

<p style="margin-left:32%;">Stop the tracee at the next
<b>clone</b>(2) and automatically start tracing the newly
cloned process, which will start with a <b>SIGSTOP</b>, or
<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
<b>waitpid</b>(2) by the tracer will return a <i>status</i>
value such that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">The PID of the
new process can be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:32%; margin-top: 1em">This option may
not catch <b>clone</b>(2) calls in all cases. If the tracee
calls <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag,
<b>PTRACE_EVENT_VFORK</b> will be delivered instead if
<b>PTRACE_O_TRACEVFORK</b> is set; otherwise if the tracee
calls <b>clone</b>(2) with the exit signal set to
<b>SIGCHLD</b>, <b>PTRACE_EVENT_FORK</b> will be delivered
if <b>PTRACE_O_TRACEFORK</b> is set.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACEEXEC</b>
(since Linux 2.5.46)</p>

<p style="margin-left:32%;">Stop the tracee at the next
<b>execve</b>(2). A <b>waitpid</b>(2) by the tracer will
return a <i>status</i> value such that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">If the execing
thread is not a thread group leader, the thread ID is reset
to thread group leader&rsquo;s ID before this stop. Since
Linux 3.0, the former thread ID can be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACEEXIT</b>
(since Linux 2.5.60)</p>

<p style="margin-left:32%;">Stop the tracee at exit. A
<b>waitpid</b>(2) by the tracer will return a <i>status</i>
value such that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">The
tracee&rsquo;s exit status can be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:32%; margin-top: 1em">The tracee is
stopped early during process exit, when registers are still
available, allowing the tracer to see where the exit
occurred, whereas the normal exit notification is done after
the process is finished exiting. Even though context is
available, the tracer cannot prevent the exit from happening
at this point.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACEFORK</b>
(since Linux 2.5.46)</p>

<p style="margin-left:32%;">Stop the tracee at the next
<b>fork</b>(2) and automatically start tracing the newly
forked process, which will start with a <b>SIGSTOP</b>, or
<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
<b>waitpid</b>(2) by the tracer will return a <i>status</i>
value such that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">The PID of the
new process can be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACESYSGOOD</b>
(since Linux 2.4.6)</p>

<p style="margin-left:32%;">When delivering system call
traps, set bit 7 in the signal number (i.e., deliver
<i>SIGTRAP|0x80</i>). This makes it easy for the tracer to
distinguish normal traps from those caused by a system call.
(<b>PTRACE_O_TRACESYSGOOD</b> may not work on all
architectures.)</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACEVFORK</b>
(since Linux 2.5.46)</p>

<p style="margin-left:32%;">Stop the tracee at the next
<b>vfork</b>(2) and automatically start tracing the newly
vforked process, which will start with a <b>SIGSTOP</b>, or
<b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
<b>waitpid</b>(2) by the tracer will return a <i>status</i>
value such that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">The PID of the
new process can be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:22%;"><b>PTRACE_O_TRACEVFORKDONE</b>
(since Linux 2.5.60)</p>

<p style="margin-left:32%;">Stop the tracee at the
completion of the next <b>vfork</b>(2). A <b>waitpid</b>(2)
by the tracer will return a <i>status</i> value such
that</p>


<p style="margin-left:32%; margin-top: 1em">status&gt;&gt;8
== (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))</p>

<p style="margin-left:32%; margin-top: 1em">The PID of the
new process can (since Linux 2.6.18) be retrieved with
<b>PTRACE_GETEVENTMSG</b>.</p>

<p style="margin-left:11%;"><b>PTRACE_GETEVENTMSG</b>
(since Linux 2.5.46)</p>

<p style="margin-left:22%;">Retrieve a message (as an
<i>unsigned long</i>) about the ptrace event that just
happened, placing it at the address <i>data</i> in the
tracer. For <b>PTRACE_EVENT_EXIT</b>, this is the
tracee&rsquo;s exit status. For <b>PTRACE_EVENT_FORK</b>,
<b>PTRACE_EVENT_VFORK</b>, <b>PTRACE_EVENT_VFORK_DONE</b>,
and <b>PTRACE_EVENT_CLONE</b>, this is the PID of the new
process. (<i>addr</i> is ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_CONT</b></p>

<p style="margin-left:22%;">Restart the stopped tracee
process. If <i>data</i> is nonzero, it is interpreted as the
number of a signal to be delivered to the tracee; otherwise,
no signal is delivered. Thus, for example, the tracer can
control whether a signal sent to the tracee is delivered or
not. (<i>addr</i> is ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_SYSCALL</b>,
<b>PTRACE_SINGLESTEP</b></p>

<p style="margin-left:22%;">Restart the stopped tracee as
for <b>PTRACE_CONT</b>, but arrange for the tracee to be
stopped at the next entry to or exit from a system call, or
after execution of a single instruction, respectively. (The
tracee will also, as usual, be stopped upon receipt of a
signal.) From the tracer&rsquo;s perspective, the tracee
will appear to have been stopped by receipt of a
<b>SIGTRAP</b>. So, for <b>PTRACE_SYSCALL</b>, for example,
the idea is to inspect the arguments to the system call at
the first stop, then do another <b>PTRACE_SYSCALL</b> and
inspect the return value of the system call at the second
stop. The <i>data</i> argument is treated as for
<b>PTRACE_CONT</b>. (<i>addr</i> is ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_SYSEMU</b>,
<b>PTRACE_SYSEMU_SINGLESTEP</b> (since Linux 2.6.14)</p>

<p style="margin-left:22%;">For <b>PTRACE_SYSEMU</b>,
continue and stop on entry to the next system call, which
will not be executed. For <b>PTRACE_SYSEMU_SINGLESTEP</b>,
do the same but also singlestep if not a system call. This
call is used by programs like User Mode Linux that want to
emulate all the tracee&rsquo;s system calls. The <i>data</i>
argument is treated as for <b>PTRACE_CONT</b>. The
<i>addr</i> argument is ignored. These requests are
currently supported only on x86.</p>

<p style="margin-left:11%;"><b>PTRACE_LISTEN</b> (since
Linux 3.4)</p>

<p style="margin-left:22%;">Restart the stopped tracee, but
prevent it from executing. The resulting state of the tracee
is similar to a process which has been stopped by a
<b>SIGSTOP</b> (or other stopping signal). See the
&quot;group-stop&quot; subsection for additional
information. <b>PTRACE_LISTEN</b> works only on tracees
attached by <b>PTRACE_SEIZE</b>.</p>

<p style="margin-left:11%;"><b>PTRACE_KILL</b></p>

<p style="margin-left:22%;">Send the tracee a
<b>SIGKILL</b> to terminate it. (<i>addr</i> and <i>data</i>
are ignored.)</p>

<p style="margin-left:22%; margin-top: 1em"><i>This
operation is deprecated; do not use it!</i> Instead, send a
<b>SIGKILL</b> directly using <b>kill</b>(2) or
<b>tgkill</b>(2). The problem with <b>PTRACE_KILL</b> is
that it requires the tracee to be in signal-delivery-stop,
otherwise it may not work (i.e., may complete successfully
but won&rsquo;t kill the tracee). By contrast, sending a
<b>SIGKILL</b> directly has no such limitation.</p>

<p style="margin-left:11%;"><b>PTRACE_INTERRUPT</b> (since
Linux 3.4)</p>

<p style="margin-left:22%;">Stop a tracee. If the tracee is
running or sleeping in kernel space and
<b>PTRACE_SYSCALL</b> is in effect, the system call is
interrupted and syscall-exit-stop is reported. (The
interrupted system call is restarted when the tracee is
restarted.) If the tracee was already stopped by a signal
and <b>PTRACE_LISTEN</b> was sent to it, the tracee stops
with <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i>
returns the stop signal. If any other ptrace-stop is
generated at the same time (for example, if a signal is sent
to the tracee), this ptrace-stop happens. If none of the
above applies (for example, if the tracee is running in
userspace), it stops with <b>PTRACE_EVENT_STOP</b> with
<i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>.
<b>PTRACE_INTERRUPT</b> only works on tracees attached by
<b>PTRACE_SEIZE</b>.</p>

<p style="margin-left:11%;"><b>PTRACE_ATTACH</b></p>

<p style="margin-left:22%;">Attach to the process specified
in <i>pid</i>, making it a tracee of the calling process.
The tracee is sent a <b>SIGSTOP</b>, but will not
necessarily have stopped by the completion of this call; use
<b>waitpid</b>(2) to wait for the tracee to stop. See the
&quot;Attaching and detaching&quot; subsection for
additional information. (<i>addr</i> and <i>data</i> are
ignored.)</p>

<p style="margin-left:11%;"><b>PTRACE_SEIZE</b> (since
Linux 3.4)</p>

<p style="margin-left:22%;">Attach to the process specified
in <i>pid</i>, making it a tracee of the calling process.
Unlike <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b> does not
stop the process. Only a <b>PTRACE_SEIZE</b>d process can
accept <b>PTRACE_INTERRUPT</b> and <b>PTRACE_LISTEN</b>
commands. <i>addr</i> must be zero. <i>data</i> contains a
bit mask of ptrace options to activate immediately.</p>

<p style="margin-left:11%;"><b>PTRACE_DETACH</b></p>

<p style="margin-left:22%;">Restart the stopped tracee as
for <b>PTRACE_CONT</b>, but first detach from it. Under
Linux, a tracee can be detached in this way regardless of
which method was used to initiate tracing. (<i>addr</i> is
ignored.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Death under
ptrace</b> <br>
When a (possibly multithreaded) process receives a killing
signal (one whose disposition is set to <b>SIG_DFL</b> and
whose default action is to kill the process), all threads
exit. Tracees report their death to their tracer(s).
Notification of this event is delivered via
<b>waitpid</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
killing signal will first cause signal-delivery-stop (on one
tracee only), and only after it is injected by the tracer
(or after it was dispatched to a thread which isn&rsquo;t
traced), will death from the signal happen on <i>all</i>
tracees within a multithreaded process. (The term
&quot;signal-delivery-stop&quot; is explained below.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIGKILL</b>
does not generate signal-delivery-stop and therefore the
tracer can&rsquo;t suppress it. <b>SIGKILL</b> kills even
within system calls (syscall-exit-stop is not generated
prior to death by <b>SIGKILL</b>). The net effect is that
<b>SIGKILL</b> always kills the process (all its threads),
even if some threads of the process are ptraced.</p>

<p style="margin-left:11%; margin-top: 1em">When the tracee
calls <b>_exit</b>(2), it reports its death to its tracer.
Other threads are not affected.</p>

<p style="margin-left:11%; margin-top: 1em">When any thread
executes <b>exit_group</b>(2), every tracee in its thread
group reports its death to its tracer.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>PTRACE_O_TRACEEXIT</b> option is on,
<b>PTRACE_EVENT_EXIT</b> will happen before actual death.
This applies to exits via <b>exit</b>(2),
<b>exit_group</b>(2), and signal deaths (except
<b>SIGKILL</b>), and when threads are torn down on
<b>execve</b>(2) in a multithreaded process.</p>

<p style="margin-left:11%; margin-top: 1em">The tracer
cannot assume that the ptrace-stopped tracee exists. There
are many scenarios when the tracee may die while stopped
(such as <b>SIGKILL</b>). Therefore, the tracer must be
prepared to handle an <b>ESRCH</b> error on any ptrace
operation. Unfortunately, the same error is returned if the
tracee exists but is not ptrace-stopped (for commands which
require a stopped tracee), or if it is not traced by the
process which issued the ptrace call. The tracer needs to
keep track of the stopped/running state of the tracee, and
interpret <b>ESRCH</b> as &quot;tracee died
unexpectedly&quot; only if it knows that the tracee has been
observed to enter ptrace-stop. Note that there is no
guarantee that <i>waitpid(WNOHANG)</i> will reliably report
the tracee&rsquo;s death status if a ptrace operation
returned <b>ESRCH</b>. <i>waitpid(WNOHANG)</i> may return 0
instead. In other words, the tracee may be &quot;not yet
fully dead&quot;, but already refusing ptrace requests.</p>

<p style="margin-left:11%; margin-top: 1em">The tracer
can&rsquo;t assume that the tracee <i>always</i> ends its
life by reporting <i>WIFEXITED(status)</i> or
<i>WIFSIGNALED(status)</i>; there are cases where this does
not occur. For example, if a thread other than thread group
leader does an <b>execve</b>(2), it disappears; its PID will
never be seen again, and any subsequent ptrace stops will be
reported under the thread group leader&rsquo;s PID.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Stopped
states</b> <br>
A tracee can be in two states: running or stopped. For the
purposes of ptrace, a tracee which is blocked in a system
call (such as <b>read</b>(2), <b>pause</b>(2), etc.) is
nevertheless considered to be running, even if the tracee is
blocked for a long time. The state of the tracee after
<b>PTRACE_LISTEN</b> is somewhat of a gray area: it is not
in any ptrace-stop (ptrace commands won&rsquo;t work on it,
and it will deliver <b>waitpid</b>(2) notifications), but it
also may be considered &quot;stopped&quot; because it is not
executing instructions (is not scheduled), and if it was in
group-stop before <b>PTRACE_LISTEN</b>, it will not respond
to signals until <b>SIGCONT</b> is received.</p>

<p style="margin-left:11%; margin-top: 1em">There are many
kinds of states when the tracee is stopped, and in ptrace
discussions they are often conflated. Therefore, it is
important to use precise terms.</p>

<p style="margin-left:11%; margin-top: 1em">In this manual
page, any stopped state in which the tracee is ready to
accept ptrace commands from the tracer is called
<i>ptrace-stop</i>. Ptrace-stops can be further subdivided
into <i>signal-delivery-stop</i>, <i>group-stop</i>,
<i>syscall-stop</i>, and so on. These stopped states are
described in detail below.</p>

<p style="margin-left:11%; margin-top: 1em">When the
running tracee enters ptrace-stop, it notifies its tracer
using <b>waitpid</b>(2) (or one of the other
&quot;wait&quot; system calls). Most of this manual page
assumes that the tracer waits with:</p>

<p style="margin-left:11%; margin-top: 1em">pid =
waitpid(pid_or_minus_1, &amp;status, __WALL);</p>

<p style="margin-left:11%; margin-top: 1em">Ptrace-stopped
tracees are reported as returns with <i>pid</i> greater than
0 and <i>WIFSTOPPED(status)</i> true.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>__WALL</b> flag does not include the <b>WSTOPPED</b> and
<b>WEXITED</b> flags, but implies their functionality.</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
<b>WCONTINUED</b> flag when calling <b>waitpid</b>(2) is not
recommended: the &quot;continued&quot; state is per-process
and consuming it can confuse the real parent of the
tracee.</p>

<p style="margin-left:11%; margin-top: 1em">Use of the
<b>WNOHANG</b> flag may cause <b>waitpid</b>(2) to return 0
(&quot;no wait results available yet&quot;) even if the
tracer knows there should be a notification. Example:</p>

<p style="margin-left:11%; margin-top: 1em">errno = 0; <br>
ptrace(PTRACE_CONT, pid, 0L, 0L); <br>
if (errno == ESRCH) { <br>
/* tracee is dead */ <br>
r = waitpid(tracee, &amp;status, __WALL | WNOHANG); <br>
/* r can still be 0 here! */ <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The following
kinds of ptrace-stops exist: signal-delivery-stops,
group-stops, <b>PTRACE_EVENT</b> stops, syscall-stops. They
all are reported by <b>waitpid</b>(2) with
<i>WIFSTOPPED(status)</i> true. They may be differentiated
by examining the value <i>status&gt;&gt;8</i>, and if there
is ambiguity in that value, by querying
<b>PTRACE_GETSIGINFO</b>. (Note: the <i>WSTOPSIG(status)</i>
macro can&rsquo;t be used to perform this examination,
because it returns the value
<i>(status&gt;&gt;8)&nbsp;&amp;&nbsp;0xff</i>.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Signal-delivery-stop</b>
<br>
When a (possibly multithreaded) process receives any signal
except <b>SIGKILL</b>, the kernel selects an arbitrary
thread which handles the signal. (If the signal is generated
with <b>tgkill</b>(2), the target thread can be explicitly
selected by the caller.) If the selected thread is traced,
it enters signal-delivery-stop. At this point, the signal is
not yet delivered to the process, and can be suppressed by
the tracer. If the tracer doesn&rsquo;t suppress the signal,
it passes the signal to the tracee in the next ptrace
restart request. This second step of signal delivery is
called <i>signal injection</i> in this manual page. Note
that if the signal is blocked, signal-delivery-stop
doesn&rsquo;t happen until the signal is unblocked, with the
usual exception that <b>SIGSTOP</b> can&rsquo;t be
blocked.</p>


<p style="margin-left:11%; margin-top: 1em">Signal-delivery-stop
is observed by the tracer as <b>waitpid</b>(2) returning
with <i>WIFSTOPPED(status)</i> true, with the signal
returned by <i>WSTOPSIG(status)</i>. If the signal is
<b>SIGTRAP</b>, this may be a different kind of ptrace-stop;
see the &quot;Syscall-stops&quot; and &quot;execve&quot;
sections below for details. If <i>WSTOPSIG(status)</i>
returns a stopping signal, this may be a group-stop; see
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signal
injection and suppression</b> <br>
After signal-delivery-stop is observed by the tracer, the
tracer should restart the tracee with the call</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_restart,
pid, 0, sig)</p>

<p style="margin-left:11%; margin-top: 1em">where
<b>PTRACE_restart</b> is one of the restarting ptrace
requests. If <i>sig</i> is 0, then a signal is not
delivered. Otherwise, the signal <i>sig</i> is delivered.
This operation is called <i>signal injection</i> in this
manual page, to distinguish it from
signal-delivery-stop.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>sig</i>
value may be different from the <i>WSTOPSIG(status)</i>
value: the tracer can cause a different signal to be
injected.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
suppressed signal still causes system calls to return
prematurely. In this case system calls will be restarted:
the tracer will observe the tracee to reexecute the
interrupted system call (or <b>restart_syscall</b>(2) system
call for a few syscalls which use a different mechanism for
restarting) if the tracer uses <b>PTRACE_SYSCALL</b>. Even
system calls (such as <b>poll</b>(2)) which are not
restartable after signal are restarted after signal is
suppressed; however, kernel bugs exist which cause some
syscalls to fail with <b>EINTR</b> even though no observable
signal is injected to the tracee.</p>

<p style="margin-left:11%; margin-top: 1em">Restarting
ptrace commands issued in ptrace-stops other than
signal-delivery-stop are not guaranteed to inject a signal,
even if <i>sig</i> is nonzero. No error is reported; a
nonzero <i>sig</i> may simply be ignored. Ptrace users
should not try to &quot;create a new signal&quot; this way:
use <b>tgkill</b>(2) instead.</p>

<p style="margin-left:11%; margin-top: 1em">The fact that
signal injection requests may be ignored when restarting the
tracee after ptrace stops that are not signal-delivery-stops
is a cause of confusion among ptrace users. One typical
scenario is that the tracer observes group-stop, mistakes it
for signal-delivery-stop, restarts the tracee with</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_restart,
pid, 0, stopsig)</p>

<p style="margin-left:11%; margin-top: 1em">with the
intention of injecting <i>stopsig</i>, but <i>stopsig</i>
gets ignored and the tracee continues to run.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SIGCONT</b> signal has a side effect of waking up (all
threads of) a group-stopped process. This side effect
happens before signal-delivery-stop. The tracer can&rsquo;t
suppress this side effect (it can only suppress signal
injection, which only causes the <b>SIGCONT</b> handler to
not be executed in the tracee, if such a handler is
installed). In fact, waking up from group-stop may be
followed by signal-delivery-stop for signal(s) <i>other
than</i> <b>SIGCONT</b>, if they were pending when
<b>SIGCONT</b> was delivered. In other words, <b>SIGCONT</b>
may be not the first signal observed by the tracee after it
was sent.</p>

<p style="margin-left:11%; margin-top: 1em">Stopping
signals cause (all threads of) a process to enter
group-stop. This side effect happens after signal injection,
and therefore can be suppressed by the tracer.</p>

<p style="margin-left:11%; margin-top: 1em">In Linux 2.4
and earlier, the <b>SIGSTOP</b> signal can&rsquo;t be
injected.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_GETSIGINFO</b>
can be used to retrieve a <i>siginfo_t</i> structure which
corresponds to the delivered signal.
<b>PTRACE_SETSIGINFO</b> may be used to modify it. If
<b>PTRACE_SETSIGINFO</b> has been used to alter
<i>siginfo_t</i>, the <i>si_signo</i> field and the
<i>sig</i> parameter in the restarting command must match,
otherwise the result is undefined.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Group-stop</b>
<br>
When a (possibly multithreaded) process receives a stopping
signal, all threads stop. If some threads are traced, they
enter a group-stop. Note that the stopping signal will first
cause signal-delivery-stop (on one tracee only), and only
after it is injected by the tracer (or after it was
dispatched to a thread which isn&rsquo;t traced), will
group-stop be initiated on <i>all</i> tracees within the
multithreaded process. As usual, every tracee reports its
group-stop separately to the corresponding tracer.</p>

<p style="margin-left:11%; margin-top: 1em">Group-stop is
observed by the tracer as <b>waitpid</b>(2) returning with
<i>WIFSTOPPED(status)</i> true, with the stopping signal
available via <i>WSTOPSIG(status)</i>. The same result is
returned by some other classes of ptrace-stops, therefore
the recommended practice is to perform the call</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_GETSIGINFO,
pid, 0, &amp;siginfo)</p>

<p style="margin-left:11%; margin-top: 1em">The call can be
avoided if the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>,
<b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals
are stopping signals. If the tracer sees something else, it
can&rsquo;t be a group-stop. Otherwise, the tracer needs to
call <b>PTRACE_GETSIGINFO</b>. If <b>PTRACE_GETSIGINFO</b>
fails with <b>EINVAL</b>, then it is definitely a
group-stop. (Other failure codes are possible, such as
<b>ESRCH</b> (&quot;no such process&quot;) if a
<b>SIGKILL</b> killed the tracee.)</p>

<p style="margin-left:11%; margin-top: 1em">If tracee was
attached using <i>PTRACE_SEIZE</i>, group-stop is indicated
by <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 ==
PTRACE_EVENT_STOP</i>. This allows detection of group-stops
without requiring an extra <b>PTRACE_GETSIGINFO</b>
call.</p>

<p style="margin-left:11%; margin-top: 1em">As of Linux
2.6.38, after the tracer sees the tracee ptrace-stop and
until it restarts or kills it, the tracee will not run, and
will not send notifications (except <b>SIGKILL</b> death) to
the tracer, even if the tracer enters into another
<b>waitpid</b>(2) call.</p>

<p style="margin-left:11%; margin-top: 1em">The kernel
behavior described in the previous paragraph causes a
problem with transparent handling of stopping signals. If
the tracer restarts the tracee after group-stop, the
stopping signal is effectively ignored&mdash;the tracee
doesn&rsquo;t remain stopped, it runs. If the tracer
doesn&rsquo;t restart the tracee before entering into the
next <b>waitpid</b>(2), future <b>SIGCONT</b> signals will
not be reported to the tracer; this would cause the
<b>SIGCONT</b> signals to have no effect on the tracee.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.4, there is a method to overcome this problem: instead of
<b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN</b> command can be
used to restart a tracee in a way where it does not execute,
but waits for a new event which it can report via
<b>waitpid</b>(2) (such as when it is restarted by a
<b>SIGCONT</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_EVENT
stops</b> <br>
If the tracer sets <b>PTRACE_O_TRACE_*</b> options, the
tracee will enter ptrace-stops called <b>PTRACE_EVENT</b>
stops.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_EVENT</b>
stops are observed by the tracer as <b>waitpid</b>(2)
returning with <i>WIFSTOPPED(status)</i>, and
<i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b>. An
additional bit is set in the higher byte of the status word:
the value <i>status&gt;&gt;8</i> will be</p>

<p style="margin-left:11%; margin-top: 1em">(SIGTRAP |
PTRACE_EVENT_foo &lt;&lt; 8).</p>

<p style="margin-left:11%; margin-top: 1em">The following
events exist: <b><br>
PTRACE_EVENT_VFORK</b></p>

<p style="margin-left:22%;">Stop before return from
<b>vfork</b>(2) or <b>clone</b>(2) with the
<b>CLONE_VFORK</b> flag. When the tracee is continued after
this stop, it will wait for child to exit/exec before
continuing its execution (in other words, the usual behavior
on <b>vfork</b>(2)).</p>

<p style="margin-left:11%;"><b>PTRACE_EVENT_FORK</b></p>

<p style="margin-left:22%;">Stop before return from
<b>fork</b>(2) or <b>clone</b>(2) with the exit signal set
to <b>SIGCHLD</b>.</p>

<p style="margin-left:11%;"><b>PTRACE_EVENT_CLONE</b></p>

<p style="margin-left:22%;">Stop before return from
<b>clone</b>(2).</p>


<p style="margin-left:11%;"><b>PTRACE_EVENT_VFORK_DONE</b></p>

<p style="margin-left:22%;">Stop before return from
<b>vfork</b>(2) or <b>clone</b>(2) with the
<b>CLONE_VFORK</b> flag, but after the child unblocked this
tracee by exiting or execing.</p>

<p style="margin-left:11%; margin-top: 1em">For all four
stops described above, the stop occurs in the parent (i.e.,
the tracee), not in the newly created thread.
<b>PTRACE_GETEVENTMSG</b> can be used to retrieve the new
thread&rsquo;s ID. <b><br>
PTRACE_EVENT_EXEC</b></p>

<p style="margin-left:22%;">Stop before return from
<b>execve</b>(2). Since Linux 3.0, <b>PTRACE_GETEVENTMSG</b>
returns the former thread ID.</p>

<p style="margin-left:11%;"><b>PTRACE_EVENT_EXIT</b></p>

<p style="margin-left:22%;">Stop before exit (including
death from <b>exit_group</b>(2)), signal death, or exit
caused by <b>execve</b>(2) in a multithreaded process.
<b>PTRACE_GETEVENTMSG</b> returns the exit status. Registers
can be examined (unlike when &quot;real&quot; exit happens).
The tracee is still alive; it needs to be
<b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to finish
exiting.</p>

<p style="margin-left:11%;"><b>PTRACE_EVENT_STOP</b></p>

<p style="margin-left:22%;">Stop induced by
<b>PTRACE_INTERRUPT</b> command, or group-stop, or initial
ptrace-stop when a new child is attached (only if attached
using <b>PTRACE_SEIZE</b>). or <b>PTRACE_EVENT_STOP</b> if
<b>PTRACE_SEIZE</b> was used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_GETSIGINFO</b>
on <b>PTRACE_EVENT</b> stops returns <b>SIGTRAP</b> in
<i>si_signo</i>, with <i>si_code</i> set to
<i>(event&lt;&lt;8)&nbsp;|&nbsp;SIGTRAP</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Syscall-stops</b>
<br>
If the tracee was restarted by <b>PTRACE_SYSCALL</b>, the
tracee enters syscall-enter-stop just prior to entering any
system call. If the tracer restarts the tracee with
<b>PTRACE_SYSCALL</b>, the tracee enters syscall-exit-stop
when the system call is finished, or if it is interrupted by
a signal. (That is, signal-delivery-stop never happens
between syscall-enter-stop and syscall-exit-stop; it happens
<i>after</i> syscall-exit-stop.)</p>

<p style="margin-left:11%; margin-top: 1em">Other
possibilities are that the tracee may stop in a
<b>PTRACE_EVENT</b> stop, exit (if it entered
<b>_exit</b>(2) or <b>exit_group</b>(2)), be killed by
<b>SIGKILL</b>, or die silently (if it is a thread group
leader, the <b>execve</b>(2) happened in another thread, and
that thread is not traced by the same tracer; this situation
is discussed later).</p>


<p style="margin-left:11%; margin-top: 1em">Syscall-enter-stop
and syscall-exit-stop are observed by the tracer as
<b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i>
true, and <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>. If
the <b>PTRACE_O_TRACESYSGOOD</b> option was set by the
tracer, then <i>WSTOPSIG(status)</i> will give the value
<i>(SIGTRAP&nbsp;|&nbsp;0x80)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Syscall-stops
can be distinguished from signal-delivery-stop with
<b>SIGTRAP</b> by querying <b>PTRACE_GETSIGINFO</b> for the
following cases: <i><br>
si_code</i> &lt;= 0</p>

<p style="margin-left:22%;"><b>SIGTRAP</b> was delivered as
a result of a user-space action, for example, a system call
(<b>tgkill</b>(2), <b>kill</b>(2), <b>sigqueue</b>(3),
etc.), expiration of a POSIX timer, change of state on a
POSIX message queue, or completion of an asynchronous I/O
request.</p>

<p style="margin-left:11%;"><i>si_code</i> == SI_KERNEL
(0x80)</p>

<p style="margin-left:22%;"><b>SIGTRAP</b> was sent by the
kernel.</p>

<p style="margin-left:11%;"><i>si_code</i> == SIGTRAP or
<i>si_code</i> == (SIGTRAP|0x80)</p>

<p style="margin-left:22%;">This is a syscall-stop.</p>

<p style="margin-left:11%; margin-top: 1em">However,
syscall-stops happen very often (twice per system call), and
performing <b>PTRACE_GETSIGINFO</b> for every syscall-stop
may be somewhat expensive.</p>

<p style="margin-left:11%; margin-top: 1em">Some
architectures allow the cases to be distinguished by
examining registers. For example, on x86, <i>rax</i> ==
-<b>ENOSYS</b> in syscall-enter-stop. Since <b>SIGTRAP</b>
(like any other signal) always happens <i>after</i>
syscall-exit-stop, and at this point <i>rax</i> almost never
contains -<b>ENOSYS</b>, the <b>SIGTRAP</b> looks like
&quot;syscall-stop which is not syscall-enter-stop&quot;; in
other words, it looks like a &quot;stray
syscall-exit-stop&quot; and can be detected this way. But
such detection is fragile and is best avoided.</p>

<p style="margin-left:11%; margin-top: 1em">Using the
<b>PTRACE_O_TRACESYSGOOD</b> option is the recommended
method to distinguish syscall-stops from other kinds of
ptrace-stops, since it is reliable and does not incur a
performance penalty.</p>


<p style="margin-left:11%; margin-top: 1em">Syscall-enter-stop
and syscall-exit-stop are indistinguishable from each other
by the tracer. The tracer needs to keep track of the
sequence of ptrace-stops in order to not misinterpret
syscall-enter-stop as syscall-exit-stop or vice versa. The
rule is that syscall-enter-stop is always followed by
syscall-exit-stop, <b>PTRACE_EVENT</b> stop or the
tracee&rsquo;s death; no other kinds of ptrace-stop can
occur in between.</p>

<p style="margin-left:11%; margin-top: 1em">If after
syscall-enter-stop, the tracer uses a restarting command
other than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not
generated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_GETSIGINFO</b>
on syscall-stops returns <b>SIGTRAP</b> in <i>si_signo</i>,
with <i>si_code</i> set to <b>SIGTRAP</b> or
<i>(SIGTRAP|0x80)</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_SINGLESTEP,
PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops</b> <br>
[Details of these kinds of stops are yet to be
documented.]</p>


<p style="margin-left:11%; margin-top: 1em"><b>Informational
and restarting ptrace commands</b> <br>
Most ptrace commands (all except <b>PTRACE_ATTACH</b>,
<b>PTRACE_SEIZE</b>, <b>PTRACE_TRACEME</b>,
<b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>) require the
tracee to be in a ptrace-stop, otherwise they fail with
<b>ESRCH</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When the tracee
is in ptrace-stop, the tracer can read and write data to the
tracee using informational commands. These commands leave
the tracee in ptrace-stopped state:</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER,
pid, addr, 0); <br>
ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr,
long_val); <br>
ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct); <br>
ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct); <br>
ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov); <br>
ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov); <br>
ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo); <br>
ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo); <br>
ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var); <br>
ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);</p>

<p style="margin-left:11%; margin-top: 1em">Note that some
errors are not reported. For example, setting signal
information (<i>siginfo</i>) may have no effect in some
ptrace-stops, yet the call may succeed (return 0 and not set
<i>errno</i>); querying <b>PTRACE_GETEVENTMSG</b> may
succeed and return some random value if current ptrace-stop
is not documented as returning a meaningful event
message.</p>

<p style="margin-left:11%; margin-top: 1em">The call</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_SETOPTIONS,
pid, 0, PTRACE_O_flags);</p>

<p style="margin-left:11%; margin-top: 1em">affects one
tracee. The tracee&rsquo;s current flags are replaced. Flags
are inherited by new tracees created and
&quot;auto-attached&quot; via active
<b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
<b>PTRACE_O_TRACECLONE</b> options.</p>

<p style="margin-left:11%; margin-top: 1em">Another group
of commands makes the ptrace-stopped tracee run. They have
the form:</p>

<p style="margin-left:11%; margin-top: 1em">ptrace(cmd,
pid, 0, sig);</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>,
<b>PTRACE_DETACH</b>, <b>PTRACE_SYSCALL</b>,
<b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>, or
<b>PTRACE_SYSEMU_SINGLESTEP</b>. If the tracee is in
signal-delivery-stop, <i>sig</i> is the signal to be
injected (if it is nonzero). Otherwise, <i>sig</i> may be
ignored. (When restarting a tracee from a ptrace-stop other
than signal-delivery-stop, recommended practice is to always
pass 0 in <i>sig</i>.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Attaching
and detaching</b> <br>
A thread can be attached to the tracer using the call</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_ATTACH,
pid, 0, 0);</p>

<p style="margin-left:11%; margin-top: 1em">or</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_SEIZE,
pid, 0, PTRACE_O_flags);</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_ATTACH</b>
sends <b>SIGSTOP</b> to this thread. If the tracer wants
this <b>SIGSTOP</b> to have no effect, it needs to suppress
it. Note that if other signals are concurrently sent to this
thread during attach, the tracer may see the tracee enter
signal-delivery-stop with other signal(s) first! The usual
practice is to reinject these signals until <b>SIGSTOP</b>
is seen, then suppress <b>SIGSTOP</b> injection. The design
bug here is that a ptrace attach and a concurrently
delivered <b>SIGSTOP</b> may race and the concurrent
<b>SIGSTOP</b> may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Since attaching
sends <b>SIGSTOP</b> and the tracer usually suppresses it,
this may cause a stray <b>EINTR</b> return from the
currently executing system call in the tracee, as described
in the &quot;Signal injection and suppression&quot;
section.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.4, <b>PTRACE_SEIZE</b> can be used instead of
<b>PTRACE_ATTACH</b>. <b>PTRACE_SEIZE</b> does not stop the
attached process. If you need to stop it after attach (or at
any other time) without sending it any signals, use
<b>PTRACE_INTERRUPT</b> command.</p>

<p style="margin-left:11%; margin-top: 1em">The request</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_TRACEME,
0, 0, 0);</p>

<p style="margin-left:11%; margin-top: 1em">turns the
calling thread into a tracee. The thread continues to run
(doesn&rsquo;t enter ptrace-stop). A common practice is to
follow the <b>PTRACE_TRACEME</b> with</p>


<p style="margin-left:11%; margin-top: 1em">raise(SIGSTOP);</p>

<p style="margin-left:11%; margin-top: 1em">and allow the
parent (which is our tracer now) to observe our
signal-delivery-stop.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
<b>PTRACE_O_TRACECLONE</b> options are in effect, then
children created by, respectively, <b>vfork</b>(2) or
<b>clone</b>(2) with the <b>CLONE_VFORK</b> flag,
<b>fork</b>(2) or <b>clone</b>(2) with the exit signal set
to <b>SIGCHLD</b>, and other kinds of <b>clone</b>(2), are
automatically attached to the same tracer which traced their
parent. <b>SIGSTOP</b> is delivered to the children, causing
them to enter signal-delivery-stop after they exit the
system call which created them.</p>

<p style="margin-left:11%; margin-top: 1em">Detaching of
the tracee is performed by:</p>


<p style="margin-left:11%; margin-top: 1em">ptrace(PTRACE_DETACH,
pid, 0, sig);</p>


<p style="margin-left:11%; margin-top: 1em"><b>PTRACE_DETACH</b>
is a restarting operation; therefore it requires the tracee
to be in ptrace-stop. If the tracee is in
signal-delivery-stop, a signal can be injected. Otherwise,
the <i>sig</i> parameter may be silently ignored.</p>

<p style="margin-left:11%; margin-top: 1em">If the tracee
is running when the tracer wants to detach it, the usual
solution is to send <b>SIGSTOP</b> (using <b>tgkill</b>(2),
to make sure it goes to the correct thread), wait for the
tracee to stop in signal-delivery-stop for <b>SIGSTOP</b>
and then detach it (suppressing <b>SIGSTOP</b> injection). A
design bug is that this can race with concurrent
<b>SIGSTOP</b>s. Another complication is that the tracee may
enter other ptrace-stops and needs to be restarted and
waited for again, until <b>SIGSTOP</b> is seen. Yet another
complication is to be sure that the tracee is not already
ptrace-stopped, because no signal delivery happens while it
is&mdash;not even <b>SIGSTOP</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the tracer
dies, all tracees are automatically detached and restarted,
unless they were in group-stop. Handling of restart from
group-stop is currently buggy, but the &quot;as
planned&quot; behavior is to leave tracee stopped and
waiting for <b>SIGCONT</b>. If the tracee is restarted from
signal-delivery-stop, the pending signal is injected.</p>

<p style="margin-left:11%; margin-top: 1em"><b>execve(2)
under ptrace</b> <br>
When one thread in a multithreaded process calls
<b>execve</b>(2), the kernel destroys all other threads in
the process, and resets the thread ID of the execing thread
to the thread group ID (process ID). (Or, to put things
another way, when a multithreaded process does an
<b>execve</b>(2), at completion of the call, it appears as
though the <b>execve</b>(2) occurred in the thread group
leader, regardless of which thread did the
<b>execve</b>(2).) This resetting of the thread ID looks
very confusing to tracers:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>All other threads stop in <b>PTRACE_EVENT_EXIT</b> stop,
if the <b>PTRACE_O_TRACEEXIT</b> option was turned on. Then
all other threads except the thread group leader report
death as if they exited via <b>_exit</b>(2) with exit code
0.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The execing tracee changes its thread ID while it is in
the <b>execve</b>(2). (Remember, under ptrace, the
&quot;pid&quot; returned from <b>waitpid</b>(2), or fed into
ptrace calls, is the tracee&rsquo;s thread ID.) That is, the
tracee&rsquo;s thread ID is reset to be the same as its
process ID, which is the same as the thread group
leader&rsquo;s thread ID.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Then a <b>PTRACE_EVENT_EXEC</b> stop happens, if the
<b>PTRACE_O_TRACEEXEC</b> option was turned on.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If the thread group leader has reported its
<b>PTRACE_EVENT_EXIT</b> stop by this time, it appears to
the tracer that the dead thread leader &quot;reappears from
nowhere&quot;. (Note: the thread group leader does not
report death via <i>WIFEXITED(status)</i> until there is at
least one other live thread. This eliminates the possibility
that the tracer will see it dying and then reappearing.) If
the thread group leader was still alive, for the tracer this
may look as if thread group leader returns from a different
system call than it entered, or even &quot;returned from a
system call even though it was not in any system call&quot;.
If the thread group leader was not traced (or was traced by
a different tracer), then during <b>execve</b>(2) it will
appear as if it has become a tracee of the tracer of the
execing tracee.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">All of the
above effects are the artifacts of the thread ID change in
the tracee.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PTRACE_O_TRACEEXEC</b> option is the recommended tool for
dealing with this situation. First, it enables
<b>PTRACE_EVENT_EXEC</b> stop, which occurs before
<b>execve</b>(2) returns. In this stop, the tracer can use
<b>PTRACE_GETEVENTMSG</b> to retrieve the tracee&rsquo;s
former thread ID. (This feature was introduced in Linux
3.0). Second, the <b>PTRACE_O_TRACEEXEC</b> option disables
legacy <b>SIGTRAP</b> generation on <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">When the tracer
receives <b>PTRACE_EVENT_EXEC</b> stop notification, it is
guaranteed that except this tracee and the thread group
leader, no other threads from the process are alive.</p>

<p style="margin-left:11%; margin-top: 1em">On receiving
the <b>PTRACE_EVENT_EXEC</b> stop notification, the tracer
should clean up all its internal data structures describing
the threads of this process, and retain only one data
structure&mdash;one which describes the single still running
tracee, with</p>

<p style="margin-left:11%; margin-top: 1em">thread ID ==
thread group ID == process ID.</p>

<p style="margin-left:11%; margin-top: 1em">Example: two
threads call <b>execve</b>(2) at the same time:</p>

<p style="margin-left:11%; margin-top: 1em">*** we get
syscall-enter-stop in thread 1: ** <br>
PID1 execve(&quot;/bin/foo&quot;, &quot;foo&quot;
&lt;unfinished ...&gt; <br>
*** we issue PTRACE_SYSCALL for thread 1 ** <br>
*** we get syscall-enter-stop in thread 2: ** <br>
PID2 execve(&quot;/bin/bar&quot;, &quot;bar&quot;
&lt;unfinished ...&gt; <br>
*** we issue PTRACE_SYSCALL for thread 2 ** <br>
*** we get PTRACE_EVENT_EXEC for PID0, we issue
PTRACE_SYSCALL ** <br>
*** we get syscall-exit-stop for PID0: ** <br>
PID0 &lt;... execve resumed&gt; ) = 0</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>PTRACE_O_TRACEEXEC</b> option is <i>not</i> in effect for
the execing tracee, the kernel delivers an extra
<b>SIGTRAP</b> to the tracee after <b>execve</b>(2) returns.
This is an ordinary signal (similar to one which can be
generated by <i>kill -TRAP</i>), not a special kind of
ptrace-stop. Employing <b>PTRACE_GETSIGINFO</b> for this
signal returns <i>si_code</i> set to 0 (<i>SI_USER</i>).
This signal may be blocked by signal mask, and thus may be
delivered (much) later.</p>

<p style="margin-left:11%; margin-top: 1em">Usually, the
tracer (for example, <b>strace</b>(1)) would not want to
show this extra post-execve <b>SIGTRAP</b> signal to the
user, and would suppress its delivery to the tracee (if
<b>SIGTRAP</b> is set to <b>SIG_DFL</b>, it is a killing
signal). However, determining <i>which</i> <b>SIGTRAP</b> to
suppress is not easy. Setting the <b>PTRACE_O_TRACEEXEC</b>
option and thus suppressing this extra <b>SIGTRAP</b> is the
recommended approach.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Real
parent</b> <br>
The ptrace API (ab)uses the standard UNIX parent/child
signaling over <b>waitpid</b>(2). This used to cause the
real parent of the process to stop receiving several kinds
of <b>waitpid</b>(2) notifications when the child process is
traced by some other process.</p>

<p style="margin-left:11%; margin-top: 1em">Many of these
bugs have been fixed, but as of Linux 2.6.38 several still
exist; see BUGS below.</p>

<p style="margin-left:11%; margin-top: 1em">As of Linux
2.6.38, the following is believed to work correctly:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">exit/death by signal is reported
first to the tracer, then, when the tracer consumes the
<b>waitpid</b>(2) result, to the real parent (to the real
parent only when the whole multithreaded process exits). If
the tracer and the real parent are the same process, the
report is sent only once.</p></td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
<b>PTRACE_PEEK*</b> requests return the requested data,
while other requests return zero. (On Linux, this is done in
the libc wrapper around ptrace system call. On the system
call level, <b>PTRACE_PEEK*</b> requests have a different
API: they store the result at the address specified by
<i>data</i> parameter, and return value is the error
flag.)</p>

<p style="margin-left:11%; margin-top: 1em">On error, all
requests return &minus;1, and <i>errno</i> is set
appropriately. Since the value returned by a successful
<b>PTRACE_PEEK*</b> request may be &minus;1, the caller must
clear <i>errno</i> before the call, and then check it
afterward to determine whether or not an error occurred.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EBUSY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">(i386 only) There was an error
with allocating or freeing a debug register.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>There was an attempt to read from or write to an invalid
area in the tracer&rsquo;s or the tracee&rsquo;s memory,
probably because the area wasn&rsquo;t mapped or accessible.
Unfortunately, under Linux, different variations of this
fault will return <b>EIO</b> or <b>EFAULT</b> more or less
arbitrarily.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>An attempt was made to set an invalid option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EIO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>request</i> is invalid, or an attempt was made to
read from or write to an invalid area in the tracer&rsquo;s
or the tracee&rsquo;s memory, or there was a word-alignment
violation, or an invalid signal was specified during a
restart request.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The specified process cannot be traced. This could be
because the tracer has insufficient privileges (the required
capability is <b>CAP_SYS_PTRACE</b>); unprivileged processes
cannot trace processes that they cannot send signals to or
those running set-user-ID/set-group-ID programs, for obvious
reasons. Alternatively, the process may already be being
traced, or (on kernels before 2.6.26) be <b>init</b>(8) (PID
1).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ESRCH</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The specified process does not exist, or is not
currently being traced by the caller, or is not stopped (for
requests that require a stopped tracee).</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SVr4,
4.3BSD.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although
arguments to <b>ptrace</b>() are interpreted according to
the prototype given, glibc currently declares
<b>ptrace</b>() as a variadic function with only the
<i>request</i> argument fixed. It is recommended to always
supply four arguments, even if the requested operation does
not use them, setting unused/ignored arguments to <i>0L</i>
or <i>(void&nbsp;*)&nbsp;0</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In Linux
kernels before 2.6.26, <b>init</b>(8), the process with PID
1, may not be traced.</p>

<p style="margin-left:11%; margin-top: 1em">The layout of
the contents of memory and the USER area are quite
operating-system- and architecture-specific. The offset
supplied, and the data returned, might not entirely match
with the definition of <i>struct user</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The size of a
&quot;word&quot; is determined by the operating-system
variant (e.g., for 32-bit Linux it is 32 bits).</p>

<p style="margin-left:11%; margin-top: 1em">This page
documents the way the <b>ptrace</b>() call works currently
in Linux. Its behavior differs noticeably on other flavors
of UNIX. In any case, use of <b>ptrace</b>() is highly
specific to the operating system and architecture.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On hosts with
2.6 kernel headers, <b>PTRACE_SETOPTIONS</b> is declared
with a different value than the one for 2.4. This leads to
applications compiled with 2.6 kernel headers failing when
run on 2.4 kernels. This can be worked around by redefining
<b>PTRACE_SETOPTIONS</b> to <b>PTRACE_OLDSETOPTIONS</b>, if
that is defined.</p>

<p style="margin-left:11%; margin-top: 1em">Group-stop
notifications are sent to the tracer, but not to real
parent. Last confirmed on 2.6.38.6.</p>

<p style="margin-left:11%; margin-top: 1em">If a thread
group leader is traced and exits by calling <b>_exit</b>(2),
a <b>PTRACE_EVENT_EXIT</b> stop will happen for it (if
requested), but the subsequent <b>WIFEXITED</b> notification
will not be delivered until all other threads exit. As
explained above, if one of other threads calls
<b>execve</b>(2), the death of the thread group leader will
<i>never</i> be reported. If the execed thread is not traced
by this tracer, the tracer will never know that
<b>execve</b>(2) happened. One possible workaround is to
<b>PTRACE_DETACH</b> the thread group leader instead of
restarting it in this case. Last confirmed on 2.6.38.6.</p>

<p style="margin-left:11%; margin-top: 1em">A
<b>SIGKILL</b> signal may still cause a
<b>PTRACE_EVENT_EXIT</b> stop before actual signal death.
This may be changed in the future; <b>SIGKILL</b> is meant
to always immediately kill tasks even under ptrace. Last
confirmed on 2.6.38.6.</p>

<p style="margin-left:11%; margin-top: 1em">Some system
calls return with <b>EINTR</b> if a signal was sent to a
tracee, but delivery was suppressed by the tracer. (This is
very typical operation: it is usually done by debuggers on
every attach, in order to not introduce a bogus
<b>SIGSTOP</b>). As of Linux 3.2.9, the following system
calls are affected (this list is likely incomplete):
<b>epoll_wait</b>(2), and <b>read</b>(2) from an
<b>inotify</b>(7) file descriptor. The usual symptom of this
bug is that when you attach to a quiescent process with the
command</p>

<p style="margin-left:11%; margin-top: 1em">strace -p
&lt;process-ID&gt;</p>

<p style="margin-left:11%; margin-top: 1em">then, instead
of the usual and expected one-line output such as</p>


<p style="margin-left:11%; margin-top: 1em">restart_syscall(&lt;...
resuming interrupted call ...&gt;_</p>

<p style="margin-left:11%; margin-top: 1em">or</p>

<p style="margin-left:11%; margin-top: 1em">select(6, [5],
NULL, [5], NULL_</p>


<p style="margin-left:11%; margin-top: 1em">(&rsquo;_&rsquo;
denotes the cursor position), you observe more than one
line. For example:</p>


<p style="margin-left:11%; margin-top: 1em">clock_gettime(CLOCK_MONOTONIC,
{15370, 690928118}) = 0 <br>
epoll_wait(4,_</p>

<p style="margin-left:11%; margin-top: 1em">What is not
visible here is that the process was blocked in
<b>epoll_wait</b>(2) before <b>strace</b>(1) has attached to
it. Attaching caused <b>epoll_wait</b>(2) to return to user
space with the error <b>EINTR</b>. In this particular case,
the program reacted to <b>EINTR</b> by checking the current
time, and then executing <b>epoll_wait</b>(2) again.
(Programs which do not expect such &quot;stray&quot;
<b>EINTR</b> errors may behave in an unintended way upon an
<b>strace</b>(1) attach.)</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>gdb</b>(1),
<b>strace</b>(1), <b>clone</b>(2), <b>execve</b>(2),
<b>fork</b>(2), <b>gettid</b>(2), <b>sigaction</b>(2),
<b>tgkill</b>(2), <b>vfork</b>(2), <b>waitpid</b>(2),
<b>exec</b>(3), <b>capabilities</b>(7), <b>signal</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
