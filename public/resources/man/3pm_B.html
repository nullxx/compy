<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:08 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>B</title>

</head>
<body>

<h1 align="center">B</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OVERVIEW">OVERVIEW</a><br>
<a href="#Utility Functions">Utility Functions</a><br>
<a href="#OVERVIEW OF CLASSES">OVERVIEW OF CLASSES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">B &minus; The
Perl Compiler Backend</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">        use B;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;B&quot;</tt> module supplies classes which allow a
Perl program to delve into its own innards. It is the module
used to implement the &quot;backends&quot; of the Perl
compiler. Usage of the compiler does not require knowledge
of this module: see the <i>O</i> module for the user-visible
part. The <tt>&quot;B&quot;</tt> module is of use to those
who want to write new compiler backends. This documentation
assumes that the reader knows a fair amount about
perl&rsquo;s internals including such things as SVs, OPs and
the internal symbol table and syntax tree of a program.</p>

<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;B&quot;</tt> module contains a set of utility
functions for querying the current state of the Perl
interpreter; typically these functions return objects from
the B::SV and B::OP classes, or their derived classes. These
classes in turn define methods for querying the resulting
objects about their own internal state.</p>

<h2>Utility Functions
<a name="Utility Functions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;B&quot;</tt> module exports a variety of
functions: some are simple utility functions, others provide
a Perl program with a way to get an initial
&quot;handle&quot; on an internal object.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Functions
Returning &quot;B::SV&quot;, &quot;B::AV&quot;,
&quot;B::HV&quot;, and &quot;B::CV&quot; objects</b> <br>
For descriptions of the class hierarchy of these objects and
the methods that can be called on them, see below, &quot;
<small>OVERVIEW OF CLASSES</small> &quot; and
&quot;SV-RELATED <small>CLASSES</small> &quot;. <br>
sv_undef</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
object corresponding to the C variable
<tt>&quot;sv_undef&quot;</tt>.</p>

<p style="margin-left:11%;">sv_yes</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
object corresponding to the C variable
<tt>&quot;sv_yes&quot;</tt>.</p>

<p style="margin-left:11%;">sv_no</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
object corresponding to the C variable
<tt>&quot;sv_no&quot;</tt>.</p>

<p style="margin-left:11%;">svref_2object(
<small>SVREF</small> )</p>

<p style="margin-left:17%;">Takes a reference to any Perl
value, and turns the referred-to value into an object in the
appropriate B::OP&minus;derived or B::SV&minus;derived
class. Apart from functions such as
<tt>&quot;main_root&quot;</tt>, this is the primary way to
get an initial &quot;handle&quot; on an internal perl data
structure which can then be followed with the other access
methods.</p>

<p style="margin-left:17%; margin-top: 1em">The returned
object will only be valid as long as the underlying OPs and
SVs continue to exist. Do not attempt to use the object
after the underlying structures are freed.</p>

<p style="margin-left:11%;">amagic_generation</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
object corresponding to the C variable
<tt>&quot;amagic_generation&quot;</tt>.</p>

<p style="margin-left:11%;">init_av</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) representing
<small>INIT</small> blocks.</p>

<p style="margin-left:11%;">check_av</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) representing
<small>CHECK</small> blocks.</p>

<p style="margin-left:11%;">unitcheck_av</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) representing
<small>UNITCHECK</small> blocks.</p>

<p style="margin-left:11%;">begin_av</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) representing
<small>BEGIN</small> blocks.</p>

<p style="margin-left:11%;">end_av</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) representing <small>END</small>
blocks.</p>

<p style="margin-left:11%;">comppadlist</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
object (i.e. in class B::AV) of the global comppadlist.</p>

<p style="margin-left:11%;">regex_padav</p>

<p style="margin-left:17%;">Only when perl was compiled
with ithreads.</p>

<p style="margin-left:11%;">main_cv</p>

<p style="margin-left:17%;">Return the (faked)
<small>CV</small> corresponding to the main part of the Perl
program.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Functions
for Examining the Symbol Table</b> <br>
walksymtable( <small>SYMREF</small> , <small>METHOD</small>
, <small>RECURSE</small> , <small>PREFIX</small> )</p>

<p style="margin-left:17%;">Walk the symbol table starting
at <small>SYMREF</small> and call <small>METHOD</small> on
each symbol (a B::GV object) visited. When the walk reaches
package symbols (such as &quot;Foo::&quot;) it invokes
<small>RECURSE</small> , passing in the symbol name, and
only recurses into the package if that sub returns true.</p>


<p style="margin-left:17%; margin-top: 1em"><small>PREFIX</small>
is the name of the <small>SYMREF</small> you&rsquo;re
walking.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">  # Walk CGI's symbol table calling print_subs on each symbol.
  # Recurse only into CGI::Util::
  walksymtable(\%CGI::, 'print_subs',
               sub { $_[0] eq 'CGI::Util::' }, 'CGI::');</pre>



<p style="margin-left:17%; margin-top: 1em"><i>print_subs()</i>
is a B::GV method you have declared. Also see &quot;B::GV
Methods&quot;, below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Functions
Returning &quot;B::OP&quot; objects or for walking op
trees</b> <br>
For descriptions of the class hierarchy of these objects and
the methods that can be called on them, see below, &quot;
<small>OVERVIEW OF CLASSES</small> &quot; and
&quot;OP-RELATED <small>CLASSES</small> &quot;. <br>
main_root</p>

<p style="margin-left:17%;">Returns the root op (i.e. an
object in the appropriate B::OP&minus;derived class) of the
main part of the Perl program.</p>

<p style="margin-left:11%;">main_start</p>

<p style="margin-left:17%;">Returns the starting op of the
main part of the Perl program.</p>

<p style="margin-left:11%;">walkoptree( <small>OP</small> ,
<small>METHOD</small> )</p>

<p style="margin-left:17%;">Does a tree-walk of the syntax
tree based at <small>OP</small> and calls
<small>METHOD</small> on each op it visits. Each node is
visited before its children. If
<tt>&quot;walkoptree_debug&quot;</tt> (see below) has been
called to turn debugging on then the method
<tt>&quot;walkoptree_debug&quot;</tt> is called on each op
before <small>METHOD</small> is called.</p>

<p style="margin-left:11%;">walkoptree_debug(
<small>DEBUG</small> )</p>

<p style="margin-left:17%;">Returns the current debugging
flag for <tt>&quot;walkoptree&quot;</tt>. If the optional
<small>DEBUG</small> argument is non-zero, it sets the
debugging flag to that. See the description of
<tt>&quot;walkoptree&quot;</tt> above for what the debugging
flag does.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous
Utility Functions</b> <br>
ppname( <small>OPNUM</small> )</p>

<p style="margin-left:17%;">Return the <small>PP</small>
function name (e.g. &quot;pp_add&quot;) of op number
<small>OPNUM</small> .</p>

<p style="margin-left:11%;">hash( <small>STR</small> )</p>

<p style="margin-left:17%;">Returns a string in the form
&quot;0x...&quot; representing the value of the internal
hash function used by perl on string <small>STR</small>
.</p>

<p style="margin-left:11%;">cast_I32(I)</p>

<p style="margin-left:17%;">Casts I to the internal I32
type used by that perl.</p>

<p style="margin-left:11%;">minus_c</p>

<p style="margin-left:17%;">Does the equivalent of the
<tt>&quot;&minus;c&quot;</tt> command-line option.
Obviously, this is only useful in a <small>BEGIN</small>
block or else the flag is set too late.</p>

<p style="margin-left:11%;">cstring( <small>STR</small>
)</p>

<p style="margin-left:17%;">Returns a
double-quote-surrounded escaped version of
<small>STR</small> which can be used as a string in C source
code.</p>

<p style="margin-left:11%;">perlstring( <small>STR</small>
)</p>

<p style="margin-left:17%;">Returns a
double-quote-surrounded escaped version of
<small>STR</small> which can be used as a string in Perl
source code.</p>

<p style="margin-left:11%;">class( <small>OBJ</small> )</p>

<p style="margin-left:17%;">Returns the class of an object
without the part of the classname preceding the first
<tt>&quot;::&quot;</tt>. This is used to turn
<tt>&quot;B::UNOP&quot;</tt> into <tt>&quot;UNOP&quot;</tt>
for example.</p>

<p style="margin-left:11%;">threadsv_names</p>

<p style="margin-left:17%;">In a perl compiled for threads,
this returns a list of the special per-thread threadsv
variables.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exported
utility variables</b> <br>
@optype</p>

<pre style="margin-left:17%;">  my $op_type = $optype[$op_type_num];</pre>


<p style="margin-left:17%; margin-top: 1em">A simple
mapping of the op type number to its type (like &rsquo;
<small>COP</small> &rsquo; or &rsquo; <small>BINOP</small>
&rsquo;).</p>

<p style="margin-left:11%;">@specialsv_name</p>

<pre style="margin-left:17%;">  my $sv_name = $specialsv_name[$sv_index];</pre>


<p style="margin-left:17%; margin-top: 1em">Certain
<small>SV</small> types are considered
&rsquo;special&rsquo;. They&rsquo;re represented by
B::SPECIAL and are referred to by a number from the
specialsv_list. This array maps that number back to the name
of the <small>SV</small> (like &rsquo;Nullsv&rsquo; or
&rsquo;&amp;PL_sv_undef&rsquo;).</p>

<h2>OVERVIEW OF CLASSES
<a name="OVERVIEW OF CLASSES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The C
structures used by Perl&rsquo;s internals to hold
<small>SV</small> and <small>OP</small> information (
<small>PVIV</small> , <small>AV</small> , <small>HV</small>
, ..., <small>OP</small> , <small>SVOP</small> ,
<small>UNOP</small> , ...) are modelled on a class hierarchy
and the <tt>&quot;B&quot;</tt> module gives access to them
via a true object hierarchy. Structure fields which point to
other objects (whether types of <small>SV</small> or types
of <small>OP</small> ) are represented by the
<tt>&quot;B&quot;</tt> module as Perl objects of the
appropriate class.</p>

<p style="margin-left:11%; margin-top: 1em">The bulk of the
<tt>&quot;B&quot;</tt> module is the methods for accessing
fields of these structures.</p>

<p style="margin-left:11%; margin-top: 1em">Note that all
access is read-only. You cannot modify the internals by
using this module. Also, note that the B::OP and B::SV
objects created by this module are only valid for as long as
the underlying objects exist; their creation doesn&rsquo;t
increase the reference counts of the underlying objects.
Trying to access the fields of a freed object will give
incomprehensible results, or worse.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SV-RELATED
<small>CLASSES</small></b> <br>
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM
(5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV,
B::FM, B::IO. These classes correspond in the obvious way to
the underlying C structures of similar names. The
inheritance hierarchy mimics the underlying C
&quot;inheritance&quot;. For the 5.10.x branch, (<i>ie</i>
5.10.0, 5.10.1 <i>etc</i>) this is:</p>

<pre style="margin-left:11%; margin-top: 1em">                           B::SV
                             |
                +&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
                |            |            |            |
              B::PV        B::IV        B::NV        B::RV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
                   +&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+
                   |     |     |     |     |
                 B::AV B::GV B::HV B::CV B::IO
                         |           |
                         |           |
                      B::PVLV      B::FM</pre>


<p style="margin-left:11%; margin-top: 1em">For 5.9.0 and
earlier, <small>PVLV</small> is a direct subclass of
<small>PVMG</small> , and <small>BM</small> is still present
as a distinct type, so the base of this diagram is</p>

<pre style="margin-left:11%; margin-top: 1em">                               |
                               |
                            B::PVMG
                               |
            +&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;+
            |      |     |     |     |     |     |
         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
                                           |
                                           |
                                         B::FM</pre>


<p style="margin-left:11%; margin-top: 1em">For 5.11.0 and
later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving
this structure:</p>

<pre style="margin-left:11%; margin-top: 1em">                           B::SV
                             |
                +&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
                |            |            |
              B::PV        B::IV        B::NV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
           +&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
           |       |       |       |       |       |
         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
                   |               |
                   |               |
                B::PVLV          B::FM</pre>


<p style="margin-left:11%; margin-top: 1em">Access methods
correspond to the underlying C macros for field access,
usually with the leading &quot;class indication&quot; prefix
removed (Sv, Av, Hv, ...). The leading prefix is only left
in cases where its removal would cause a clash in method
name. For example, <tt>&quot;GvREFCNT&quot;</tt> stays as-is
since its abbreviation would clash with the
&quot;superclass&quot; method <tt>&quot;REFCNT&quot;</tt>
(corresponding to the C function
<tt>&quot;SvREFCNT&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::SV
Methods</b> <small><br>
REFCNT <br>
FLAGS</small> <br>
object_2svref</p>

<p style="margin-left:17%;">Returns a reference to the
regular scalar corresponding to this B::SV object. In other
words, this method is the inverse operation to the
<i>svref_2object()</i> subroutine. This scalar and other
data it points at should be considered read-only: modifying
them is neither safe nor guaranteed to have a sensible
effect.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::IV
Methods</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>IV</small></p></td>
<td width="2%"></td>
<td width="83%">


<p>Returns the value of the <small>IV</small> ,
<i>interpreted as a signed integer</i>. This will be
misleading if <tt>&quot;FLAGS &amp; SVf_IVisUV&quot;</tt>.
Perhaps you want the <tt>&quot;int_value&quot;</tt> method
instead?</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>IVX</small></p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>UVX</small></p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:11%;">int_value</p>

<p style="margin-left:17%;">This method returns the value
of the <small>IV</small> as an integer. It differs from
<tt>&quot;IV&quot;</tt> in that it returns the correct value
regardless of whether it&rsquo;s stored signed or
unsigned.</p>

<p style="margin-left:11%;">needs64bits <br>
packiv</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::NV
Methods</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>NV</small></p></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>NVX</small></p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>B::RV Methods</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><small>RV</small></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>B::PV Methods</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><small>PV</small></p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">This method is the one you
usually want. It constructs a string using the length and
offset information in the struct: for ordinary scalars it
will return the string that you&rsquo;d see from Perl, even
if it contains null characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>RV</small></p></td>
<td width="2%"></td>
<td width="83%">


<p>Same as B::RV::RV, except that it will <i>die()</i> if
the <small>PV</small> isn&rsquo;t a reference.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>PVX</small></p></td>
<td width="2%"></td>
<td width="83%">


<p>This method is less often useful. It assumes that the
string stored in the struct is null-terminated, and
disregards the length information.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">It is the
appropriate method to use if you need to get the name of a
lexical variable from a padname array. Lexical variable
names are always stored with a null terminator, and the
length field ( <small>CUR</small> ) is overloaded for other
purposes and can&rsquo;t be relied on here.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><small>CUR</small></p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">This method returns the internal
length field, which consists of the number of internal
bytes, not necessarily the number of logical characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>LEN</small></p></td>
<td width="2%"></td>
<td width="83%">


<p>This method returns the number of bytes allocated (via
malloc) for storing the string. This is 0 if the scalar does
not &quot;own&quot; the string.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>B::PVMG
Methods</b> <small><br>
MAGIC</small> <br>
SvSTASH</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::MAGIC
Methods</b> <small><br>
MOREMAGIC</small> <br>
precomp</p>

<p style="margin-left:17%;">Only valid on r&minus;magic,
returns the string that generated the regexp.</p>

<p style="margin-left:11%;"><small>PRIVATE <br>
TYPE <br>
FLAGS</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>OBJ</small></p></td>
<td width="2%"></td>
<td width="49%">


<p>Will <i>die()</i> if called on r&minus;magic.</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>PTR</small></p></td>
<td width="2%"></td>
<td width="49%"></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>REGEX</small></p>

<p style="margin-left:17%;">Only valid on r&minus;magic,
returns the integer value of the <small>REGEX</small> stored
in the <small>MAGIC</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::PVLV
Methods</b> <small><br>
TARGOFF <br>
TARGLEN <br>
TYPE <br>
TARG</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>B::BM
Methods</b> <small><br>
USEFUL <br>
PREVIOUS <br>
RARE <br>
TABLE</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>B::GV
Methods</b> <br>
is_empty</p>

<p style="margin-left:17%;">This method returns
<small>TRUE</small> if the <small>GP</small> field of the
<small>GV</small> is <small>NULL</small> .</p>

<p style="margin-left:11%;"><small>NAME <br>
SAFENAME</small></p>

<p style="margin-left:17%;">This method returns the name of
the glob, but if the first character of the name is a
control character, then it converts it to ^X first, so that
*^G would return &quot;^G&quot; rather than
&quot;\cG&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
useful if you want to print out the name of a variable. If
you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
<tt>&quot;${&quot;^G&quot;} = 1&quot;</tt> is compiled as
two ops &minus; a constant string and a dereference (rv2gv)
&minus; so that the glob is created at runtime.</p>

<p style="margin-left:17%; margin-top: 1em">If you&rsquo;re
working with globs at runtime, and need to disambiguate *^G
from *{&quot;^G&quot;}, then you should use the raw
<small>NAME</small> method.</p>

<p style="margin-left:11%;"><small>STASH</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><small>SV</small></p></td>
<td width="86%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><small>IO</small></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>FORM</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>AV</small></p></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>HV</small></p></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>EGV</small></p></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>CV</small></p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>CVGEN <br>
LINE <br>
FILE <br>
FILEGV</small> <br>
GvREFCNT <small><br>
FLAGS</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>B::IO
Methods</b> <br>
B::IO objects derive from <small>IO</small> objects and you
will get more information from the <small>IO</small> object
itself.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $gvio = B::svref_2object(\*main::stdin)&minus;&gt;IO;
  $IO = $gvio&minus;&gt;object_2svref();
  $fd = $IO&minus;&gt;fileno();</pre>


<p style="margin-left:11%;"><small>LINES <br>
PAGE <br>
PAGE_LEN <br>
LINES_LEFT <br>
TOP_NAME <br>
TOP_GV <br>
FMT_NAME <br>
FMT_GV <br>
BOTTOM_NAME <br>
BOTTOM_GV <br>
SUBPROCESS</small> <br>
IoTYPE</p>

<p style="margin-left:17%;">A character symbolizing the
type of <small>IO</small> Handle.</p>

<pre style="margin-left:17%; margin-top: 1em">  &minus;     STDIN/OUT
  I     STDIN/OUT/ERR
  &lt;     read&minus;only
  &gt;     write&minus;only
  a     append
  +     read and write
  s     socket
  |     pipe
  I     IMPLICIT
  #     NUMERIC
  space closed handle
  \0    closed internal handle</pre>


<p style="margin-left:11%;">IoFLAGS <br>
IsSTD</p>

<p style="margin-left:17%;">Takes one argument (
&rsquo;stdin&rsquo; | &rsquo;stdout&rsquo; |
&rsquo;stderr&rsquo; ) and returns true if the IoIFP of the
object is equal to the handle whose name was passed as
argument; i.e.,
<tt>$io</tt>&minus;&gt;IsSTD(&rsquo;stderr&rsquo;) is true
if IoIFP($io) == <i>PerlIO_stderr()</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::AV
Methods</b> <small><br>
FILL</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>MAX</small></p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>ARRAY</small> <br>
ARRAYelt</p>

<p style="margin-left:17%;">Like
<tt>&quot;ARRAY&quot;</tt>, but takes an index as an
argument to get only one element, rather than a list of all
of them.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>OFF</small></p></td>
<td width="2%"></td>
<td width="83%">


<p>This method is deprecated if running under Perl 5.8, and
is no longer present if running under Perl 5.9</p></td></tr>
</table>

<p style="margin-left:11%;">AvFLAGS</p>

<p style="margin-left:17%;">This method returns the
<small>AV</small> specific flags. In Perl 5.9 these are now
stored in with the main <small>SV</small> flags, so this
method is no longer present.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::CV
Methods</b> <small><br>
STASH <br>
START <br>
ROOT</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><small>GV</small></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>FILE <br>
DEPTH <br>
PADLIST <br>
OUTSIDE <br>
OUTSIDE_SEQ <br>
XSUB <br>
XSUBANY</small></p>

<p style="margin-left:17%;">For constant subroutines,
returns the constant <small>SV</small> returned by the
subroutine.</p>

<p style="margin-left:11%;">CvFLAGS <br>
const_sv</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::HV
Methods</b> <small><br>
FILL</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>MAX</small></p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>KEYS <br>
RITER <br>
NAME <br>
ARRAY <br>
PMROOT</small></p>

<p style="margin-left:17%;">This method is not present if
running under Perl 5.9, as the <small>PMROOT</small>
information is no longer stored directly in the hash.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OP-RELATED
<small>CLASSES</small></b> <tt><br>
&quot;B::OP&quot;</tt>, <tt>&quot;B::UNOP&quot;</tt>,
<tt>&quot;B::BINOP&quot;</tt>,
<tt>&quot;B::LOGOP&quot;</tt>,
<tt>&quot;B::LISTOP&quot;</tt>,
<tt>&quot;B::PMOP&quot;</tt>, <tt>&quot;B::SVOP&quot;</tt>,
<tt>&quot;B::PADOP&quot;</tt>, <tt>&quot;B::PVOP&quot;</tt>,
<tt>&quot;B::LOOP&quot;</tt>,
<tt>&quot;B::COP&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">These classes
correspond in the obvious way to the underlying C structures
of similar names. The inheritance hierarchy mimics the
underlying C &quot;inheritance&quot;:</p>

<pre style="margin-left:11%; margin-top: 1em">                                 B::OP
                                   |
                   +&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+&minus;&minus;&minus;&minus;&minus;&minus;&minus;+
                   |               |        |        |       |
                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
                 ,'  `&minus;.
                /       `&minus;&minus;.
           B::BINOP     B::LOGOP
               |
               |
           B::LISTOP
             ,' `.
            /     \
        B::LOOP B::PMOP</pre>


<p style="margin-left:11%; margin-top: 1em">Access methods
correspond to the underlying C structre field names, with
the leading &quot;class indication&quot; prefix
(<tt>&quot;op_&quot;</tt>) removed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::OP
Methods</b> <br>
These methods get the values of similarly named fields
within the <small>OP</small> data structure. See top of
<tt>&quot;op.h&quot;</tt> for more info. <br>
next <br>
sibling <br>
name</p>

<p style="margin-left:17%;">This returns the op name as a
string (e.g. &quot;add&quot;, &quot;rv2av&quot;).</p>

<p style="margin-left:11%;">ppaddr</p>

<p style="margin-left:17%;">This returns the function name
as a string (e.g. &quot;PL_ppaddr[ <small>OP_ADD</small>
]&quot;, &quot;PL_ppaddr[ <small>OP_RV2AV</small>
]&quot;).</p>

<p style="margin-left:11%;">desc</p>

<p style="margin-left:17%;">This returns the op description
from the global C PL_op_desc array (e.g.
&quot;addition&quot; &quot;array deref&quot;).</p>

<p style="margin-left:11%;">targ <br>
type</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>opt</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;">flags <br>
private <br>
spare</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::UNOP
<small>METHOD</small></b> <br>
first</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::BINOP
<small>METHOD</small></b> <br>
last</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::LOGOP
<small>METHOD</small></b> <br>
other</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::LISTOP
<small>METHOD</small></b> <br>
children</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::PMOP
Methods</b> <br>
pmreplroot <br>
pmreplstart <br>
pmnext</p>

<p style="margin-left:17%;">Only up to Perl 5.9.4</p>

<p style="margin-left:11%;">pmflags <br>
extflags</p>

<p style="margin-left:17%;">Since Perl 5.9.5</p>

<p style="margin-left:11%;">precomp <br>
pmoffset</p>

<p style="margin-left:17%;">Only when perl was compiled
with ithreads.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::SVOP
<small>METHOD</small></b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>sv</p></td>
<td width="86%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>gv</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>B::PADOP
<small>METHOD</small></b> <br>
padix</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::PVOP
<small>METHOD</small></b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>pv</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>B::LOOP Methods</b> <br>
redoop <br>
nextop <br>
lastop</p>

<p style="margin-left:11%; margin-top: 1em"><b>B::COP
Methods</b> <br>
label <br>
stash <br>
stashpv <br>
stashlen <br>
file <br>
cop_seq <br>
arybase <br>
line <br>
warnings</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>io</p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;">hints <br>
hints_hash</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Malcolm
Beattie, <tt>&quot;mbeattie@sable.ox.ac.uk&quot;</tt></p>
<hr>
</body>
</html>
