<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLSUB</title>

</head>
<body>

<h1 align="center">PERLSUB</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlsub &minus;
Perl subroutines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To declare
subroutines:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub NAME;                     # A &quot;forward&quot; declaration.
    sub NAME(PROTO);              #  ditto, but with prototypes
    sub NAME : ATTRS;             #  with attributes
    sub NAME(PROTO) : ATTRS;      #  with attributes and prototypes
    sub NAME BLOCK                # A declaration and a definition.
    sub NAME(PROTO) BLOCK         #  ditto, but with prototypes
    sub NAME : ATTRS BLOCK        #  with attributes
    sub NAME(PROTO) : ATTRS BLOCK #  with prototypes and attributes</pre>


<p style="margin-left:11%; margin-top: 1em">To define an
anonymous subroutine at runtime:</p>

<pre style="margin-left:11%; margin-top: 1em">    $subref = sub BLOCK;                 # no proto
    $subref = sub (PROTO) BLOCK;         # with proto
    $subref = sub : ATTRS BLOCK;         # with attributes
    $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes</pre>


<p style="margin-left:11%; margin-top: 1em">To import
subroutines:</p>

<pre style="margin-left:11%; margin-top: 1em">    use MODULE qw(NAME1 NAME2 NAME3);</pre>


<p style="margin-left:11%; margin-top: 1em">To call
subroutines:</p>

<pre style="margin-left:11%; margin-top: 1em">    NAME(LIST);    # &amp; is optional with parentheses.
    NAME LIST;     # Parentheses optional if predeclared/imported.
    &amp;NAME(LIST);   # Circumvent prototypes.
    &amp;NAME;         # Makes current @_ visible to called subroutine.</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Like many
languages, Perl provides for user-defined subroutines. These
may be located anywhere in the main program, loaded in from
other files via the <tt>&quot;do&quot;</tt>,
<tt>&quot;require&quot;</tt>, or <tt>&quot;use&quot;</tt>
keywords, or generated on the fly using
<tt>&quot;eval&quot;</tt> or anonymous subroutines. You can
even call a function indirectly using a variable containing
its name or a <small>CODE</small> reference.</p>

<p style="margin-left:11%; margin-top: 1em">The Perl model
for function call and return values is simple: all functions
are passed as parameters one single flat list of scalars,
and all functions likewise return to their caller one single
flat list of scalars. Any arrays or hashes in these call and
return lists will collapse, losing their identities--but you
may always use pass-by-reference instead to avoid this. Both
call and return lists may contain as many or as few scalar
elements as you&rsquo;d like. (Often a function without an
explicit return statement is called a subroutine, but
there&rsquo;s really no difference from Perl&rsquo;s
perspective.)</p>

<p style="margin-left:11%; margin-top: 1em">Any arguments
passed in show up in the array <tt>@_</tt>. Therefore, if
you called a function with two arguments, those would be
stored in <tt>$_[0]</tt> and <tt>$_[1]</tt>. The array
<tt>@_</tt> is a local array, but its elements are aliases
for the actual scalar parameters. In particular, if an
element <tt>$_[0]</tt> is updated, the corresponding
argument is updated (or an error occurs if it is not
updatable). If an argument is an array or hash element which
did not exist when the function was called, that element is
created only when (and if) it is modified or a reference to
it is taken. (Some earlier versions of Perl created the
element whether or not the element was assigned to.)
Assigning to the whole array <tt>@_</tt> removes that
aliasing, and does not update any arguments.</p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;return&quot;</tt> statement may be used to exit a
subroutine, optionally specifying the returned value, which
will be evaluated in the appropriate context (list, scalar,
or void) depending on the context of the subroutine call. If
you specify no return value, the subroutine returns an empty
list in list context, the undefined value in scalar context,
or nothing in void context. If you return one or more
aggregates (arrays and hashes), these will be flattened
together into one large indistinguishable list.</p>

<p style="margin-left:11%; margin-top: 1em">If no
<tt>&quot;return&quot;</tt> is found and if the last
statement is an expression, its value is returned. If the
last statement is a loop control structure like a
<tt>&quot;foreach&quot;</tt> or a
<tt>&quot;while&quot;</tt>, the returned value is
unspecified. The empty sub returns the empty list.</p>

<p style="margin-left:11%; margin-top: 1em">Perl does not
have named formal parameters. In practice all you do is
assign to a <tt>&quot;my()&quot;</tt> list of these.
Variables that aren&rsquo;t declared to be private are
global variables. For gory details on creating private
variables, see &quot;Private Variables via <i>my()</i>&quot;
and &quot;Temporary Values via <i>local()</i>&quot;. To
create protected environments for a set of functions in a
separate package (and probably a separate file), see
&quot;Packages&quot; in perlmod.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub max {
        my $max = shift(@_);
        foreach $foo (@_) {
            $max = $foo if $max &lt; $foo;
        }
        return $max;
    }
    $bestday = max($mon,$tue,$wed,$thu,$fri);</pre>


<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">    # get a line, combining continuation lines
    #  that start with whitespace
    sub get_line {
        $thisline = $lookahead;  # global variables!
        LINE: while (defined($lookahead = &lt;STDIN&gt;)) {
            if ($lookahead =~ /^[ \t]/) {
                $thisline .= $lookahead;
            }
            else {
                last LINE;
            }
        }
        return $thisline;
    }
    $lookahead = &lt;STDIN&gt;;       # get first line
    while (defined($line = get_line())) {
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Assigning to a
list of private variables to name your arguments:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub maybeset {
        my($key, $value) = @_;
        $Foo{$key} = $value unless $Foo{$key};
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Because the
assignment copies the values, this also has the effect of
turning call-by-reference into call-by-value. Otherwise a
function is free to do in-place modifications of <tt>@_</tt>
and change its caller&rsquo;s values.</p>

<pre style="margin-left:11%; margin-top: 1em">    upcase_in($v1, $v2);  # this changes $v1 and $v2
    sub upcase_in {
        for (@_) { tr/a&minus;z/A&minus;Z/ }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You
aren&rsquo;t allowed to modify constants in this way, of
course. If an argument were actually literal and you tried
to change it, you&rsquo;d take a (presumably fatal)
exception. For example, this won&rsquo;t work:</p>

<pre style="margin-left:11%; margin-top: 1em">    upcase_in(&quot;frederick&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">It would be
much safer if the <tt>&quot;upcase_in()&quot;</tt> function
were written to return a copy of its parameters instead of
changing them in place:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($v3, $v4) = upcase($v1, $v2);  # this doesn't change $v1 and $v2
    sub upcase {
        return unless defined wantarray;  # void context, do nothing
        my @parms = @_;
        for (@parms) { tr/a&minus;z/A&minus;Z/ }
        return wantarray ? @parms : $parms[0];
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Notice how this
(unprototyped) function doesn&rsquo;t care whether it was
passed real scalars or arrays. Perl sees all arguments as
one big, long, flat parameter list in <tt>@_</tt>. This is
one area where Perl&rsquo;s simple argument-passing style
shines. The <tt>&quot;upcase()&quot;</tt> function would
work perfectly well without changing the
<tt>&quot;upcase()&quot;</tt> definition even if we fed it
things like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    @newlist   = upcase(@list1, @list2);
    @newlist   = upcase( split /:/, $var );</pre>


<p style="margin-left:11%; margin-top: 1em">Do not,
however, be tempted to do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    (@a, @b)   = upcase(@list1, @list2);</pre>


<p style="margin-left:11%; margin-top: 1em">Like the
flattened incoming parameter list, the return list is also
flattened on return. So all you have managed to do here is
stored everything in <tt>@a</tt> and made <tt>@b</tt> empty.
See &quot;Pass by Reference&quot; for alternatives.</p>

<p style="margin-left:11%; margin-top: 1em">A subroutine
may be called using an explicit <tt>&quot;&amp;&quot;</tt>
prefix. The <tt>&quot;&amp;&quot;</tt> is optional in modern
Perl, as are parentheses if the subroutine has been
predeclared. The <tt>&quot;&amp;&quot;</tt> is <i>not</i>
optional when just naming the subroutine, such as when
it&rsquo;s used as an argument to <i>defined()</i> or
<i>undef()</i>. Nor is it optional when you want to do an
indirect subroutine call with a subroutine name or reference
using the <tt>&quot;&amp;$subref()&quot;</tt> or
<tt>&quot;&amp;{$subref}()&quot;</tt> constructs, although
the <tt>&quot;$subref&minus;&gt;()&quot;</tt> notation
solves that problem. See perlref for more about all
that.</p>

<p style="margin-left:11%; margin-top: 1em">Subroutines may
be called recursively. If a subroutine is called using the
<tt>&quot;&amp;&quot;</tt> form, the argument list is
optional, and if omitted, no <tt>@_</tt> array is set up for
the subroutine: the <tt>@_</tt> array at the time of the
call is visible to subroutine instead. This is an efficiency
mechanism that new users may wish to avoid.</p>

<pre style="margin-left:11%; margin-top: 1em">    &amp;foo(1,2,3);        # pass three arguments
    foo(1,2,3);         # the same
    foo();              # pass a null list
    &amp;foo();             # the same
    &amp;foo;               # foo() get current args, like foo(@_) !!
    foo;                # like foo() IFF sub foo predeclared, else &quot;foo&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Not only does
the <tt>&quot;&amp;&quot;</tt> form make the argument list
optional, it also disables any prototype checking on
arguments you do provide. This is partly for historical
reasons, and partly for having a convenient way to cheat if
you know what you&rsquo;re doing. See &quot;Prototypes&quot;
below.</p>

<p style="margin-left:11%; margin-top: 1em">Since Perl
5.16.0, the <tt>&quot;__SUB__&quot;</tt> token is available
under <tt>&quot;use feature 'current_sub'&quot;</tt> and
<tt>&quot;use 5.16.0&quot;</tt>. It will evaluate to a
reference to the currently-running sub, which allows for
recursive calls without knowing your subroutine&rsquo;s
name.</p>

<pre style="margin-left:11%; margin-top: 1em">    use 5.16.0;
    my $factorial = sub {
      my ($x) = @_;
      return 1 if $x == 1;
      return($x * __SUB__&minus;&gt;( $x &minus; 1 ) );
    };</pre>


<p style="margin-left:11%; margin-top: 1em">Subroutines
whose names are in all upper case are reserved to the Perl
core, as are modules whose names are in all lower case. A
subroutine in all capitals is a loosely-held convention
meaning it will be called indirectly by the run-time system
itself, usually due to a triggered event. Subroutines that
do special, pre-defined things include
<tt>&quot;AUTOLOAD&quot;</tt>, <tt>&quot;CLONE&quot;</tt>,
<tt>&quot;DESTROY&quot;</tt> plus all functions mentioned in
perltie and PerlIO::via.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;BEGIN&quot;</tt>, <tt>&quot;UNITCHECK&quot;</tt>,
<tt>&quot;CHECK&quot;</tt>, <tt>&quot;INIT&quot;</tt> and
<tt>&quot;END&quot;</tt> subroutines are not so much
subroutines as named special code blocks, of which you can
have more than one in a package, and which you can
<b>not</b> call explicitly. See &quot; <small>BEGIN</small>
, <small>UNITCHECK</small> , <small>CHECK</small> ,
<small>INIT</small> and <small>END</small> &quot; in
perlmod</p>

<p style="margin-left:11%; margin-top: 1em"><b>Private
Variables via</b> <i>my()</i> <br>
Synopsis:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $foo;            # declare $foo lexically local
    my (@wid, %get);    # declare list of variables local
    my $foo = &quot;flurp&quot;;  # declare $foo lexical, and init it
    my @oof = @bar;     # declare @oof lexical, and init it
    my $x : Foo = $y;   # similar, with an attribute applied</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: The use of attribute lists on <tt>&quot;my&quot;</tt>
declarations is still evolving. The current semantics and
interface are subject to change. See attributes and
Attribute::Handlers.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;my&quot;</tt> operator declares the listed
variables to be lexically confined to the enclosing block,
conditional (<tt>&quot;if/unless/elsif/else&quot;</tt>),
loop
(<tt>&quot;for/foreach/while/until/continue&quot;</tt>),
subroutine, <tt>&quot;eval&quot;</tt>, or
<tt>&quot;do/require/use&quot;</tt>&rsquo;d file. If more
than one value is listed, the list must be placed in
parentheses. All listed elements must be legal lvalues. Only
alphanumeric identifiers may be lexically scoped--magical
built-ins like <tt>$/</tt> must currently be
<tt>&quot;local&quot;</tt>ized with
<tt>&quot;local&quot;</tt> instead.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike dynamic
variables created by the <tt>&quot;local&quot;</tt>
operator, lexical variables declared with
<tt>&quot;my&quot;</tt> are totally hidden from the outside
world, including any called subroutines. This is true if
it&rsquo;s the same subroutine called from itself or
elsewhere--every call gets its own copy.</p>

<p style="margin-left:11%; margin-top: 1em">This
doesn&rsquo;t mean that a <tt>&quot;my&quot;</tt> variable
declared in a statically enclosing lexical scope would be
invisible. Only dynamic scopes are cut off. For example, the
<tt>&quot;bumpx()&quot;</tt> function below has access to
the lexical <tt>$x</tt> variable because both the
<tt>&quot;my&quot;</tt> and the <tt>&quot;sub&quot;</tt>
occurred at the same scope, presumably file scope.</p>

<pre style="margin-left:11%; margin-top: 1em">    my $x = 10;
    sub bumpx { $x++ }</pre>


<p style="margin-left:11%; margin-top: 1em">An
<tt>&quot;eval()&quot;</tt>, however, can see lexical
variables of the scope it is being evaluated in, so long as
the names aren&rsquo;t hidden by declarations within the
<tt>&quot;eval()&quot;</tt> itself. See perlref.</p>

<p style="margin-left:11%; margin-top: 1em">The parameter
list to <i>my()</i> may be assigned to if desired, which
allows you to initialize your variables. (If no initializer
is given for a particular variable, it is created with the
undefined value.) Commonly this is used to name input
parameters to a subroutine. Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    $arg = &quot;fred&quot;;        # &quot;global&quot; variable
    $n = cube_root(27);
    print &quot;$arg thinks the root is $n\n&quot;;
 fred thinks the root is 3
    sub cube_root {
        my $arg = shift;  # name doesn't matter
        $arg **= 1/3;
        return $arg;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;my&quot;</tt> is simply a modifier on something
you might assign to. So when you do assign to variables in
its argument list, <tt>&quot;my&quot;</tt> doesn&rsquo;t
change whether those variables are viewed as a scalar or an
array. So</p>

<pre style="margin-left:11%; margin-top: 1em">    my ($foo) = &lt;STDIN&gt;;                # WRONG?
    my @FOO = &lt;STDIN&gt;;</pre>


<p style="margin-left:11%; margin-top: 1em">both supply a
list context to the right-hand side, while</p>

<pre style="margin-left:11%; margin-top: 1em">    my $foo = &lt;STDIN&gt;;</pre>


<p style="margin-left:11%; margin-top: 1em">supplies a
scalar context. But the following declares only one
variable:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $foo, $bar = 1;                  # WRONG</pre>


<p style="margin-left:11%; margin-top: 1em">That has the
same effect as</p>

<pre style="margin-left:11%; margin-top: 1em">    my $foo;
    $bar = 1;</pre>


<p style="margin-left:11%; margin-top: 1em">The declared
variable is not introduced (is not visible) until after the
current statement. Thus,</p>

<pre style="margin-left:11%; margin-top: 1em">    my $x = $x;</pre>


<p style="margin-left:11%; margin-top: 1em">can be used to
initialize a new <tt>$x</tt> with the value of the old
<tt>$x</tt>, and the expression</p>

<pre style="margin-left:11%; margin-top: 1em">    my $x = 123 and $x == 123</pre>


<p style="margin-left:11%; margin-top: 1em">is false unless
the old <tt>$x</tt> happened to have the value
<tt>123</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Lexical scopes
of control structures are not bounded precisely by the
braces that delimit their controlled blocks; control
expressions are part of that scope, too. Thus in the
loop</p>

<pre style="margin-left:11%; margin-top: 1em">    while (my $line = &lt;&gt;) {
        $line = lc $line;
    } continue {
        print $line;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">the scope of
<tt>$line</tt> extends from its declaration throughout the
rest of the loop construct (including the
<tt>&quot;continue&quot;</tt> clause), but not beyond it.
Similarly, in the conditional</p>

<pre style="margin-left:11%; margin-top: 1em">    if ((my $answer = &lt;STDIN&gt;) =~ /^yes$/i) {
        user_agrees();
    } elsif ($answer =~ /^no$/i) {
        user_disagrees();
    } else {
        chomp $answer;
        die &quot;'$answer' is neither 'yes' nor 'no'&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">the scope of
<tt>$answer</tt> extends from its declaration through the
rest of that conditional, including any
<tt>&quot;elsif&quot;</tt> and <tt>&quot;else&quot;</tt>
clauses, but not beyond it. See &quot;Simple
Statements&quot; in perlsyn for information on the scope of
variables in statements with modifiers.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;foreach&quot;</tt> loop defaults to scoping its
index variable dynamically in the manner of
<tt>&quot;local&quot;</tt>. However, if the index variable
is prefixed with the keyword <tt>&quot;my&quot;</tt>, or if
there is already a lexical by that name in scope, then a new
lexical is created instead. Thus in the loop</p>

<pre style="margin-left:11%; margin-top: 1em">    for my $i (1, 2, 3) {
        some_function();
    }</pre>


<p style="margin-left:11%; margin-top: 1em">the scope of
<tt>$i</tt> extends to the end of the loop, but not beyond
it, rendering the value of <tt>$i</tt> inaccessible within
<tt>&quot;some_function()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Some users may
wish to encourage the use of lexically scoped variables. As
an aid to catching implicit uses to package variables, which
are always global, if you say</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict 'vars';</pre>


<p style="margin-left:11%; margin-top: 1em">then any
variable mentioned from there to the end of the enclosing
block must either refer to a lexical variable, be
predeclared via <tt>&quot;our&quot;</tt> or <tt>&quot;use
vars&quot;</tt>, or else must be fully qualified with the
package name. A compilation error results otherwise. An
inner block may countermand this with <tt>&quot;no strict
'vars'&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;my&quot;</tt> has both a compile-time and a
run-time effect. At compile time, the compiler takes notice
of it. The principal usefulness of this is to quiet
<tt>&quot;use strict 'vars'&quot;</tt>, but it is also
essential for generation of closures as detailed in perlref.
Actual initialization is delayed until run time, though, so
it gets executed at the appropriate time, such as each time
through a loop, for example.</p>

<p style="margin-left:11%; margin-top: 1em">Variables
declared with <tt>&quot;my&quot;</tt> are not part of any
package and are therefore never fully qualified with the
package name. In particular, you&rsquo;re not allowed to try
to make a package variable (or other global) lexical:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $pack::var;      # ERROR!  Illegal syntax</pre>


<p style="margin-left:11%; margin-top: 1em">In fact, a
dynamic variable (also known as package or global variables)
are still accessible using the fully qualified
<tt>&quot;::&quot;</tt> notation even while a lexical of the
same name is also visible:</p>

<pre style="margin-left:11%; margin-top: 1em">    package main;
    local $x = 10;
    my    $x = 20;
    print &quot;$x and $::x\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">That will print
out <tt>20</tt> and <tt>10</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">You may declare
<tt>&quot;my&quot;</tt> variables at the outermost scope of
a file to hide any such identifiers from the world outside
that file. This is similar in spirit to C&rsquo;s static
variables when they are used at the file level. To do this
with a subroutine requires the use of a closure (an
anonymous function that accesses enclosing lexicals). If you
want to create a private subroutine that cannot be called
from outside that block, it can declare a lexical variable
containing an anonymous sub reference:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $secret_version = '1.001&minus;beta';
    my $secret_sub = sub { print $secret_version };
    &amp;$secret_sub();</pre>


<p style="margin-left:11%; margin-top: 1em">As long as the
reference is never returned by any function within the
module, no outside module can see the subroutine, because
its name is not in any package&rsquo;s symbol table.
Remember that it&rsquo;s not <i><small>REALLY</small></i>
called <tt>$some_pack::secret_version</tt> or anything;
it&rsquo;s just <tt>$secret_version</tt>, unqualified and
unqualifiable.</p>

<p style="margin-left:11%; margin-top: 1em">This does not
work with object methods, however; all object methods have
to be in the symbol table of some package to be found. See
&quot;Function Templates&quot; in perlref for something of a
work-around to this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Persistent
Private Variables</b> <br>
There are two ways to build persistent private variables in
Perl 5.10. First, you can simply use the
<tt>&quot;state&quot;</tt> feature. Or, you can use
closures, if you want to stay compatible with releases older
than 5.10.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Persistent
variables via state()</i></p>

<p style="margin-left:11%; margin-top: 1em">Beginning with
Perl 5.9.4, you can declare variables with the
<tt>&quot;state&quot;</tt> keyword in place of
<tt>&quot;my&quot;</tt>. For that to work, though, you must
have enabled that feature beforehand, either by using the
<tt>&quot;feature&quot;</tt> pragma, or by using
<tt>&quot;&minus;E&quot;</tt> on one-liners (see feature).
Beginning with Perl 5.16, the
<tt>&quot;CORE::state&quot;</tt> form does not require the
<tt>&quot;feature&quot;</tt> pragma.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following code maintains a private counter, incremented
each time the <i>gimme_another()</i> function is called:</p>

<pre style="margin-left:11%; margin-top: 1em">    use feature 'state';
    sub gimme_another { state $x; return ++$x }</pre>


<p style="margin-left:11%; margin-top: 1em">Also, since
<tt>$x</tt> is lexical, it can&rsquo;t be reached or
modified by any Perl code outside.</p>

<p style="margin-left:11%; margin-top: 1em">When combined
with variable declaration, simple scalar assignment to
<tt>&quot;state&quot;</tt> variables (as in <tt>&quot;state
$x = 42&quot;</tt>) is executed only the first time. When
such statements are evaluated subsequent times, the
assignment is ignored. The behavior of this sort of
assignment to non-scalar variables is undefined.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Persistent
variables with closures</i></p>

<p style="margin-left:11%; margin-top: 1em">Just because a
lexical variable is lexically (also called statically)
scoped to its enclosing block, <tt>&quot;eval&quot;</tt>, or
<tt>&quot;do&quot;</tt> <small>FILE</small> , this
doesn&rsquo;t mean that within a function it works like a C
static. It normally works more like a C auto, but with
implicit garbage collection.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike local
variables in C or C <small>++</small> , Perl&rsquo;s lexical
variables don&rsquo;t necessarily get recycled just because
their scope has exited. If something more permanent is still
aware of the lexical, it will stick around. So long as
something else references a lexical, that lexical
won&rsquo;t be freed--which is as it should be. You
wouldn&rsquo;t want memory being free until you were done
using it, or kept around once you were done. Automatic
garbage collection takes care of this for you.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
you can pass back or save away references to lexical
variables, whereas to return a pointer to a C auto is a
grave error. It also gives us a way to simulate C&rsquo;s
function statics. Here&rsquo;s a mechanism for giving a
function private variables with both lexical scoping and a
static lifetime. If you do want to create something like
C&rsquo;s static variables, just enclose the whole function
in an extra block, and put the static variable outside the
function but in the block.</p>

<pre style="margin-left:11%; margin-top: 1em">    {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
    # $secret_val now becomes unreachable by the outside
    # world, but retains its value between calls to gimme_another</pre>


<p style="margin-left:11%; margin-top: 1em">If this
function is being sourced in from a separate file via
<tt>&quot;require&quot;</tt> or <tt>&quot;use&quot;</tt>,
then this is probably just fine. If it&rsquo;s all in the
main program, you&rsquo;ll need to arrange for the
<tt>&quot;my&quot;</tt> to be executed early, either by
putting the whole block above your main program, or more
likely, placing merely a <tt>&quot;BEGIN&quot;</tt> code
block around it to make sure it gets executed before your
program starts to run:</p>

<pre style="margin-left:11%; margin-top: 1em">    BEGIN {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>BEGIN</small> , <small>UNITCHECK</small> ,
<small>CHECK</small> , <small>INIT</small> and
<small>END</small> &quot; in perlmod about the special
triggered code blocks, <tt>&quot;BEGIN&quot;</tt>,
<tt>&quot;UNITCHECK&quot;</tt>, <tt>&quot;CHECK&quot;</tt>,
<tt>&quot;INIT&quot;</tt> and <tt>&quot;END&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If declared at
the outermost scope (the file scope), then lexicals work
somewhat like C&rsquo;s file statics. They are available to
all functions in that same file declared below them, but are
inaccessible from outside that file. This strategy is
sometimes used in modules to create private variables that
the whole module can see.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Temporary
Values via</b> <i>local()</i> <b><small><br>
WARNING</small></b> : In general, you should be using
<tt>&quot;my&quot;</tt> instead of
<tt>&quot;local&quot;</tt>, because it&rsquo;s faster and
safer. Exceptions to this include the global punctuation
variables, global filehandles and formats, and direct
manipulation of the Perl symbol table itself.
<tt>&quot;local&quot;</tt> is mostly used when the current
value of a variable must be visible to called
subroutines.</p>

<p style="margin-left:11%; margin-top: 1em">Synopsis:</p>

<pre style="margin-left:11%; margin-top: 1em">    # localization of values
    local $foo;                 # make $foo dynamically local
    local (@wid, %get);         # make list of variables local
    local $foo = &quot;flurp&quot;;       # make $foo dynamic, and init it
    local @oof = @bar;          # make @oof dynamic, and init it
    local $hash{key} = &quot;val&quot;;   # sets a local value for this hash entry
    delete local $hash{key};    # delete this entry for the current block
    local ($cond ? $v1 : $v2);  # several types of lvalues support
                                # localization
    # localization of symbols
    local *FH;                  # localize $FH, @FH, %FH, &amp;FH  ...
    local *merlyn = *randal;    # now $merlyn is really $randal, plus
                                #     @merlyn is really @randal, etc
    local *merlyn = 'randal';   # SAME THING: promote 'randal' to *randal
    local *merlyn = \$randal;   # just alias $merlyn, not @merlyn etc</pre>


<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;local&quot;</tt> modifies its listed variables to
be &quot;local&quot; to the enclosing block,
<tt>&quot;eval&quot;</tt>, or <tt>&quot;do
FILE&quot;</tt>&minus;&minus;and to <i>any subroutine called
from within that block</i>. A <tt>&quot;local&quot;</tt>
just gives temporary values to global (meaning package)
variables. It does <i>not</i> create a local variable. This
is known as dynamic scoping. Lexical scoping is done with
<tt>&quot;my&quot;</tt>, which works more like C&rsquo;s
auto declarations.</p>

<p style="margin-left:11%; margin-top: 1em">Some types of
lvalues can be localized as well: hash and array elements
and slices, conditionals (provided that their result is
always localizable), and symbolic references. As for simple
variables, this creates new, dynamically scoped values.</p>

<p style="margin-left:11%; margin-top: 1em">If more than
one variable or expression is given to
<tt>&quot;local&quot;</tt>, they must be placed in
parentheses. This operator works by saving the current
values of those variables in its argument list on a hidden
stack and restoring them upon exiting the block, subroutine,
or eval. This means that called subroutines can also
reference the local variable, but not the global one. The
argument list may be assigned to if desired, which allows
you to initialize your local variables. (If no initializer
is given for a particular variable, it is created with an
undefined value.)</p>

<p style="margin-left:11%; margin-top: 1em">Because
<tt>&quot;local&quot;</tt> is a run-time operator, it gets
executed each time through a loop. Consequently, it&rsquo;s
more efficient to localize your variables outside the
loop.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Grammatical
note on local()</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;local&quot;</tt> is simply a modifier on an lvalue
expression. When you assign to a
<tt>&quot;local&quot;</tt>ized variable, the
<tt>&quot;local&quot;</tt> doesn&rsquo;t change whether its
list is viewed as a scalar or an array. So</p>

<pre style="margin-left:11%; margin-top: 1em">    local($foo) = &lt;STDIN&gt;;
    local @FOO = &lt;STDIN&gt;;</pre>


<p style="margin-left:11%; margin-top: 1em">both supply a
list context to the right-hand side, while</p>

<pre style="margin-left:11%; margin-top: 1em">    local $foo = &lt;STDIN&gt;;</pre>


<p style="margin-left:11%; margin-top: 1em">supplies a
scalar context.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Localization
of special variables</i></p>

<p style="margin-left:11%; margin-top: 1em">If you localize
a special variable, you&rsquo;ll be giving a new value to
it, but its magic won&rsquo;t go away. That means that all
side-effects related to this magic still work with the
localized value.</p>

<p style="margin-left:11%; margin-top: 1em">This feature
allows code like this to work :</p>

<pre style="margin-left:11%; margin-top: 1em">    # Read the whole contents of FILE in $slurp
    { local $/ = undef; $slurp = &lt;FILE&gt;; }</pre>


<p style="margin-left:11%; margin-top: 1em">Note, however,
that this restricts localization of some values ; for
example, the following statement dies, as of perl 5.9.0,
with an error <i>Modification of a read-only value
attempted</i>, because the <tt>$1</tt> variable is magical
and read-only :</p>

<pre style="margin-left:11%; margin-top: 1em">    local $1 = 2;</pre>


<p style="margin-left:11%; margin-top: 1em">One exception
is the default scalar variable: starting with perl 5.14
<tt>&quot;local($_)&quot;</tt> will always strip all magic
from <tt>$_</tt>, to make it possible to safely reuse
<tt>$_</tt> in a subroutine.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: Localization of tied arrays and hashes does not currently
work as described. This will be fixed in a future release of
Perl; in the meantime, avoid code that relies on any
particular behaviour of localising tied arrays or hashes
(localising individual elements is still okay). See
&quot;Localising Tied Arrays and Hashes Is Broken&quot; in
perl58delta for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Localization
of globs</i></p>

<p style="margin-left:11%; margin-top: 1em">The
construct</p>

<pre style="margin-left:11%; margin-top: 1em">    local *name;</pre>


<p style="margin-left:11%; margin-top: 1em">creates a whole
new symbol table entry for the glob
<tt>&quot;name&quot;</tt> in the current package. That means
that all variables in its glob slot ($name, <tt>@name</tt>,
<tt>%name</tt>, &amp;name, and the <tt>&quot;name&quot;</tt>
filehandle) are dynamically reset.</p>

<p style="margin-left:11%; margin-top: 1em">This implies,
among other things, that any magic eventually carried by
those variables is locally lost. In other words, saying
<tt>&quot;local */&quot;</tt> will not have any effect on
the internal value of the input record separator.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Localization
of elements of composite types</i></p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s also
worth taking a moment to explain what happens when you
<tt>&quot;local&quot;</tt>ize a member of a composite type
(i.e. an array or hash element). In this case, the element
is <tt>&quot;local&quot;</tt>ized <i>by name</i>. This means
that when the scope of the <tt>&quot;local()&quot;</tt>
ends, the saved value will be restored to the hash element
whose key was named in the <tt>&quot;local()&quot;</tt>, or
the array element whose index was named in the
<tt>&quot;local()&quot;</tt>. If that element was deleted
while the <tt>&quot;local()&quot;</tt> was in effect (e.g.
by a <tt>&quot;delete()&quot;</tt> from a hash or a
<tt>&quot;shift()&quot;</tt> of an array), it will spring
back into existence, possibly extending an array and filling
in the skipped elements with <tt>&quot;undef&quot;</tt>. For
instance, if you say</p>

<pre style="margin-left:11%; margin-top: 1em">    %hash = ( 'This' =&gt; 'is', 'a' =&gt; 'test' );
    @ary  = ( 0..5 );
    {
         local($ary[5]) = 6;
         local($hash{'a'}) = 'drill';
         while (my $e = pop(@ary)) {
             print &quot;$e . . .\n&quot;;
             last unless $e &gt; 3;
         }
         if (@ary) {
             $hash{'only a'} = 'test';
             delete $hash{'a'};
         }
    }
    print join(' ', map { &quot;$_ $hash{$_}&quot; } sort keys %hash),&quot;.\n&quot;;
    print &quot;The array has &quot;,scalar(@ary),&quot; elements: &quot;,
          join(', ', map { defined $_ ? $_ : 'undef' } @ary),&quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Perl will
print</p>

<pre style="margin-left:11%; margin-top: 1em">    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5</pre>


<p style="margin-left:11%; margin-top: 1em">The behavior of
<i>local()</i> on non-existent members of composite types is
subject to change in future.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Localized
deletion of elements of composite types</i></p>

<p style="margin-left:11%; margin-top: 1em">You can use the
<tt>&quot;delete local $array[$idx]&quot;</tt> and
<tt>&quot;delete local $hash{key}&quot;</tt> constructs to
delete a composite type entry for the current block and
restore it when it ends. They return the array/hash value
before the localization, which means that they are
respectively equivalent to</p>

<pre style="margin-left:11%; margin-top: 1em">    do {
        my $val = $array[$idx];
        local  $array[$idx];
        delete $array[$idx];
        $val
    }</pre>


<p style="margin-left:11%; margin-top: 1em">and</p>

<pre style="margin-left:11%; margin-top: 1em">    do {
        my $val = $hash{key};
        local  $hash{key};
        delete $hash{key};
        $val
    }</pre>


<p style="margin-left:11%; margin-top: 1em">except that for
those the <tt>&quot;local&quot;</tt> is scoped to the
<tt>&quot;do&quot;</tt> block. Slices are also accepted.</p>

<pre style="margin-left:11%; margin-top: 1em">    my %hash = (
     a =&gt; [ 7, 8, 9 ],
     b =&gt; 1,
    )
    {
     my $a = delete local $hash{a};
     # $a is [ 7, 8, 9 ]
     # %hash is (b =&gt; 1)
     {
      my @nums = delete local @$a[0, 2]
      # @nums is (7, 9)
      # $a is [ undef, 8 ]
      $a[0] = 999; # will be erased when the scope ends
     }
     # $a is back to [ 7, 8, 9 ]
    }
    # %hash is back to its original state</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Lvalue
subroutines <small><br>
WARNING</small></b> : Lvalue subroutines are still
experimental and the implementation may change in future
versions of Perl.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to return a modifiable value from a subroutine. To do this,
you have to declare the subroutine to return an lvalue.</p>

<pre style="margin-left:11%; margin-top: 1em">    my $val;
    sub canmod : lvalue {
        $val;  # or:  return $val;
    }
    sub nomod {
        $val;
    }
    canmod() = 5;   # assigns to $val
    nomod()  = 5;   # ERROR</pre>


<p style="margin-left:11%; margin-top: 1em">The scalar/list
context for the subroutine and for the right-hand side of
assignment is determined as if the subroutine call is
replaced by a scalar. For example, consider:</p>

<pre style="margin-left:11%; margin-top: 1em">    data(2,3) = get_data(3,4);</pre>


<p style="margin-left:11%; margin-top: 1em">Both
subroutines here are called in a scalar context, while
in:</p>

<pre style="margin-left:11%; margin-top: 1em">    (data(2,3)) = get_data(3,4);</pre>


<p style="margin-left:11%; margin-top: 1em">and in:</p>

<pre style="margin-left:11%; margin-top: 1em">    (data(2),data(3)) = get_data(3,4);</pre>


<p style="margin-left:11%; margin-top: 1em">all the
subroutines are called in a list context. <br>
Lvalue subroutines are <small>EXPERIMENTAL</small></p>

<p style="margin-left:17%;">They appear to be convenient,
but there is at least one reason to be circumspect.</p>

<p style="margin-left:17%; margin-top: 1em">They violate
encapsulation. A normal mutator can check the supplied
argument before setting the attribute it is protecting, an
lvalue subroutine never gets that chance. Consider;</p>

<pre style="margin-left:17%; margin-top: 1em">    my $some_array_ref = [];    # protected by mutators ??
    sub set_arr {               # normal mutator
        my $val = shift;
        die(&quot;expected array, you supplied &quot;, ref $val)
           unless ref $val eq 'ARRAY';
        $some_array_ref = $val;
    }
    sub set_arr_lv : lvalue {   # lvalue mutator
        $some_array_ref;
    }
    # set_arr_lv cannot stop this !
    set_arr_lv() = { a =&gt; 1 };</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Passing
Symbol Table Entries (typeglobs) <small><br>
WARNING</small></b> : The mechanism described in this
section was originally the only way to simulate
pass-by-reference in older versions of Perl. While it still
works fine in modern versions, the new reference mechanism
is generally easier to work with. See below.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes you
don&rsquo;t want to pass the value of an array to a
subroutine but rather the name of it, so that the subroutine
can modify the global copy of it rather than working with a
local copy. In perl you can refer to all objects of a
particular name by prefixing the name with a star:
<tt>*foo</tt>. This is often known as a
&quot;typeglob&quot;, because the star on the front can be
thought of as a wildcard match for all the funny prefix
characters on variables and subroutines and such.</p>

<p style="margin-left:11%; margin-top: 1em">When evaluated,
the typeglob produces a scalar value that represents all the
objects of that name, including any filehandle, format, or
subroutine. When assigned to, it causes the name mentioned
to refer to whatever <tt>&quot;*&quot;</tt> value was
assigned to it. Example:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub doubleary {
        local(*someary) = @_;
        foreach $elem (@someary) {
            $elem *= 2;
        }
    }
    doubleary(*foo);
    doubleary(*bar);</pre>


<p style="margin-left:11%; margin-top: 1em">Scalars are
already passed by reference, so you can modify scalar
arguments without using this mechanism by referring
explicitly to <tt>$_[0]</tt> etc. You can modify all the
elements of an array by passing all the elements as scalars,
but you have to use the <tt>&quot;*&quot;</tt> mechanism (or
the equivalent reference mechanism) to
<tt>&quot;push&quot;</tt>, <tt>&quot;pop&quot;</tt>, or
change the size of an array. It will certainly be faster to
pass the typeglob (or reference).</p>

<p style="margin-left:11%; margin-top: 1em">Even if you
don&rsquo;t want to modify an array, this mechanism is
useful for passing multiple arrays in a single
<small>LIST</small> , because normally the
<small>LIST</small> mechanism will merge all the array
values so that you can&rsquo;t extract out the individual
arrays. For more on typeglobs, see &quot;Typeglobs and
Filehandles&quot; in perldata.</p>

<p style="margin-left:11%; margin-top: 1em"><b>When to
Still Use</b> <i>local()</i> <br>
Despite the existence of <tt>&quot;my&quot;</tt>, there are
still three places where the <tt>&quot;local&quot;</tt>
operator still shines. In fact, in these three places, you
<i>must</i> use <tt>&quot;local&quot;</tt> instead of
<tt>&quot;my&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>You need to give a global variable a temporary value,
especially <tt>$_</tt>.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The global
variables, like <tt>@ARGV</tt> or the punctuation variables,
must be <tt>&quot;local&quot;</tt>ized with
<tt>&quot;local()&quot;</tt>. This block reads in
<i>/etc/motd</i>, and splits it up into chunks separated by
lines of equal signs, which are placed in
<tt>@Fields</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">    {
        local @ARGV = (&quot;/etc/motd&quot;);
        local $/ = undef;
        local $_ = &lt;&gt;;
        @Fields = split /^\s*=+\s*$/;
    }</pre>


<p style="margin-left:17%; margin-top: 1em">It particular,
it&rsquo;s important to <tt>&quot;local&quot;</tt>ize
<tt>$_</tt> in any routine that assigns to it. Look out for
implicit assignments in <tt>&quot;while&quot;</tt>
conditionals.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">You need to create a local file
or directory handle or a local function.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A function that
needs a filehandle of its own must use
<tt>&quot;local()&quot;</tt> on a complete typeglob. This
can be used to create new symbol table entries:</p>

<pre style="margin-left:17%; margin-top: 1em">    sub ioqueue {
        local  (*READER, *WRITER);    # not my!
        pipe    (READER,  WRITER)     or die &quot;pipe: $!&quot;;
        return (*READER, *WRITER);
    }
    ($head, $tail) = ioqueue();</pre>


<p style="margin-left:17%; margin-top: 1em">See the Symbol
module for a way to create anonymous symbol table
entries.</p>

<p style="margin-left:17%; margin-top: 1em">Because
assignment of a reference to a typeglob creates an alias,
this can be used to create what is effectively a local
function, or at least, a local alias.</p>

<pre style="margin-left:17%; margin-top: 1em">    {
        local *grow = \&amp;shrink; # only until this block exits
        grow();                 # really calls shrink()
        move();                 # if move() grow()s, it shrink()s too
    }
    grow();                     # get the real grow() again</pre>


<p style="margin-left:17%; margin-top: 1em">See
&quot;Function Templates&quot; in perlref for more about
manipulating functions by name in this way.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">You want to temporarily change
just one element of an array or hash.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You can
<tt>&quot;local&quot;</tt>ize just one element of an
aggregate. Usually this is done on dynamics:</p>

<pre style="margin-left:17%; margin-top: 1em">    {
        local $SIG{INT} = 'IGNORE';
        funct();                            # uninterruptible
    }
    # interruptibility automatically restored here</pre>


<p style="margin-left:17%; margin-top: 1em">But it also
works on lexically declared aggregates. Prior to 5.005, this
operation could on occasion misbehave.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pass by
Reference</b> <br>
If you want to pass more than one array or hash into a
function--or return them from it--and have them maintain
their integrity, then you&rsquo;re going to have to use an
explicit pass-by-reference. Before you do that, you need to
understand references as detailed in perlref. This section
may not make much sense to you otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Here are a few
simple examples. First, let&rsquo;s pass in several arrays
to a function and have it <tt>&quot;pop&quot;</tt> all of
then, returning a new list of all their former last
elements:</p>

<pre style="margin-left:11%; margin-top: 1em">    @tailings = popmany ( \@a, \@b, \@c, \@d );
    sub popmany {
        my $aref;
        my @retlist = ();
        foreach $aref ( @_ ) {
            push @retlist, pop @$aref;
        }
        return @retlist;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how you might write a function that returns a list of keys
occurring in all the hashes passed to it:</p>

<pre style="margin-left:11%; margin-top: 1em">    @common = inter( \%foo, \%bar, \%joe );
    sub inter {
        my ($k, $href, %seen); # locals
        foreach $href (@_) {
            while ( $k = each %$href ) {
                $seen{$k}++;
            }
        }
        return grep { $seen{$_} == @_ } keys %seen;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">So far,
we&rsquo;re using just the normal list return mechanism.
What happens if you want to pass or return a hash? Well, if
you&rsquo;re using only one of them, or you don&rsquo;t mind
them concatenating, then the normal calling convention is
ok, although a little expensive.</p>

<p style="margin-left:11%; margin-top: 1em">Where people
get into trouble is here:</p>

<pre style="margin-left:11%; margin-top: 1em">    (@a, @b) = func(@c, @d);
or
    (%a, %b) = func(%c, %d);</pre>


<p style="margin-left:11%; margin-top: 1em">That syntax
simply won&rsquo;t work. It sets just <tt>@a</tt> or
<tt>%a</tt> and clears the <tt>@b</tt> or <tt>%b</tt>. Plus
the function didn&rsquo;t get passed into two separate
arrays or hashes: it got one long list in <tt>@_</tt>, as
always.</p>

<p style="margin-left:11%; margin-top: 1em">If you can
arrange for everyone to deal with this through references,
it&rsquo;s cleaner code, although not so nice to look at.
Here&rsquo;s a function that takes two array references as
arguments, returning the two array elements in order of how
many elements they have in them:</p>

<pre style="margin-left:11%; margin-top: 1em">    ($aref, $bref) = func(\@c, \@d);
    print &quot;@$aref has more than @$bref\n&quot;;
    sub func {
        my ($cref, $dref) = @_;
        if (@$cref &gt; @$dref) {
            return ($cref, $dref);
        } else {
            return ($dref, $cref);
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">It turns out
that you can actually do this also:</p>

<pre style="margin-left:11%; margin-top: 1em">    (*a, *b) = func(\@c, \@d);
    print &quot;@a has more than @b\n&quot;;
    sub func {
        local (*c, *d) = @_;
        if (@c &gt; @d) {
            return (\@c, \@d);
        } else {
            return (\@d, \@c);
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Here
we&rsquo;re using the typeglobs to do symbol table aliasing.
It&rsquo;s a tad subtle, though, and also won&rsquo;t work
if you&rsquo;re using <tt>&quot;my&quot;</tt> variables,
because only globals (even in disguise as
<tt>&quot;local&quot;</tt>s) are in the symbol table.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
passing around filehandles, you could usually just use the
bare typeglob, like <tt>*STDOUT</tt>, but typeglobs
references work, too. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    splutter(\*STDOUT);
    sub splutter {
        my $fh = shift;
        print $fh &quot;her um well a hmmm\n&quot;;
    }
    $rec = get_rec(\*STDIN);
    sub get_rec {
        my $fh = shift;
        return scalar &lt;$fh&gt;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
planning on generating new filehandles, you could do this.
Notice to pass back just the bare *FH, not its
reference.</p>

<pre style="margin-left:11%; margin-top: 1em">    sub openit {
        my $path = shift;
        local *FH;
        return open (FH, $path) ? *FH : undef;
    }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Prototypes</b>
<br>
Perl supports a very limited kind of compile-time argument
checking using function prototyping. If you declare</p>

<pre style="margin-left:11%; margin-top: 1em">    sub mypush (+@)</pre>


<p style="margin-left:11%; margin-top: 1em">then
<tt>&quot;mypush()&quot;</tt> takes arguments exactly like
<tt>&quot;push()&quot;</tt> does. The function declaration
must be visible at compile time. The prototype affects only
interpretation of new-style calls to the function, where
new-style is defined as not using the
<tt>&quot;&amp;&quot;</tt> character. In other words, if you
call it like a built-in function, then it behaves like a
built-in function. If you call it like an old-fashioned
subroutine, then it behaves like an old-fashioned
subroutine. It naturally falls out from this rule that
prototypes have no influence on subroutine references like
<tt>&quot;\&amp;foo&quot;</tt> or on indirect subroutine
calls like <tt>&quot;&amp;{$subref}&quot;</tt> or
<tt>&quot;$subref&minus;&gt;()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Method calls
are not influenced by prototypes either, because the
function to be called is indeterminate at compile time,
since the exact code called depends on inheritance.</p>

<p style="margin-left:11%; margin-top: 1em">Because the
intent of this feature is primarily to let you define
subroutines that work like built-in functions, here are
prototypes for some other functions that parse almost
exactly like the corresponding built-in.</p>

<pre style="margin-left:11%; margin-top: 1em">    Declared as                 Called as
    sub mylink ($$)          mylink $old, $new
    sub myvec ($$$)          myvec $var, $offset, 1
    sub myindex ($$;$)       myindex &amp;getstring, &quot;substr&quot;
    sub mysyswrite ($$$;$)   mysyswrite $buf, 0, length($buf) &minus; $off, $off
    sub myreverse (@)        myreverse $a, $b, $c
    sub myjoin ($@)          myjoin &quot;:&quot;, $a, $b, $c
    sub mypop (+)            mypop @array
    sub mysplice (+$$@)      mysplice @array, 0, 2, @pushme
    sub mykeys (+)           mykeys %{$hashref}
    sub myopen (*;$)         myopen HANDLE, $name
    sub mypipe (**)          mypipe READHANDLE, WRITEHANDLE
    sub mygrep (&amp;@)          mygrep { /foo/ } $a, $b, $c
    sub myrand (;$)          myrand 42
    sub mytime ()            mytime</pre>


<p style="margin-left:11%; margin-top: 1em">Any backslashed
prototype character represents an actual argument that must
start with that character (optionally preceded by
<tt>&quot;my&quot;</tt>, <tt>&quot;our&quot;</tt> or
<tt>&quot;local&quot;</tt>), with the exception of
<tt>&quot;$&quot;</tt>, which will accept any scalar lvalue
expression, such as <tt>&quot;$foo = 7&quot;</tt> or
<tt>&quot;my_function()&minus;&gt;[0]&quot;</tt>. The value
passed as part of <tt>@_</tt> will be a reference to the
actual argument given in the subroutine call, obtained by
applying <tt>&quot;\&quot;</tt> to that argument.</p>

<p style="margin-left:11%; margin-top: 1em">You can use the
<tt>&quot;\[]&quot;</tt> backslash group notation to specify
more than one allowed argument type. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub myref (\[$@%&amp;*])</pre>


<p style="margin-left:11%; margin-top: 1em">will allow
calling <i>myref()</i> as</p>

<pre style="margin-left:11%; margin-top: 1em">    myref $var
    myref @array
    myref %hash
    myref &amp;sub
    myref *glob</pre>


<p style="margin-left:11%; margin-top: 1em">and the first
argument of <i>myref()</i> will be a reference to a scalar,
an array, a hash, a code, or a glob.</p>

<p style="margin-left:11%; margin-top: 1em">Unbackslashed
prototype characters have special meanings. Any
unbackslashed <tt>&quot;@&quot;</tt> or
<tt>&quot;%&quot;</tt> eats all remaining arguments, and
forces list context. An argument represented by
<tt>&quot;$&quot;</tt> forces scalar context. An
<tt>&quot;&amp;&quot;</tt> requires an anonymous subroutine,
which, if passed as the first argument, does not require the
<tt>&quot;sub&quot;</tt> keyword or a subsequent comma.</p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>&quot;*&quot;</tt> allows the subroutine to accept a
bareword, constant, scalar expression, typeglob, or a
reference to a typeglob in that slot. The value will be
available to the subroutine either as a simple scalar, or
(in the latter two cases) as a reference to the typeglob. If
you wish to always convert such arguments to a typeglob
reference, use <i>Symbol::qualify_to_ref()</i> as
follows:</p>

<pre style="margin-left:11%; margin-top: 1em">    use Symbol 'qualify_to_ref';
    sub foo (*) {
        my $fh = qualify_to_ref(shift, caller);
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;+&quot;</tt> prototype is a special alternative to
<tt>&quot;$&quot;</tt> that will act like
<tt>&quot;\[@%]&quot;</tt> when given a literal array or
hash variable, but will otherwise force scalar context on
the argument. This is useful for functions which should
accept either a literal array or an array reference as the
argument:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub mypush (+@) {
        my $aref = shift;
        die &quot;Not an array or arrayref&quot; unless ref $aref eq 'ARRAY';
        push @$aref, @_;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">When using the
<tt>&quot;+&quot;</tt> prototype, your function must check
that the argument is of an acceptable type.</p>

<p style="margin-left:11%; margin-top: 1em">A semicolon
(<tt>&quot;;&quot;</tt>) separates mandatory arguments from
optional arguments. It is redundant before
<tt>&quot;@&quot;</tt> or <tt>&quot;%&quot;</tt>, which
gobble up everything else.</p>

<p style="margin-left:11%; margin-top: 1em">As the last
character of a prototype, or just before a semicolon, a
<tt>&quot;@&quot;</tt> or a <tt>&quot;%&quot;</tt>, you can
use <tt>&quot;_&quot;</tt> in place of
<tt>&quot;$&quot;</tt>: if this argument is not provided,
<tt>$_</tt> will be used instead.</p>

<p style="margin-left:11%; margin-top: 1em">Note how the
last three examples in the table above are treated specially
by the parser. <tt>&quot;mygrep()&quot;</tt> is parsed as a
true list operator, <tt>&quot;myrand()&quot;</tt> is parsed
as a true unary operator with unary precedence the same as
<tt>&quot;rand()&quot;</tt>, and
<tt>&quot;mytime()&quot;</tt> is truly without arguments,
just like <tt>&quot;time()&quot;</tt>. That is, if you
say</p>

<pre style="margin-left:11%; margin-top: 1em">    mytime +2;</pre>


<p style="margin-left:11%; margin-top: 1em">you&rsquo;ll
get <tt>&quot;mytime() + 2&quot;</tt>, not
<tt>mytime(2)</tt>, which is how it would be parsed without
a prototype. If you want to force a unary function to have
the same precedence as a list operator, add
<tt>&quot;;&quot;</tt> to the end of the prototype:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub mygetprotobynumber($;);
    mygetprotobynumber $a &gt; $b; # parsed as mygetprotobynumber($a &gt; $b)</pre>


<p style="margin-left:11%; margin-top: 1em">The interesting
thing about <tt>&quot;&amp;&quot;</tt> is that you can
generate new syntax with it, provided it&rsquo;s in the
initial position:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub try (&amp;@) {
        my($try,$catch) = @_;
        eval { &amp;$try };
        if ($@) {
            local $_ = $@;
            &amp;$catch;
        }
    }
    sub catch (&amp;) { $_[0] }
    try {
        die &quot;phooey&quot;;
    } catch {
        /phooey/ and print &quot;unphooey\n&quot;;
    };</pre>


<p style="margin-left:11%; margin-top: 1em">That prints
<tt>&quot;unphooey&quot;</tt>. (Yes, there are still
unresolved issues having to do with visibility of
<tt>@_</tt>. I&rsquo;m ignoring that question for the
moment. (But note that if we make <tt>@_</tt> lexically
scoped, those anonymous subroutines can act like closures...
(Gee, is this sounding a little Lispish? (Never
mind.))))</p>

<p style="margin-left:11%; margin-top: 1em">And
here&rsquo;s a reimplementation of the Perl
<tt>&quot;grep&quot;</tt> operator:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub mygrep (&amp;@) {
        my $code = shift;
        my @result;
        foreach $_ (@_) {
            push(@result, $_) if &amp;$code;
        }
        @result;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Some folks
would prefer full alphanumeric prototypes. Alphanumerics
have been intentionally left out of prototypes for the
express purpose of someday in the future adding named,
formal parameters. The current mechanism&rsquo;s main goal
is to let module writers provide better diagnostics for
module users. Larry feels the notation quite understandable
to Perl programmers, and that it will not intrude greatly
upon the meat of the module, nor make it harder to read. The
line noise is visually encapsulated into a small pill
that&rsquo;s easy to swallow.</p>

<p style="margin-left:11%; margin-top: 1em">If you try to
use an alphanumeric sequence in a prototype you will
generate an optional warning &minus; &quot;Illegal character
in prototype...&quot;. Unfortunately earlier versions of
Perl allowed the prototype to be used as long as its prefix
was a valid prototype. The warning may be upgraded to a
fatal error in a future version of Perl once the majority of
offending code is fixed.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
probably best to prototype new functions, not retrofit
prototyping into older ones. That&rsquo;s because you must
be especially careful about silent impositions of differing
list versus scalar contexts. For example, if you decide that
a function should take just one parameter, like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub func ($) {
        my $n = shift;
        print &quot;you gave me $n\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">and someone has
been calling it with an array or expression returning a
list:</p>

<pre style="margin-left:11%; margin-top: 1em">    func(@foo);
    func( split /:/ );</pre>


<p style="margin-left:11%; margin-top: 1em">Then
you&rsquo;ve just supplied an automatic
<tt>&quot;scalar&quot;</tt> in front of their argument,
which can be more than a bit surprising. The old
<tt>@foo</tt> which used to hold one thing doesn&rsquo;t get
passed in. Instead, <tt>&quot;func()&quot;</tt> now gets
passed in a <tt>1</tt>; that is, the number of elements in
<tt>@foo</tt>. And the <tt>&quot;split&quot;</tt> gets
called in scalar context so it starts scribbling on your
<tt>@_</tt> parameter list. Ouch!</p>

<p style="margin-left:11%; margin-top: 1em">This is all
very powerful, of course, and should be used only in
moderation to make the world a better place.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constant
Functions</b> <br>
Functions with a prototype of <tt>&quot;()&quot;</tt> are
potential candidates for inlining. If the result after
optimization and constant folding is either a constant or a
lexically-scoped scalar which has no other references, then
it will be used in place of function calls made without
<tt>&quot;&amp;&quot;</tt>. Calls made using
<tt>&quot;&amp;&quot;</tt> are never inlined. (See
<i>constant.pm</i> for an easy way to declare most
constants.)</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions would all be inlined:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub pi ()           { 3.14159 }             # Not exact, but close.
    sub PI ()           { 4 * atan2 1, 1 }      # As good as it gets,
                                                # and it's inlined, too!
    sub ST_DEV ()       { 0 }
    sub ST_INO ()       { 1 }
    sub FLAG_FOO ()     { 1 &lt;&lt; 8 }
    sub FLAG_BAR ()     { 1 &lt;&lt; 9 }
    sub FLAG_MASK ()    { FLAG_FOO | FLAG_BAR }
    sub OPT_BAZ ()      { not (0x1B58 &amp; FLAG_MASK) }
    sub N () { int(OPT_BAZ) / 3 }
    sub FOO_SET () { 1 if FLAG_MASK &amp; FLAG_FOO }</pre>


<p style="margin-left:11%; margin-top: 1em">Be aware that
these will not be inlined; as they contain inner scopes, the
constant folding doesn&rsquo;t reduce them to a single
constant:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub foo_set () { if (FLAG_MASK &amp; FLAG_FOO) { 1 } }
    sub baz_val () {
        if (OPT_BAZ) {
            return 23;
        }
        else {
            return 42;
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If you redefine
a subroutine that was eligible for inlining, you&rsquo;ll
get a warning by default. (You can use this warning to tell
whether or not a particular subroutine is considered
constant.) The warning is considered severe enough not to be
affected by the <b>&minus;w</b> switch (or its absence)
because previously compiled invocations of the function will
still be using the old value of the function. If you need to
be able to redefine the subroutine, you need to ensure that
it isn&rsquo;t inlined, either by dropping the
<tt>&quot;()&quot;</tt> prototype (which changes calling
semantics, so beware) or by thwarting the inlining mechanism
in some other way, such as</p>

<pre style="margin-left:11%; margin-top: 1em">    sub not_inlined () {
        23 if $];
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Overriding
Built-in Functions</b> <br>
Many built-in functions may be overridden, though this
should be tried only occasionally and for good reason.
Typically this might be done by a package attempting to
emulate missing built-in functionality on a non-Unix
system.</p>

<p style="margin-left:11%; margin-top: 1em">Overriding may
be done only by importing the name from a module at compile
time--ordinary predeclaration isn&rsquo;t good enough.
However, the <tt>&quot;use subs&quot;</tt> pragma lets you,
in effect, predeclare subs via the import syntax, and these
names may then override built-in ones:</p>

<pre style="margin-left:11%; margin-top: 1em">    use subs 'chdir', 'chroot', 'chmod', 'chown';
    chdir $somewhere;
    sub chdir { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">To
unambiguously refer to the built-in form, precede the
built-in name with the special package qualifier
<tt>&quot;CORE::&quot;</tt>. For example, saying
<tt>&quot;CORE::open()&quot;</tt> always refers to the
built-in <tt>&quot;open()&quot;</tt>, even if the current
package has imported some other subroutine called
<tt>&quot;&amp;open()&quot;</tt> from elsewhere. Even though
it looks like a regular function call, it isn&rsquo;t: the
<small>CORE::</small> prefix in that case is part of
Perl&rsquo;s syntax, and works for any keyword, regardless
of what is in the <small>CORE</small> package. Taking a
reference to it, that is,
<tt>&quot;\&amp;CORE::open&quot;</tt>, only works for some
keywords. See <small>CORE</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Library modules
should not in general export built-in names like
<tt>&quot;open&quot;</tt> or <tt>&quot;chdir&quot;</tt> as
part of their default <tt>@EXPORT</tt> list, because these
may sneak into someone else&rsquo;s namespace and change the
semantics unexpectedly. Instead, if the module adds that
name to <tt>@EXPORT_OK</tt>, then it&rsquo;s possible for a
user to import the name explicitly, but not implicitly. That
is, they could say</p>

<pre style="margin-left:11%; margin-top: 1em">    use Module 'open';</pre>


<p style="margin-left:11%; margin-top: 1em">and it would
import the <tt>&quot;open&quot;</tt> override. But if they
said</p>

<pre style="margin-left:11%; margin-top: 1em">    use Module;</pre>


<p style="margin-left:11%; margin-top: 1em">they would get
the default imports without overrides.</p>

<p style="margin-left:11%; margin-top: 1em">The foregoing
mechanism for overriding built-in is restricted, quite
deliberately, to the package that requests the import. There
is a second method that is sometimes applicable when you
wish to override a built-in everywhere, without regard to
namespace boundaries. This is achieved by importing a sub
into the special namespace
<tt>&quot;CORE::GLOBAL::&quot;</tt>. Here is an example that
quite brazenly replaces the <tt>&quot;glob&quot;</tt>
operator with something that understands regular
expressions.</p>

<pre style="margin-left:11%; margin-top: 1em">    package REGlob;
    require Exporter;
    @ISA = 'Exporter';
    @EXPORT_OK = 'glob';
    sub import {
        my $pkg = shift;
        return unless @_;
        my $sym = shift;
        my $where = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
        $pkg&minus;&gt;export($where, $sym, @_);
    }
    sub glob {
        my $pat = shift;
        my @got;
        if (opendir my $d, '.') {
            @got = grep /$pat/, readdir $d;
            closedir $d;
        }
        return @got;
    }
    1;</pre>


<p style="margin-left:11%; margin-top: 1em">And
here&rsquo;s how it could be (ab)used:</p>

<pre style="margin-left:11%; margin-top: 1em">    #use REGlob 'GLOBAL_glob';      # override glob() in ALL namespaces
    package Foo;
    use REGlob 'glob';              # override glob() in Foo:: only
    print for &lt;^[a&minus;z_]+\.pm\$&gt;;     # show all pragmatic modules</pre>


<p style="margin-left:11%; margin-top: 1em">The initial
comment shows a contrived, even dangerous example. By
overriding <tt>&quot;glob&quot;</tt> globally, you would be
forcing the new (and subversive) behavior for the
<tt>&quot;glob&quot;</tt> operator for <i>every</i>
namespace, without the complete cognizance or cooperation of
the modules that own those namespaces. Naturally, this
should be done with extreme caution--if it must be done at
all.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;REGlob&quot;</tt> example above does not implement
all the support needed to cleanly override perl&rsquo;s
<tt>&quot;glob&quot;</tt> operator. The built-in
<tt>&quot;glob&quot;</tt> has different behaviors depending
on whether it appears in a scalar or list context, but our
<tt>&quot;REGlob&quot;</tt> doesn&rsquo;t. Indeed, many perl
built-in have such context sensitive behaviors, and these
must be adequately supported by a properly written override.
For a fully functional example of overriding
<tt>&quot;glob&quot;</tt>, study the implementation of
<tt>&quot;File::DosGlob&quot;</tt> in the standard
library.</p>

<p style="margin-left:11%; margin-top: 1em">When you
override a built-in, your replacement should be consistent
(if possible) with the built-in native syntax. You can
achieve this by using a suitable prototype. To get the
prototype of an overridable built-in, use the
<tt>&quot;prototype&quot;</tt> function with an argument of
<tt>&quot;CORE::builtin_name&quot;</tt> (see
&quot;prototype&quot; in perlfunc).</p>

<p style="margin-left:11%; margin-top: 1em">Note however
that some built-ins can&rsquo;t have their syntax expressed
by a prototype (such as <tt>&quot;system&quot;</tt> or
<tt>&quot;chomp&quot;</tt>). If you override them you
won&rsquo;t be able to fully mimic their original
syntax.</p>

<p style="margin-left:11%; margin-top: 1em">The built-ins
<tt>&quot;do&quot;</tt>, <tt>&quot;require&quot;</tt> and
<tt>&quot;glob&quot;</tt> can also be overridden, but due to
special magic, their original syntax is preserved, and you
don&rsquo;t have to define a prototype for their
replacements. (You can&rsquo;t override the <tt>&quot;do
BLOCK&quot;</tt> syntax, though).</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;require&quot;</tt>
has special additional dark magic: if you invoke your
<tt>&quot;require&quot;</tt> replacement as
<tt>&quot;require Foo::Bar&quot;</tt>, it will actually
receive the argument <tt>&quot;Foo/Bar.pm&quot;</tt> in
<tt>@_</tt>. See &quot;require&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">And, as
you&rsquo;ll have noticed from the previous example, if you
override <tt>&quot;glob&quot;</tt>, the
<tt>&quot;&lt;*&gt;&quot;</tt> glob operator is overridden
as well.</p>

<p style="margin-left:11%; margin-top: 1em">In a similar
fashion, overriding the <tt>&quot;readline&quot;</tt>
function also overrides the equivalent I/O operator
<tt>&quot;&lt;FILEHANDLE&gt;&quot;</tt>. Also, overriding
<tt>&quot;readpipe&quot;</tt> also overrides the operators
<tt>&quot;``&quot;</tt> and <tt>&quot;qx//&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, some
built-ins (e.g. <tt>&quot;exists&quot;</tt> or
<tt>&quot;grep&quot;</tt>) can&rsquo;t be overridden.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Autoloading</b>
<br>
If you call a subroutine that is undefined, you would
ordinarily get an immediate, fatal error complaining that
the subroutine doesn&rsquo;t exist. (Likewise for
subroutines being used as methods, when the method
doesn&rsquo;t exist in any base class of the class&rsquo;s
package.) However, if an <tt>&quot;AUTOLOAD&quot;</tt>
subroutine is defined in the package or packages used to
locate the original subroutine, then that
<tt>&quot;AUTOLOAD&quot;</tt> subroutine is called with the
arguments that would have been passed to the original
subroutine. The fully qualified name of the original
subroutine magically appears in the global
<tt>$AUTOLOAD</tt> variable of the same package as the
<tt>&quot;AUTOLOAD&quot;</tt> routine. The name is not
passed as an ordinary argument because, er, well, just
because, that&rsquo;s why. (As an exception, a method call
to a nonexistent <tt>&quot;import&quot;</tt> or
<tt>&quot;unimport&quot;</tt> method is just skipped
instead. Also, if the <small>AUTOLOAD</small> subroutine is
an <small>XSUB</small> , there are other ways to retrieve
the subroutine name. See &quot;Autoloading with XSUBs&quot;
in perlguts for details.)</p>

<p style="margin-left:11%; margin-top: 1em">Many
<tt>&quot;AUTOLOAD&quot;</tt> routines load in a definition
for the requested subroutine using <i>eval()</i>, then
execute that subroutine using a special form of
<i>goto()</i> that erases the stack frame of the
<tt>&quot;AUTOLOAD&quot;</tt> routine without a trace. (See
the source to the standard module documented in AutoLoader,
for example.) But an <tt>&quot;AUTOLOAD&quot;</tt> routine
can also just emulate the routine and never define it. For
example, let&rsquo;s pretend that a function that
wasn&rsquo;t defined should just invoke
<tt>&quot;system&quot;</tt> with those arguments. All
you&rsquo;d do is:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub AUTOLOAD {
        my $program = $AUTOLOAD;
        $program =~ s/.*:://;
        system($program, @_);
    }
    date();
    who('am', 'i');
    ls('&minus;l');</pre>


<p style="margin-left:11%; margin-top: 1em">In fact, if you
predeclare functions you want to call that way, you
don&rsquo;t even need parentheses:</p>

<pre style="margin-left:11%; margin-top: 1em">    use subs qw(date who ls);
    date;
    who &quot;am&quot;, &quot;i&quot;;
    ls '&minus;l';</pre>


<p style="margin-left:11%; margin-top: 1em">A more complete
example of this is the Shell module on <small>CPAN</small> ,
which can treat undefined subroutine calls as calls to
external programs.</p>

<p style="margin-left:11%; margin-top: 1em">Mechanisms are
available to help modules writers split their modules into
autoloadable files. See the standard AutoLoader module
described in AutoLoader and in AutoSplit, the standard
SelfLoader modules in SelfLoader, and the document on adding
C functions to Perl code in perlxs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Subroutine
Attributes</b> <br>
A subroutine declaration or definition may have a list of
attributes associated with it. If such an attribute list is
present, it is broken up at space or colon boundaries and
treated as though a <tt>&quot;use attributes&quot;</tt> had
been seen. See attributes for details about what attributes
are currently supported. Unlike the limitation with the
obsolescent <tt>&quot;use attrs&quot;</tt>, the
<tt>&quot;sub : ATTRLIST&quot;</tt> syntax works to
associate the attributes with a pre-declaration, and not
just with a subroutine definition.</p>

<p style="margin-left:11%; margin-top: 1em">The attributes
must be valid as simple identifier names (without any
punctuation other than the &rsquo;_&rsquo; character). They
may have a parameter list appended, which is only checked
for whether its parentheses
(&rsquo;(&rsquo;,&rsquo;)&rsquo;) nest properly.</p>

<p style="margin-left:11%; margin-top: 1em">Examples of
valid syntax (even though the attributes are unknown):</p>

<pre style="margin-left:11%; margin-top: 1em">    sub fnord (&amp;\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly('\(&quot;) :Bad;
    sub xyzzy : _5x5 { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Examples of
invalid syntax:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub fnord : switch(10,foo(); # ()&minus;string not balanced
    sub snoid : Ugly('(');        # ()&minus;string not balanced
    sub xyzzy : 5x5;              # &quot;5x5&quot; not a valid identifier
    sub plugh : Y2::north;        # &quot;Y2::north&quot; not a simple identifier
    sub snurt : foo + bar;        # &quot;+&quot; not a colon or space</pre>


<p style="margin-left:11%; margin-top: 1em">The attribute
list is passed as a list of constant strings to the code
which associates them with the subroutine. In particular,
the second example of valid syntax above currently looks
like this in terms of how it&rsquo;s parsed and invoked:</p>

<pre style="margin-left:11%; margin-top: 1em">    use attributes __PACKAGE__, \&amp;plugh, q[Ugly('\(&quot;)], 'Bad';</pre>


<p style="margin-left:11%; margin-top: 1em">For further
details on attribute lists and their manipulation, see
attributes and Attribute::Handlers.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
&quot;Function Templates&quot; in perlref for more about
references and closures. See perlxs if you&rsquo;d like to
learn about calling C subroutines from Perl. See perlembed
if you&rsquo;d like to learn about calling Perl subroutines
from C. See perlmod to learn about bundling up your
functions in separate files. See perlmodlib to learn what
library modules come standard on your system. See perlootut
to learn how to make object method calls.</p>
<hr>
</body>
</html>
