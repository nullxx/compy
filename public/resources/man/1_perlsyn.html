<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLSYN</title>

</head>
<body>

<h1 align="center">PERLSYN</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlsyn &minus;
Perl syntax</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A Perl program
consists of a sequence of declarations and statements which
run from the top to the bottom. Loops, subroutines, and
other control structures allow you to jump around within the
code.</p>

<p style="margin-left:11%; margin-top: 1em">Perl is a
<b>free-form</b> language: you can format and indent it
however you like. Whitespace serves mostly to separate
tokens, unlike languages like Python where it is an
important part of the syntax, or Fortran where it is
immaterial.</p>

<p style="margin-left:11%; margin-top: 1em">Many of
Perl&rsquo;s syntactic elements are <b>optional</b>. Rather
than requiring you to put parentheses around every function
call and declare every variable, you can often leave such
explicit elements off and Perl will figure out what you
meant. This is known as <b>Do What I Mean</b>, abbreviated
<b><small>DWIM</small></b> . It allows programmers to be
<b>lazy</b> and to code in a style with which they are
comfortable.</p>

<p style="margin-left:11%; margin-top: 1em">Perl <b>borrows
syntax</b> and concepts from many languages: awk, sed, C,
Bourne Shell, Smalltalk, Lisp and even English. Other
languages have borrowed syntax from Perl, particularly its
regular expression extensions. So if you have programmed in
another language you will see familiar pieces in Perl. They
often work the same, but see perltrap for information about
how they differ.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Declarations</b>
<br>
The only things you need to declare in Perl are report
formats and subroutines (and sometimes not even
subroutines). A scalar variable holds the undefined value
(<tt>&quot;undef&quot;</tt>) until it has been assigned a
defined value, which is anything other than
<tt>&quot;undef&quot;</tt>. When used as a number,
<tt>&quot;undef&quot;</tt> is treated as <tt>0</tt>; when
used as a string, it is treated as the empty string,
<tt>&quot;&quot;</tt>; and when used as a reference that
isn&rsquo;t being assigned to, it is treated as an error. If
you enable warnings, you&rsquo;ll be notified of an
uninitialized value whenever you treat
<tt>&quot;undef&quot;</tt> as a string or a number. Well,
usually. Boolean contexts, such as:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($a) {}</pre>


<p style="margin-left:11%; margin-top: 1em">are exempt from
warnings (because they care about truth rather than
definedness). Operators such as <tt>&quot;++&quot;</tt>,
<tt>&quot;&minus;&minus;&quot;</tt>,
<tt>&quot;+=&quot;</tt>, <tt>&quot;&minus;=&quot;</tt>, and
<tt>&quot;.=&quot;</tt>, that operate on undefined variables
such as:</p>

<pre style="margin-left:11%; margin-top: 1em">    undef $a;
    $a++;</pre>


<p style="margin-left:11%; margin-top: 1em">are also always
exempt from such warnings.</p>

<p style="margin-left:11%; margin-top: 1em">A declaration
can be put anywhere a statement can, but has no effect on
the execution of the primary sequence of statements:
declarations all take effect at compile time. All
declarations are typically put at the beginning or the end
of the script. However, if you&rsquo;re using
lexically-scoped private variables created with
<tt>&quot;my()&quot;</tt>, <tt>&quot;state()&quot;</tt>, or
<tt>&quot;our()&quot;</tt>, you&rsquo;ll have to make sure
your format or subroutine definition is within the same
block scope as the my if you expect to be able to access
those private variables.</p>

<p style="margin-left:11%; margin-top: 1em">Declaring a
subroutine allows a subroutine name to be used as if it were
a list operator from that point forward in the program. You
can declare a subroutine without defining it by saying
<tt>&quot;sub name&quot;</tt>, thus:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub myname;
    $me = myname $0             or die &quot;can't get myname&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">A bare
declaration like that declares the function to be a list
operator, not a unary operator, so you have to be careful to
use parentheses (or <tt>&quot;or&quot;</tt> instead of
<tt>&quot;||&quot;</tt>.) The <tt>&quot;||&quot;</tt>
operator binds too tightly to use after list operators; it
becomes part of the last element. You can always use
parentheses around the list operators arguments to turn the
list operator back into something that behaves more like a
function call. Alternatively, you can use the prototype
<tt>&quot;($)&quot;</tt> to turn the subroutine into a unary
operator:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub myname ($);
  $me = myname $0             || die &quot;can't get myname&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">That now parses
as you&rsquo;d expect, but you still ought to get in the
habit of using parentheses in that situation. For more on
prototypes, see perlsub</p>

<p style="margin-left:11%; margin-top: 1em">Subroutines
declarations can also be loaded up with the
<tt>&quot;require&quot;</tt> statement or both loaded and
imported into your namespace with a <tt>&quot;use&quot;</tt>
statement. See perlmod for details on this.</p>

<p style="margin-left:11%; margin-top: 1em">A statement
sequence may contain declarations of lexically-scoped
variables, but apart from declaring a variable name, the
declaration acts like an ordinary statement, and is
elaborated within the sequence of statements as if it were
an ordinary statement. That means it actually has both
compile-time and run-time effects.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Comments</b>
<br>
Text from a <tt>&quot;#&quot;</tt> character until the end
of the line is a comment, and is ignored. Exceptions include
<tt>&quot;#&quot;</tt> inside a string or regular
expression.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Simple
Statements</b> <br>
The only kind of simple statement is an expression evaluated
for its side-effects. Every simple statement must be
terminated with a semicolon, unless it is the final
statement in a block, in which case the semicolon is
optional. But put the semicolon in anyway if the block takes
up more than one line, because you may eventually add
another line. Note that there are operators like
<tt>&quot;eval {}&quot;</tt>, <tt>&quot;sub {}&quot;</tt>,
and <tt>&quot;do {}&quot;</tt> that <i>look</i> like
compound statements, but aren&rsquo;t--they&rsquo;re just
TERMs in an expression--and thus need an explicit
termination when used as the last item in a statement.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Truth and
Falsehood</b> <br>
The number 0, the strings <tt>'0'</tt> and
<tt>&quot;&quot;</tt>, the empty list
<tt>&quot;()&quot;</tt>, and <tt>&quot;undef&quot;</tt> are
all false in a boolean context. All other values are true.
Negation of a true value by <tt>&quot;!&quot;</tt> or
<tt>&quot;not&quot;</tt> returns a special false value. When
evaluated as a string it is treated as
<tt>&quot;&quot;</tt>, but as a number, it is treated as 0.
Most Perl operators that return true or false behave this
way.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Statement
Modifiers</b> <br>
Any simple statement may optionally be followed by a
<i><small>SINGLE</small></i> modifier, just before the
terminating semicolon (or block ending). The possible
modifiers are:</p>

<pre style="margin-left:11%; margin-top: 1em">    if EXPR
    unless EXPR
    while EXPR
    until EXPR
    for LIST
    foreach LIST
    when EXPR</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;EXPR&quot;</tt> following the modifier is referred
to as the &quot;condition&quot;. Its truth or falsehood
determines how the modifier will behave.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;if&quot;</tt>
executes the statement once <i>if</i> and only if the
condition is true. <tt>&quot;unless&quot;</tt> is the
opposite, it executes the statement <i>unless</i> the
condition is true (that is, if the condition is false).</p>

<pre style="margin-left:11%; margin-top: 1em">    print &quot;Basset hounds got long ears&quot; if length $ear &gt;= 10;
    go_outside() and play() unless $is_raining;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;for(each)&quot;</tt> modifier is an iterator: it
executes the statement once for each item in the
<small>LIST</small> (with <tt>$_</tt> aliased to each item
in turn).</p>

<pre style="margin-left:11%; margin-top: 1em">    print &quot;Hello $_!\n&quot; for qw(world Dolly nurse);</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;while&quot;
repeats the statement <i>while</i> the condition is true.
<tt>&quot;until&quot;</tt> does the opposite, it repeats the
statement <i>until</i> the condition is true (or while the
condition is false):</p>

<pre style="margin-left:11%; margin-top: 1em">    # Both of these count from 0 to 10.
    print $i++ while $i &lt;= 10;
    print $j++ until $j &gt;  10;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;while&quot;</tt> and <tt>&quot;until&quot;</tt>
modifiers have the usual &quot;<tt>&quot;while&quot;</tt>
loop&quot; semantics (conditional evaluated first), except
when applied to a <tt>&quot;do&quot;</tt>&minus;BLOCK (or to
the Perl4 <tt>&quot;do&quot;</tt>&minus;SUBROUTINE
statement), in which case the block executes once before the
conditional is evaluated.</p>

<p style="margin-left:11%; margin-top: 1em">This is so that
you can write loops like:</p>

<pre style="margin-left:11%; margin-top: 1em">    do {
        $line = &lt;STDIN&gt;;
        ...
    } until !defined($line) || $line eq &quot;.\n&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">See
&quot;do&quot; in perlfunc. Note also that the loop control
statements described later will <i><small>NOT</small></i>
work in this construct, because modifiers don&rsquo;t take
loop labels. Sorry. You can always put another block inside
of it (for <tt>&quot;next&quot;</tt>) or around it (for
<tt>&quot;last&quot;</tt>) to do that sort of thing. For
<tt>&quot;next&quot;</tt>, just double the braces:</p>

<pre style="margin-left:11%; margin-top: 1em">    do {{
        next if $x == $y;
        # do something here
    }} until $x++ &gt; $z;</pre>


<p style="margin-left:11%; margin-top: 1em">For
<tt>&quot;last&quot;</tt>, you have to be more
elaborate:</p>

<pre style="margin-left:11%; margin-top: 1em">    LOOP: {
            do {
                last if $x = $y**2;
                # do something here
            } while $x++ &lt;= $z;
    }</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
The behaviour of a <tt>&quot;my&quot;</tt>,
<tt>&quot;state&quot;</tt>, or <tt>&quot;our&quot;</tt>
modified with a statement modifier conditional or loop
construct (for example, <tt>&quot;my $x if ...&quot;</tt>)
is <b>undefined</b>. The value of the
<tt>&quot;my&quot;</tt> variable may be
<tt>&quot;undef&quot;</tt>, any previously assigned value,
or possibly anything else. Don&rsquo;t rely on it. Future
versions of perl might do something different from the
version of perl you try it out on. Here be dragons.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;when&quot;</tt> modifier is an experimental
feature that first appeared in Perl 5.14. To use it, you
should include a <tt>&quot;use v5.14&quot;</tt> declaration.
(Technically, it requires only the
<tt>&quot;switch&quot;</tt> feature, but that aspect of it
was not available before 5.14.) Operative only from within a
<tt>&quot;foreach&quot;</tt> loop or a
<tt>&quot;given&quot;</tt> block, it executes the statement
only if the smartmatch <tt>&quot;$_ ~~</tt>
<i>EXPR</i><tt>&quot;</tt> is true. If the statement
executes, it is followed by a <tt>&quot;next&quot;</tt> from
inside a <tt>&quot;foreach&quot;</tt> and
<tt>&quot;break&quot;</tt> from inside a
<tt>&quot;given&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Under the
current implementation, the <tt>&quot;foreach&quot;</tt>
loop can be anywhere within the <tt>&quot;when&quot;</tt>
modifier&rsquo;s dynamic scope, but must be within the
<tt>&quot;given&quot;</tt> block&rsquo;s lexical scope. This
restricted may be relaxed in a future release. See
&quot;Switch Statements&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compound
Statements</b> <br>
In Perl, a sequence of statements that defines a scope is
called a block. Sometimes a block is delimited by the file
containing it (in the case of a required file, or the
program as a whole), and sometimes a block is delimited by
the extent of a string (in the case of an eval).</p>

<p style="margin-left:11%; margin-top: 1em">But generally,
a block is delimited by curly brackets, also known as
braces. We will call this syntactic construct a
<small>BLOCK</small> .</p>

<p style="margin-left:11%; margin-top: 1em">The following
compound statements may be used to control flow:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (EXPR) BLOCK
    if (EXPR) BLOCK else BLOCK
    if (EXPR) BLOCK elsif (EXPR) BLOCK ...
    if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
    unless (EXPR) BLOCK
    unless (EXPR) BLOCK else BLOCK
    unless (EXPR) BLOCK elsif (EXPR) BLOCK ...
    unless (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
    given (EXPR) BLOCK
    LABEL while (EXPR) BLOCK
    LABEL while (EXPR) BLOCK continue BLOCK
    LABEL until (EXPR) BLOCK
    LABEL until (EXPR) BLOCK continue BLOCK
    LABEL for (EXPR; EXPR; EXPR) BLOCK
    LABEL for VAR (LIST) BLOCK
    LABEL for VAR (LIST) BLOCK continue BLOCK
    LABEL foreach (EXPR; EXPR; EXPR) BLOCK
    LABEL foreach VAR (LIST) BLOCK
    LABEL foreach VAR (LIST) BLOCK continue BLOCK
    LABEL BLOCK
    LABEL BLOCK continue BLOCK
    PHASE BLOCK</pre>


<p style="margin-left:11%; margin-top: 1em">The
experimental <tt>&quot;given&quot;</tt> statement is <i>not
automatically enabled</i>; see &quot;Switch Statements&quot;
below for how to do so, and the attendant caveats.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike in C and
Pascal, in Perl these are all defined in terms of BLOCKs,
not statements. This means that the curly brackets are
<i>required</i>&minus;&minus;no dangling statements allowed.
If you want to write conditionals without curly brackets,
there are several other ways to do it. The following all do
the same thing:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (!open(FOO)) { die &quot;Can't open $FOO: $!&quot; }
    die &quot;Can't open $FOO: $!&quot; unless open(FOO);
    open(FOO)  || die &quot;Can't open $FOO: $!&quot;;
    open(FOO) ? () : die &quot;Can't open $FOO: $!&quot;;
                        # a bit exotic, that last one</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;if&quot;</tt> statement is straightforward.
Because BLOCKs are always bounded by curly brackets, there
is never any ambiguity about which <tt>&quot;if&quot;</tt>
an <tt>&quot;else&quot;</tt> goes with. If you use
<tt>&quot;unless&quot;</tt> in place of
<tt>&quot;if&quot;</tt>, the sense of the test is reversed.
Like <tt>&quot;if&quot;</tt>, <tt>&quot;unless&quot;</tt>
can be followed by <tt>&quot;else&quot;</tt>.
<tt>&quot;unless&quot;</tt> can even be followed by one or
more <tt>&quot;elsif&quot;</tt> statements, though you may
want to think twice before using that particular language
construct, as everyone reading your code will have to think
at least twice before they can understand what&rsquo;s going
on.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;while&quot;</tt> statement executes the block as
long as the expression is true. The
<tt>&quot;until&quot;</tt> statement executes the block as
long as the expression is false. The <small>LABEL</small> is
optional, and if present, consists of an identifier followed
by a colon. The <small>LABEL</small> identifies the loop for
the loop control statements <tt>&quot;next&quot;</tt>,
<tt>&quot;last&quot;</tt>, and <tt>&quot;redo&quot;</tt>. If
the <small>LABEL</small> is omitted, the loop control
statement refers to the innermost enclosing loop. This may
include dynamically looking back your call-stack at run time
to find the <small>LABEL</small> . Such desperate behavior
triggers a warning if you use the <tt>&quot;use
warnings&quot;</tt> pragma or the <b>&minus;w</b> flag.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
<tt>&quot;continue&quot;</tt> <small>BLOCK</small> , it is
always executed just before the conditional is about to be
evaluated again. Thus it can be used to increment a loop
variable, even when the loop has been continued via the
<tt>&quot;next&quot;</tt> statement.</p>

<p style="margin-left:11%; margin-top: 1em">When a block is
preceding by a compilation phase keyword such as
<tt>&quot;BEGIN&quot;</tt>, <tt>&quot;END&quot;</tt>,
<tt>&quot;INIT&quot;</tt>, <tt>&quot;CHECK&quot;</tt>, or
<tt>&quot;UNITCHECK&quot;</tt>, then the block will run only
during the corresponding phase of execution. See perlmod for
more details.</p>

<p style="margin-left:11%; margin-top: 1em">Extension
modules can also hook into the Perl parser to define new
kinds of compound statements. These are introduced by a
keyword which the extension recognizes, and the syntax
following the keyword is defined entirely by the extension.
If you are an implementor, see &quot;PL_keyword_plugin&quot;
in perlapi for the mechanism. If you are using such a
module, see the module&rsquo;s documentation for details of
the syntax that it defines.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Loop
Control</b> <br>
The <tt>&quot;next&quot;</tt> command starts the next
iteration of the loop:</p>

<pre style="margin-left:11%; margin-top: 1em">    LINE: while (&lt;STDIN&gt;) {
        next LINE if /^#/;      # discard comments
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;last&quot;</tt> command immediately exits the loop
in question. The <tt>&quot;continue&quot;</tt> block, if
any, is not executed:</p>

<pre style="margin-left:11%; margin-top: 1em">    LINE: while (&lt;STDIN&gt;) {
        last LINE if /^$/;      # exit when done with header
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;redo&quot;</tt> command restarts the loop block
without evaluating the conditional again. The
<tt>&quot;continue&quot;</tt> block, if any, is <i>not</i>
executed. This command is normally used by programs that
want to lie to themselves about what was just input.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
when processing a file like <i>/etc/termcap</i>. If your
input lines might end in backslashes to indicate
continuation, you want to skip ahead and get the next
record.</p>

<pre style="margin-left:11%; margin-top: 1em">    while (&lt;&gt;) {
        chomp;
        if (s/\\$//) {
            $_ .= &lt;&gt;;
            redo unless eof();
        }
        # now process $_
    }</pre>


<p style="margin-left:11%; margin-top: 1em">which is Perl
shorthand for the more explicitly written version:</p>

<pre style="margin-left:11%; margin-top: 1em">    LINE: while (defined($line = &lt;ARGV&gt;)) {
        chomp($line);
        if ($line =~ s/\\$//) {
            $line .= &lt;ARGV&gt;;
            redo LINE unless eof(); # not eof(ARGV)!
        }
        # now process $line
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that if
there were a <tt>&quot;continue&quot;</tt> block on the
above code, it would get executed only on lines discarded by
the regex (since redo skips the continue block). A continue
block is often used to reset line counters or
<tt>&quot;m?pat?&quot;</tt> one-time matches:</p>

<pre style="margin-left:11%; margin-top: 1em">    # inspired by :1,$g/fred/s//WILMA/
    while (&lt;&gt;) {
        m?(fred)?    &amp;&amp; s//WILMA $1 WILMA/;
        m?(barney)?  &amp;&amp; s//BETTY $1 BETTY/;
        m?(homer)?   &amp;&amp; s//MARGE $1 MARGE/;
    } continue {
        print &quot;$ARGV $.: $_&quot;;
        close ARGV  if eof;             # reset $.
        reset       if eof;             # reset ?pat?
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If the word
<tt>&quot;while&quot;</tt> is replaced by the word
<tt>&quot;until&quot;</tt>, the sense of the test is
reversed, but the conditional is still tested before the
first iteration.</p>

<p style="margin-left:11%; margin-top: 1em">Loop control
statements don&rsquo;t work in an <tt>&quot;if&quot;</tt> or
<tt>&quot;unless&quot;</tt>, since they aren&rsquo;t loops.
You can double the braces to make them such, though.</p>

<pre style="margin-left:11%; margin-top: 1em">    if (/pattern/) {{
        last if /fred/;
        next if /barney/; # same effect as &quot;last&quot;,
                          # but doesn't document as well
        # do something here
    }}</pre>


<p style="margin-left:11%; margin-top: 1em">This is caused
by the fact that a block by itself acts as a loop that
executes once, see &quot;Basic BLOCKs&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The form
<tt>&quot;while/if BLOCK BLOCK&quot;</tt>, available in Perl
4, is no longer available. Replace any occurrence of
<tt>&quot;if BLOCK&quot;</tt> by <tt>&quot;if (do
BLOCK)&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>For
Loops</b> <br>
Perl&rsquo;s C&minus;style <tt>&quot;for&quot;</tt> loop
works like the corresponding <tt>&quot;while&quot;</tt>
loop; that means that this:</p>

<pre style="margin-left:11%; margin-top: 1em">    for ($i = 1; $i &lt; 10; $i++) {
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">is the same as
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $i = 1;
    while ($i &lt; 10) {
        ...
    } continue {
        $i++;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">There is one
minor difference: if variables are declared with
<tt>&quot;my&quot;</tt> in the initialization section of the
<tt>&quot;for&quot;</tt>, the lexical scope of those
variables is exactly the <tt>&quot;for&quot;</tt> loop (the
body of the loop and the control sections).</p>

<p style="margin-left:11%; margin-top: 1em">Besides the
normal array index looping, <tt>&quot;for&quot;</tt> can
lend itself to many other interesting applications.
Here&rsquo;s one that avoids the problem you get into if you
explicitly test for end-of-file on an interactive file
descriptor causing your program to appear to hang.</p>

<pre style="margin-left:11%; margin-top: 1em">    $on_a_tty = &minus;t STDIN &amp;&amp; &minus;t STDOUT;
    sub prompt { print &quot;yes? &quot; if $on_a_tty }
    for ( prompt(); &lt;STDIN&gt;; prompt() ) {
        # do something
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Using
<tt>&quot;readline&quot;</tt> (or the operator form,
<tt>&quot;&lt;EXPR&gt;&quot;</tt>) as the conditional of a
<tt>&quot;for&quot;</tt> loop is shorthand for the
following. This behaviour is the same as a
<tt>&quot;while&quot;</tt> loop conditional.</p>

<pre style="margin-left:11%; margin-top: 1em">    for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt() ) {
        # do something
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Foreach
Loops</b> <br>
The <tt>&quot;foreach&quot;</tt> loop iterates over a normal
list value and sets the variable <small>VAR</small> to be
each element of the list in turn. If the variable is
preceded with the keyword <tt>&quot;my&quot;</tt>, then it
is lexically scoped, and is therefore visible only within
the loop. Otherwise, the variable is implicitly local to the
loop and regains its former value upon exiting the loop. If
the variable was previously declared with
<tt>&quot;my&quot;</tt>, it uses that variable instead of
the global one, but it&rsquo;s still localized to the loop.
This implicit localization occurs <i>only</i> in a
<tt>&quot;foreach&quot;</tt> loop.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;foreach&quot;</tt> keyword is actually a synonym
for the <tt>&quot;for&quot;</tt> keyword, so you can use
either. If <small>VAR</small> is omitted, <tt>$_</tt> is set
to each value.</p>

<p style="margin-left:11%; margin-top: 1em">If any element
of <small>LIST</small> is an lvalue, you can modify it by
modifying <small>VAR</small> inside the loop. Conversely, if
any element of <small>LIST</small> is <small>NOT</small> an
lvalue, any attempt to modify that element will fail. In
other words, the <tt>&quot;foreach&quot;</tt> loop index
variable is an implicit alias for each item in the list that
you&rsquo;re looping over.</p>

<p style="margin-left:11%; margin-top: 1em">If any part of
<small>LIST</small> is an array,
<tt>&quot;foreach&quot;</tt> will get very confused if you
add or remove elements within the loop body, for example
with <tt>&quot;splice&quot;</tt>. So don&rsquo;t do
that.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;foreach&quot;</tt>
probably won&rsquo;t do what you expect if
<small>VAR</small> is a tied or other special variable.
Don&rsquo;t do that either.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">    for (@ary) { s/foo/bar/ }
    for my $elem (@elements) {
        $elem *= 2;
    }
    for $count (reverse(1..10), &quot;BOOM&quot;) {
        print $count, &quot;\n&quot;;
        sleep(1);
    }
    for (1..15) { print &quot;Merry Christmas\n&quot;; }
    foreach $item (split(/:[\\\n:]*/, $ENV{TERMCAP})) {
        print &quot;Item: $item\n&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how a C programmer might code up a particular algorithm in
Perl:</p>

<pre style="margin-left:11%; margin-top: 1em">    for (my $i = 0; $i &lt; @ary1; $i++) {
        for (my $j = 0; $j &lt; @ary2; $j++) {
            if ($ary1[$i] &gt; $ary2[$j]) {
                last; # can't go to outer :&minus;(
            }
            $ary1[$i] += $ary2[$j];
        }
        # this is where that last takes me
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Whereas
here&rsquo;s how a Perl programmer more comfortable with the
idiom might do it:</p>

<pre style="margin-left:11%; margin-top: 1em">    OUTER: for my $wid (@ary1) {
    INNER:   for my $jet (@ary2) {
                next OUTER if $wid &gt; $jet;
                $wid += $jet;
             }
          }</pre>


<p style="margin-left:11%; margin-top: 1em">See how much
easier this is? It&rsquo;s cleaner, safer, and faster.
It&rsquo;s cleaner because it&rsquo;s less noisy. It&rsquo;s
safer because if code gets added between the inner and outer
loops later on, the new code won&rsquo;t be accidentally
executed. The <tt>&quot;next&quot;</tt> explicitly iterates
the other loop rather than merely terminating the inner one.
And it&rsquo;s faster because Perl executes a
<tt>&quot;foreach&quot;</tt> statement more rapidly than it
would the equivalent <tt>&quot;for&quot;</tt> loop.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Basic
BLOCKs</b> <br>
A <small>BLOCK</small> by itself (labeled or not) is
semantically equivalent to a loop that executes once. Thus
you can use any of the loop control statements in it to
leave or restart the block. (Note that this is
<i><small>NOT</small></i> true in
<tt>&quot;eval{}&quot;</tt>, <tt>&quot;sub{}&quot;</tt>, or
contrary to popular belief <tt>&quot;do{}&quot;</tt> blocks,
which do <i><small>NOT</small></i> count as loops.) The
<tt>&quot;continue&quot;</tt> block is optional.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>BLOCK</small> construct can be used to emulate case
structures.</p>

<pre style="margin-left:11%; margin-top: 1em">    SWITCH: {
        if (/^abc/) { $abc = 1; last SWITCH; }
        if (/^def/) { $def = 1; last SWITCH; }
        if (/^xyz/) { $xyz = 1; last SWITCH; }
        $nothing = 1;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You&rsquo;ll
also find that <tt>&quot;foreach&quot;</tt> loop used to
create a topicalizer and a switch:</p>

<pre style="margin-left:11%; margin-top: 1em">    SWITCH:
    for ($var) {
        if (/^abc/) { $abc = 1; last SWITCH; }
        if (/^def/) { $def = 1; last SWITCH; }
        if (/^xyz/) { $xyz = 1; last SWITCH; }
        $nothing = 1;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Such constructs
are quite frequently used, both because older versions of
Perl had no official <tt>&quot;switch&quot;</tt> statement,
and also because the new version described immediately below
remains experimental and can sometimes be confusing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Switch
Statements</b> <br>
Starting from Perl 5.10.1 (well, 5.10.0, but it didn&rsquo;t
work right), you can say</p>

<pre style="margin-left:11%; margin-top: 1em">    use feature &quot;switch&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">to enable an
experimental switch feature. This is loosely based on an old
version of a Perl 6 proposal, but it no longer resembles the
Perl 6 construct. You also get the switch feature whenever
you declare that your code prefers to run under a version of
Perl that is 5.10 or later. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.14;</pre>


<p style="margin-left:11%; margin-top: 1em">Under the
&quot;switch&quot; feature, Perl gains the experimental
keywords <tt>&quot;given&quot;</tt>,
<tt>&quot;when&quot;</tt>, <tt>&quot;default&quot;</tt>,
<tt>&quot;continue&quot;</tt>, and
<tt>&quot;break&quot;</tt>. Starting from Perl 5.16, one can
prefix the switch keywords with <tt>&quot;CORE::&quot;</tt>
to access the feature without a <tt>&quot;use
feature&quot;</tt> statement. The keywords
<tt>&quot;given&quot;</tt> and <tt>&quot;when&quot;</tt> are
analogous to <tt>&quot;switch&quot;</tt> and
<tt>&quot;case&quot;</tt> in other languages, so the code in
the previous section could be rewritten as</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.10.1;
    for ($var) {
        when (/^abc/) { $abc = 1 }
        when (/^def/) { $def = 1 }
        when (/^xyz/) { $xyz = 1 }
        default       { $nothing = 1 }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;foreach&quot;</tt> is the non-experimental way to
set a topicalizer. If you wish to use the highly
experimental <tt>&quot;given&quot;</tt>, that could be
written like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.10.1;
    given ($var) {
        when (/^abc/) { $abc = 1 }
        when (/^def/) { $def = 1 }
        when (/^xyz/) { $xyz = 1 }
        default       { $nothing = 1 }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">As of 5.14,
that can also be written this way:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.14;
    for ($var) {
        $abc = 1 when /^abc/;
        $def = 1 when /^def/;
        $xyz = 1 when /^xyz/;
        default { $nothing = 1 }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Or if you
don&rsquo;t care to play it safe, like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.14;
    given ($var) {
        $abc = 1 when /^abc/;
        $def = 1 when /^def/;
        $xyz = 1 when /^xyz/;
        default { $nothing = 1 }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The arguments
to <tt>&quot;given&quot;</tt> and <tt>&quot;when&quot;</tt>
are in scalar context, and <tt>&quot;given&quot;</tt>
assigns the <tt>$_</tt> variable its topic value.</p>

<p style="margin-left:11%; margin-top: 1em">Exactly what
the <i><small>EXPR</small></i> argument to
<tt>&quot;when&quot;</tt> does is hard to describe
precisely, but in general, it tries to guess what you want
done. Sometimes it is interpreted as <tt>&quot;$_ ~~</tt>
<i>EXPR</i><tt>&quot;</tt>, and sometimes it does not. It
also behaves differently when lexically enclosed by a
<tt>&quot;given&quot;</tt> block than it does when
dynamically enclosed by a <tt>&quot;foreach&quot;</tt> loop.
The rules are far too difficult to understand to be
described here. See &quot;Experimental Details on given and
when&quot; later on.</p>

<p style="margin-left:11%; margin-top: 1em">Due to an
unfortunate bug in how <tt>&quot;given&quot;</tt> was
implemented between Perl 5.10 and 5.14, under those
implementations the version of <tt>$_</tt> governed by
<tt>&quot;given&quot;</tt> is merely a lexically scoped copy
of the original, not a dynamically scoped alias to the
original, as it would be if it were a
<tt>&quot;foreach&quot;</tt> or under both the original and
the current Perl 6 language specification. This bug is
expected to be addressed in a future release of Perl. For
forwards compatibility, if you really want a lexical
<tt>$_</tt>, specify that explicitly:</p>

<pre style="margin-left:11%; margin-top: 1em">    given(my $_ = EXPR) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">In the
meanwhile, stick to <tt>&quot;foreach&quot;</tt> for your
topicalizer and you will be less unhappy.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Goto</b>
<br>
Although not for the faint of heart, Perl does support a
<tt>&quot;goto&quot;</tt> statement. There are three forms:
<tt>&quot;goto&quot;</tt>&minus;LABEL,
<tt>&quot;goto&quot;</tt>&minus;EXPR, and
<tt>&quot;goto&quot;</tt>&minus;&amp;NAME. A loop&rsquo;s
<small>LABEL</small> is not actually a valid target for a
<tt>&quot;goto&quot;</tt>; it&rsquo;s just the name of the
loop.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;goto&quot;</tt>&minus;LABEL form finds the
statement labeled with <small>LABEL</small> and resumes
execution there. It may not be used to go into any construct
that requires initialization, such as a subroutine or a
<tt>&quot;foreach&quot;</tt> loop. It also can&rsquo;t be
used to go into a construct that is optimized away. It can
be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it&rsquo;s usually better
to use some other construct such as
<tt>&quot;last&quot;</tt> or <tt>&quot;die&quot;</tt>. The
author of Perl has never felt the need to use this form of
<tt>&quot;goto&quot;</tt> (in Perl, that is--C is another
matter).</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;goto&quot;</tt>&minus;EXPR form expects a label
name, whose scope will be resolved dynamically. This allows
for computed <tt>&quot;goto&quot;</tt>s per
<small>FORTRAN</small> , but isn&rsquo;t necessarily
recommended if you&rsquo;re optimizing for
maintainability:</p>

<pre style="margin-left:11%; margin-top: 1em">    goto((&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i]);</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;goto&quot;</tt>&minus;&amp;NAME form is highly
magical, and substitutes a call to the named subroutine for
the currently running subroutine. This is used by
<tt>&quot;AUTOLOAD()&quot;</tt> subroutines that wish to
load another subroutine and then pretend that the other
subroutine had been called in the first place (except that
any modifications to <tt>@_</tt> in the current subroutine
are propagated to the other subroutine.) After the
<tt>&quot;goto&quot;</tt>, not even
<tt>&quot;caller()&quot;</tt> will be able to tell that this
routine was called first.</p>

<p style="margin-left:11%; margin-top: 1em">In almost all
cases like this, it&rsquo;s usually a far, far better idea
to use the structured control flow mechanisms of
<tt>&quot;next&quot;</tt>, <tt>&quot;last&quot;</tt>, or
<tt>&quot;redo&quot;</tt> instead of resorting to a
<tt>&quot;goto&quot;</tt>. For certain applications, the
catch and throw pair of <tt>&quot;eval{}&quot;</tt> and
<i>die()</i> for exception processing can also be a prudent
approach.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Ellipsis
Statement</b> <br>
Beginning in Perl 5.12, Perl accepts an ellipsis,
&quot;<tt>&quot;...&quot;</tt>&quot;, as a placeholder for
code that you haven&rsquo;t implemented yet. This form of
ellipsis, the unimplemented statement, should not be
confused with the binary flip-flop <tt>&quot;...&quot;</tt>
operator. One is a statement and the other an operator.
(Perl doesn&rsquo;t usually confuse them because usually
Perl can tell whether it wants an operator or a statement,
but see below for exceptions.)</p>

<p style="margin-left:11%; margin-top: 1em">When Perl 5.12
or later encounters an ellipsis statement, it parses this
without error, but if and when you should actually try to
execute it, Perl throws an exception with the text
<tt>&quot;Unimplemented&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.12;
    sub unimplemented { ... }
    eval { unimplemented() };
    if ($@ =~ /^Unimplemented at /) {
        say &quot;I found an ellipsis!&quot;;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You can only
use the elliptical statement to stand in for a complete
statement. These examples of how the ellipsis works:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.12;
    { ... }
    sub foo { ... }
    ...;
    eval { ... };
    sub somemeth {
        my $self = shift;
        ...;
    }
    $x = do {
        my $n;
        ...;
        say &quot;Hurrah!&quot;;
        $n;
    };</pre>


<p style="margin-left:11%; margin-top: 1em">The elliptical
statement cannot stand in for an expression that is part of
a larger statement, since the <tt>&quot;...&quot;</tt> is
also the three-dot version of the flip-flop operator (see
&quot;Range Operators&quot; in perlop).</p>

<p style="margin-left:11%; margin-top: 1em">These examples
of attempts to use an ellipsis are syntax errors:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.12;
    print ...;
    open(my $fh, &quot;&gt;&quot;, &quot;/dev/passwd&quot;) or ...;
    if ($condition &amp;&amp; ... ) { say &quot;Howdy&quot; };</pre>


<p style="margin-left:11%; margin-top: 1em">There are some
cases where Perl can&rsquo;t immediately tell the difference
between an expression and a statement. For instance, the
syntax for a block and an anonymous hash reference
constructor look the same unless there&rsquo;s something in
the braces to give Perl a hint. The ellipsis is a syntax
error if Perl doesn&rsquo;t guess that the <tt>&quot;{ ...
}&quot;</tt> is a block. In that case, it doesn&rsquo;t
think the <tt>&quot;...&quot;</tt> is an ellipsis because
it&rsquo;s expecting an expression instead of a
statement:</p>

<pre style="margin-left:11%; margin-top: 1em">    @transformed = map { ... } @input;  # syntax error</pre>


<p style="margin-left:11%; margin-top: 1em">You can use a
<tt>&quot;;&quot;</tt> inside your block to denote that the
<tt>&quot;{ ... }&quot;</tt> is a block and not a hash
reference constructor. Now the ellipsis works:</p>

<pre style="margin-left:11%; margin-top: 1em">    @transformed = map {; ... } @input; # ; disambiguates
    @transformed = map { ...; } @input; # ; disambiguates</pre>


<p style="margin-left:11%; margin-top: 1em">Note: Some
folks colloquially refer to this bit of punctuation as a
&quot;yada-yada&quot; or &quot;triple-dot&quot;, but its
true name is actually an ellipsis. Perl does not yet accept
the Unicode version, U+2026 <small>HORIZONTAL
ELLIPSIS</small> , as an alias for <tt>&quot;...&quot;</tt>,
but someday it may.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PODs:
Embedded Documentation</b> <br>
Perl has a mechanism for intermixing documentation with
source code. While it&rsquo;s expecting the beginning of a
new statement, if the compiler encounters a line that begins
with an equal sign and a word, like this</p>

<pre style="margin-left:11%; margin-top: 1em">    =head1 Here There Be Pods!</pre>


<p style="margin-left:11%; margin-top: 1em">Then that text
and all remaining text up through and including a line
beginning with <tt>&quot;=cut&quot;</tt> will be ignored.
The format of the intervening text is described in
perlpod.</p>

<p style="margin-left:11%; margin-top: 1em">This allows you
to intermix your source code and your documentation text
freely, as in</p>

<pre style="margin-left:11%; margin-top: 1em">    =item snazzle($)
    The snazzle() function will behave in the most spectacular
    form that you can possibly imagine, not even excepting
    cybernetic pyrotechnics.
    =cut back to the compiler, nuff of this pod stuff!
    sub snazzle($) {
        my $thingie = shift;
        .........
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that pod
translators should look at only paragraphs beginning with a
pod directive (it makes parsing easier), whereas the
compiler actually knows to look for pod escapes even in the
middle of a paragraph. This means that the following secret
stuff will be ignored by both the compiler and the
translators.</p>

<pre style="margin-left:11%; margin-top: 1em">    $a=3;
    =secret stuff
     warn &quot;Neither POD nor CODE!?&quot;
    =cut back
    print &quot;got $a\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">You probably
shouldn&rsquo;t rely upon the <tt>&quot;warn()&quot;</tt>
being podded out forever. Not all pod translators are
well-behaved in this regard, and perhaps the compiler will
become pickier.</p>

<p style="margin-left:11%; margin-top: 1em">One may also
use pod directives to quickly comment out a section of
code.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Plain Old
Comments (Not!)</b> <br>
Perl can process line directives, much like the C
preprocessor. Using this, one can control Perl&rsquo;s idea
of filenames and line numbers in error or warning messages
(especially for strings that are processed with
<tt>&quot;eval()&quot;</tt>). The syntax for this mechanism
is almost the same as for most C preprocessors: it matches
the regular expression</p>

<pre style="margin-left:11%; margin-top: 1em">    # example: '# line 42 &quot;new_filename.plx&quot;'
    /^\#   \s*
      line \s+ (\d+)   \s*
      (?:\s(&quot;?)([^&quot;]+)\g2)? \s*
     $/x</pre>


<p style="margin-left:11%; margin-top: 1em">with
<tt>$1</tt> being the line number for the next line, and
<tt>$3</tt> being the optional filename (specified with or
without quotes). Note that no whitespace may precede the
<tt>&quot;#&quot;</tt>, unlike modern C preprocessors.</p>

<p style="margin-left:11%; margin-top: 1em">There is a
fairly obvious gotcha included with the line directive:
Debuggers and profilers will only show the last source line
to appear at a particular line number in a given file. Care
should be taken not to cause line number collisions in code
you&rsquo;d like to debug later.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples that you should be able to type into your command
shell:</p>

<pre style="margin-left:11%; margin-top: 1em">    % perl
    # line 200 &quot;bzzzt&quot;
    # the '#' on the previous line must be the first char on line
    die 'foo';
    __END__
    foo at bzzzt line 201.
    % perl
    # line 200 &quot;bzzzt&quot;
    eval qq[\n#line 2001 &quot;&quot;\ndie 'foo']; print $@;
    __END__
    foo at &minus; line 2001.
    % perl
    eval qq[\n#line 200 &quot;foo bar&quot;\ndie 'foo']; print $@;
    __END__
    foo at foo bar line 200.
    % perl
    # line 345 &quot;goop&quot;
    eval &quot;\n#line &quot; . __LINE__ . ' &quot;' . __FILE__ .&quot;\&quot;\ndie 'foo'&quot;;
    print $@;
    __END__
    foo at goop line 345.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Experimental
Details on given and when</b> <br>
As previously mentioned, the &quot;switch&quot; feature is
considered highly experimental; it is subject to change with
little notice. In particular, both
<tt>&quot;given&quot;</tt> and <tt>&quot;when&quot;</tt>
have tricky behaviours that are expected to change to become
less tricky in the future. Do not rely upon their current
(mis)implementations.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
longer example of <tt>&quot;given&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use feature &quot;:5.10&quot;;
    given ($foo) {
        when (undef) {
            say '$foo is undefined';
        }
        when (&quot;foo&quot;) {
            say '$foo is the string &quot;foo&quot;';
        }
        when ([1,3,5,7,9]) {
            say '$foo is an odd digit';
            continue; # Fall through
        }
        when ($_ &lt; 100) {
            say '$foo is numerically less than 100';
        }
        when (\&amp;complicated_check) {
            say 'a complicated check for $foo is true';
        }
        default {
            die q(I don't know what to do with $foo);
        }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">As currently
implemented, <tt>&quot;given(EXPR)&quot;</tt> assign the
value of <i><small>EXPR</small></i> to merely a lexically
scoped <b><i>copy</i></b> (!) of <tt>$_</tt>, not a
dynamically scoped alias the way
<tt>&quot;foreach&quot;</tt> does. That makes it similar
to</p>

<pre style="margin-left:11%; margin-top: 1em">        do { my $_ = EXPR; ... }</pre>


<p style="margin-left:11%; margin-top: 1em">except that the
block is automatically broken out of by a successful
<tt>&quot;when&quot;</tt> or an explicit
<tt>&quot;break&quot;</tt>. Because it is only a copy, and
because it is only lexically scoped, not dynamically scoped,
you cannot do the things with it that you are used to in a
<tt>&quot;foreach&quot;</tt> loop. In particular, you
probably cannot use arbitrary function calls. Best stick to
<tt>&quot;foreach&quot;</tt> for that.</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
power comes from the implicit smartmatching that can
sometimes apply. Most of the time,
<tt>&quot;when(EXPR)&quot;</tt> is treated as an implicit
smartmatch of <tt>$_</tt>, that is, <tt>&quot;$_ ~~
EXPR&quot;</tt>. (See &quot;Smartmatch Operator&quot; in
perlop for more information on smartmatching.) But when
<i><small>EXPR</small></i> is one of the 10 exceptional
cases (or things like them) listed below, it is used
directly as a boolean.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A user-defined subroutine call or a method
invocation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A regular expression match in the form of
<tt>&quot;/REGEX/&quot;</tt>, <tt>&quot;$foo =~
/REGEX/&quot;</tt>, or <tt>&quot;$foo =~ EXPR&quot;</tt>.
Also, a negated regular expression match in the form
<tt>&quot;!/REGEX/&quot;</tt>, <tt>&quot;$foo !~
/REGEX/&quot;</tt>, or <tt>&quot;$foo !~
EXPR&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A smart match that uses an explicit
<tt>&quot;~~&quot;</tt> operator, such as <tt>&quot;EXPR ~~
EXPR&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A boolean comparison operator such as <tt>&quot;$_ &lt;
10&quot;</tt> or <tt>&quot;$x eq &quot;abc&quot;&quot;</tt>
The relational operators that this applies to are the six
numeric comparisons (<tt>&quot;&lt;&quot;</tt>,
<tt>&quot;&gt;&quot;</tt>, <tt>&quot;&lt;=&quot;</tt>,
<tt>&quot;&gt;=&quot;</tt>, <tt>&quot;==&quot;</tt>, and
<tt>&quot;!=&quot;</tt>), and the six string comparisons
(<tt>&quot;lt&quot;</tt>, <tt>&quot;gt&quot;</tt>,
<tt>&quot;le&quot;</tt>, <tt>&quot;ge&quot;</tt>,
<tt>&quot;eq&quot;</tt>, and <tt>&quot;ne&quot;</tt>).</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
You will often have to use <tt>&quot;$c ~~ $_&quot;</tt>
because the default case uses <tt>&quot;$_ ~~ $c&quot;</tt>
, which is frequently the opposite of what you want.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">At least the three builtin
functions <tt>&quot;defined(...)&quot;</tt>,
<tt>&quot;exists(...)&quot;</tt>, and
<tt>&quot;eof(...)&quot;</tt>. We might someday add more of
these later if we think of them.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A negated expression, whether
<tt>&quot;!(EXPR)&quot;</tt> or
<tt>&quot;not(EXPR)&quot;</tt>, or a logical exclusive-or,
<tt>&quot;(EXPR1) xor (EXPR2)&quot;</tt>. The bitwise
versions (<tt>&quot;~&quot;</tt> and <tt>&quot;^&quot;</tt>)
are not included.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A filetest operator, with exactly 4 exceptions:
<tt>&quot;&minus;s&quot;</tt>,
<tt>&quot;&minus;M&quot;</tt>,
<tt>&quot;&minus;A&quot;</tt>, and
<tt>&quot;&minus;C&quot;</tt>, as these return numerical
values, not boolean ones. The <tt>&quot;&minus;z&quot;</tt>
filetest operator is not included in the exception list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The <tt>&quot;..&quot;</tt> and <tt>&quot;...&quot;</tt>
flip-flop operators. Note that the <tt>&quot;...&quot;</tt>
flip-flop operator is completely different from the
<tt>&quot;...&quot;</tt> elliptical statement just
described.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In those 8
cases above, the value of <small>EXPR</small> is used
directly as a boolean, so no smartmatching is done. You may
think of <tt>&quot;when&quot;</tt> as a smartsmartmatch.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore,
Perl inspects the operands of logical operators to decide
whether to use smartmatching for each one by applying the
above test to the operands:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">9.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">If <small>EXPR</small> is
<tt>&quot;EXPR1 &amp;&amp; EXPR2&quot;</tt> or
<tt>&quot;EXPR1 and EXPR2&quot;</tt>, the test is applied
<i>recursively</i> to both <small>EXPR1</small> and
<small>EXPR2</small> . Only if <i>both</i> operands also
pass the test, <i>recursively</i>, will the expression be
treated as boolean. Otherwise, smartmatching is used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>10.</p></td>
<td width="2%"></td>
<td width="83%">


<p>If <small>EXPR</small> is <tt>&quot;EXPR1 ||
EXPR2&quot;</tt>, <tt>&quot;EXPR1 // EXPR2&quot;</tt>, or
<tt>&quot;EXPR1 or EXPR2&quot;</tt>, the test is applied
<i>recursively</i> to <small>EXPR1</small> only (which might
itself be a higher-precedence <small>AND</small> operator,
for example, and thus subject to the previous rule), not to
<small>EXPR2</small> . If <small>EXPR1</small> is to use
smartmatching, then <small>EXPR2</small> also does so, no
matter what <small>EXPR2</small> contains. But if
<small>EXPR2</small> does not get to use smartmatching, then
the second argument will not be either. This is quite
different from the <tt>&quot;&amp;&amp;&quot;</tt> case just
described, so be careful.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These rules are
complicated, but the goal is for them to do what you want
(even if you don&rsquo;t quite understand why they are doing
it). For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    when (/^\d+$/ &amp;&amp; $_ &lt; 75) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">will be treated
as a boolean match because the rules say both a regex match
and an explicit test on <tt>$_</tt> will be treated as
boolean.</p>

<p style="margin-left:11%; margin-top: 1em">Also:</p>

<pre style="margin-left:11%; margin-top: 1em">    when ([qw(foo bar)] &amp;&amp; /baz/) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">will use
smartmatching because only <i>one</i> of the operands is a
boolean: the other uses smartmatching, and that wins.</p>

<p style="margin-left:11%; margin-top: 1em">Further:</p>

<pre style="margin-left:11%; margin-top: 1em">    when ([qw(foo bar)] || /^baz/) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">will use smart
matching (only the first operand is considered), whereas</p>

<pre style="margin-left:11%; margin-top: 1em">    when (/^baz/ || [qw(foo bar)]) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">will test only
the regex, which causes both operands to be treated as
boolean. Watch out for this one, then, because an arrayref
is always a true value, which makes it effectively
redundant. Not a good idea.</p>

<p style="margin-left:11%; margin-top: 1em">Tautologous
boolean operators are still going to be optimized away.
Don&rsquo;t be tempted to write</p>

<pre style="margin-left:11%; margin-top: 1em">    when (&quot;foo&quot; or &quot;bar&quot;) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">This will
optimize down to <tt>&quot;foo&quot;</tt>, so
<tt>&quot;bar&quot;</tt> will never be considered (even
though the rules say to use a smartmatch on
<tt>&quot;foo&quot;</tt>). For an alternation like this, an
array ref will work, because this will instigate
smartmatching:</p>

<pre style="margin-left:11%; margin-top: 1em">    when ([qw(foo bar)] { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">This is
somewhat equivalent to the C&minus;style switch
statement&rsquo;s fallthrough functionality (not to be
confused with <i>Perl&rsquo;s</i> fallthrough
functionality--see below), wherein the same block is used
for several <tt>&quot;case&quot;</tt> statements.</p>

<p style="margin-left:11%; margin-top: 1em">Another useful
shortcut is that, if you use a literal array or hash as the
argument to <tt>&quot;given&quot;</tt>, it is turned into a
reference. So <tt>&quot;given(@foo)&quot;</tt> is the same
as <tt>&quot;given(\@foo)&quot;</tt>, for example.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;default&quot;</tt>
behaves exactly like <tt>&quot;when(1 == 1)&quot;</tt>,
which is to say that it always matches.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Breaking
out</i></p>

<p style="margin-left:11%; margin-top: 1em">You can use the
<tt>&quot;break&quot;</tt> keyword to break out of the
enclosing <tt>&quot;given&quot;</tt> block. Every
<tt>&quot;when&quot;</tt> block is implicitly ended with a
<tt>&quot;break&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Fall-through</i></p>

<p style="margin-left:11%; margin-top: 1em">You can use the
<tt>&quot;continue&quot;</tt> keyword to fall through from
one case to the next:</p>

<pre style="margin-left:11%; margin-top: 1em">    given($foo) {
        when (/x/) { say '$foo contains an x'; continue }
        when (/y/) { say '$foo contains a y'            }
        default    { say '$foo does not contain a y'    }
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Return
value</i></p>

<p style="margin-left:11%; margin-top: 1em">When a
<tt>&quot;given&quot;</tt> statement is also a valid
expression (for example, when it&rsquo;s the last statement
of a block), it evaluates to:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">An empty list as soon as an
explicit <tt>&quot;break&quot;</tt> is encountered.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The value of the last evaluated expression of the
successful
<tt>&quot;when&quot;</tt>/<tt>&quot;default&quot;</tt>
clause, if there happens to be one.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The value of the last evaluated expression of the
<tt>&quot;given&quot;</tt> block if no condition is
true.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In both last
cases, the last expression is evaluated in the context that
was applied to the <tt>&quot;given&quot;</tt> block.</p>

<p style="margin-left:11%; margin-top: 1em">Note that,
unlike <tt>&quot;if&quot;</tt> and
<tt>&quot;unless&quot;</tt>, failed
<tt>&quot;when&quot;</tt> statements always evaluate to an
empty list.</p>

<pre style="margin-left:11%; margin-top: 1em">    my $price = do {
        given ($item) {
            when ([&quot;pear&quot;, &quot;apple&quot;]) { 1 }
            break when &quot;vote&quot;;      # My vote cannot be bought
            1e10  when /Mona Lisa/;
            &quot;unknown&quot;;
        }
    };</pre>


<p style="margin-left:11%; margin-top: 1em">Currently,
<tt>&quot;given&quot;</tt> blocks can&rsquo;t always be used
as proper expressions. This may be addressed in a future
version of Perl.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Switching in
a loop</i></p>

<p style="margin-left:11%; margin-top: 1em">Instead of
using <tt>&quot;given()&quot;</tt>, you can use a
<tt>&quot;foreach()&quot;</tt> loop. For example,
here&rsquo;s one way to count how many times a particular
string occurs in an array:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.10.1;
    my $count = 0;
    for (@array) {
        when (&quot;foo&quot;) { ++$count }
    }
    print &quot;\@array contains $count copies of 'foo'\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Or in a more
recent version:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.14;
    my $count = 0;
    for (@array) {
        ++$count when &quot;foo&quot;;
    }
    print &quot;\@array contains $count copies of 'foo'\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">At the end of
all <tt>&quot;when&quot;</tt> blocks, there is an implicit
<tt>&quot;next&quot;</tt>. You can override that with an
explicit <tt>&quot;last&quot;</tt> if you&rsquo;re
interested in only the first match alone.</p>

<p style="margin-left:11%; margin-top: 1em">This
doesn&rsquo;t work if you explicitly specify a loop
variable, as in <tt>&quot;for $item (@array)&quot;</tt>. You
have to use the default variable <tt>$_</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Differences
from Perl 6</i></p>

<p style="margin-left:11%; margin-top: 1em">The Perl 5
smartmatch and
<tt>&quot;given&quot;</tt>/<tt>&quot;when&quot;</tt>
constructs are not compatible with their Perl 6 analogues.
The most visible difference and least important difference
is that, in Perl 5, parentheses are required around the
argument to <tt>&quot;given()&quot;</tt> and
<tt>&quot;when()&quot;</tt> (except when this last one is
used as a statement modifier). Parentheses in Perl 6 are
always optional in a control construct such as
<tt>&quot;if()&quot;</tt>, <tt>&quot;while()&quot;</tt>, or
<tt>&quot;when()&quot;</tt>; they can&rsquo;t be made
optional in Perl 5 without a great deal of potential
confusion, because Perl 5 would parse the expression</p>

<pre style="margin-left:11%; margin-top: 1em">    given $foo {
        ...
    }</pre>


<p style="margin-left:11%; margin-top: 1em">as though the
argument to <tt>&quot;given&quot;</tt> were an element of
the hash <tt>%foo</tt>, interpreting the braces as
hash-element syntax.</p>

<p style="margin-left:11%; margin-top: 1em">However, their
are many, many other differences. For example, this works in
Perl 5:</p>

<pre style="margin-left:11%; margin-top: 1em">    use v5.12;
    my @primary = (&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);
    if (@primary ~~ &quot;red&quot;) {
        say &quot;primary smartmatches red&quot;;
    }
    if (&quot;red&quot; ~~ @primary) {
        say &quot;red smartmatches primary&quot;;
    }
    say &quot;that's all, folks!&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">But it
doesn&rsquo;t work at all in Perl 6. Instead, you should use
the (parallelizable) <tt>&quot;any&quot;</tt> operator
instead:</p>

<pre style="margin-left:11%; margin-top: 1em">   if any(@primary) eq &quot;red&quot; {
       say &quot;primary smartmatches red&quot;;
   }
   if &quot;red&quot; eq any(@primary) {
       say &quot;red smartmatches primary&quot;;
   }</pre>


<p style="margin-left:11%; margin-top: 1em">The table of
smartmatches in &quot;Smartmatch Operator&quot; in perlop is
not identical to that proposed by the Perl 6 specification,
mainly due to differences between Perl 6&rsquo;s and Perl
5&rsquo;s data models, but also because the Perl 6 spec has
changed since Perl 5 rushed into early adoption.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl 6,
<tt>&quot;when()&quot;</tt> will always do an implicit
smartmatch with its argument, while in Perl 5 it is
convenient (albeit potentially confusing) to suppress this
implicit smartmatch in various rather loosely-defined
situations, as roughly outlined above. (The difference is
largely because Perl 5 does not have, even internally, a
boolean type.)</p>
<hr>
</body>
</html>
