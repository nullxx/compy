<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:18:18 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>BN_add</title>

</head>
<body>

<h1 align="center">BN_add</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUES">RETURN VALUES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#HISTORY">HISTORY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">BN_add, BN_sub,
BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add,
BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_exp, BN_mod_exp,
BN_gcd &minus; arithmetic operations on BIGNUMs</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> #include &lt;openssl/bn.h&gt;
 int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
 int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
 int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
         BN_CTX *ctx);
 int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
 int BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
 int BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);
 int BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);
 int BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);
 int BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
 int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
 int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
         const BIGNUM *m, BN_CTX *ctx);
 int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>BN_add()</i>
adds <i>a</i> and <i>b</i> and places the result in <i>r</i>
(<tt>&quot;r=a+b&quot;</tt>). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_sub()</i>
subtracts <i>b</i> from <i>a</i> and places the result in
<i>r</i> (<tt>&quot;r=a&minus;b&quot;</tt>).</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mul()</i>
multiplies <i>a</i> and <i>b</i> and places the result in
<i>r</i> (<tt>&quot;r=a*b&quot;</tt>). <i>r</i> may be the
same <b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>.
For multiplication by powers of 2, use
<i>BN_lshift</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_sqr()</i>
takes the square of <i>a</i> and places the result in
<i>r</i> (<tt>&quot;r=a^2&quot;</tt>). <i>r</i> and <i>a</i>
may be the same <b><small>BIGNUM</small></b> . This function
is faster than BN_mul(r,a,a).</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_div()</i>
divides <i>a</i> by <i>d</i> and places the result in
<i>dv</i> and the remainder in <i>rem</i> (<tt>&quot;dv=a/d,
rem=a%d&quot;</tt>). Either of <i>dv</i> and <i>rem</i> may
be <b><small>NULL</small></b> , in which case the respective
value is not returned. The result is rounded towards zero;
thus if <i>a</i> is negative, the remainder will be zero or
negative. For division by powers of 2, use
<i>BN_rshift</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod()</i>
corresponds to <i>BN_div()</i> with <i>dv</i> set to
<b><small>NULL</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_nnmod()</i>
reduces <i>a</i> modulo <i>m</i> and places the non-negative
remainder in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod_add()</i>
adds <i>a</i> to <i>b</i> modulo <i>m</i> and places the
non-negative result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod_sub()</i>
subtracts <i>b</i> from <i>a</i> modulo <i>m</i> and places
the non-negative result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod_mul()</i>
multiplies <i>a</i> by <i>b</i> and finds the non-negative
remainder respective to modulus <i>m</i> (<tt>&quot;r=(a*b)
mod m&quot;</tt>). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>. For
more efficient algorithms for repeated computations using
the same modulus, see <i>BN_mod_mul_montgomery</i>(3) and
<i>BN_mod_mul_reciprocal</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod_sqr()</i>
takes the square of <i>a</i> modulo <b>m</b> and places the
result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_exp()</i>
raises <i>a</i> to the <i>p</i>&minus;th power and places
the result in <i>r</i> (<tt>&quot;r=a^p&quot;</tt>). This
function is faster than repeated applications of
<i>BN_mul()</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_mod_exp()</i>
computes <i>a</i> to the <i>p</i>&minus;th power modulo
<i>m</i> (<tt>&quot;r=a^p % m&quot;</tt>). This function
uses less time and space than <i>BN_exp()</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BN_gcd()</i>
computes the greatest common divisor of <i>a</i> and
<i>b</i> and places the result in <i>r</i>. <i>r</i> may be
the same <b><small>BIGNUM</small></b> as <i>a</i> or
<i>b</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For all
functions, <i>ctx</i> is a previously allocated
<b><small>BN_CTX</small></b> used for temporary variables;
see <i>BN_CTX_new</i>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Unless noted
otherwise, the result <b><small>BIGNUM</small></b> must be
different from the arguments.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For all
functions, 1 is returned for success, 0 on error. The return
value should always be checked (e.g., <tt>&quot;if
(!BN_add(r,a,b)) goto err;&quot;</tt>). The error codes can
be obtained by <i>ERR_get_error</i>(3).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>bn</i>(3),
<i>ERR_get_error</i>(3), <i>BN_CTX_new</i>(3),
<i>BN_add_word</i>(3), <i>BN_set_bit</i>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>BN_add()</i>,
<i>BN_sub()</i>, <i>BN_sqr()</i>, <i>BN_div()</i>,
<i>BN_mod()</i>, <i>BN_mod_mul()</i>, <i>BN_mod_exp()</i>
and <i>BN_gcd()</i> are available in all versions of SSLeay
and OpenSSL. The <i>ctx</i> argument to <i>BN_mul()</i> was
added in SSLeay 0.9.1b. <i>BN_exp()</i> appeared in SSLeay
0.9.0. <i>BN_nnmod()</i>, <i>BN_mod_add()</i>,
<i>BN_mod_sub()</i>, and <i>BN_mod_sqr()</i> were added in
OpenSSL 0.9.7.</p>
<hr>
</body>
</html>
