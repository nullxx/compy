<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:34 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_StringObj</title>

</head>
<body>

<h1 align="center">Tcl_StringObj</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_NewStringObj,
Tcl_NewUnicodeObj, Tcl_SetStringObj, Tcl_SetUnicodeObj,
Tcl_GetStringFromObj, Tcl_GetString, Tcl_GetUnicodeFromObj,
Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength,
Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj,
Tcl_AppendObjToObj, Tcl_AppendStringsToObj,
Tcl_AppendStringsToObjVA, Tcl_AppendLimitedToObj,
Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf,
Tcl_AppendPrintfToObj, Tcl_SetObjLength,
Tcl_AttemptSetObjLength, Tcl_ConcatObj &minus; manipulate
Tcl objects as strings</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_NewStringObj</b>(<i>bytes, length</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_NewUnicodeObj</b>(<i>unicode, numChars</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_SetStringObj</b>(<i>objPtr, bytes, length</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_SetUnicodeObj</b>(<i>objPtr, unicode, numChars</i>)</p>

<p style="margin-left:11%; margin-top: 1em">char * <b><br>
Tcl_GetStringFromObj</b>(<i>objPtr, lengthPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">char * <b><br>
Tcl_GetString</b>(<i>objPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_UniChar *
<b><br>
Tcl_GetUnicodeFromObj</b>(<i>objPtr, lengthPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_UniChar *
<b><br>
Tcl_GetUnicode</b>(<i>objPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_UniChar
<b><br>
Tcl_GetUniChar</b>(<i>objPtr, index</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetCharLength</b>(<i>objPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_GetRange</b>(<i>objPtr, first, last</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_AppendToObj</b>(<i>objPtr, bytes, length</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_AppendUnicodeToObj</b>(<i>objPtr, unicode,
numChars</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_AppendObjToObj</b>(<i>objPtr, appendObjPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_AppendStringsToObj</b>(<i>objPtr, string, string,
...</i> <b>(char *) NULL</b>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_AppendStringsToObjVA</b>(<i>objPtr, argList</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void
<big>&#9474;</big> <b><br>
Tcl_AppendLimitedToObj</b>(<i>objPtr, bytes, length, limit,
ellipsis</i>) <big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<big>&#9474;</big> <b><br>
Tcl_Format</b>(<i>interp, format, objc, objv</i>)
<big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">int
<big>&#9474;</big> <b><br>
Tcl_AppendFormatToObj</b>(<i>interp, objPtr, format, objc,
objv</i>) <big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<big>&#9474;</big> <b><br>
Tcl_ObjPrintf</b>(<i>format, ...</i>) <big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">int
<big>&#9474;</big> <b><br>
Tcl_AppendPrintfToObj</b>(<i>objPtr, format, ...</i>)
<big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_SetObjLength</b>(<i>objPtr, newLength</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_AttemptSetObjLength</b>(<i>objPtr, newLength</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_ConcatObj</b>(<i>objc, objv</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p style="margin-top: 1em">const char <i>*bytes</i>
(in)</p> </td>
<td width="24%"></td>
<td width="18%">


<p style="margin-top: 1em">Points to the first byte of an
array of UTF-8-encoded bytes used to set or append to a
string object. This byte array may contain embedded null
characters unless <i>numChars</i> is negative. (Applications
needing null bytes should represent them as the two-byte
sequence <i>\700\600</i>, use <b>Tcl_ExternalToUtf</b> to
convert, or <b>Tcl_NewByteArrayObj</b> if the string is a
collection of uninterpreted bytes.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>length</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The number of bytes to copy from <i>bytes</i> when
initializing, setting, or appending to a string object. If
negative, all bytes up to the first null are used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>const Tcl_UniChar <i>*unicode</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Points to the first byte of an array of Unicode
characters used to set or append to a string object. This
byte array may contain embedded null characters unless
<i>numChars</i> is negative.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>numChars</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The number of Unicode characters to copy from
<i>unicode</i> when initializing, setting, or appending to a
string object. If negative, all characters up to the first
null character are used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>index</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The index of the Unicode character to return.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>first</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The index of the first Unicode character in the Unicode
range to be returned as a new object.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>last</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The index of the last Unicode character in the Unicode
range to be returned as a new object.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>Tcl_Obj <i>*objPtr</i> (in/out)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Points to an object to manipulate.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>Tcl_Obj <i>*appendObjPtr</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The object to append to <i>objPtr</i> in
<b>Tcl_AppendObjToObj</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>*lengthPtr</i> (out)</p></td>
<td width="24%"></td>
<td width="18%">


<p>If non-NULL, the location where
<b>Tcl_GetStringFromObj</b> will store the length of an
object&rsquo;s string representation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>const char <i>*string</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Null-terminated string value to append to
<i>objPtr</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>va_list <i>argList</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>An argument list which must have been initialised using
<b>va_start</b>, and cleared using <b>va_end</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>limit</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Maximum number of bytes to be appended.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>const char <i>*ellipsis</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Suffix to append when the limit leads to string
truncation. If NULL is passed then the suffix
&quot;...&quot; is used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>const char <i>*format</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>Format control string including % conversion
specifiers.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>objc</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The number of elements to format or concatenate.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>Tcl_Obj <i>*objv[]</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>The array of objects to format or concatenate.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="47%">


<p>int <i>newLength</i> (in)</p></td>
<td width="24%"></td>
<td width="18%">


<p>New length for the string value of <i>objPtr</i>, not
including the final null character.</p></td></tr>
</table>


<p style="margin-left:82%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The procedures
described in this manual entry allow Tcl objects to be
manipulated as string values. They use the internal
representation of the object to store additional information
to make the string manipulations more efficient. In
particular, they make a series of append operations
efficient by allocating extra storage space for the string
so that it does not have to be copied for each append. Also,
indexing and length computations are optimized because the
Unicode string representation is calculated and cached as
needed. When using the <b>Tcl_Append*</b> family of
functions where the interpreter&rsquo;s result is the object
being appended to, it is important to call Tcl_ResetResult
first to ensure you are not unintentionally appending to
existing data in the result object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_NewStringObj</b>
and <b>Tcl_SetStringObj</b> create a new object or modify an
existing object to hold a copy of the string given by
<i>bytes</i> and <i>length</i>. <b>Tcl_NewUnicodeObj</b> and
<b>Tcl_SetUnicodeObj</b> create a new object or modify an
existing object to hold a copy of the Unicode string given
by <i>unicode</i> and <i>numChars</i>.
<b>Tcl_NewStringObj</b> and <b>Tcl_NewUnicodeObj</b> return
a pointer to a newly created object with reference count
zero. All four procedures set the object to hold a copy of
the specified string. <b>Tcl_SetStringObj</b> and
<b>Tcl_SetUnicodeObj</b> free any old string representation
as well as any old internal representation of the
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetStringFromObj</b>
and <b>Tcl_GetString</b> return an object&rsquo;s string
representation. This is given by the returned byte pointer
and (for <b>Tcl_GetStringFromObj</b>) length, which is
stored in <i>lengthPtr</i> if it is non-NULL. If the
object&rsquo;s UTF string representation is invalid (its
byte pointer is NULL), the string representation is
regenerated from the object&rsquo;s internal representation.
The storage referenced by the returned byte pointer is owned
by the object manager. It is passed back as a writable
pointer so that extension author creating their own
<b>Tcl_ObjType</b> will be able to modify the string
representation within the <b>Tcl_UpdateStringProc</b> of
their <b>Tcl_ObjType</b>. Except for that limited purpose,
the pointer returned by <b>Tcl_GetStringFromObj</b> or
<b>Tcl_GetString</b> should be treated as read-only. It is
recommended that this pointer be assigned to a (const char
*) variable. Even in the limited situations where writing to
this pointer is acceptable, one should take care to respect
the copy-on-write semantics required by
<b>Tcl_Obj</b>&rsquo;s, with appropriate calls to
<b>Tcl_IsShared</b> and <b>Tcl_DuplicateObj</b> prior to any
in-place modification of the string representation. The
procedure <b>Tcl_GetString</b> is used in the common case
where the caller does not need the length of the string
representation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetUnicodeFromObj</b>
and <b>Tcl_GetUnicode</b> return an object&rsquo;s value as
a Unicode string. This is given by the returned pointer and
(for <b>Tcl_GetUnicodeFromObj</b>) length, which is stored
in <i>lengthPtr</i> if it is non-NULL. The storage
referenced by the returned byte pointer is owned by the
object manager and should not be modified by the caller. The
procedure <b>Tcl_GetUnicode</b> is used in the common case
where the caller does not need the length of the unicode
string representation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetUniChar</b>
returns the <i>index</i>&rsquo;th character in the
object&rsquo;s Unicode representation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetRange</b>
returns a newly created object comprised of the characters
between <i>first</i> and <i>last</i> (inclusive) in the
object&rsquo;s Unicode representation. If the object&rsquo;s
Unicode representation is invalid, the Unicode
representation is regenerated from the object&rsquo;s string
representation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetCharLength</b>
returns the number of characters (as opposed to bytes) in
the string object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendToObj</b>
appends the data given by <i>bytes</i> and <i>length</i> to
the string representation of the object specified by
<i>objPtr</i>. If the object has an invalid string
representation, then an attempt is made to convert
<i>bytes</i> is to the Unicode format. If the conversion is
successful, then the converted form of <i>bytes</i> is
appended to the object&rsquo;s Unicode representation.
Otherwise, the object&rsquo;s Unicode representation is
invalidated and converted to the UTF format, and
<i>bytes</i> is appended to the object&rsquo;s new string
representation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendUnicodeToObj</b>
appends the Unicode string given by <i>unicode</i> and
<i>numChars</i> to the object specified by <i>objPtr</i>. If
the object has an invalid Unicode representation, then
<i>unicode</i> is converted to the UTF format and appended
to the object&rsquo;s string representation. Appends are
optimized to handle repeated appends relatively efficiently
(it overallocates the string or Unicode space to avoid
repeated reallocations and copies of object&rsquo;s string
value).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendObjToObj</b>
is similar to <b>Tcl_AppendToObj</b>, but it appends the
string or Unicode value (whichever exists and is best suited
to be appended to <i>objPtr</i>) of <i>appendObjPtr</i> to
<i>objPtr</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendStringsToObj</b>
is similar to <b>Tcl_AppendToObj</b> except that it can be
passed more than one value to append and each value must be
a null-terminated string (i.e. none of the values may
contain internal null characters). Any number of
<i>string</i> arguments may be provided, but the last
argument must be a NULL pointer to indicate the end of the
list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendStringsToObjVA</b>
is the same as <b>Tcl_AppendStringsToObj</b> except that
instead of taking a variable number of arguments it takes an
argument list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendLimitedToObj</b>
is similar to <b>Tcl_AppendToObj</b> except that it
<big>&#9474;</big> imposes a limit on how many bytes are
appended. This can be handy when <big>&#9474;</big> the
string to be appended might be very large, but the value
being <big>&#9474;</big> constructed should not be allowed
to grow without bound. A common usage <big>&#9474;</big> is
when constructing an error message, where the end result
should be <big>&#9474;</big> kept short enough to be read.
Bytes from <i>bytes</i> are appended to <i>objPtr</i>,
<big>&#9474;</big> but no more than <i>limit</i> bytes total
are to be appended. If the limit <big>&#9474;</big> prevents
all <i>length</i> bytes that are available from being
appended, then <big>&#9474;</big> the appending is done so
that the last bytes appended are from the <big>&#9474;</big>
string <i>ellipsis</i>. This allows for an indication of the
truncation to be <big>&#9474;</big> left in the string. When
<i>length</i> is <b>-1</b>, all bytes up to the first zero
<big>&#9474;</big> byte are appended, subject to the limit.
When <i>ellipsis</i> is NULL, the <big>&#9474;</big> default
string <b>...</b> is used. When <i>ellipsis</i> is non-NULL,
it must point to <big>&#9474;</big> a zero-byte-terminated
string in Tcl&rsquo;s internal UTF encoding. The
<big>&#9474;</big> number of bytes appended can be less than
the lesser of <i>length</i> and <big>&#9474;</big>
<i>limit</i> when appending fewer bytes is necessary to
append only whole <big>&#9474;</big> multi-byte characters.
<big>&#9474;</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_Format</b>
is the C-level interface to the engine of the <b>format</b>
<big>&#9474;</big> command. The actual command procedure for
<b>format</b> is little more than <big>&#9474;</big></p>

<p style="margin-left:22%;">Tcl_Format(interp,
Tcl_GetString(objv[1]), objc-2, objv+2);
<big>&#9474;</big></p>

<p style="margin-left:11%;">The <i>objc</i> Tcl_Obj values
in <i>objv</i> are formatted into a string according
<big>&#9474;</big> to the conversion specification in
<i>format</i> argument, following the <big>&#9474;</big>
documentation for the <b>format</b> command. The resulting
formatted string <big>&#9474;</big> is converted to a new
Tcl_Obj with refcount of zero and returned. If
<big>&#9474;</big> some error happens during production of
the formatted string, NULL is <big>&#9474;</big> returned,
and an error message is recorded in <i>interp</i>, if
<i>interp</i> is <big>&#9474;</big> non-NULL.
<big>&#9474;</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendFormatToObj</b>
is an appending alternative form of <b>Tcl_Format</b>
<big>&#9474;</big> with functionality equivalent to
<big>&#9474;</big></p>

<p style="margin-left:22%;">Tcl_Obj *newPtr =
Tcl_Format(interp, format, objc, objv); <big>&#9474;</big>
<br>
if (newPtr == NULL) return TCL_ERROR; <big>&#9474;</big>
<br>
Tcl_AppendObjToObj(objPtr, newPtr); <big>&#9474;</big> <br>
return TCL_OK; <big>&#9474;</big></p>

<p style="margin-left:11%;">but with greater convenience
and efficiency when the appending <big>&#9474;</big>
functionality is needed. <big>&#9474;</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ObjPrintf</b>
serves as a replacement for the common sequence
<big>&#9474;</big></p>

<p style="margin-left:22%;">char buf[SOME_SUITABLE_LENGTH];
<big>&#9474;</big> <br>
sprintf(buf, format, ...); <big>&#9474;</big> <br>
Tcl_NewStringObj(buf, -1); <big>&#9474;</big></p>

<p style="margin-left:11%;">but with greater convenience
and no need to determine <big>&#9474;</big>
<b>SOME_SUITABLE_LENGTH</b>. The formatting is done with the
same core <big>&#9474;</big> formatting engine used by
<b>Tcl_Format</b>. This means the set of supported
<big>&#9474;</big> conversion specifiers is that of the
<b>format</b> command and not that of the <big>&#9474;</big>
<b>sprintf</b> routine where the two sets differ. When a
conversion specifier <big>&#9474;</big> passed to
<b>Tcl_ObjPrintf</b> includes a precision, the value is
taken as a <big>&#9474;</big> number of bytes, as
<b>sprintf</b> does, and not as a number of characters, as
<big>&#9474;</big> <b>format</b> does. This is done on the
assumption that C code is more likely <big>&#9474;</big> to
know how many bytes it is passing around than the number of
encoded <big>&#9474;</big> characters those bytes happen to
represent. The variable number of <big>&#9474;</big>
arguments passed in should be of the types that would be
suitable for <big>&#9474;</big> passing to <b>sprintf</b>.
Note in this example usage, <i>x</i> is of type <b>long</b>.
<big>&#9474;</big></p>

<p style="margin-left:22%;">long x = 5; <big>&#9474;</big>
<br>
Tcl_Obj *objPtr = Tcl_ObjPrintf(&quot;Value is %d&quot;, x);
<big>&#9474;</big></p>

<p style="margin-left:11%;">If the value of <i>format</i>
contains internal inconsistencies or invalid
<big>&#9474;</big> specifier formats, the formatted string
result produced by <big>&#9474;</big> <b>Tcl_ObjPrintf</b>
will be an error message describing the error.
<big>&#9474;</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AppendPrintfToObj</b>
is an appending alternative form of <b>Tcl_ObjPrintf</b>
<big>&#9474;</big> with functionality equivalent to
<big>&#9474;</big></p>

<p style="margin-left:22%;">Tcl_AppendObjToObj(objPtr,
Tcl_ObjPrintf(format, ...)); <big>&#9474;</big></p>

<p style="margin-left:11%;">but with greater convenience
and efficiency when the appending <big>&#9474;</big>
functionality is needed.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_SetObjLength</b> procedure changes the length of the
string value of its <i>objPtr</i> argument. If the
<i>newLength</i> argument is greater than the space
allocated for the object&rsquo;s string, then the string
space is reallocated and the old value is copied to the new
space; the bytes between the old length of the string and
the new length may have arbitrary values. If the
<i>newLength</i> argument is less than the current length of
the object&rsquo;s string, with <i>objPtr-&gt;length</i> is
reduced without reallocating the string space; the original
allocated size for the string is recorded in the object, so
that the string length can be enlarged in a subsequent call
to <b>Tcl_SetObjLength</b> without reallocating storage. In
all cases <b>Tcl_SetObjLength</b> leaves a null character at
<i>objPtr-&gt;bytes[newLength]</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AttemptSetObjLength</b>
is identical in function to <b>Tcl_SetObjLength</b> except
that if sufficient memory to satisfy the request cannot be
allocated, it does not cause the Tcl interpreter to
<b>panic</b>. Thus, if <i>newLength</i> is greater than the
space allocated for the object&rsquo;s string, and there is
not enough memory available to satisfy the request,
<b>Tcl_AttemptSetObjLength</b> will take no action and
return 0 to indicate failure. If there is enough memory to
satisfy the request, <b>Tcl_AttemptSetObjLength</b> behaves
just like <b>Tcl_SetObjLength</b> and returns 1 to indicate
success.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_ConcatObj</b> function returns a new string object
whose value is the space-separated concatenation of the
string representations of all of the objects in the
<i>objv</i> array. <b>Tcl_ConcatObj</b> eliminates leading
and trailing white space as it copies the string
representations of the <i>objv</i> array to the result. If
an element of the <i>objv</i> array consists of nothing but
white space, then that object is ignored entirely. This
white-space removal was added to make the output of the
<b>concat</b> command cleaner-looking. <b>Tcl_ConcatObj</b>
returns a pointer to a newly-created object whose ref count
is zero.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl_NewObj,
Tcl_IncrRefCount, Tcl_DecrRefCount, format, sprintf</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">append,
internal representation, object, object type, string object,
string type, string representation, concat, concatenate,
unicode</p>
<hr>
</body>
</html>
