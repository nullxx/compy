<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:24:54 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>iptables-extensions</title>

</head>
<body>

<h1 align="center">iptables-extensions</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#MATCH EXTENSIONS">MATCH EXTENSIONS</a><br>
<a href="#TARGET EXTENSIONS">TARGET EXTENSIONS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">iptables-extensions
&mdash; list of extensions in the standard iptables
distribution</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ip6tables</b>
[<b>&minus;m</b> <i>name</i> [<i>module-options</i>...]]
[<b>&minus;j</b> <i>target-name</i>
[<i>target-options</i>...]</p>


<p style="margin-left:11%; margin-top: 1em"><b>iptables</b>
[<b>&minus;m</b> <i>name</i> [<i>module-options</i>...]]
[<b>&minus;j</b> <i>target-name</i>
[<i>target-options</i>...]</p>

<h2>MATCH EXTENSIONS
<a name="MATCH EXTENSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">iptables can
use extended packet matching modules with the
<b>&minus;m</b> or <b>&minus;&minus;match</b> options,
followed by the matching module name; after these, various
extra command line options become available, depending on
the specific module. You can specify multiple extended match
modules in one line, and you can use the <b>&minus;h</b> or
<b>&minus;&minus;help</b> options after the module has been
specified to receive help specific to that module. The
extended match modules are evaluated in the order they are
specified in the rule.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>&minus;p</b> or <b>&minus;&minus;protocol</b> was
specified and if and only if an unknown option is
encountered, iptables will try load a match module of the
same name as the protocol, to try making the option
available.</p>


<p style="margin-left:11%; margin-top: 1em"><b>addrtype</b>
<br>
This module matches packets based on their <b>address
type.</b> Address types are used within the kernel
networking stack and categorize addresses into various
groups. The exact definition of that group depends on the
specific layer three protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The following
address types are possible:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>UNSPEC</b></p></td>
<td width="2%"></td>
<td width="56%">


<p>an unspecified address (i.e. 0.0.0.0)</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>UNICAST</b></p>

<p style="margin-left:22%;">an unicast address</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>LOCAL</b></p></td>
<td width="4%"></td>
<td width="23%">


<p>a local address</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>BROADCAST</b></p>

<p style="margin-left:22%;">a broadcast address</p>

<p style="margin-left:11%;"><b>ANYCAST</b></p>

<p style="margin-left:22%;">an anycast packet</p>

<p style="margin-left:11%;"><b>MULTICAST</b></p>

<p style="margin-left:22%;">a multicast address</p>

<p style="margin-left:11%;"><b>BLACKHOLE</b></p>

<p style="margin-left:22%;">a blackhole address</p>

<p style="margin-left:11%;"><b>UNREACHABLE</b></p>

<p style="margin-left:22%;">an unreachable address</p>

<p style="margin-left:11%;"><b>PROHIBIT</b></p>

<p style="margin-left:22%;">a prohibited address</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>THROW</b></p></td>
<td width="4%"></td>
<td width="7%">


<p>FIXME</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>NAT</b></p></td>
<td width="4%"></td>
<td width="7%">


<p>FIXME</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>XRESOLVE</b> <br>
[<b>!</b>] <b>&minus;&minus;src&minus;type</b>
<i>type</i></p>

<p style="margin-left:22%;">Matches if the source address
is of given type</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;dst&minus;type</b> <i>type</i></p>

<p style="margin-left:22%;">Matches if the destination
address is of given type</p>


<p style="margin-left:11%;"><b>&minus;&minus;limit&minus;iface&minus;in</b></p>

<p style="margin-left:22%;">The address type checking can
be limited to the interface the packet is coming in. This
option is only valid in the <b>PREROUTING</b>, <b>INPUT</b>
and <b>FORWARD</b> chains. It cannot be specified with the
<b>&minus;&minus;limit&minus;iface&minus;out</b> option.</p>


<p style="margin-left:11%;"><b>&minus;&minus;limit&minus;iface&minus;out</b></p>

<p style="margin-left:22%;">The address type checking can
be limited to the interface the packet is going out. This
option is only valid in the <b>POSTROUTING</b>,
<b>OUTPUT</b> and <b>FORWARD</b> chains. It cannot be
specified with the
<b>&minus;&minus;limit&minus;iface&minus;in</b> option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ah
(IPv6-specific)</b> <br>
This module matches the parameters in Authentication header
of IPsec packets. <br>
[<b>!</b>] <b>&minus;&minus;ahspi</b>
<i>spi</i>[<b>:</b><i>spi</i>]</p>

<p style="margin-left:22%;">Matches SPI.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ahlen</b> <i>length</i></p>

<p style="margin-left:22%;">Total length of this header in
octets.</p>

<p style="margin-left:11%;"><b>&minus;&minus;ahres</b></p>

<p style="margin-left:22%;">Matches if the reserved field
is filled with zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ah
(IPv4-specific)</b> <br>
This module matches the SPIs in Authentication header of
IPsec packets. <br>
[<b>!</b>] <b>&minus;&minus;ahspi</b>
<i>spi</i>[<b>:</b><i>spi</i>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>bpf</b> <br>
Match using Linux Socket Filter. Expects a BPF program in
decimal format. This is the format generated by the
<b>nfbpf_compile</b> utility. <b><br>
&minus;&minus;bytecode</b> <i>code</i></p>

<p style="margin-left:22%;">Pass the BPF byte code format
(described in the example below).</p>

<p style="margin-left:11%; margin-top: 1em">The code format
is similar to the output of the tcpdump -ddd command: one
line that stores the number of instructions, followed by one
line for each instruction. Instruction lines follow the
pattern &rsquo;u16 u8 u8 u32&rsquo; in decimal notation.
Fields encode the operation, jump offset if true, jump
offset if false and generic multiuse field &rsquo;K&rsquo;.
Comments are not supported.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
read only packets matching &rsquo;ip proto 6&rsquo;, insert
the following, without the comments or trailing
whitespace:</p>

<p style="margin-left:22%; margin-top: 1em">4 # number of
instructions <br>
48 0 0 9 # load byte ip-&gt;proto <br>
21 0 1 6 # jump equal IPPROTO_TCP <br>
6 0 0 1 # return pass (non-zero) <br>
6 0 0 0 # return fail (zero)</p>

<p style="margin-left:11%; margin-top: 1em">You can pass
this filter to the bpf match with the following command:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A OUTPUT &minus;m bpf &minus;&minus;bytecode
&rsquo;4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0&rsquo; &minus;j
ACCEPT</p>

<p style="margin-left:11%; margin-top: 1em">Or instead, you
can invoke the nfbpf_compile utility.</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A OUTPUT &minus;m bpf &minus;&minus;bytecode
&quot;&lsquo;nfbpf_compile RAW &rsquo;ip proto
6&rsquo;&lsquo;&quot; &minus;j ACCEPT</p>

<p style="margin-left:11%; margin-top: 1em">You may want to
learn more about BPF from FreeBSD&rsquo;s bpf(4)
manpage.</p>

<p style="margin-left:11%; margin-top: 1em"><b>cgroup</b>
<br>
[<b>!</b>] <b>&minus;&minus;cgroup</b> <i>fwid</i></p>

<p style="margin-left:22%;">Match corresponding cgroup for
this packet.</p>

<p style="margin-left:22%; margin-top: 1em">Can be used to
assign particular firewall policies for aggregated task/jobs
on the system. This allows for more fine-grained firewall
policies that only match for a subset of the system&rsquo;s
processes. fwid is the maker set through the net_cls
cgroup&rsquo;s id.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;A OUTPUT &minus;p tcp &minus;&minus;sport 80 &minus;m
cgroup ! &minus;&minus;cgroup 1 &minus;j DROP</p>

<p style="margin-left:11%; margin-top: 1em">Available since
Linux 3.14.</p>

<p style="margin-left:11%; margin-top: 1em"><b>cluster</b>
<br>
Allows you to deploy gateway and back-end load-sharing
clusters without the need of load-balancers.</p>

<p style="margin-left:11%; margin-top: 1em">This match
requires that all the nodes see the same packets. Thus, the
cluster match decides if this node has to handle a packet
given the following options: <b><br>
&minus;&minus;cluster&minus;total&minus;nodes</b>
<i>num</i></p>

<p style="margin-left:22%;">Set number of total nodes in
cluster.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;cluster&minus;local&minus;node</b>
<i>num</i></p>

<p style="margin-left:22%;">Set the local node number
ID.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;cluster&minus;local&minus;nodemask</b>
<i>mask</i></p>

<p style="margin-left:22%;">Set the local node number ID
mask. You can use this option instead of
<b>&minus;&minus;cluster&minus;local&minus;node</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;cluster&minus;hash&minus;seed</b>
<i>value</i></p>

<p style="margin-left:22%;">Set seed value of the Jenkins
hash.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A PREROUTING &minus;t mangle &minus;i eth1 &minus;m
cluster &minus;&minus;cluster&minus;total&minus;nodes 2
&minus;&minus;cluster&minus;local&minus;node 1
&minus;&minus;cluster&minus;hash&minus;seed 0xdeadbeef
&minus;j MARK &minus;&minus;set-mark 0xffff</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A PREROUTING &minus;t mangle &minus;i eth2 &minus;m
cluster &minus;&minus;cluster&minus;total&minus;nodes 2
&minus;&minus;cluster&minus;local&minus;node 1
&minus;&minus;cluster&minus;hash&minus;seed 0xdeadbeef
&minus;j MARK -&minus;set&minus;mark 0xffff</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A PREROUTING &minus;t mangle &minus;i eth1 &minus;m
mark ! &minus;&minus;mark 0xffff &minus;j DROP</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A PREROUTING &minus;t mangle &minus;i eth2 &minus;m
mark ! &minus;&minus;mark 0xffff &minus;j DROP</p>

<p style="margin-left:11%; margin-top: 1em">And the
following commands to make all nodes see the same
packets:</p>

<p style="margin-left:22%; margin-top: 1em">ip maddr add
01:00:5e:00:01:01 dev eth1</p>

<p style="margin-left:22%; margin-top: 1em">ip maddr add
01:00:5e:00:01:02 dev eth2</p>

<p style="margin-left:22%; margin-top: 1em">arptables
&minus;A OUTPUT &minus;o eth1 &minus;&minus;h&minus;length 6
&minus;j mangle &minus;&minus;mangle-mac-s
01:00:5e:00:01:01</p>

<p style="margin-left:22%; margin-top: 1em">arptables
&minus;A INPUT &minus;i eth1 &minus;&minus;h-length 6
&minus;&minus;destination-mac 01:00:5e:00:01:01 &minus;j
mangle &minus;&minus;mangle&minus;mac&minus;d
00:zz:yy:xx:5a:27</p>

<p style="margin-left:22%; margin-top: 1em">arptables
&minus;A OUTPUT &minus;o eth2 &minus;&minus;h&minus;length 6
&minus;j mangle &minus;&minus;mangle&minus;mac&minus;s
01:00:5e:00:01:02</p>

<p style="margin-left:22%; margin-top: 1em">arptables
&minus;A INPUT &minus;i eth2 &minus;&minus;h&minus;length 6
&minus;&minus;destination&minus;mac 01:00:5e:00:01:02
&minus;j mangle &minus;&minus;mangle&minus;mac&minus;d
00:zz:yy:xx:5a:27</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE</b>:
the arptables commands above use mainstream syntax. If you
are using arptables-jf included in some RedHat, CentOS and
Fedora versions, you will hit syntax errors. Therefore,
you&rsquo;ll have to adapt these to the arptables-jf syntax
to get them working.</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
TCP connections, pickup facility has to be disabled to avoid
marking TCP ACK packets coming in the reply direction as
valid.</p>

<p style="margin-left:22%; margin-top: 1em">echo 0 &gt;
/proc/sys/net/netfilter/nf_conntrack_tcp_loose</p>

<p style="margin-left:11%; margin-top: 1em"><b>comment</b>
<br>
Allows you to add comments (up to 256 characters) to any
rule. <b><br>
&minus;&minus;comment</b> <i>comment</i> <br>
Example:</p>

<p style="margin-left:22%;">iptables &minus;A INPUT
&minus;i eth1 &minus;m comment &minus;&minus;comment
&quot;my local LAN&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>connbytes</b>
<br>
Match by how many bytes or packets a connection (or one of
the two flows constituting the connection) has transferred
so far, or by average bytes per packet.</p>

<p style="margin-left:11%; margin-top: 1em">The counters
are 64-bit and are thus not expected to overflow ;)</p>

<p style="margin-left:11%; margin-top: 1em">The primary use
is to detect long-lived downloads and mark them to be
scheduled using a lower priority band in traffic
control.</p>

<p style="margin-left:11%; margin-top: 1em">The transferred
bytes per connection can also be viewed through
&lsquo;conntrack &minus;L&lsquo; and accessed via
ctnetlink.</p>

<p style="margin-left:11%; margin-top: 1em">NOTE that for
connections which have no accounting information, the match
will always return false. The
&quot;net.netfilter.nf_conntrack_acct&quot; sysctl flag
controls whether <b>new</b> connections will be byte/packet
counted. Existing connection flows will not be
gaining/losing a/the accounting structure when be sysctl
flag is flipped. <br>
[<b>!</b>] <b>&minus;&minus;connbytes</b>
<i>from</i>[<b>:</b><i>to</i>]</p>

<p style="margin-left:22%;">match packets from a connection
whose packets/bytes/average packet size is more than FROM
and less than TO bytes/packets. if TO is omitted only FROM
check is done. &quot;!&quot; is used to match packets not
falling in the range.</p>


<p style="margin-left:11%;"><b>&minus;&minus;connbytes&minus;dir</b>
{<b>original</b>|<b>reply</b>|<b>both</b>}</p>

<p style="margin-left:22%;">which packets to consider</p>


<p style="margin-left:11%;"><b>&minus;&minus;connbytes&minus;mode</b>
{<b>packets</b>|<b>bytes</b>|<b>avgpkt</b>}</p>

<p style="margin-left:22%;">whether to check the amount of
packets, number of bytes transferred or the average size (in
bytes) of all packets received so far. Note that when
&quot;both&quot; is used together with &quot;avgpkt&quot;,
and data is going (mainly) only in one direction (for
example HTTP), the average packet size will be about half of
the actual data packets.</p>

<p style="margin-left:11%;">Example:</p>

<p style="margin-left:22%;">iptables .. &minus;m connbytes
&minus;&minus;connbytes 10000:100000
&minus;&minus;connbytes&minus;dir both
&minus;&minus;connbytes&minus;mode bytes ...</p>


<p style="margin-left:11%; margin-top: 1em"><b>connlabel</b>
<br>
Module matches or adds connlabels to a connection.
connlabels are similar to connmarks, except labels are
bit-based; i.e. all labels may be attached to a flow at the
same time. Up to 128 unique labels are currently supported.
<br>
[<b>!</b>] <b>&minus;&minus;label name</b></p>

<p style="margin-left:22%;">matches if label <b>name</b>
has been set on a connection. Instead of a name (which will
be translated to a number, see EXAMPLE below), a number may
be used instead. Using a number always overrides
connlabel.conf.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;set</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>if the label has not been set on the connection, set it.
Note that setting a label can fail. This is because the
kernel allocates the conntrack label storage area when the
connection is created, and it only reserves the amount of
memory required by the ruleset that exists at the time the
connection is created. In this case, the match will fail (or
succeed, in case <b>&minus;&minus;label</b> option was
negated).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This match
depends on libnetfilter_conntrack 1.0.4 or later. Label
translation is done via the
<b>/etc/xtables/connlabel.conf</b> configuration file.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">0 eth0-in</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>1</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>eth0-out</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>2</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>ppp-in</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>3</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>ppp-out</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>4</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>bulk-traffic</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>5</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="85%">


<p>interactive</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>connlimit</b>
<br>
Allows you to restrict the number of parallel connections to
a server per client IP address (or client address block).
<b><br>
&minus;&minus;connlimit&minus;upto</b> <i>n</i></p>

<p style="margin-left:22%;">Match if the number of existing
connections is below or equal <i>n</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;connlimit&minus;above</b>
<i>n</i></p>

<p style="margin-left:22%;">Match if the number of existing
connections is above <i>n</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;connlimit&minus;mask</b>
<i>prefix_length</i></p>

<p style="margin-left:22%;">Group hosts using the prefix
length. For IPv4, this must be a number between (including)
0 and 32. For IPv6, between 0 and 128. If not specified, the
maximum prefix length for the applicable protocol is
used.</p>


<p style="margin-left:11%;"><b>&minus;&minus;connlimit&minus;saddr</b></p>

<p style="margin-left:22%;">Apply the limit onto the source
group. This is the default if
&minus;&minus;connlimit&minus;daddr is not specified.</p>


<p style="margin-left:11%;"><b>&minus;&minus;connlimit&minus;daddr</b></p>

<p style="margin-left:22%;">Apply the limit onto the
destination group.</p>

<p style="margin-left:11%; margin-top: 1em">Examples: <br>
# allow 2 telnet connections per client host</p>

<p style="margin-left:22%;">iptables &minus;A INPUT
&minus;p tcp &minus;&minus;syn &minus;&minus;dport 23
&minus;m connlimit &minus;&minus;connlimit&minus;above 2
&minus;j REJECT</p>

<p style="margin-left:11%;"># you can also match the other
way around:</p>

<p style="margin-left:22%;">iptables &minus;A INPUT
&minus;p tcp &minus;&minus;syn &minus;&minus;dport 23
&minus;m connlimit &minus;&minus;connlimit&minus;upto 2
&minus;j ACCEPT</p>

<p style="margin-left:11%;"># limit the number of parallel
HTTP requests to 16 per class C sized <br>
source network (24 bit netmask)</p>

<p style="margin-left:22%;">iptables &minus;p tcp
&minus;&minus;syn &minus;&minus;dport 80 &minus;m connlimit
&minus;&minus;connlimit&minus;above 16
&minus;&minus;connlimit&minus;mask 24 &minus;j REJECT</p>

<p style="margin-left:11%;"># limit the number of parallel
HTTP requests to 16 for the link local <br>
network</p>

<p style="margin-left:22%;">(ipv6) ip6tables &minus;p tcp
&minus;&minus;syn &minus;&minus;dport 80 &minus;s fe80::/64
&minus;m connlimit &minus;&minus;connlimit&minus;above 16
&minus;&minus;connlimit&minus;mask 64 &minus;j REJECT</p>

<p style="margin-left:11%;"># Limit the number of
connections to a particular host:</p>

<p style="margin-left:22%;">ip6tables &minus;p tcp
&minus;&minus;syn &minus;&minus;dport 49152:65535 &minus;d
2001:db8::1 &minus;m connlimit &minus;&minus;connlimit-above
100 &minus;j REJECT</p>


<p style="margin-left:11%; margin-top: 1em"><b>connmark</b>
<br>
This module matches the netfilter mark field associated with
a connection (which can be set using the <b>CONNMARK</b>
target below). <br>
[<b>!</b>] <b>&minus;&minus;mark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches packets in connections
with the given mark value (if a mask is specified, this is
logically ANDed with the mark before the comparison).</p>


<p style="margin-left:11%; margin-top: 1em"><b>conntrack</b>
<br>
This module, when combined with connection tracking, allows
access to the connection tracking state for this
packet/connection. <br>
[<b>!</b>] <b>&minus;&minus;ctstate</b> <i>statelist</i></p>

<p style="margin-left:22%;"><i>statelist</i> is a comma
separated list of the connection states to match. Possible
states are listed below.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ctproto</b> <i>l4proto</i></p>

<p style="margin-left:22%;">Layer-4 protocol to match (by
number or name)</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ctorigsrc</b>
<i>address</i>[<b>/</b><i>mask</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctorigdst</b>
<i>address</i>[<b>/</b><i>mask</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctreplsrc</b>
<i>address</i>[<b>/</b><i>mask</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctrepldst</b>
<i>address</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Match against original/reply
source/destination address</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ctorigsrcport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctorigdstport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctreplsrcport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>] <b>&minus;&minus;ctrepldstport</b>
<i>port</i>[<b>:</b><i>port</i>]</p>

<p style="margin-left:22%;">Match against original/reply
source/destination port (TCP/UDP/etc.) or GRE key. Matching
against port ranges is only supported in kernel versions
above 2.6.38.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ctstatus</b> <i>statelist</i></p>

<p style="margin-left:22%;"><i>statuslist</i> is a comma
separated list of the connection statuses to match. Possible
statuses are listed below.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ctexpire</b>
<i>time</i>[<b>:</b><i>time</i>]</p>

<p style="margin-left:22%;">Match remaining lifetime in
seconds against given value or range of values
(inclusive)</p>

<p style="margin-left:11%;"><b>&minus;&minus;ctdir</b>
{<b>ORIGINAL</b>|<b>REPLY</b>}</p>

<p style="margin-left:22%;">Match packets that are flowing
in the specified direction. If this flag is not specified at
all, matches packets in both directions.</p>

<p style="margin-left:11%; margin-top: 1em">States for
<b>&minus;&minus;ctstate</b>: <b><br>
INVALID</b></p>

<p style="margin-left:22%;">The packet is associated with
no known connection.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>NEW</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The packet has started a new connection or otherwise
associated with a connection which has not seen packets in
both directions.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ESTABLISHED</b></p>

<p style="margin-left:22%;">The packet is associated with a
connection which has seen packets in both directions.</p>

<p style="margin-left:11%;"><b>RELATED</b></p>

<p style="margin-left:22%;">The packet is starting a new
connection, but is associated with an existing connection,
such as an FTP data transfer or an ICMP error.</p>

<p style="margin-left:11%;"><b>UNTRACKED</b></p>

<p style="margin-left:22%;">The packet is not tracked at
all, which happens if you explicitly untrack it by using
&minus;j CT &minus;&minus;notrack in the raw table.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>SNAT</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>A virtual state, matching if the original source address
differs from the reply destination.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>DNAT</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>A virtual state, matching if the original destination
differs from the reply source.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Statuses for
<b>&minus;&minus;ctstatus</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>NONE</b></p></td>
<td width="5%"></td>
<td width="27%">


<p style="margin-top: 1em">None of the below.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>EXPECTED</b></p>

<p style="margin-left:22%;">This is an expected connection
(i.e. a conntrack helper set it up).</p>

<p style="margin-left:11%;"><b>SEEN_REPLY</b></p>

<p style="margin-left:22%;">Conntrack has seen packets in
both directions.</p>

<p style="margin-left:11%;"><b>ASSURED</b></p>

<p style="margin-left:22%;">Conntrack entry should never be
early-expired.</p>

<p style="margin-left:11%;"><b>CONFIRMED</b></p>

<p style="margin-left:22%;">Connection is confirmed:
originating packet has left box.</p>

<p style="margin-left:11%; margin-top: 1em"><b>cpu</b> <br>
[<b>!</b>] <b>&minus;&minus;cpu</b> <i>number</i></p>

<p style="margin-left:22%;">Match cpu handling this packet.
cpus are numbered from 0 to NR_CPUS-1 Can be used in
combination with RPS (Remote Packet Steering) or multiqueue
NICs to spread network traffic on different queues.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t nat &minus;A PREROUTING &minus;p tcp
&minus;&minus;dport 80 &minus;m cpu &minus;&minus;cpu 0
&minus;j REDIRECT &minus;&minus;to&minus;port 8080</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t nat &minus;A PREROUTING &minus;p tcp
&minus;&minus;dport 80 &minus;m cpu &minus;&minus;cpu 1
&minus;j REDIRECT &minus;&minus;to&minus;port 8081</p>

<p style="margin-left:11%; margin-top: 1em">Available since
Linux 2.6.36.</p>

<p style="margin-left:11%; margin-top: 1em"><b>dccp</b>
<br>
[<b>!</b>]
<b>&minus;&minus;source&minus;port</b>,<b>&minus;&minus;sport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>]
<b>&minus;&minus;destination&minus;port</b>,<b>&minus;&minus;dport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>] <b>&minus;&minus;dccp&minus;types</b>
<i>mask</i></p>

<p style="margin-left:22%;">Match when the DCCP packet type
is one of &rsquo;mask&rsquo;. &rsquo;mask&rsquo; is a
comma-separated list of packet types. Packet types are:
<b>REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET
SYNC SYNCACK INVALID</b>.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;dccp&minus;option</b> <i>number</i></p>

<p style="margin-left:22%;">Match if DCCP option set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>devgroup</b>
<br>
Match device group of a packets incoming/outgoing interface.
<br>
[<b>!</b>] <b>&minus;&minus;src&minus;group</b>
<i>name</i></p>

<p style="margin-left:22%;">Match device group of incoming
device</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;dst&minus;group</b> <i>name</i></p>

<p style="margin-left:22%;">Match device group of outgoing
device</p>

<p style="margin-left:11%; margin-top: 1em"><b>dscp</b>
<br>
This module matches the 6 bit DSCP field within the TOS
field in the IP header. DSCP has superseded TOS within the
IETF. <br>
[<b>!</b>] <b>&minus;&minus;dscp</b> <i>value</i></p>

<p style="margin-left:22%;">Match against a numeric
(decimal or hex) value [0-63].</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;dscp&minus;class</b> <i>class</i></p>

<p style="margin-left:22%;">Match the DiffServ class. This
value may be any of the BE, EF, AFxx or CSx classes. It will
then be converted into its according numeric value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>dst
(IPv6-specific)</b> <br>
This module matches the parameters in Destination Options
header <br>
[<b>!</b>] <b>&minus;&minus;dst&minus;len</b>
<i>length</i></p>

<p style="margin-left:22%;">Total length of this header in
octets.</p>


<p style="margin-left:11%;"><b>&minus;&minus;dst&minus;opts</b>
<i>type</i>[<b>:</b><i>length</i>][<b>,</b><i>type</i>[<b>:</b><i>length</i>]...]</p>

<p style="margin-left:22%;">numeric type of option and the
length of the option data in octets.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ecn</b> <br>
This allows you to match the ECN bits of the IPv4/IPv6 and
TCP header. ECN is the Explicit Congestion Notification
mechanism as specified in RFC3168 <br>
[<b>!</b>] <b>&minus;&minus;ecn&minus;tcp&minus;cwr</b></p>

<p style="margin-left:22%;">This matches if the TCP ECN CWR
(Congestion Window Received) bit is set.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ecn&minus;tcp&minus;ece</b></p>

<p style="margin-left:22%;">This matches if the TCP ECN ECE
(ECN Echo) bit is set.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ecn&minus;ip&minus;ect</b> <i>num</i></p>

<p style="margin-left:22%;">This matches a particular
IPv4/IPv6 ECT (ECN-Capable Transport). You have to specify a
number between &lsquo;0&rsquo; and &lsquo;3&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>esp</b> <br>
This module matches the SPIs in ESP header of IPsec packets.
<br>
[<b>!</b>] <b>&minus;&minus;espspi</b>
<i>spi</i>[<b>:</b><i>spi</i>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>eui64
(IPv6-specific)</b> <br>
This module matches the EUI-64 part of a stateless
autoconfigured IPv6 address. It compares the EUI-64 derived
from the source MAC address in Ethernet frame with the lower
64 bits of the IPv6 source address. But
&quot;Universal/Local&quot; bit is not compared. This module
doesn&rsquo;t match other link layer frame, and is only
valid in the <b>PREROUTING</b>, <b>INPUT</b> and
<b>FORWARD</b> chains.</p>

<p style="margin-left:11%; margin-top: 1em"><b>frag
(IPv6-specific)</b> <br>
This module matches the parameters in Fragment header. <br>
[<b>!</b>] <b>&minus;&minus;fragid</b>
<i>id</i>[<b>:</b><i>id</i>]</p>

<p style="margin-left:22%;">Matches the given
Identification or range of it.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;fraglen</b> <i>length</i></p>

<p style="margin-left:22%;">This option cannot be used with
kernel version 2.6.10 or later. The length of Fragment
header is static and this option doesn&rsquo;t make
sense.</p>


<p style="margin-left:11%;"><b>&minus;&minus;fragres</b></p>

<p style="margin-left:22%;">Matches if the reserved fields
are filled with zero.</p>


<p style="margin-left:11%;"><b>&minus;&minus;fragfirst</b></p>

<p style="margin-left:22%;">Matches on the first
fragment.</p>


<p style="margin-left:11%;"><b>&minus;&minus;fragmore</b></p>

<p style="margin-left:22%;">Matches if there are more
fragments.</p>


<p style="margin-left:11%;"><b>&minus;&minus;fraglast</b></p>

<p style="margin-left:22%;">Matches if this is the last
fragment.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hashlimit
<br>
hashlimit</b> uses hash buckets to express a rate limiting
match (like the <b>limit</b> match) for a group of
connections using a <b>single</b> iptables rule. Grouping
can be done per-hostgroup (source and/or destination
address) and/or per-port. It gives you the ability to
express &quot;<i>N</i> packets per time quantum per
group&quot; or &quot;<i>N</i> bytes per seconds&quot; (see
below for some examples).</p>

<p style="margin-left:11%; margin-top: 1em">A hash limit
option (<b>&minus;&minus;hashlimit&minus;upto</b>,
<b>&minus;&minus;hashlimit&minus;above</b>) and
<b>&minus;&minus;hashlimit&minus;name</b> are required.
<b><br>
&minus;&minus;hashlimit&minus;upto</b>
<i>amount</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]</p>

<p style="margin-left:22%;">Match if the rate is below or
equal to <i>amount</i>/quantum. It is specified either as a
number, with an optional time quantum suffix (the default is
3/hour), or as <i>amount</i>b/second (number of bytes per
second).</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;above</b>
<i>amount</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]</p>

<p style="margin-left:22%;">Match if the rate is above
<i>amount</i>/quantum.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;burst</b>
<i>amount</i></p>

<p style="margin-left:22%;">Maximum initial number of
packets to match: this number gets recharged by one every
time the limit specified above is not reached, up to this
number; the default is 5. When byte-based rate matching is
requested, this option specifies the amount of bytes that
can exceed the given rate. This option should be used with
caution -- if the entry expires, the burst value is reset
too.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;mode</b>
{<b>srcip</b>|<b>srcport</b>|<b>dstip</b>|<b>dstport</b>}<b>,</b>...</p>

<p style="margin-left:22%;">A comma-separated list of
objects to take into consideration. If no
&minus;&minus;hashlimit&minus;mode option is given,
hashlimit acts like limit, but at the expensive of doing the
hash housekeeping.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;srcmask</b>
<i>prefix</i></p>

<p style="margin-left:22%;">When
&minus;&minus;hashlimit&minus;mode srcip is used, all source
addresses encountered will be grouped according to the given
prefix length and the so-created subnet will be subject to
hashlimit. <i>prefix</i> must be between (inclusive) 0 and
32. Note that &minus;&minus;hashlimit&minus;srcmask 0 is
basically doing the same thing as not specifying srcip for
&minus;&minus;hashlimit&minus;mode, but is technically more
expensive.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;dstmask</b>
<i>prefix</i></p>

<p style="margin-left:22%;">Like
&minus;&minus;hashlimit&minus;srcmask, but for destination
addresses.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;name</b>
<i>foo</i></p>

<p style="margin-left:22%;">The name for the
/proc/net/ipt_hashlimit/foo entry.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;htable&minus;size</b>
<i>buckets</i></p>

<p style="margin-left:22%;">The number of buckets of the
hash table</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;htable&minus;max</b>
<i>entries</i></p>

<p style="margin-left:22%;">Maximum entries in the
hash.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;htable&minus;expire</b>
<i>msec</i></p>

<p style="margin-left:22%;">After how many milliseconds do
hash entries expire.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashlimit&minus;htable&minus;gcinterval</b>
<i>msec</i></p>

<p style="margin-left:22%;">How many milliseconds between
garbage collection intervals.</p>

<p style="margin-left:11%; margin-top: 1em">Examples: <br>
matching on source host</p>

<p style="margin-left:22%;">&quot;1000 packets per second
for every host in 192.168.0.0/16&quot; =&gt; &minus;s
192.168.0.0/16 &minus;&minus;hashlimit&minus;mode srcip
&minus;&minus;hashlimit&minus;upto 1000/sec</p>

<p style="margin-left:11%;">matching on source port</p>

<p style="margin-left:22%;">&quot;100 packets per second
for every service of 192.168.1.1&quot; =&gt; &minus;s
192.168.1.1 &minus;&minus;hashlimit&minus;mode srcport
&minus;&minus;hashlimit&minus;upto 100/sec</p>

<p style="margin-left:11%;">matching on subnet</p>

<p style="margin-left:22%;">&quot;10000 packets per minute
for every /28 subnet (groups of 8 addresses) in
10.0.0.0/8&quot; =&gt; &minus;s 10.0.0.0/8
&minus;&minus;hashlimit&minus;mask 28
&minus;&minus;hashlimit&minus;upto 10000/min</p>

<p style="margin-left:11%;">matching bytes per second</p>

<p style="margin-left:22%;">&quot;flows exceeding
512kbyte/s&quot; =&gt; &minus;&minus;hashlimit-mode
srcip,dstip,srcport,dstport
&minus;&minus;hashlimit&minus;above 512kb/s</p>

<p style="margin-left:11%;">matching bytes per second</p>

<p style="margin-left:22%;">&quot;hosts that exceed
512kbyte/s, but permit up to 1Megabytes without
matching&quot; &minus;&minus;hashlimit-mode dstip
&minus;&minus;hashlimit&minus;above 512kb/s
&minus;&minus;hashlimit-burst 1mb</p>

<p style="margin-left:11%; margin-top: 1em"><b>hbh
(IPv6-specific)</b> <br>
This module matches the parameters in Hop-by-Hop Options
header <br>
[<b>!</b>] <b>&minus;&minus;hbh&minus;len</b>
<i>length</i></p>

<p style="margin-left:22%;">Total length of this header in
octets.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hbh&minus;opts</b>
<i>type</i>[<b>:</b><i>length</i>][<b>,</b><i>type</i>[<b>:</b><i>length</i>]...]</p>

<p style="margin-left:22%;">numeric type of option and the
length of the option data in octets.</p>

<p style="margin-left:11%; margin-top: 1em"><b>helper</b>
<br>
This module matches packets related to a specific
conntrack-helper. <br>
[<b>!</b>] <b>&minus;&minus;helper</b> <i>string</i></p>

<p style="margin-left:22%;">Matches packets related to the
specified conntrack-helper.</p>

<p style="margin-left:22%; margin-top: 1em">string can be
&quot;ftp&quot; for packets related to a ftp-session on
default port. For other ports append &minus;portnr to the
value, ie. &quot;ftp&minus;2121&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">Same rules
apply for other conntrack-helpers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hl
(IPv6-specific)</b> <br>
This module matches the Hop Limit field in the IPv6 header.
<br>
[<b>!</b>] <b>&minus;&minus;hl&minus;eq</b> <i>value</i></p>

<p style="margin-left:22%;">Matches if Hop Limit equals
<i>value</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hl&minus;lt</b>
<i>value</i></p>

<p style="margin-left:22%;">Matches if Hop Limit is less
than <i>value</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hl&minus;gt</b>
<i>value</i></p>

<p style="margin-left:22%;">Matches if Hop Limit is greater
than <i>value</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>icmp
(IPv4-specific)</b> <br>
This extension can be used if &lsquo;&minus;&minus;protocol
icmp&rsquo; is specified. It provides the following option:
<br>
[<b>!</b>] <b>&minus;&minus;icmp&minus;type</b>
{<i>type</i>[<b>/</b><i>code</i>]|<i>typename</i>}</p>

<p style="margin-left:22%;">This allows specification of
the ICMP type, which can be a numeric ICMP type, type/code
pair, or one of the ICMP type names shown by the command
<br>
iptables &minus;p icmp &minus;h</p>

<p style="margin-left:11%; margin-top: 1em"><b>icmp6
(IPv6-specific)</b> <br>
This extension can be used if &lsquo;&minus;&minus;protocol
ipv6&minus;icmp&rsquo; or &lsquo;&minus;&minus;protocol
icmpv6&rsquo; is specified. It provides the following
option: <br>
[<b>!</b>] <b>&minus;&minus;icmpv6&minus;type</b>
<i>type</i>[<b>/</b><i>code</i>]|<i>typename</i></p>

<p style="margin-left:22%;">This allows specification of
the ICMPv6 type, which can be a numeric ICMPv6 <i>type</i>,
<i>type</i> and <i>code</i>, or one of the ICMPv6 type names
shown by the command <br>
ip6tables &minus;p ipv6&minus;icmp &minus;h</p>

<p style="margin-left:11%; margin-top: 1em"><b>iprange</b>
<br>
This matches on a given arbitrary range of IP addresses.
<br>
[<b>!</b>] <b>&minus;&minus;src&minus;range</b>
<i>from</i>[<b>&minus;</b><i>to</i>]</p>

<p style="margin-left:22%;">Match source IP in the
specified range.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;dst&minus;range</b>
<i>from</i>[<b>&minus;</b><i>to</i>]</p>

<p style="margin-left:22%;">Match destination IP in the
specified range.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ipv6header
(IPv6-specific)</b> <br>
This module matches IPv6 extension headers and/or upper
layer header.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;soft</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Matches if the packet includes <b>any</b> of the headers
specified with <b>&minus;&minus;header</b>.</p></td></tr>
</table>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;header</b>
<i>header</i>[<b>,</b><i>header</i>...]</p>

<p style="margin-left:22%;">Matches the packet which
EXACTLY includes all specified headers. The headers
encapsulated with ESP header are out of scope. Possible
<i>header</i> types can be:</p>


<p style="margin-left:11%;"><b>hop</b>|<b>hop&minus;by&minus;hop</b></p>

<p style="margin-left:22%;">Hop-by-Hop Options header</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>dst</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Destination Options header</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>route</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Routing header</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>frag</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Fragment header</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>auth</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Authentication header</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>esp</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Encapsulating Security Payload header</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>none</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>No Next header which matches 59 in the &rsquo;Next
Header field&rsquo; of IPv6 header or any IPv6 extension
headers</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>proto</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>which matches any upper layer protocol header. A
protocol name from /etc/protocols and numeric value also
allowed. The number 255 is equivalent to <b>proto</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>ipvs</b>
<br>
Match IPVS connection properties. <br>
[<b>!</b>] <b>&minus;&minus;ipvs</b></p>

<p style="margin-left:22%;">packet belongs to an IPVS
connection</p>

<p style="margin-left:11%;">Any of the following options
implies &minus;&minus;ipvs (even negated) <br>
[<b>!</b>] <b>&minus;&minus;vproto</b> <i>protocol</i></p>

<p style="margin-left:22%;">VIP protocol to match; by
number or name, e.g. &quot;tcp&quot;</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;vaddr</b>
<i>address</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">VIP address to match</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;vport</b> <i>port</i></p>

<p style="margin-left:22%;">VIP port to match; by number or
name, e.g. &quot;http&quot;</p>

<p style="margin-left:11%;"><b>&minus;&minus;vdir</b>
{<b>ORIGINAL</b>|<b>REPLY</b>}</p>

<p style="margin-left:22%;">flow direction of packet</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;vmethod</b>
{<b>GATE</b>|<b>IPIP</b>|<b>MASQ</b>}</p>

<p style="margin-left:22%;">IPVS forwarding method used</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;vportctl</b> <i>port</i></p>

<p style="margin-left:22%;">VIP port of the controlling
connection to match, e.g. 21 for FTP</p>

<p style="margin-left:11%; margin-top: 1em"><b>length</b>
<br>
This module matches the length of the layer-3 payload (e.g.
layer-4 packet) of a packet against a specific value or
range of values. <br>
[<b>!</b>] <b>&minus;&minus;length</b>
<i>length</i>[<b>:</b><i>length</i>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>limit</b>
<br>
This module matches at a limited rate using a token bucket
filter. A rule using this extension will match until this
limit is reached. It can be used in combination with the
<b>LOG</b> target to give limited logging, for example.</p>

<p style="margin-left:11%; margin-top: 1em">xt_limit has no
negation support - you will have to use &minus;m hashlimit !
&minus;&minus;hashlimit <i>rate</i> in this case whilst
omitting &minus;&minus;hashlimit&minus;mode. <b><br>
&minus;&minus;limit</b>
<i>rate</i>[<b>/second</b>|<b>/minute</b>|<b>/hour</b>|<b>/day</b>]</p>

<p style="margin-left:22%;">Maximum average matching rate:
specified as a number, with an optional
&lsquo;/second&rsquo;, &lsquo;/minute&rsquo;,
&lsquo;/hour&rsquo;, or &lsquo;/day&rsquo; suffix; the
default is 3/hour.</p>


<p style="margin-left:11%;"><b>&minus;&minus;limit&minus;burst</b>
<i>number</i></p>

<p style="margin-left:22%;">Maximum initial number of
packets to match: this number gets recharged by one every
time the limit specified above is not reached, up to this
number; the default is 5.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mac</b> <br>
[<b>!</b>] <b>&minus;&minus;mac&minus;source</b>
<i>address</i></p>

<p style="margin-left:22%;">Match source MAC address. It
must be of the form XX:XX:XX:XX:XX:XX. Note that this only
makes sense for packets coming from an Ethernet device and
entering the <b>PREROUTING</b>, <b>FORWARD</b> or
<b>INPUT</b> chains.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mark</b>
<br>
This module matches the netfilter mark field associated with
a packet (which can be set using the <b>MARK</b> target
below). <br>
[<b>!</b>] <b>&minus;&minus;mark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches packets with the given
unsigned mark value (if a <i>mask</i> is specified, this is
logically ANDed with the <i>mask</i> before the
comparison).</p>

<p style="margin-left:11%; margin-top: 1em"><b>mh
(IPv6-specific)</b> <br>
This extension is loaded if &lsquo;&minus;&minus;protocol
ipv6&minus;mh&rsquo; or &lsquo;&minus;&minus;protocol
mh&rsquo; is specified. It provides the following option:
<br>
[<b>!</b>] <b>&minus;&minus;mh&minus;type</b>
<i>type</i>[<b>:</b><i>type</i>]</p>

<p style="margin-left:22%;">This allows specification of
the Mobility Header(MH) type, which can be a numeric MH
<i>type</i>, <i>type</i> or one of the MH type names shown
by the command <br>
ip6tables &minus;p mh &minus;h</p>


<p style="margin-left:11%; margin-top: 1em"><b>multiport</b>
<br>
This module matches a set of source or destination ports. Up
to 15 ports can be specified. A port range (port:port)
counts as two ports. It can only be used in conjunction with
one of the following protocols: <b>tcp</b>, <b>udp</b>,
<b>udplite</b>, <b>dccp</b> and <b>sctp</b>. <br>
[<b>!</b>]
<b>&minus;&minus;source&minus;ports</b>,<b>&minus;&minus;sports</b>
<i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</p>

<p style="margin-left:22%;">Match if the source port is one
of the given ports. The flag <b>&minus;&minus;sports</b> is
a convenient alias for this option. Multiple ports or port
ranges are separated using a comma, and a port range is
specified using a colon. <b>53,1024:65535</b> would
therefore match ports 53 and all from 1024 through
65535.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;destination&minus;ports</b>,<b>&minus;&minus;dports</b>
<i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</p>

<p style="margin-left:22%;">Match if the destination port
is one of the given ports. The flag
<b>&minus;&minus;dports</b> is a convenient alias for this
option.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;ports</b>
<i>port</i>[<b>,</b><i>port</i>|<b>,</b><i>port</i><b>:</b><i>port</i>]...</p>

<p style="margin-left:22%;">Match if either the source or
destination ports are equal to one of the given ports.</p>

<p style="margin-left:11%; margin-top: 1em"><b>nfacct</b>
<br>
The nfacct match provides the extended accounting
infrastructure for iptables. You have to use this match
together with the standalone user-space utility
<b>nfacct(8)</b></p>

<p style="margin-left:11%; margin-top: 1em">The only option
available for this match is the following: <b><br>
&minus;&minus;nfacct&minus;name</b> <i>name</i></p>

<p style="margin-left:22%;">This allows you to specify the
existing object name that will be use for accounting the
traffic that this rule-set is matching.</p>

<p style="margin-left:11%; margin-top: 1em">To use this
extension, you have to create an accounting object:</p>

<p style="margin-left:22%; margin-top: 1em">nfacct add
http&minus;traffic</p>

<p style="margin-left:11%; margin-top: 1em">Then, you have
to attach it to the accounting object via iptables:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;I INPUT &minus;p tcp &minus;&minus;sport 80 &minus;m
nfacct &minus;&minus;nfacct&minus;name
http&minus;traffic</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;I OUTPUT &minus;p tcp &minus;&minus;dport 80 &minus;m
nfacct &minus;&minus;nfacct&minus;name
http&minus;traffic</p>

<p style="margin-left:11%; margin-top: 1em">Then, you can
check for the amount of traffic that the rules match:</p>

<p style="margin-left:22%; margin-top: 1em">nfacct get
http&minus;traffic</p>

<p style="margin-left:22%; margin-top: 1em">{ pkts =
00000000000000000156, bytes = 00000000000000151786 } =
http-traffic;</p>

<p style="margin-left:11%; margin-top: 1em">You can obtain
<b>nfacct(8)</b> from http://www.netfilter.org or,
alternatively, from the git.netfilter.org repository.</p>

<p style="margin-left:11%; margin-top: 1em"><b>osf</b> <br>
The osf module does passive operating system fingerprinting.
This modules compares some data (Window Size, MSS, options
and their order, TTL, DF, and others) from packets with the
SYN bit set. <br>
[<b>!</b>] <b>&minus;&minus;genre</b> <i>string</i></p>

<p style="margin-left:22%;">Match an operating system genre
by using a passive fingerprinting.</p>

<p style="margin-left:11%;"><b>&minus;&minus;ttl</b>
<i>level</i></p>

<p style="margin-left:22%;">Do additional TTL checks on the
packet to determine the operating system. <i>level</i> can
be one of the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>0 - True IP address and fingerprint TTL comparison. This
generally works for LANs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>1 - Check if the IP header&rsquo;s TTL is less than the
fingerprint one. Works for globally-routable addresses.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>2 - Do not compare the TTL at all.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;log</b>
<i>level</i></p>

<p style="margin-left:17%;">Log determined genres into
dmesg even if they do not match the desired one.
<i>level</i> can be one of the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="63%">


<p>0 - Log all matched or unknown signatures</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="63%">


<p>1 - Log only the first one</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="63%">


<p>2 - Log all known matched signatures</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">You may find
something like this in syslog:</p>

<p style="margin-left:11%; margin-top: 1em">Windows
[2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024
-&gt; 11.22.33.44:139 hops=3 Linux [2.5-2.6:] :
1.2.3.4:42624 -&gt; 1.2.3.5:22 hops=4</p>

<p style="margin-left:11%; margin-top: 1em">OS fingerprints
are loadable using the <b>nfnl_osf</b> program. To load
fingerprints from a file, use:</p>

<p style="margin-left:11%; margin-top: 1em"><b>nfnl_osf -f
/usr/share/xtables/pf.os</b></p>

<p style="margin-left:11%; margin-top: 1em">To remove them
again,</p>

<p style="margin-left:11%; margin-top: 1em"><b>nfnl_osf -f
/usr/share/xtables/pf.os -d</b></p>

<p style="margin-left:11%; margin-top: 1em">The fingerprint
database can be downlaoded from
http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os .</p>

<p style="margin-left:11%; margin-top: 1em"><b>owner</b>
<br>
This module attempts to match various characteristics of the
packet creator, for locally generated packets. This match is
only valid in the OUTPUT and POSTROUTING chains. Forwarded
packets do not have any socket associated with them. Packets
from kernel threads do have a socket, but usually no owner.
<br>
[<b>!</b>] <b>&minus;&minus;uid&minus;owner</b>
<i>username</i> <br>
[<b>!</b>] <b>&minus;&minus;uid&minus;owner</b>
<i>userid</i>[<b>&minus;</b><i>userid</i>]</p>

<p style="margin-left:22%;">Matches if the packet
socket&rsquo;s file structure (if it has one) is owned by
the given user. You may also specify a numerical UID, or an
UID range.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;gid&minus;owner</b> <i>groupname</i> <br>
[<b>!</b>] <b>&minus;&minus;gid&minus;owner</b>
<i>groupid</i>[<b>&minus;</b><i>groupid</i>]</p>

<p style="margin-left:22%;">Matches if the packet
socket&rsquo;s file structure is owned by the given group.
You may also specify a numerical GID, or a GID range.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;socket&minus;exists</b></p>

<p style="margin-left:22%;">Matches if the packet is
associated with a socket.</p>

<p style="margin-left:11%; margin-top: 1em"><b>physdev</b>
<br>
This module matches on the bridge port input and output
devices enslaved to a bridge device. This module is a part
of the infrastructure that enables a transparent bridging IP
firewall and is only useful for kernel versions above
version 2.5.44. <br>
[<b>!</b>] <b>&minus;&minus;physdev&minus;in</b>
<i>name</i></p>

<p style="margin-left:22%;">Name of a bridge port via which
a packet is received (only for packets entering the
<b>INPUT</b>, <b>FORWARD</b> and <b>PREROUTING</b> chains).
If the interface name ends in a &quot;+&quot;, then any
interface which begins with this name will match. If the
packet didn&rsquo;t arrive through a bridge device, this
packet won&rsquo;t match this option, unless &rsquo;!&rsquo;
is used.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;physdev&minus;out</b> <i>name</i></p>

<p style="margin-left:22%;">Name of a bridge port via which
a packet is going to be sent (for packets entering the
<b>FORWARD</b>, <b>OUTPUT</b> and <b>POSTROUTING</b>
chains). If the interface name ends in a &quot;+&quot;, then
any interface which begins with this name will match. Note
that in the <b>nat</b> and <b>mangle OUTPUT</b> chains one
cannot match on the bridge output port, however one can in
the <b>filter OUTPUT</b> chain. If the packet won&rsquo;t
leave by a bridge device or if it is yet unknown what the
output device will be, then the packet won&rsquo;t match
this option, unless &rsquo;!&rsquo; is used.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;physdev&minus;is&minus;in</b></p>

<p style="margin-left:22%;">Matches if the packet has
entered through a bridge interface.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;physdev&minus;is&minus;out</b></p>

<p style="margin-left:22%;">Matches if the packet will
leave through a bridge interface.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;physdev&minus;is&minus;bridged</b></p>

<p style="margin-left:22%;">Matches if the packet is being
bridged and therefore is not being routed. This is only
useful in the FORWARD and POSTROUTING chains.</p>

<p style="margin-left:11%; margin-top: 1em"><b>pkttype</b>
<br>
This module matches the link-layer packet type. <br>
[<b>!</b>] <b>&minus;&minus;pkt&minus;type</b>
{<b>unicast</b>|<b>broadcast</b>|<b>multicast</b>}</p>

<p style="margin-left:11%; margin-top: 1em"><b>policy</b>
<br>
This modules matches the policy used by IPsec for handling a
packet. <b><br>
&minus;&minus;dir</b> {<b>in</b>|<b>out</b>}</p>

<p style="margin-left:22%;">Used to select whether to match
the policy used for decapsulation or the policy that will be
used for encapsulation. <b>in</b> is valid in the
<b>PREROUTING, INPUT and FORWARD</b> chains, <b>out</b> is
valid in the <b>POSTROUTING, OUTPUT and FORWARD</b>
chains.</p>

<p style="margin-left:11%;"><b>&minus;&minus;pol</b>
{<b>none</b>|<b>ipsec</b>}</p>

<p style="margin-left:22%;">Matches if the packet is
subject to IPsec processing. <b>&minus;&minus;pol none</b>
cannot be combined with <b>&minus;&minus;strict</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;strict</b></p>

<p style="margin-left:22%;">Selects whether to match the
exact policy or match if any rule of the policy matches the
given policy.</p>

<p style="margin-left:11%; margin-top: 1em">For each policy
element that is to be described, one can use one or more of
the following options. When <b>&minus;&minus;strict</b> is
in effect, at least one must be used per element. <br>
[<b>!</b>] <b>&minus;&minus;reqid</b> <i>id</i></p>

<p style="margin-left:22%;">Matches the reqid of the policy
rule. The reqid can be specified with <b>setkey(8)</b> using
<b>unique:id</b> as level.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;spi</b> <i>spi</i></p>

<p style="margin-left:22%;">Matches the SPI of the SA.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;proto</b>
{<b>ah</b>|<b>esp</b>|<b>ipcomp</b>}</p>

<p style="margin-left:22%;">Matches the encapsulation
protocol.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;mode</b>
{<b>tunnel</b>|<b>transport</b>}</p>

<p style="margin-left:22%;">Matches the encapsulation
mode.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;tunnel&minus;src</b>
<i>addr</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches the source end-point
address of a tunnel mode SA. Only valid with
<b>&minus;&minus;mode tunnel</b>.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;tunnel&minus;dst</b>
<i>addr</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches the destination
end-point address of a tunnel mode SA. Only valid with
<b>&minus;&minus;mode tunnel</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;next</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Start the next element in the policy specification. Can
only be used with <b>&minus;&minus;strict</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>quota</b>
<br>
Implements network quotas by decrementing a byte counter
with each packet. The condition matches until the byte
counter reaches zero. Behavior is reversed with negation
(i.e. the condition does not match until the byte counter
reaches zero). <br>
[<b>!</b>] <b>&minus;&minus;quota</b> <i>bytes</i></p>

<p style="margin-left:22%;">The quota in bytes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rateest</b>
<br>
The rate estimator can match on estimated rates as collected
by the RATEEST target. It supports matching on absolute
bps/pps values, comparing two rate estimators and matching
on the difference between two rate estimators.</p>

<p style="margin-left:11%; margin-top: 1em">For a better
understanding of the available options, these are all
possible combinations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>rateest</b> <i>operator</i> <b>rateest-bps</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>rateest</b> <i>operator</i> <b>rateest-pps</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>(<b>rateest</b> minus <b>rateest-bps1</b>)
<i>operator</i> <b>rateest-bps2</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>(<b>rateest</b> minus <b>rateest-pps1</b>)
<i>operator</i> <b>rateest-pps2</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>rateest1</b> <i>operator</i> <b>rateest2
rateest-bps</b>(without rate!)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>rateest1</b> <i>operator</i> <b>rateest2
rateest-pps</b>(without rate!)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>(<b>rateest1</b> minus <b>rateest-bps1</b>)
<i>operator</i> (<b>rateest2</b> minus
<b>rateest-bps2</b>)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>(<b>rateest1</b> minus <b>rateest-pps1</b>)
<i>operator</i> (<b>rateest2</b> minus
<b>rateest-pps2</b>)</p> </td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;rateest&minus;delta</b></p>

<p style="margin-left:17%;">For each estimator (either
absolute or relative mode), calculate the difference between
the estimator-determined flow rate and the static value
chosen with the BPS/PPS options. If the flow rate is higher
than the specified BPS/PPS, 0 will be used instead of a
negative value. In other words, &quot;max(0, rateest#_rate -
rateest#_bps)&quot; is used.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rateest&minus;lt</b></p>

<p style="margin-left:17%;">Match if rate is less than
given rate/estimator.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rateest&minus;gt</b></p>

<p style="margin-left:17%;">Match if rate is greater than
given rate/estimator.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rateest&minus;eq</b></p>

<p style="margin-left:17%;">Match if rate is equal to given
rate/estimator.</p>

<p style="margin-left:11%; margin-top: 1em">In the
so-called &quot;absolute mode&quot;, only one rate estimator
is used and compared against a static value, while in
&quot;relative mode&quot;, two rate estimators are compared
against another. <b><br>
&minus;&minus;rateest</b> <i>name</i></p>

<p style="margin-left:22%;">Name of the one rate estimator
for absolute mode.</p>

<p style="margin-left:11%;"><b>&minus;&minus;rateest1</b>
<i>name</i> <b><br>
&minus;&minus;rateest2</b> <i>name</i></p>

<p style="margin-left:22%;">The names of the two rate
estimators for relative mode.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rateest&minus;bps</b>
[<i>value</i>] <b><br>
&minus;&minus;rateest&minus;pps</b> [<i>value</i>] <b><br>
&minus;&minus;rateest&minus;bps1</b> [<i>value</i>] <b><br>
&minus;&minus;rateest&minus;bps2</b> [<i>value</i>] <b><br>
&minus;&minus;rateest&minus;pps1</b> [<i>value</i>] <b><br>
&minus;&minus;rateest&minus;pps2</b> [<i>value</i>]</p>

<p style="margin-left:22%;">Compare the estimator(s) by
bytes or packets per second, and compare against the chosen
value. See the above bullet list for which option is to be
used in which case. A unit suffix may be used - available
ones are: bit, [kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps,
[KMGT]iBps.</p>

<p style="margin-left:11%; margin-top: 1em">Example: This
is what can be used to route outgoing data connections from
an FTP server over two lines based on the available
bandwidth at the time the data connection was started:</p>

<p style="margin-left:11%; margin-top: 1em"># Estimate
outgoing rates</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A POSTROUTING &minus;o eth0 &minus;j
RATEEST &minus;&minus;rateest&minus;name eth0
&minus;&minus;rateest&minus;interval 250ms
&minus;&minus;rateest&minus;ewma 0.5s</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A POSTROUTING &minus;o ppp0 &minus;j
RATEEST &minus;&minus;rateest&minus;name ppp0
&minus;&minus;rateest&minus;interval 250ms
&minus;&minus;rateest&minus;ewma 0.5s</p>

<p style="margin-left:11%; margin-top: 1em"># Mark based on
available bandwidth</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A balance &minus;m conntrack
&minus;&minus;ctstate NEW &minus;m helper
&minus;&minus;helper ftp &minus;m rateest
&minus;&minus;rateest&minus;delta &minus;&minus;rateest1
eth0 &minus;&minus;rateest&minus;bps1 2.5mbit
&minus;&minus;rateest&minus;gt &minus;&minus;rateest2 ppp0
&minus;&minus;rateest&minus;bps2 2mbit &minus;j CONNMARK
&minus;&minus;set&minus;mark 1</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A balance &minus;m conntrack
&minus;&minus;ctstate NEW &minus;m helper
&minus;&minus;helper ftp &minus;m rateest
&minus;&minus;rateest&minus;delta &minus;&minus;rateest1
ppp0 &minus;&minus;rateest&minus;bps1 2mbit
&minus;&minus;rateest&minus;gt &minus;&minus;rateest2 eth0
&minus;&minus;rateest&minus;bps2 2.5mbit &minus;j CONNMARK
&minus;&minus;set&minus;mark 2</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A balance &minus;j CONNMARK
&minus;&minus;restore&minus;mark</p>

<p style="margin-left:11%; margin-top: 1em"><b>realm
(IPv4-specific)</b> <br>
This matches the routing realm. Routing realms are used in
complex routing setups involving dynamic routing protocols
like BGP. <br>
[<b>!</b>] <b>&minus;&minus;realm</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches a given realm number
(and optionally mask). If not a number, value can be a named
realm from /etc/iproute2/rt_realms (mask can not be used in
that case).</p>

<p style="margin-left:11%; margin-top: 1em"><b>recent</b>
<br>
Allows you to dynamically create a list of IP addresses and
then match against that list in a few different ways.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
you can create a &quot;badguy&quot; list out of people
attempting to connect to port 139 on your firewall and then
DROP all future packets from them without considering
them.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;set</b>,
<b>&minus;&minus;rcheck</b>, <b>&minus;&minus;update</b> and
<b>&minus;&minus;remove</b> are mutually exclusive. <b><br>
&minus;&minus;name</b> <i>name</i></p>

<p style="margin-left:22%;">Specify the list to use for the
commands. If no name is given then <b>DEFAULT</b> will be
used.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;set</b></p>

<p style="margin-left:22%;">This will add the source
address of the packet to the list. If the source address is
already in the list, this will update the existing entry.
This will always return success (or failure if <b>!</b> is
passed in).</p>


<p style="margin-left:11%;"><b>&minus;&minus;rsource</b></p>

<p style="margin-left:22%;">Match/save the source address
of each packet in the recent list table. This is the
default.</p>

<p style="margin-left:11%;"><b>&minus;&minus;rdest</b></p>

<p style="margin-left:22%;">Match/save the destination
address of each packet in the recent list table.</p>

<p style="margin-left:11%;"><b>&minus;&minus;mask</b>
<i>netmask</i></p>

<p style="margin-left:22%;">Netmask that will be applied to
this recent list.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rcheck</b></p>

<p style="margin-left:22%;">Check if the source address of
the packet is currently in the list.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;update</b></p>

<p style="margin-left:22%;">Like
<b>&minus;&minus;rcheck</b>, except it will update the
&quot;last seen&quot; timestamp if it matches.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;remove</b></p>

<p style="margin-left:22%;">Check if the source address of
the packet is currently in the list and if so that address
will be removed from the list and the rule will return true.
If the address is not found, false is returned.</p>

<p style="margin-left:11%;"><b>&minus;&minus;seconds</b>
<i>seconds</i></p>

<p style="margin-left:22%;">This option must be used in
conjunction with one of <b>&minus;&minus;rcheck</b> or
<b>&minus;&minus;update</b>. When used, this will narrow the
match to only happen when the address is in the list and was
seen within the last given number of seconds.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;reap</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This option can only be used in conjunction with
<b>&minus;&minus;seconds</b>. When used, this will cause
entries older than the last given number of seconds to be
purged.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;hitcount</b>
<i>hits</i></p>

<p style="margin-left:22%;">This option must be used in
conjunction with one of <b>&minus;&minus;rcheck</b> or
<b>&minus;&minus;update</b>. When used, this will narrow the
match to only happen when the address is in the list and
packets had been received greater than or equal to the given
value. This option may be used along with
<b>&minus;&minus;seconds</b> to create an even narrower
match requiring a certain number of hits within a specific
time frame. The maximum value for the hitcount parameter is
given by the &quot;ip_pkt_list_tot&quot; parameter of the
xt_recent kernel module. Exceeding this value on the command
line will cause the rule to be rejected.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;rttl</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This option may only be used in conjunction with one of
<b>&minus;&minus;rcheck</b> or <b>&minus;&minus;update</b>.
When used, this will narrow the match to only happen when
the address is in the list and the TTL of the current packet
matches that of the packet which hit the
<b>&minus;&minus;set</b> rule. This may be useful if you
have problems with people faking their source address in
order to DoS you via this module by disallowing others
access to your site by sending bogus packets to you.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A FORWARD &minus;m recent &minus;&minus;name badguy
&minus;&minus;rcheck &minus;&minus;seconds 60 &minus;j
DROP</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A FORWARD &minus;p tcp &minus;i eth0
&minus;&minus;dport 139 &minus;m recent &minus;&minus;name
badguy &minus;&minus;set &minus;j DROP</p>


<p style="margin-left:11%; margin-top: 1em"><b>/proc/net/xt_recent/*</b>
are the current lists of addresses and information about
each entry of each list.</p>

<p style="margin-left:11%; margin-top: 1em">Each file in
<b>/proc/net/xt_recent/</b> can be read from to see the
current list or written two using the following commands to
modify the list: <b><br>
echo +</b><i>addr</i>
<b>&gt;/proc/net/xt_recent/DEFAULT</b></p>

<p style="margin-left:22%;">to add <i>addr</i> to the
DEFAULT list</p>

<p style="margin-left:11%;"><b>echo &minus;</b><i>addr</i>
<b>&gt;/proc/net/xt_recent/DEFAULT</b></p>

<p style="margin-left:22%;">to remove <i>addr</i> from the
DEFAULT list</p>

<p style="margin-left:11%;"><b>echo /
&gt;/proc/net/xt_recent/DEFAULT</b></p>

<p style="margin-left:22%;">to flush the DEFAULT list
(remove all entries).</p>

<p style="margin-left:11%; margin-top: 1em">The module
itself accepts parameters, defaults shown: <b><br>
ip_list_tot</b>=<i>100</i></p>

<p style="margin-left:22%;">Number of addresses remembered
per table.</p>


<p style="margin-left:11%;"><b>ip_pkt_list_tot</b>=<i>20</i></p>

<p style="margin-left:22%;">Number of packets per address
remembered.</p>


<p style="margin-left:11%;"><b>ip_list_hash_size</b>=<i>0</i></p>

<p style="margin-left:22%;">Hash table size. 0 means to
calculate it based on ip_list_tot, default: 512.</p>


<p style="margin-left:11%;"><b>ip_list_perms</b>=<i>0644</i></p>

<p style="margin-left:22%;">Permissions for
/proc/net/xt_recent/* files.</p>


<p style="margin-left:11%;"><b>ip_list_uid</b>=<i>0</i></p>

<p style="margin-left:22%;">Numerical UID for ownership of
/proc/net/xt_recent/* files.</p>


<p style="margin-left:11%;"><b>ip_list_gid</b>=<i>0</i></p>

<p style="margin-left:22%;">Numerical GID for ownership of
/proc/net/xt_recent/* files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>rpfilter</b>
<br>
Performs a reverse path filter test on a packet. If a reply
to the packet would be sent via the same interface that the
packet arrived on, the packet will match. Note that, unlike
the in-kernel rp_filter, packets protected by IPSec are not
treated specially. Combine this match with the policy match
if you want this. Also, packets arriving via the loopback
interface are always permitted. This match can only be used
in the PREROUTING chain of the raw or mangle table. <b><br>
&minus;&minus;loose</b></p>

<p style="margin-left:22%;">Used to specifiy that the
reverse path filter test should match even if the selected
output device is not the expected one.</p>


<p style="margin-left:11%;"><b>&minus;&minus;validmark</b></p>

<p style="margin-left:22%;">Also use the packets&rsquo;
nfmark value when performing the reverse path route
lookup.</p>


<p style="margin-left:11%;"><b>&minus;&minus;accept&minus;local</b></p>

<p style="margin-left:22%;">This will permit packets
arriving from the network with a source address that is also
assigned to the local machine.</p>


<p style="margin-left:11%;"><b>&minus;&minus;invert</b></p>

<p style="margin-left:22%;">This will invert the sense of
the match. Instead of matching packets that passed the
reverse path filter test, match those that have failed
it.</p>

<p style="margin-left:11%; margin-top: 1em">Example to log
and drop packets failing the reverse path filter test:</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;N RPFILTER</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;A RPFILTER &minus;m rpfilter &minus;j
RETURN</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;A RPFILTER &minus;m limit
&minus;&minus;limit 10/minute &minus;j NFLOG
&minus;&minus;nflog&minus;prefix &quot;rpfilter
drop&quot;</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;A RPFILTER &minus;j DROP</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;A PREROUTING &minus;j RPFILTER</p>

<p style="margin-left:11%; margin-top: 1em">Example to drop
failed packets, without logging:</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t raw &minus;A RPFILTER &minus;m rpfilter
&minus;&minus;invert &minus;j DROP</p>

<p style="margin-left:11%; margin-top: 1em"><b>rt
(IPv6-specific)</b> <br>
Match on IPv6 routing header <br>
[<b>!</b>] <b>&minus;&minus;rt&minus;type</b>
<i>type</i></p>

<p style="margin-left:22%;">Match the type (numeric).</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rt&minus;segsleft</b>
<i>num</i>[<b>:</b><i>num</i>]</p>

<p style="margin-left:22%;">Match the &lsquo;segments
left&rsquo; field (range).</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;rt&minus;len</b> <i>length</i></p>

<p style="margin-left:22%;">Match the length of this
header.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rt&minus;0&minus;res</b></p>

<p style="margin-left:22%;">Match the reserved field, too
(type=0)</p>


<p style="margin-left:11%;"><b>&minus;&minus;rt&minus;0&minus;addrs</b>
<i>addr</i>[<b>,</b><i>addr</i>...]</p>

<p style="margin-left:22%;">Match type=0 addresses
(list).</p>


<p style="margin-left:11%;"><b>&minus;&minus;rt&minus;0&minus;not&minus;strict</b></p>

<p style="margin-left:22%;">List of type=0 addresses is not
a strict list.</p>

<p style="margin-left:11%; margin-top: 1em"><b>sctp</b>
<br>
[<b>!</b>]
<b>&minus;&minus;source&minus;port</b>,<b>&minus;&minus;sport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>]
<b>&minus;&minus;destination&minus;port</b>,<b>&minus;&minus;dport</b>
<i>port</i>[<b>:</b><i>port</i>] <br>
[<b>!</b>] <b>&minus;&minus;chunk&minus;types</b>
{<b>all</b>|<b>any</b>|<b>only</b>}
<i>chunktype</i>[<b>:</b><i>flags</i>] [...]</p>

<p style="margin-left:22%;">The flag letter in upper case
indicates that the flag is to match if set, in the lower
case indicates to match if unset.</p>

<p style="margin-left:22%; margin-top: 1em">Chunk types:
DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT
SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE
ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN</p>

<p style="margin-left:22%; margin-top: 1em">chunk type
available flags <br>
DATA I U B E i u b e <br>
ABORT T t <br>
SHUTDOWN_COMPLETE T t</p>

<p style="margin-left:22%; margin-top: 1em">(lowercase
means flag should be &quot;off&quot;, uppercase means
&quot;on&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;A INPUT &minus;p sctp &minus;&minus;dport 80 &minus;j
DROP</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;A INPUT &minus;p sctp &minus;&minus;chunk&minus;types
any DATA,INIT &minus;j DROP</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;A INPUT &minus;p sctp &minus;&minus;chunk&minus;types
any DATA:Be &minus;j ACCEPT</p>

<p style="margin-left:11%; margin-top: 1em"><b>set</b> <br>
This module matches IP sets which can be defined by
ipset(8). <br>
[<b>!</b>] <b>&minus;&minus;match&minus;set</b> <i>setname
flag</i>[<b>,</b><i>flag</i>]...</p>

<p style="margin-left:22%;">where flags are the comma
separated list of <b>src</b> and/or <b>dst</b>
specifications and there can be no more than six of them.
Hence the command</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A FORWARD &minus;m set &minus;&minus;match&minus;set
test src,dst</p>

<p style="margin-left:22%; margin-top: 1em">will match
packets, for which (if the set type is ipportmap) the source
address and destination port pair can be found in the
specified set. If the set type of the specified set is
single dimension (for example ipmap), then the command will
match packets for which the source address can be found in
the specified set.</p>


<p style="margin-left:11%;"><b>&minus;&minus;return&minus;nomatch</b></p>

<p style="margin-left:22%;">If the
<b>&minus;&minus;return&minus;nomatch</b> option is
specified and the set type supports the <b>nomatch</b> flag,
then the matching is reversed: a match with an element
flagged with <b>nomatch</b> returns <b>true</b>, while a
match with a plain element returns <b>false</b>.</p>

<p style="margin-left:11%;"><b>!
&minus;&minus;update&minus;counters</b></p>

<p style="margin-left:22%;">If the
<b>&minus;&minus;update&minus;counters</b> flag is negated,
then the packet and byte counters of the matching element in
the set won&rsquo;t be updated. Default the packet and byte
counters are updated.</p>

<p style="margin-left:11%;"><b>!
&minus;&minus;update&minus;subcounters</b></p>

<p style="margin-left:22%;">If the
<b>&minus;&minus;update&minus;subcounters</b> flag is
negated, then the packet and byte counters of the matching
element in the member set of a list type of set won&rsquo;t
be updated. Default the packet and byte counters are
updated.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;packets&minus;eq</b> <i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the packet counter of the
element matches the given value too.</p>


<p style="margin-left:11%;"><b>&minus;&minus;packets&minus;lt</b>
<i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the packet counter of the
element is less than the given value as well.</p>


<p style="margin-left:11%;"><b>&minus;&minus;packets&minus;gt</b>
<i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the packet counter of the
element is greater than the given value as well.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;bytes&minus;eq</b> <i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the byte counter of the
element matches the given value too.</p>


<p style="margin-left:11%;"><b>&minus;&minus;bytes&minus;lt</b>
<i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the byte counter of the
element is less than the given value as well.</p>


<p style="margin-left:11%;"><b>&minus;&minus;bytes&minus;gt</b>
<i>value</i></p>

<p style="margin-left:22%;">If the packet is matched an
element in the set, match only if the byte counter of the
element is greater than the given value as well.</p>

<p style="margin-left:11%; margin-top: 1em">The packet and
byte counters related options and flags are ignored when the
set was defined without counter support.</p>

<p style="margin-left:11%; margin-top: 1em">The option
<b>&minus;&minus;match&minus;set</b> can be replaced by
<b>&minus;&minus;set</b> if that does not clash with an
option of other extensions.</p>

<p style="margin-left:11%; margin-top: 1em">Use of -m set
requires that ipset kernel support is provided, which, for
standard kernels, is the case since Linux 2.6.39.</p>

<p style="margin-left:11%; margin-top: 1em"><b>socket</b>
<br>
This matches if an open TCP/UDP socket can be found by doing
a socket lookup on the packet. It matches if there is an
established or non&minus;zero bound listening socket
(possibly with a non&minus;local address). The lookup is
performed using the <b>packet</b> tuple of TCP/UDP packets,
or the original TCP/UDP header <b>embedded</b> in an
ICMP/ICPMv6 error packet. <b><br>
&minus;&minus;transparent</b></p>

<p style="margin-left:22%;">Ignore non-transparent
sockets.</p>


<p style="margin-left:11%;"><b>&minus;&minus;nowildcard</b></p>

<p style="margin-left:22%;">Do not ignore sockets bound to
&rsquo;any&rsquo; address. The socket match won&rsquo;t
accept zero&minus;bound listeners by default, since then
local services could intercept traffic that would otherwise
be forwarded. This option therefore has security
implications when used to match traffic being forwarded to
redirect such packets to local machine with policy routing.
When using the socket match to implement fully transparent
proxies bound to non&minus;local addresses it is recommended
to use the &minus;&minus;transparent option instead.</p>

<p style="margin-left:11%; margin-top: 1em">Example
(assuming packets with mark 1 are delivered locally):</p>

<p style="margin-left:22%; margin-top: 1em">&minus;t mangle
&minus;A PREROUTING &minus;m socket
&minus;&minus;transparent &minus;j MARK
&minus;&minus;set&minus;mark 1</p>

<p style="margin-left:11%; margin-top: 1em"><b>state</b>
<br>
The &quot;state&quot; extension is a subset of the
&quot;conntrack&quot; module. &quot;state&quot; allows
access to the connection tracking state for this packet.
<br>
[<b>!</b>] <b>&minus;&minus;state</b> <i>state</i></p>

<p style="margin-left:22%;">Where state is a comma
separated list of the connection states to match. Only a
subset of the states unterstood by &quot;conntrack&quot; are
recognized: <b>INVALID</b>, <b>ESTABLISHED</b>, <b>NEW</b>,
<b>RELATED</b> or <b>UNTRACKED</b>. For their description,
see the &quot;conntrack&quot; heading in this manpage.</p>


<p style="margin-left:11%; margin-top: 1em"><b>statistic</b>
<br>
This module matches packets based on some statistic
condition. It supports two distinct modes settable with the
<b>&minus;&minus;mode</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">Supported
options: <b><br>
&minus;&minus;mode</b> <i>mode</i></p>

<p style="margin-left:22%;">Set the matching mode of the
matching rule, supported modes are <b>random</b> and
<b>nth.</b></p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;probability</b> <i>p</i></p>

<p style="margin-left:22%;">Set the probability for a
packet to be randomly matched. It only works with the
<b>random</b> mode. <i>p</i> must be within 0.0 and 1.0. The
supported granularity is in 1/2147483648th increments.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;every</b> <i>n</i></p>

<p style="margin-left:22%;">Match one packet every nth
packet. It works only with the <b>nth</b> mode (see also the
<b>&minus;&minus;packet</b> option).</p>

<p style="margin-left:11%;"><b>&minus;&minus;packet</b>
<i>p</i></p>

<p style="margin-left:22%;">Set the initial counter value
(0 &lt;= p &lt;= n&minus;1, default 0) for the <b>nth</b>
mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>string</b>
<br>
This modules matches a given string by using some pattern
matching strategy. It requires a linux kernel &gt;= 2.6.14.
<b><br>
&minus;&minus;algo</b> {<b>bm</b>|<b>kmp</b>}</p>

<p style="margin-left:22%;">Select the pattern matching
strategy. (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)</p>

<p style="margin-left:11%;"><b>&minus;&minus;from</b>
<i>offset</i></p>

<p style="margin-left:22%;">Set the offset from which it
starts looking for any matching. If not passed, default is
0.</p>

<p style="margin-left:11%;"><b>&minus;&minus;to</b>
<i>offset</i></p>

<p style="margin-left:22%;">Set the offset up to which
should be scanned. That is, byte <i>offset</i>-1 (counting
from 0) is the last one that is scanned. If not passed,
default is the packet size.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;string</b> <i>pattern</i></p>

<p style="margin-left:22%;">Matches the given pattern.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;hex&minus;string</b> <i>pattern</i></p>

<p style="margin-left:22%;">Matches the given pattern in
hex notation.</p>

<p style="margin-left:11%;">Examples:</p>

<p style="margin-left:22%; margin-top: 1em"># The string
pattern can be used for simple text characters. <br>
iptables &minus;A INPUT &minus;p tcp &minus;&minus;dport 80
&minus;m string &minus;&minus;algo bm &minus;&minus;string
&rsquo;GET /index.html&rsquo; &minus;j LOG</p>

<p style="margin-left:22%; margin-top: 1em"># The hex
string pattern can be used for non-printable characters,
like |0D 0A| or |0D0A|. <br>
iptables &minus;p udp &minus;&minus;dport 53 &minus;m string
&minus;&minus;algo bm &minus;&minus;from 40 &minus;&minus;to
57 &minus;&minus;hex&minus;string
&rsquo;|03|www|09|netfilter|03|org|00|&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em"><b>tcp</b> <br>
These extensions can be used if
&lsquo;&minus;&minus;protocol tcp&rsquo; is specified. It
provides the following options: <br>
[<b>!</b>]
<b>&minus;&minus;source&minus;port</b>,<b>&minus;&minus;sport</b>
<i>port</i>[<b>:</b><i>port</i>]</p>

<p style="margin-left:22%;">Source port or port range
specification. This can either be a service name or a port
number. An inclusive range can also be specified, using the
format <i>first</i><b>:</b><i>last</i>. If the first port is
omitted, &quot;0&quot; is assumed; if the last is omitted,
&quot;65535&quot; is assumed. If the first port is greater
than the second one they will be swapped. The flag
<b>&minus;&minus;sport</b> is a convenient alias for this
option.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;destination&minus;port</b>,<b>&minus;&minus;dport</b>
<i>port</i>[<b>:</b><i>port</i>]</p>

<p style="margin-left:22%;">Destination port or port range
specification. The flag <b>&minus;&minus;dport</b> is a
convenient alias for this option.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;tcp&minus;flags</b> <i>mask comp</i></p>

<p style="margin-left:22%;">Match when the TCP flags are as
specified. The first argument <i>mask</i> is the flags which
we should examine, written as a comma-separated list, and
the second argument <i>comp</i> is a comma-separated list of
flags which must be set. Flags are: <b>SYN ACK FIN RST URG
PSH ALL NONE</b>. Hence the command <br>
iptables &minus;A FORWARD &minus;p tcp
&minus;&minus;tcp&minus;flags SYN,ACK,FIN,RST SYN <br>
will only match packets with the SYN flag set, and the ACK,
FIN and RST flags unset.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;syn</b></p>

<p style="margin-left:22%;">Only match TCP packets with the
SYN bit set and the ACK,RST and FIN bits cleared. Such
packets are used to request TCP connection initiation; for
example, blocking such packets coming in an interface will
prevent incoming TCP connections, but outgoing TCP
connections will be unaffected. It is equivalent to
<b>&minus;&minus;tcp&minus;flags SYN,RST,ACK,FIN SYN</b>. If
the &quot;!&quot; flag precedes the
&quot;&minus;&minus;syn&quot;, the sense of the option is
inverted.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;tcp&minus;option</b> <i>number</i></p>

<p style="margin-left:22%;">Match if TCP option set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tcpmss</b>
<br>
This matches the TCP MSS (maximum segment size) field of the
TCP header. You can only use this on TCP SYN or SYN/ACK
packets, since the MSS is only negotiated during the TCP
handshake at connection startup time. <br>
[<b>!</b>] <b>&minus;&minus;mss</b>
<i>value</i>[<b>:</b><i>value</i>]</p>

<p style="margin-left:22%;">Match a given TCP MSS value or
range.</p>

<p style="margin-left:11%; margin-top: 1em"><b>time</b>
<br>
This matches if the packet arrival time/date is within a
given range. All options are optional, but are ANDed when
specified. All times are interpreted as UTC by default.
<b><br>
&minus;&minus;datestart</b>
<i>YYYY</i>[<b>&minus;</b><i>MM</i>[<b>&minus;</b><i>DD</i>[<b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]
<b><br>
&minus;&minus;datestop</b>
<i>YYYY</i>[<b>&minus;</b><i>MM</i>[<b>&minus;</b><i>DD</i>[<b>T</b><i>hh</i>[<b>:</b><i>mm</i>[<b>:</b><i>ss</i>]]]]]</p>

<p style="margin-left:22%;">Only match during the given
time, which must be in ISO 8601 &quot;T&quot; notation. The
possible time range is 1970-01-01T00:00:00 to
2038-01-19T04:17:07.</p>

<p style="margin-left:22%; margin-top: 1em">If
&minus;&minus;datestart or &minus;&minus;datestop are not
specified, it will default to 1970-01-01 and 2038-01-19,
respectively.</p>

<p style="margin-left:11%;"><b>&minus;&minus;timestart</b>
<i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>] <b><br>
&minus;&minus;timestop</b>
<i>hh</i><b>:</b><i>mm</i>[<b>:</b><i>ss</i>]</p>

<p style="margin-left:22%;">Only match during the given
daytime. The possible time range is 00:00:00 to 23:59:59.
Leading zeroes are allowed (e.g. &quot;06:03&quot;) and
correctly interpreted as base-10.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;monthdays</b>
<i>day</i>[<b>,</b><i>day</i>...]</p>

<p style="margin-left:22%;">Only match on the given days of
the month. Possible values are <b>1</b> to <b>31</b>. Note
that specifying <b>31</b> will of course not match on months
which do not have a 31st day; the same goes for 28- or
29-day February.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;weekdays</b>
<i>day</i>[<b>,</b><i>day</i>...]</p>

<p style="margin-left:22%;">Only match on the given
weekdays. Possible values are <b>Mon</b>, <b>Tue</b>,
<b>Wed</b>, <b>Thu</b>, <b>Fri</b>, <b>Sat</b>, <b>Sun</b>,
or values from <b>1</b> to <b>7</b>, respectively. You may
also use two-character variants (<b>Mo</b>, <b>Tu</b>,
etc.).</p>


<p style="margin-left:11%;"><b>&minus;&minus;contiguous</b></p>

<p style="margin-left:22%;">When
<b>&minus;&minus;timestop</b> is smaller than
<b>&minus;&minus;timestart</b> value, match this as a single
time period instead distinct intervals. See EXAMPLES.</p>


<p style="margin-left:11%;"><b>&minus;&minus;kerneltz</b></p>

<p style="margin-left:22%;">Use the kernel timezone instead
of UTC to determine whether a packet meets the time
regulations.</p>

<p style="margin-left:11%; margin-top: 1em">About kernel
timezones: Linux keeps the system time in UTC, and always
does so. On boot, system time is initialized from a
referential time source. Where this time source has no
timezone information, such as the x86 CMOS RTC, UTC will be
assumed. If the time source is however not in UTC, userspace
should provide the correct system time and timezone to the
kernel once it has the information.</p>

<p style="margin-left:11%; margin-top: 1em">Local time is a
feature on top of the (timezone independent) system time.
Each process has its own idea of local time, specified via
the TZ environment variable. The kernel also has its own
timezone offset variable. The TZ userspace environment
variable specifies how the UTC-based system time is
displayed, e.g. when you run date(1), or what you see on
your desktop clock. The TZ string may resolve to different
offsets at different dates, which is what enables the
automatic time-jumping in userspace. when DST changes. The
kernel&rsquo;s timezone offset variable is used when it has
to convert between non-UTC sources, such as FAT filesystems,
to UTC (since the latter is what the rest of the system
uses).</p>

<p style="margin-left:11%; margin-top: 1em">The caveat with
the kernel timezone is that Linux distributions may ignore
to set the kernel timezone, and instead only set the system
time. Even if a particular distribution does set the
timezone at boot, it is usually does not keep the kernel
timezone offset - which is what changes on DST - up to date.
ntpd will not touch the kernel timezone, so running it will
not resolve the issue. As such, one may encounter a timezone
that is always +0000, or one that is wrong half of the time
of the year. As such, <b>using &minus;&minus;kerneltz is
highly discouraged.</b></p>

<p style="margin-left:11%; margin-top: 1em">EXAMPLES. To
match on weekends, use:</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;weekdays Sa,Su</p>

<p style="margin-left:11%; margin-top: 1em">Or, to match
(once) on a national holiday block:</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;datestart 2007&minus;12&minus;24
&minus;&minus;datestop 2007&minus;12&minus;27</p>

<p style="margin-left:11%; margin-top: 1em">Since the stop
time is actually inclusive, you would need the following
stop time to not match the first second of the new day:</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;datestart 2007&minus;01&minus;01T17:00
&minus;&minus;datestop 2007&minus;01&minus;01T23:59:59</p>

<p style="margin-left:11%; margin-top: 1em">During lunch
hour:</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;timestart 12:30 &minus;&minus;timestop
13:30</p>

<p style="margin-left:11%; margin-top: 1em">The fourth
Friday in the month:</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;weekdays Fr &minus;&minus;monthdays
22,23,24,25,26,27,28</p>

<p style="margin-left:11%; margin-top: 1em">(Note that this
exploits a certain mathematical property. It is not possible
to say &quot;fourth Thursday OR fourth Friday&quot; in one
rule. It is possible with multiple rules, though.)</p>

<p style="margin-left:11%; margin-top: 1em">Matching across
days might not do what is expected. For instance,</p>

<p style="margin-left:22%; margin-top: 1em">&minus;m time
&minus;&minus;weekdays Mo &minus;&minus;timestart 23:00
&minus;&minus;timestop 01:00 Will match Monday, for one hour
from midnight to 1 a.m., and then again for another hour
from 23:00 onwards. If this is unwanted, e.g. if you would
like &rsquo;match for two hours from Montay 23:00
onwards&rsquo; you need to also specify the
&minus;&minus;contiguous option in the example above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tos</b> <br>
This module matches the 8-bit Type of Service field in the
IPv4 header (i.e. including the &quot;Precedence&quot; bits)
or the (also 8-bit) Priority field in the IPv6 header. <br>
[<b>!</b>] <b>&minus;&minus;tos</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Matches packets with the given
TOS mark value. If a mask is specified, it is logically
ANDed with the TOS mark before the comparison.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;tos</b> <i>symbol</i></p>

<p style="margin-left:22%;">You can specify a symbolic name
when using the tos match for IPv4. The list of recognized
TOS names can be obtained by calling iptables with
<b>&minus;m tos &minus;h</b>. Note that this implies a mask
of 0x3F, i.e. all but the ECN bits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ttl
(IPv4-specific)</b> <br>
This module matches the time to live field in the IP header.
<br>
[<b>!</b>] <b>&minus;&minus;ttl&minus;eq</b> <i>ttl</i></p>

<p style="margin-left:22%;">Matches the given TTL
value.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ttl&minus;gt</b>
<i>ttl</i></p>

<p style="margin-left:22%;">Matches if TTL is greater than
the given TTL value.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ttl&minus;lt</b>
<i>ttl</i></p>

<p style="margin-left:22%;">Matches if TTL is less than the
given TTL value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>u32</b> <br>
U32 tests whether quantities of up to 4 bytes extracted from
a packet have specified values. The specification of what to
extract is general enough to find data at given offsets from
tcp headers or payloads. <br>
[<b>!</b>] <b>&minus;&minus;u32</b> <i>tests</i></p>

<p style="margin-left:22%;">The argument amounts to a
program in a small language described below.</p>

<p style="margin-left:22%; margin-top: 1em">tests :=
location &quot;=&quot; value | tests &quot;&amp;&amp;&quot;
location &quot;=&quot; value</p>

<p style="margin-left:22%; margin-top: 1em">value := range
| value &quot;,&quot; range</p>

<p style="margin-left:22%; margin-top: 1em">range := number
| number &quot;:&quot; number</p>

<p style="margin-left:11%; margin-top: 1em">a single
number, <i>n</i>, is interpreted the same as <i>n:n</i>.
<i>n:m</i> is interpreted as the range of numbers
<b>&gt;=n</b> and <b>&lt;=m</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="69%">


<p>location := number | location operator number</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="69%">


<p>operator := &quot;&amp;&quot; | &quot;&lt;&lt;&quot; |
&quot;&gt;&gt;&quot; | &quot;@&quot;</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The operators
<b>&amp;</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b> and
<b>&amp;&amp;</b> mean the same as in C. The <b>=</b> is
really a set membership operator and the value syntax
describes a set. The <b>@</b> operator is what allows moving
to the next header and is described further below.</p>

<p style="margin-left:11%; margin-top: 1em">There are
currently some artificial implementation limits on the size
of the tests:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">no more than 10 of
&quot;<b>=</b>&quot; (and 9 &quot;<b>&amp;&amp;</b>&quot;s)
in the u32 argument</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="4%"></td>
<td width="78%">


<p>no more than 10 ranges (and 9 commas) per value</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>*</p></td>
<td width="4%"></td>
<td width="78%">


<p>no more than 10 numbers (and 9 operators) per
location</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">To describe the
meaning of location, imagine the following machine that
interprets it. There are three registers:</p>

<p style="margin-left:22%; margin-top: 1em">A is of type
<b>char *</b>, initially the address of the IP header</p>

<p style="margin-left:22%; margin-top: 1em">B and C are
unsigned 32 bit integers, initially zero</p>

<p style="margin-left:11%; margin-top: 1em">The
instructions are:</p>

<p style="margin-left:22%; margin-top: 1em">number B =
number;</p>

<p style="margin-left:22%; margin-top: 1em">C =
(*(A+B)&lt;&lt;24) + (*(A+B+1)&lt;&lt;16) +
(*(A+B+2)&lt;&lt;8) + *(A+B+3)</p>

<p style="margin-left:22%; margin-top: 1em">&amp;number C =
C &amp; number</p>

<p style="margin-left:22%; margin-top: 1em">&lt;&lt; number
C = C &lt;&lt; number</p>

<p style="margin-left:22%; margin-top: 1em">&gt;&gt; number
C = C &gt;&gt; number</p>

<p style="margin-left:22%; margin-top: 1em">@number A = A +
C; then do the instruction number</p>

<p style="margin-left:11%; margin-top: 1em">Any access of
memory outside [skb&minus;&gt;data,skb&minus;&gt;end] causes
the match to fail. Otherwise the result of the computation
is the final value of C.</p>

<p style="margin-left:11%; margin-top: 1em">Whitespace is
allowed but not required in the tests. However, the
characters that do occur there are likely to require shell
quoting, so it is a good idea to enclose the arguments in
quotes.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">match IP
packets with total length &gt;= 256</p>

<p style="margin-left:22%; margin-top: 1em">The IP header
contains a total length field in bytes 2-3.</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;u32
&quot;<b>0 &amp; 0xFFFF = 0x100:0xFFFF</b>&quot;</p>

<p style="margin-left:22%; margin-top: 1em">read bytes
0-3</p>

<p style="margin-left:22%; margin-top: 1em">AND that with
0xFFFF (giving bytes 2-3), and test whether that is in the
range [0x100:0xFFFF]</p>

<p style="margin-left:11%; margin-top: 1em">Example: (more
realistic, hence more complicated)</p>

<p style="margin-left:22%; margin-top: 1em">match ICMP
packets with icmp type 0</p>

<p style="margin-left:22%; margin-top: 1em">First test that
it is an ICMP packet, true iff byte 9 (protocol) = 1</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;u32
&quot;<b>6 &amp; 0xFF = 1 &amp;&amp;</b> ...</p>

<p style="margin-left:22%; margin-top: 1em">read bytes 6-9,
use <b>&amp;</b> to throw away bytes 6-8 and compare the
result to 1. Next test that it is not a fragment. (If so, it
might be part of such a packet but we cannot always tell.)
N.B.: This test is generally needed if you want to match
anything beyond the IP header. The last 6 bits of byte 6 and
all of byte 7 are 0 iff this is a complete packet (not a
fragment). Alternatively, you can allow first fragments by
only testing the last 5 bits of byte 6.</p>

<p style="margin-left:22%; margin-top: 1em">... <b>4 &amp;
0x3FFF = 0 &amp;&amp;</b> ...</p>

<p style="margin-left:22%; margin-top: 1em">Last test: the
first byte past the IP header (the type) is 0. This is where
we have to use the @syntax. The length of the IP header
(IHL) in 32 bit words is stored in the right half of byte 0
of the IP header itself.</p>

<p style="margin-left:22%; margin-top: 1em">... <b>0
&gt;&gt; 22 &amp; 0x3C @ 0 &gt;&gt; 24 = 0</b>&quot;</p>

<p style="margin-left:22%; margin-top: 1em">The first 0
means read bytes 0-3, <b>&gt;&gt;22</b> means shift that 22
bits to the right. Shifting 24 bits would give the first
byte, so only 22 bits is four times that plus a few more
bits. <b>&amp;3C</b> then eliminates the two extra bits on
the right and the first four bits of the first byte. For
instance, if IHL=5, then the IP header is 20 (4 x 5) bytes
long. In this case, bytes 0-1 are (in binary) xxxx0101
yyzzzzzz, <b>&gt;&gt;22</b> gives the 10 bit value
xxxx0101yy and <b>&amp;3C</b> gives 010100. <b>@</b> means
to use this number as a new offset into the packet, and read
four bytes starting from there. This is the first 4 bytes of
the ICMP payload, of which byte 0 is the ICMP type.
Therefore, we simply shift the value 24 to the right to
throw out all but the first byte and compare the result with
0.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">TCP payload
bytes 8-12 is any of 1, 2, 5 or 8</p>

<p style="margin-left:22%; margin-top: 1em">First we test
that the packet is a tcp packet (similar to ICMP).</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;u32
&quot;<b>6 &amp; 0xFF = 6 &amp;&amp;</b> ...</p>

<p style="margin-left:22%; margin-top: 1em">Next, test that
it is not a fragment (same as above).</p>

<p style="margin-left:22%; margin-top: 1em">... <b>0
&gt;&gt; 22 &amp; 0x3C @ 12 &gt;&gt; 26 &amp; 0x3C @ 8 =
1,2,5,8</b>&quot;</p>


<p style="margin-left:22%; margin-top: 1em"><b>0&gt;&gt;22&amp;3C</b>
as above computes the number of bytes in the IP header.
<b>@</b> makes this the new offset into the packet, which is
the start of the TCP header. The length of the TCP header
(again in 32 bit words) is the left half of byte 12 of the
TCP header. The <b>12&gt;&gt;26&amp;3C</b> computes this
length in bytes (similar to the IP header before).
&quot;@&quot; makes this the new offset, which is the start
of the TCP payload. Finally, 8 reads bytes 8-12 of the
payload and <b>=</b> checks whether the result is any of 1,
2, 5 or 8.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udp</b> <br>
These extensions can be used if
&lsquo;&minus;&minus;protocol udp&rsquo; is specified. It
provides the following options: <br>
[<b>!</b>]
<b>&minus;&minus;source&minus;port</b>,<b>&minus;&minus;sport</b>
<i>port</i>[<b>:</b><i>port</i>]</p>

<p style="margin-left:22%;">Source port or port range
specification. See the description of the
<b>&minus;&minus;source&minus;port</b> option of the TCP
extension for details.</p>

<p style="margin-left:11%;">[<b>!</b>]
<b>&minus;&minus;destination&minus;port</b>,<b>&minus;&minus;dport</b>
<i>port</i>[<b>:</b><i>port</i>]</p>

<p style="margin-left:22%;">Destination port or port range
specification. See the description of the
<b>&minus;&minus;destination&minus;port</b> option of the
TCP extension for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unclean
(IPv4-specific)</b> <br>
This module takes no options, but attempts to match packets
which seem malformed or unusual. This is regarded as
experimental.</p>

<h2>TARGET EXTENSIONS
<a name="TARGET EXTENSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">iptables can
use extended target modules: the following are included in
the standard distribution.</p>

<p style="margin-left:11%; margin-top: 1em"><b>AUDIT</b>
<br>
This target allows to create audit records for packets
hitting the target. It can be used to record accepted,
dropped, and rejected packets. See auditd(8) for additional
details. <b><br>
&minus;&minus;type</b>
{<b>accept</b>|<b>drop</b>|<b>reject</b>}</p>

<p style="margin-left:22%;">Set type of audit record.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;N AUDIT_DROP</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A AUDIT_DROP &minus;j AUDIT &minus;&minus;type
drop</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;A AUDIT_DROP &minus;j DROP</p>


<p style="margin-left:11%; margin-top: 1em"><b>CHECKSUM</b>
<br>
This target allows to selectively work around broken/old
applications. It can only be used in the mangle table.
<b><br>
&minus;&minus;checksum&minus;fill</b></p>

<p style="margin-left:22%;">Compute and fill in the
checksum in a packet that lacks a checksum. This is
particularly useful, if you need to work around old
applications such as dhcp clients, that do not work well
with checksum offloads, but don&rsquo;t want to disable
checksum offload in your device.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CLASSIFY</b>
<br>
This module allows you to set the skb&minus;&gt;priority
value (and thus classify the packet into a specific CBQ
class). <b><br>
&minus;&minus;set&minus;class</b>
<i>major</i><b>:</b><i>minor</i></p>

<p style="margin-left:22%;">Set the major and minor class
value. The values are always interpreted as hexadecimal even
if no 0x prefix is given.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CLUSTERIP
(IPv4-specific)</b> <br>
This module allows you to configure a simple cluster of
nodes that share a certain IP and MAC address without an
explicit load balancer in front of them. Connections are
statically distributed between the nodes in this
cluster.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;new</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Create a new ClusterIP. You always have to set this on
the first rule for a given ClusterIP.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;hashmode</b>
<i>mode</i></p>

<p style="margin-left:22%;">Specify the hashing mode. Has
to be one of <b>sourceip</b>,
<b>sourceip&minus;sourceport</b>,
<b>sourceip&minus;sourceport&minus;destport</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;clustermac</b>
<i>mac</i></p>

<p style="margin-left:22%;">Specify the ClusterIP MAC
address. Has to be a link&minus;layer multicast address</p>


<p style="margin-left:11%;"><b>&minus;&minus;total&minus;nodes</b>
<i>num</i></p>

<p style="margin-left:22%;">Number of total nodes within
this cluster.</p>


<p style="margin-left:11%;"><b>&minus;&minus;local&minus;node</b>
<i>num</i></p>

<p style="margin-left:22%;">Local node number within this
cluster.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hash&minus;init</b>
<i>rnd</i></p>

<p style="margin-left:22%;">Specify the random seed used
for hash initialization.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CONNMARK</b>
<br>
This module sets the netfilter mark value associated with a
connection. The mark is 32 bits wide. <b><br>
&minus;&minus;set&minus;xmark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Zero out the bits given by
<i>mask</i> and XOR <i>value</i> into the ctmark.</p>


<p style="margin-left:11%;"><b>&minus;&minus;save&minus;mark</b>
[<b>&minus;&minus;nfmask</b> <i>nfmask</i>]
[<b>&minus;&minus;ctmask</b> <i>ctmask</i>]</p>

<p style="margin-left:22%;">Copy the packet mark (nfmark)
to the connection mark (ctmark) using the given masks. The
new nfmark value is determined as follows:</p>

<p style="margin-left:22%; margin-top: 1em">ctmark =
(ctmark &amp; ~ctmask) ^ (nfmark &amp; nfmask)</p>

<p style="margin-left:22%; margin-top: 1em">i.e.
<i>ctmask</i> defines what bits to clear and <i>nfmask</i>
what bits of the nfmark to XOR into the ctmark.
<i>ctmask</i> and <i>nfmask</i> default to 0xFFFFFFFF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;restore&minus;mark</b>
[<b>&minus;&minus;nfmask</b> <i>nfmask</i>]
[<b>&minus;&minus;ctmask</b> <i>ctmask</i>]</p>

<p style="margin-left:22%;">Copy the connection mark
(ctmark) to the packet mark (nfmark) using the given masks.
The new ctmark value is determined as follows:</p>

<p style="margin-left:22%; margin-top: 1em">nfmark =
(nfmark &amp; ~<i>nfmask</i>) ^ (ctmark &amp;
<i>ctmask</i>);</p>

<p style="margin-left:22%; margin-top: 1em">i.e.
<i>nfmask</i> defines what bits to clear and <i>ctmask</i>
what bits of the ctmark to XOR into the nfmark.
<i>ctmask</i> and <i>nfmask</i> default to 0xFFFFFFFF.</p>


<p style="margin-left:22%; margin-top: 1em"><b>&minus;&minus;restore&minus;mark</b>
is only valid in the <b>mangle</b> table.</p>

<p style="margin-left:11%; margin-top: 1em">The following
mnemonics are available for
<b>&minus;&minus;set&minus;xmark</b>: <b><br>
&minus;&minus;and&minus;mark</b> <i>bits</i></p>

<p style="margin-left:22%;">Binary AND the ctmark with
<i>bits</i>. (Mnemonic for <b>&minus;&minus;set&minus;xmark
0/</b><i>invbits</i>, where <i>invbits</i> is the binary
negation of <i>bits</i>.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;or&minus;mark</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary OR the ctmark with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;xmark</b>
<i>bits</i><b>/</b><i>bits</i>.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;xor&minus;mark</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary XOR the ctmark with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;xmark</b>
<i>bits</i><b>/0</b>.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;mark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Set the connection mark. If a
mask is specified then only those bits set in the mask are
modified.</p>


<p style="margin-left:11%;"><b>&minus;&minus;save&minus;mark</b>
[<b>&minus;&minus;mask</b> <i>mask</i>]</p>

<p style="margin-left:22%;">Copy the nfmark to the ctmark.
If a mask is specified, only those bits are copied.</p>


<p style="margin-left:11%;"><b>&minus;&minus;restore&minus;mark</b>
[<b>&minus;&minus;mask</b> <i>mask</i>]</p>

<p style="margin-left:22%;">Copy the ctmark to the nfmark.
If a mask is specified, only those bits are copied. This is
only valid in the <b>mangle</b> table.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CONNSECMARK</b>
<br>
This module copies security markings from packets to
connections (if unlabeled), and from connections back to
packets (also only if unlabeled). Typically used in
conjunction with SECMARK, it is valid in the <b>security</b>
table (for backwards compatibility with older kernels, it is
also valid in the <b>mangle</b> table).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;save</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If the packet has a security marking, copy it to the
connection if the connection is not marked.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;restore</b></p>

<p style="margin-left:22%;">If the packet does not have a
security marking, and the connection does, copy the security
marking from the connection to the packet.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CT</b> <br>
The CT target allows to set parameters for a packet or its
associated connection. The target attaches a
&quot;template&quot; connection tracking entry to the
packet, which is then used by the conntrack core when
initializing a new ct entry. This target is thus only valid
in the &quot;raw&quot; table. <b><br>
&minus;&minus;notrack</b></p>

<p style="margin-left:22%;">Disables connection tracking
for this packet.</p>

<p style="margin-left:11%;"><b>&minus;&minus;helper</b>
<i>name</i></p>

<p style="margin-left:22%;">Use the helper identified by
<i>name</i> for the connection. This is more flexible than
loading the conntrack helper modules with preset ports.</p>

<p style="margin-left:11%;"><b>&minus;&minus;ctevents</b>
<i>event</i>[<b>,</b>...]</p>

<p style="margin-left:22%;">Only generate the specified
conntrack events for this connection. Possible event types
are: <b>new</b>, <b>related</b>, <b>destroy</b>,
<b>reply</b>, <b>assured</b>, <b>protoinfo</b>,
<b>helper</b>, <b>mark</b> (this refers to the ctmark, not
nfmark), <b>natseqinfo</b>, <b>secmark</b> (ctsecmark).</p>

<p style="margin-left:11%;"><b>&minus;&minus;expevents</b>
<i>event</i>[<b>,</b>...]</p>

<p style="margin-left:22%;">Only generate the specified
expectation events for this connection. Possible event types
are: <b>new</b>.</p>

<p style="margin-left:11%;"><b>&minus;&minus;zone</b>
<i>id</i></p>

<p style="margin-left:22%;">Assign this packet to zone
<i>id</i> and only have lookups done in that zone. By
default, packets have zone 0.</p>

<p style="margin-left:11%;"><b>&minus;&minus;timeout</b>
<i>name</i></p>

<p style="margin-left:22%;">Use the timeout policy
identified by <i>name</i> for the connection. This is
provides more flexible timeout policy definition than global
timeout values available at
/proc/sys/net/netfilter/nf_conntrack_*_timeout_*.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DNAT</b>
<br>
This target is only valid in the <b>nat</b> table, in the
<b>PREROUTING</b> and <b>OUTPUT</b> chains, and user-defined
chains which are only called from those chains. It specifies
that the destination address of the packet should be
modified (and all future packets in this connection will
also be mangled), and rules should cease being examined. It
takes the following options: <b><br>
&minus;&minus;to&minus;destination</b>
[<i>ipaddr</i>[<b>&minus;</b><i>ipaddr</i>]][<b>:</b><i>port</i>[<b>&minus;</b><i>port</i>]]</p>

<p style="margin-left:22%;">which can specify a single new
destination IP address, an inclusive range of IP addresses.
Optionally a port range, if the rule also specifies one of
the following protocols: <b>tcp</b>, <b>udp</b>, <b>dccp</b>
or <b>sctp</b>. If no port range is specified, then the
destination port will never be modified. If no IP address is
specified then only the destination port will be modified.
In Kernels up to 2.6.10 you can add several
&minus;&minus;to&minus;destination options. For those
kernels, if you specify more than one destination address,
either via an address range or multiple
&minus;&minus;to&minus;destination options, a simple
round-robin (one after another in cycle) load balancing
takes place between these addresses. Later Kernels (&gt;=
2.6.11-rc1) don&rsquo;t have the ability to NAT to multiple
ranges anymore.</p>


<p style="margin-left:11%;"><b>&minus;&minus;random</b></p>

<p style="margin-left:22%;">If option
<b>&minus;&minus;random</b> is used then port mapping will
be randomized (kernel &gt;= 2.6.22).</p>


<p style="margin-left:11%;"><b>&minus;&minus;persistent</b></p>

<p style="margin-left:22%;">Gives a client the same
source-/destination-address for each connection. This
supersedes the SAME target. Support for persistent mappings
is available from 2.6.29-rc2.</p>

<p style="margin-left:11%;">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DNPT
(IPv6-specific)</b> <br>
Provides stateless destination IPv6-to-IPv6 Network Prefix
Translation (as described by RFC 6296).</p>

<p style="margin-left:11%; margin-top: 1em">You have to use
this target in the <b>mangle</b> table, not in the
<b>nat</b> table. It takes the following options: <b><br>
&minus;&minus;src&minus;pfx</b> [<i>prefix/length]</i></p>

<p style="margin-left:22%;">Set source prefix that you want
to translate and length</p>


<p style="margin-left:11%;"><b>&minus;&minus;dst&minus;pfx</b>
[<i>prefix/length]</i></p>

<p style="margin-left:22%;">Set destination prefix that you
want to use in the translation and length</p>

<p style="margin-left:11%; margin-top: 1em">You have to use
the SNPT target to undo the translation. Example:</p>

<p style="margin-left:22%; margin-top: 1em">ip6tables
&minus;t mangle &minus;I POSTROUTING &minus;s fd00::/64
&minus;o vboxnet0 &minus;j SNPT &minus;&minus;src-pfx
fd00::/64 &minus;&minus;dst-pfx 2001:e20:2000:40f::/64</p>

<p style="margin-left:22%; margin-top: 1em">ip6tables
&minus;t mangle &minus;I PREROUTING &minus;i wlan0 &minus;d
2001:e20:2000:40f::/64 &minus;j DNPT &minus;&minus;src-pfx
2001:e20:2000:40f::/64 &minus;&minus;dst-pfx fd00::/64</p>

<p style="margin-left:11%; margin-top: 1em">You may need to
enable IPv6 neighbor proxy:</p>

<p style="margin-left:22%; margin-top: 1em">sysctl -w
net.ipv6.conf.all.proxy_ndp=1</p>

<p style="margin-left:11%; margin-top: 1em">You also have
to use the <b>NOTRACK</b> target to disable connection
tracking for translated flows.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DSCP</b>
<br>
This target allows to alter the value of the DSCP bits
within the TOS header of the IPv4 packet. As this
manipulates a packet, it can only be used in the mangle
table. <b><br>
&minus;&minus;set&minus;dscp</b> <i>value</i></p>

<p style="margin-left:22%;">Set the DSCP field to a
numerical value (can be decimal or hex)</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;dscp&minus;class</b>
<i>class</i></p>

<p style="margin-left:22%;">Set the DSCP field to a
DiffServ class.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ECN
(IPv4-specific)</b> <br>
This target allows to selectively work around known ECN
blackholes. It can only be used in the mangle table. <b><br>
&minus;&minus;ecn&minus;tcp&minus;remove</b></p>

<p style="margin-left:22%;">Remove all ECN bits from the
TCP header. Of course, it can only be used in conjunction
with <b>&minus;p tcp</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HL
(IPv6-specific)</b> <br>
This is used to modify the Hop Limit field in IPv6 header.
The Hop Limit field is similar to what is known as TTL value
in IPv4. Setting or incrementing the Hop Limit field can
potentially be very dangerous, so it should be avoided at
any cost. This target is only valid in <b>mangle</b>
table.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Don&rsquo;t
ever set or increment the value on packets that leave your
local network! <br>
&minus;&minus;hl&minus;set</b> <i>value</i></p>

<p style="margin-left:22%;">Set the Hop Limit to
&lsquo;value&rsquo;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hl&minus;dec</b>
<i>value</i></p>

<p style="margin-left:22%;">Decrement the Hop Limit
&lsquo;value&rsquo; times.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hl&minus;inc</b>
<i>value</i></p>

<p style="margin-left:22%;">Increment the Hop Limit
&lsquo;value&rsquo; times.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HMARK</b>
<br>
Like MARK, i.e. set the fwmark, but the mark is calculated
from hashing packet selector at choice. You have also to
specify the mark range and, optionally, the offset to start
from. ICMP error messages are inspected and used to
calculate the hashing.</p>

<p style="margin-left:11%; margin-top: 1em">Existing
options are: <b><br>
&minus;&minus;hmark&minus;tuple</b> tuple</p>

<p style="margin-left:22%;">Possible tuple members are:
<b>src</b> meaning source address (IPv4, IPv6 address),
<b>dst</b> meaning destination address (IPv4, IPv6 address),
<b>sport</b> meaning source port (TCP, UDP, UDPlite, SCTP,
DCCP), <b>dport</b> meaning destination port (TCP, UDP,
UDPlite, SCTP, DCCP), <b>spi</b> meaning Security Parameter
Index (AH, ESP), and <b>ct</b> meaning the usage of the
conntrack tuple instead of the packet selectors.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;mod</b>
<i>value (must be &gt; 0)</i></p>

<p style="margin-left:22%;">Modulus for hash calculation
(to limit the range of possible marks)</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;offset</b>
<i>value</i></p>

<p style="margin-left:22%;">Offset to start marks from.</p>

<p style="margin-left:11%;">For advanced usage, instead of
using &minus;&minus;hmark&minus;tuple, you can specify <br>
custom</p>

<p style="margin-left:22%;">prefixes and masks:</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;src&minus;prefix</b>
<i>cidr</i></p>

<p style="margin-left:22%;">The source address mask in CIDR
notation.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;dst&minus;prefix</b>
<i>cidr</i></p>

<p style="margin-left:22%;">The destination address mask in
CIDR notation.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;sport&minus;mask</b>
<i>value</i></p>

<p style="margin-left:22%;">A 16 bit source port mask in
hexadecimal.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;dport&minus;mask</b>
<i>value</i></p>

<p style="margin-left:22%;">A 16 bit destination port mask
in hexadecimal.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;spi&minus;mask</b>
<i>value</i></p>

<p style="margin-left:22%;">A 32 bit field with spi
mask.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;proto&minus;mask</b>
<i>value</i></p>

<p style="margin-left:22%;">An 8 bit field with layer 4
protocol number.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hmark&minus;rnd</b>
<i>value</i></p>

<p style="margin-left:22%;">A 32 bit random custom value to
feed hash calculation.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples:</i></p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A PREROUTING &minus;m conntrack
&minus;&minus;ctstate NEW <br>
&minus;j HMARK &minus;&minus;hmark-tuple ct,src,dst,proto
&minus;&minus;hmark-offset 10000
&minus;&minus;hmark&minus;mod 10
&minus;&minus;hmark&minus;rnd 0xfeedcafe</p>

<p style="margin-left:11%; margin-top: 1em">iptables
&minus;t mangle &minus;A PREROUTING -j HMARK
&minus;&minus;hmark&minus;offset 10000
&minus;&minus;hmark-tuple src,dst,proto
&minus;&minus;hmark-mod 10 &minus;&minus;hmark&minus;rnd
0xdeafbeef</p>


<p style="margin-left:11%; margin-top: 1em"><b>IDLETIMER</b>
<br>
This target can be used to identify when interfaces have
been idle for a certain period of time. Timers are
identified by labels and are created when a rule is set with
a new label. The rules also take a timeout value (in
seconds) as an option. If more than one rule uses the same
timer label, the timer will be restarted whenever any of the
rules get a hit. One entry for each timer is created in
sysfs. This attribute contains the timer remaining for the
timer to expire. The attributes are located under the
xt_idletimer class:</p>


<p style="margin-left:11%; margin-top: 1em">/sys/class/xt_idletimer/timers/&lt;label&gt;</p>

<p style="margin-left:11%; margin-top: 1em">When the timer
expires, the target module sends a sysfs notification to the
userspace, which can then decide what to do (eg. disconnect
to save power). <b><br>
&minus;&minus;timeout</b> <i>amount</i></p>

<p style="margin-left:22%;">This is the time in seconds
that will trigger the notification.</p>

<p style="margin-left:11%;"><b>&minus;&minus;label</b>
<i>string</i></p>

<p style="margin-left:22%;">This is a unique identifier for
the timer. The maximum length for the label string is 27
characters.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LED</b> <br>
This creates an LED-trigger that can then be attached to
system indicator lights, to blink or illuminate them when
certain packets pass through the system. One example might
be to light up an LED for a few minutes every time an SSH
connection is made to the local machine. The following
options control the trigger behavior: <b><br>
&minus;&minus;led&minus;trigger&minus;id</b> <i>name</i></p>

<p style="margin-left:22%;">This is the name given to the
LED trigger. The actual name of the trigger will be prefixed
with &quot;netfilter-&quot;.</p>

<p style="margin-left:11%;"><b>&minus;&minus;led-delay</b>
<i>ms</i></p>

<p style="margin-left:22%;">This indicates how long (in
milliseconds) the LED should be left illuminated when a
packet arrives before being switched off again. The default
is 0 (blink as fast as possible.) The special value
<i>inf</i> can be given to leave the LED on permanently once
activated. (In this case the trigger will need to be
manually detached and reattached to the LED device to switch
it off again.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;led&minus;always&minus;blink</b></p>

<p style="margin-left:22%;">Always make the LED blink on
packet arrival, even if the LED is already on. This allows
notification of new packets even with long delay values
(which otherwise would result in a silent prolonging of the
delay time.)</p>

<p style="margin-left:11%;">Example: <br>
Create an LED trigger for incoming SSH traffic:</p>

<p style="margin-left:22%;">iptables &minus;A INPUT
&minus;p tcp &minus;&minus;dport 22 &minus;j LED
&minus;&minus;led&minus;trigger&minus;id ssh</p>

<p style="margin-left:11%;">Then attach the new trigger to
an LED:</p>

<p style="margin-left:22%;">echo netfilter&minus;ssh
&gt;/sys/class/leds/<i>ledname</i>/trigger</p>

<p style="margin-left:11%; margin-top: 1em"><b>LOG</b> <br>
Turn on kernel logging of matching packets. When this option
is set for a rule, the Linux kernel will print some
information on all matching packets (like most IP/IPv6
header fields) via the kernel log (where it can be read with
<i>dmesg(1)</i> or read in the syslog).</p>

<p style="margin-left:11%; margin-top: 1em">This is a
&quot;non-terminating target&quot;, i.e. rule traversal
continues at the next rule. So if you want to LOG the
packets you refuse, use two separate rules with the same
matching criteria, first using target LOG then DROP (or
REJECT). <b><br>
&minus;&minus;log&minus;level</b> <i>level</i></p>

<p style="margin-left:22%;">Level of logging, which can be
(system-specific) numeric or a mnemonic. Possible values are
(in decreasing order of priority): <b>emerg</b>,
<b>alert</b>, <b>crit</b>, <b>error</b>, <b>warning</b>,
<b>notice</b>, <b>info</b> or <b>debug</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log&minus;prefix</b>
<i>prefix</i></p>

<p style="margin-left:22%;">Prefix log messages with the
specified prefix; up to 29 letters long, and useful for
distinguishing messages in the logs.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log&minus;tcp&minus;sequence</b></p>

<p style="margin-left:22%;">Log TCP sequence numbers. This
is a security risk if the log is readable by users.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log&minus;tcp&minus;options</b></p>

<p style="margin-left:22%;">Log options from the TCP packet
header.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log&minus;ip&minus;options</b></p>

<p style="margin-left:22%;">Log options from the IP/IPv6
packet header.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log&minus;uid</b></p>

<p style="margin-left:22%;">Log the userid of the process
which generated the packet.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MARK</b>
<br>
This target is used to set the Netfilter mark value
associated with the packet. It can, for example, be used in
conjunction with routing based on fwmark (needs iproute2).
If you plan on doing so, note that the mark needs to be set
in the PREROUTING chain of the mangle table to affect
routing. The mark field is 32 bits wide. <b><br>
&minus;&minus;set&minus;xmark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Zeroes out the bits given by
<i>mask</i> and XORs <i>value</i> into the packet mark
(&quot;nfmark&quot;). If <i>mask</i> is omitted, 0xFFFFFFFF
is assumed.</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;mark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Zeroes out the bits given by
<i>mask</i> and ORs <i>value</i> into the packet mark. If
<i>mask</i> is omitted, 0xFFFFFFFF is assumed.</p>

<p style="margin-left:11%; margin-top: 1em">The following
mnemonics are available: <b><br>
&minus;&minus;and&minus;mark</b> <i>bits</i></p>

<p style="margin-left:22%;">Binary AND the nfmark with
<i>bits</i>. (Mnemonic for <b>&minus;&minus;set&minus;xmark
0/</b><i>invbits</i>, where <i>invbits</i> is the binary
negation of <i>bits</i>.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;or&minus;mark</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary OR the nfmark with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;xmark</b>
<i>bits</i><b>/</b><i>bits</i>.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;xor&minus;mark</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary XOR the nfmark with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;xmark</b>
<i>bits</i><b>/0</b>.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>MASQUERADE</b>
<br>
This target is only valid in the <b>nat</b> table, in the
<b>POSTROUTING</b> chain. It should only be used with
dynamically assigned IP (dialup) connections: if you have a
static IP address, you should use the SNAT target.
Masquerading is equivalent to specifying a mapping to the IP
address of the interface the packet is going out, but also
has the effect that connections are <i>forgotten</i> when
the interface goes down. This is the correct behavior when
the next dialup is unlikely to have the same interface
address (and hence any established connections are lost
anyway). <b><br>
&minus;&minus;to&minus;ports</b>
<i>port</i>[<b>&minus;</b><i>port</i>]</p>

<p style="margin-left:22%;">This specifies a range of
source ports to use, overriding the default <b>SNAT</b>
source port-selection heuristics (see above). This is only
valid if the rule also specifies one of the following
protocols: <b>tcp</b>, <b>udp</b>, <b>dccp</b> or
<b>sctp</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;random</b></p>

<p style="margin-left:22%;">Randomize source port mapping
If option <b>&minus;&minus;random</b> is used then port
mapping will be randomized (kernel &gt;= 2.6.21).</p>

<p style="margin-left:11%;">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MIRROR
(IPv4-specific)</b> <br>
This is an experimental demonstration target which inverts
the source and destination fields in the IP header and
retransmits the packet. It is only valid in the
<b>INPUT</b>, <b>FORWARD</b> and <b>PREROUTING</b> chains,
and user-defined chains which are only called from those
chains. Note that the outgoing packets are <b>NOT</b> seen
by any packet filtering chains, connection tracking or NAT,
to avoid loops and other problems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NETMAP</b>
<br>
This target allows you to statically map a whole network of
addresses onto another network of addresses. It can only be
used from rules in the <b>nat</b> table. <b><br>
&minus;&minus;to</b> <i>address</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Network address to map to. The
resulting address will be constructed in the following way:
All &rsquo;one&rsquo; bits in the mask are filled in from
the new &lsquo;address&rsquo;. All bits that are zero in the
mask are filled in from the original address.</p>

<p style="margin-left:11%;">IPv6 support available since
Linux kernels &gt;= 3.7.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NFLOG</b>
<br>
This target provides logging of matching packets. When this
target is set for a rule, the Linux kernel will pass the
packet to the loaded logging backend to log the packet. This
is usually used in combination with nfnetlink_log as logging
backend, which will multicast the packet through a
<i>netlink</i> socket to the specified multicast group. One
or more userspace processes may subscribe to the group to
receive the packets. Like LOG, this is a non-terminating
target, i.e. rule traversal continues at the next rule.
<b><br>
&minus;&minus;nflog&minus;group</b> <i>nlgroup</i></p>

<p style="margin-left:22%;">The netlink group (0 -
2^16&minus;1) to which packets are (only applicable for
nfnetlink_log). The default value is 0.</p>


<p style="margin-left:11%;"><b>&minus;&minus;nflog&minus;prefix</b>
<i>prefix</i></p>

<p style="margin-left:22%;">A prefix string to include in
the log message, up to 64 characters long, useful for
distinguishing messages in the logs.</p>


<p style="margin-left:11%;"><b>&minus;&minus;nflog&minus;range</b>
<i>size</i></p>

<p style="margin-left:22%;">The number of bytes to be
copied to userspace (only applicable for nfnetlink_log).
nfnetlink_log instances may specify their own range, this
option overrides it.</p>


<p style="margin-left:11%;"><b>&minus;&minus;nflog&minus;threshold</b>
<i>size</i></p>

<p style="margin-left:22%;">Number of packets to queue
inside the kernel before sending them to userspace (only
applicable for nfnetlink_log). Higher values result in less
overhead per packet, but increase delay until the packets
reach userspace. The default value is 1.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NFQUEUE</b>
<br>
This target passes the packet to userspace using the
<b>nfnetlink_queue</b> handler. The packet is put into the
queue identified by its 16-bit queue number. Userspace can
inspect and modify the packet if desired. Userspace must
then drop or reinject the packet into the kernel. Please see
libnetfilter_queue for details. <b>nfnetlink_queue</b> was
added in Linux 2.6.14. The <b>queue-balance</b> option was
added in Linux 2.6.31, <b>queue-bypass</b> in 2.6.39.
<b><br>
&minus;&minus;queue&minus;num</b> <i>value</i></p>

<p style="margin-left:22%;">This specifies the QUEUE number
to use. Valid queue numbers are 0 to 65535. The default
value is 0.</p>


<p style="margin-left:11%;"><b>&minus;&minus;queue&minus;balance</b>
<i>value</i><b>:</b><i>value</i></p>

<p style="margin-left:22%;">This specifies a range of
queues to use. Packets are then balanced across the given
queues. This is useful for multicore systems: start multiple
instances of the userspace program on queues x, x+1, .. x+n
and use &quot;&minus;&minus;queue&minus;balance
<i>x</i><b>:</b><i>x+n</i>&quot;. Packets belonging to the
same connection are put into the same nfqueue.</p>


<p style="margin-left:11%;"><b>&minus;&minus;queue&minus;bypass</b></p>

<p style="margin-left:22%;">By default, if no userspace
program is listening on an NFQUEUE, then all packets that
are to be queued are dropped. When this option is used, the
NFQUEUE rule behaves like ACCEPT instead, and the packet
will move on to the next table.</p>


<p style="margin-left:11%;"><b>&minus;&minus;queue&minus;cpu-fanout</b></p>

<p style="margin-left:22%;">Available starting Linux kernel
3.10. When used together with <b>--queue-balance</b> this
will use the CPU ID as an index to map packets to the
queues. The idea is that you can improve performance if
there&rsquo;s a queue per CPU. This requires
<b>--queue-balance</b> to be specified.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTRACK</b>
<br>
This extension disables connection tracking for all packets
matching that rule. It is equivalent with &minus;j CT
&minus;&minus;notrack. Like CT, NOTRACK can only be used in
the <b>raw</b> table.</p>

<p style="margin-left:11%; margin-top: 1em"><b>RATEEST</b>
<br>
The RATEEST target collects statistics, performs rate
estimation calculation and saves the results for later
evaluation using the <b>rateest</b> match. <b><br>
&minus;&minus;rateest&minus;name</b> <i>name</i></p>

<p style="margin-left:22%;">Count matched packets into the
pool referred to by <i>name</i>, which is freely
choosable.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rateest&minus;interval</b>
<i>amount</i>{<b>s</b>|<b>ms</b>|<b>us</b>}</p>

<p style="margin-left:22%;">Rate measurement interval, in
seconds, milliseconds or microseconds.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rateest&minus;ewmalog</b>
<i>value</i></p>

<p style="margin-left:22%;">Rate measurement averaging time
constant.</p>


<p style="margin-left:11%; margin-top: 1em"><b>REDIRECT</b>
<br>
This target is only valid in the <b>nat</b> table, in the
<b>PREROUTING</b> and <b>OUTPUT</b> chains, and user-defined
chains which are only called from those chains. It redirects
the packet to the machine itself by changing the destination
IP to the primary address of the incoming interface
(locally-generated packets are mapped to the localhost
address, 127.0.0.1 for IPv4 and ::1 for IPv6). <b><br>
&minus;&minus;to&minus;ports</b>
<i>port</i>[<b>&minus;</b><i>port</i>]</p>

<p style="margin-left:22%;">This specifies a destination
port or range of ports to use: without this, the destination
port is never altered. This is only valid if the rule also
specifies one of the following protocols: <b>tcp</b>,
<b>udp</b>, <b>dccp</b> or <b>sctp</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;random</b></p>

<p style="margin-left:22%;">If option
<b>&minus;&minus;random</b> is used then port mapping will
be randomized (kernel &gt;= 2.6.22).</p>

<p style="margin-left:11%;">IPv6 support available starting
Linux kernels &gt;= 3.7.</p>

<p style="margin-left:11%; margin-top: 1em"><b>REJECT
(IPv6-specific)</b> <br>
This is used to send back an error packet in response to the
matched packet: otherwise it is equivalent to <b>DROP</b> so
it is a terminating TARGET, ending rule traversal. This
target is only valid in the <b>INPUT</b>, <b>FORWARD</b> and
<b>OUTPUT</b> chains, and user-defined chains which are only
called from those chains. The following option controls the
nature of the error packet returned: <b><br>
&minus;&minus;reject&minus;with</b> <i>type</i></p>

<p style="margin-left:22%;">The type given can be
<b>icmp6&minus;no&minus;route</b>, <b>no&minus;route</b>,
<b>icmp6&minus;adm&minus;prohibited</b>,
<b>adm&minus;prohibited</b>,
<b>icmp6&minus;addr&minus;unreachable</b>,
<b>addr&minus;unreach</b>, or
<b>icmp6&minus;port&minus;unreachable</b>, which return the
appropriate ICMPv6 error message
(<b>icmp6&minus;port&minus;unreachable</b> is the default).
Finally, the option <b>tcp&minus;reset</b> can be used on
rules which only match the TCP protocol: this causes a TCP
RST packet to be sent back. This is mainly useful for
blocking <i>ident</i> (113/tcp) probes which frequently
occur when sending mail to broken mail hosts (which
won&rsquo;t accept your mail otherwise).
<b>tcp&minus;reset</b> can only be used with kernel versions
2.6.14 or later.</p>

<p style="margin-left:11%; margin-top: 1em"><b>REJECT
(IPv4-specific)</b> <br>
This is used to send back an error packet in response to the
matched packet: otherwise it is equivalent to <b>DROP</b> so
it is a terminating TARGET, ending rule traversal. This
target is only valid in the <b>INPUT</b>, <b>FORWARD</b> and
<b>OUTPUT</b> chains, and user-defined chains which are only
called from those chains. The following option controls the
nature of the error packet returned: <b><br>
&minus;&minus;reject&minus;with</b> <i>type</i></p>

<p style="margin-left:22%;">The type given can be
<b>icmp&minus;net&minus;unreachable</b>,
<b>icmp&minus;host&minus;unreachable</b>,
<b>icmp&minus;port&minus;unreachable</b>,
<b>icmp&minus;proto&minus;unreachable</b>,
<b>icmp&minus;net&minus;prohibited</b>,
<b>icmp&minus;host&minus;prohibited</b>, or
<b>icmp&minus;admin&minus;prohibited</b> (*), which return
the appropriate ICMP error message
(<b>icmp&minus;port&minus;unreachable</b> is the default).
The option <b>tcp&minus;reset</b> can be used on rules which
only match the TCP protocol: this causes a TCP RST packet to
be sent back. This is mainly useful for blocking
<i>ident</i> (113/tcp) probes which frequently occur when
sending mail to broken mail hosts (which won&rsquo;t accept
your mail otherwise).</p>

<p style="margin-left:11%; margin-top: 1em">(*) Using
icmp&minus;admin&minus;prohibited with kernels that do not
support it will result in a plain DROP instead of REJECT</p>

<p style="margin-left:11%; margin-top: 1em"><b>SAME
(IPv4-specific)</b> <br>
Similar to SNAT/DNAT depending on chain: it takes a range of
addresses (&lsquo;&minus;&minus;to
1.2.3.4&minus;1.2.3.7&rsquo;) and gives a client the same
source-/destination-address for each connection.</p>

<p style="margin-left:11%; margin-top: 1em">N.B.: The DNAT
target&rsquo;s <b>&minus;&minus;persistent</b> option
replaced the SAME target. <b><br>
&minus;&minus;to</b>
<i>ipaddr</i>[<b>&minus;</b><i>ipaddr</i>]</p>

<p style="margin-left:22%;">Addresses to map source to. May
be specified more than once for multiple ranges.</p>

<p style="margin-left:11%;"><b>&minus;&minus;nodst</b></p>

<p style="margin-left:22%;">Don&rsquo;t use the
destination-ip in the calculations when selecting the new
source-ip</p>


<p style="margin-left:11%;"><b>&minus;&minus;random</b></p>

<p style="margin-left:22%;">Port mapping will be forcibly
randomized to avoid attacks based on port prediction (kernel
&gt;= 2.6.21).</p>

<p style="margin-left:11%; margin-top: 1em"><b>SECMARK</b>
<br>
This is used to set the security mark value associated with
the packet for use by security subsystems such as SELinux.
It is valid in the <b>security</b> table (for backwards
compatibility with older kernels, it is also valid in the
<b>mangle</b> table). The mark is 32 bits wide. <b><br>
&minus;&minus;selctx</b> <i>security_context</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>SET</b> <br>
This module adds and/or deletes entries from IP sets which
can be defined by ipset(8). <b><br>
&minus;&minus;add&minus;set</b> <i>setname
flag</i>[<b>,</b><i>flag</i>...]</p>

<p style="margin-left:22%;">add the address(es)/port(s) of
the packet to the set</p>


<p style="margin-left:11%;"><b>&minus;&minus;del&minus;set</b>
<i>setname flag</i>[<b>,</b><i>flag</i>...]</p>

<p style="margin-left:22%;">delete the address(es)/port(s)
of the packet from the set</p>

<p style="margin-left:22%; margin-top: 1em">where
<i>flag</i>(s) are <b>src</b> and/or <b>dst</b>
specifications and there can be no more than six of
them.</p>

<p style="margin-left:11%;"><b>&minus;&minus;timeout</b>
<i>value</i></p>

<p style="margin-left:22%;">when adding an entry, the
timeout value to use instead of the default one from the set
definition</p>

<p style="margin-left:11%;"><b>&minus;&minus;exist</b></p>

<p style="margin-left:22%;">when adding an entry if it
already exists, reset the timeout value to the specified one
or to the default from the set definition</p>

<p style="margin-left:11%; margin-top: 1em">Use of -j SET
requires that ipset kernel support is provided, which, for
standard kernels, is the case since Linux 2.6.39.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SNAT</b>
<br>
This target is only valid in the <b>nat</b> table, in the
<b>POSTROUTING</b> and <b>INPUT</b> chains, and user-defined
chains which are only called from those chains. It specifies
that the source address of the packet should be modified
(and all future packets in this connection will also be
mangled), and rules should cease being examined. It takes
the following options: <b><br>
&minus;&minus;to&minus;source</b>
[<i>ipaddr</i>[<b>&minus;</b><i>ipaddr</i>]][<b>:</b><i>port</i>[<b>&minus;</b><i>port</i>]]</p>

<p style="margin-left:22%;">which can specify a single new
source IP address, an inclusive range of IP addresses.
Optionally a port range, if the rule also specifies one of
the following protocols: <b>tcp</b>, <b>udp</b>, <b>dccp</b>
or <b>sctp</b>. If no port range is specified, then source
ports below 512 will be mapped to other ports below 512:
those between 512 and 1023 inclusive will be mapped to ports
below 1024, and other ports will be mapped to 1024 or above.
Where possible, no port alteration will occur. In Kernels up
to 2.6.10, you can add several &minus;&minus;to&minus;source
options. For those kernels, if you specify more than one
source address, either via an address range or multiple
&minus;&minus;to&minus;source options, a simple round-robin
(one after another in cycle) takes place between these
addresses. Later Kernels (&gt;= 2.6.11-rc1) don&rsquo;t have
the ability to NAT to multiple ranges anymore.</p>


<p style="margin-left:11%;"><b>&minus;&minus;random</b></p>

<p style="margin-left:22%;">If option
<b>&minus;&minus;random</b> is used then port mapping will
be randomized (kernel &gt;= 2.6.21).</p>


<p style="margin-left:11%;"><b>&minus;&minus;persistent</b></p>

<p style="margin-left:22%;">Gives a client the same
source-/destination-address for each connection. This
supersedes the SAME target. Support for persistent mappings
is available from 2.6.29-rc2.</p>

<p style="margin-left:11%; margin-top: 1em">Kernels prior
to 2.6.36-rc1 don&rsquo;t have the ability to <b>SNAT</b> in
the <b>INPUT</b> chain. <br>
IPv6 support available since Linux kernels &gt;= 3.7.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SNPT
(IPv6-specific)</b> <br>
Provides stateless source IPv6-to-IPv6 Network Prefix
Translation (as described by RFC 6296).</p>

<p style="margin-left:11%; margin-top: 1em">You have to use
this target in the <b>mangle</b> table, not in the
<b>nat</b> table. It takes the following options: <b><br>
&minus;&minus;src&minus;pfx</b> [<i>prefix/length]</i></p>

<p style="margin-left:22%;">Set source prefix that you want
to translate and length</p>


<p style="margin-left:11%;"><b>&minus;&minus;dst&minus;pfx</b>
[<i>prefix/length]</i></p>

<p style="margin-left:22%;">Set destination prefix that you
want to use in the translation and length</p>

<p style="margin-left:11%; margin-top: 1em">You have to use
the DNPT target to undo the translation. Example:</p>

<p style="margin-left:22%; margin-top: 1em">ip6tables
&minus;t mangle &minus;I POSTROUTING &minus;s fd00::/64
&minus;o vboxnet0 &minus;j SNPT &minus;&minus;src-pfx
fd00::/64 &minus;&minus;dst-pfx 2001:e20:2000:40f::/64</p>

<p style="margin-left:22%; margin-top: 1em">ip6tables
&minus;t mangle &minus;I PREROUTING &minus;i wlan0 &minus;d
2001:e20:2000:40f::/64 &minus;j DNPT &minus;&minus;src-pfx
2001:e20:2000:40f::/64 &minus;&minus;dst-pfx fd00::/64</p>

<p style="margin-left:11%; margin-top: 1em">You may need to
enable IPv6 neighbor proxy:</p>

<p style="margin-left:22%; margin-top: 1em">sysctl -w
net.ipv6.conf.all.proxy_ndp=1</p>

<p style="margin-left:11%; margin-top: 1em">You also have
to use the <b>NOTRACK</b> target to disable connection
tracking for translated flows.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TCPMSS</b>
<br>
This target allows to alter the MSS value of TCP SYN
packets, to control the maximum size for that connection
(usually limiting it to your outgoing interface&rsquo;s MTU
minus 40 for IPv4 or 60 for IPv6, respectively). Of course,
it can only be used in conjunction with <b>&minus;p
tcp</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This target is
used to overcome criminally braindead ISPs or servers which
block &quot;ICMP Fragmentation Needed&quot; or &quot;ICMPv6
Packet Too Big&quot; packets. The symptoms of this problem
are that everything works fine from your Linux
firewall/router, but machines behind it can never exchange
large packets:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Web browsers connect, then hang with no data
received.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Small mail works fine, but large emails hang.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>ssh works fine, but scp hangs after initial
handshaking.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Workaround:
activate this option and add a rule to your firewall
configuration like:</p>

<p style="margin-left:22%; margin-top: 1em">iptables
&minus;t mangle &minus;A FORWARD &minus;p tcp
&minus;&minus;tcp&minus;flags SYN,RST SYN <br>
&minus;j TCPMSS
&minus;&minus;clamp&minus;mss&minus;to&minus;pmtu</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;mss</b>
<i>value</i></p>

<p style="margin-left:22%;">Explicitly sets MSS option to
specified value. If the MSS of the packet is already lower
than <i>value</i>, it will <b>not</b> be increased (from
Linux 2.6.25 onwards) to avoid more problems with hosts
relying on a proper MSS.</p>


<p style="margin-left:11%;"><b>&minus;&minus;clamp&minus;mss&minus;to&minus;pmtu</b></p>

<p style="margin-left:22%;">Automatically clamp MSS value
to (path_MTU &minus; 40 for IPv4; &minus;60 for IPv6). This
may not function as desired where asymmetric routes with
differing path MTU exist &mdash; the kernel uses the path
MTU which it would use to send packets from itself to the
source and destination IP addresses. Prior to Linux 2.6.25,
only the path MTU to the destination IP address was
considered by this option; subsequent kernels also consider
the path MTU to the source IP address.</p>

<p style="margin-left:11%; margin-top: 1em">These options
are mutually exclusive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TCPOPTSTRIP</b>
<br>
This target will strip TCP options off a TCP packet. (It
will actually replace them by NO-OPs.) As such, you will
need to add the <b>&minus;p tcp</b> parameters. <b><br>
&minus;&minus;strip&minus;options</b>
<i>option</i>[<b>,</b><i>option</i>...]</p>

<p style="margin-left:22%;">Strip the given option(s). The
options may be specified by TCP option number or by symbolic
name. The list of recognized options can be obtained by
calling iptables with <b>&minus;j TCPOPTSTRIP
&minus;h</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TEE</b> <br>
The <b>TEE</b> target will clone a packet and redirect this
clone to another machine on the <b>local</b> network
segment. In other words, the nexthop must be the target, or
you will have to configure the nexthop to forward it further
if so desired. <b><br>
&minus;&minus;gateway</b> <i>ipaddr</i></p>

<p style="margin-left:22%;">Send the cloned packet to the
host reachable at the given IP address. Use of 0.0.0.0 (for
IPv4 packets) or :: (IPv6) is invalid.</p>

<p style="margin-left:11%; margin-top: 1em">To forward all
incoming traffic on eth0 to an Network Layer logging
box:</p>

<p style="margin-left:11%; margin-top: 1em">&minus;t mangle
&minus;A PREROUTING &minus;i eth0 &minus;j TEE
&minus;&minus;gateway 2001:db8::1</p>

<p style="margin-left:11%; margin-top: 1em"><b>TOS</b> <br>
This module sets the Type of Service field in the IPv4
header (including the &quot;precedence&quot; bits) or the
Priority field in the IPv6 header. Note that TOS shares the
same bits as DSCP and ECN. The TOS target is only valid in
the <b>mangle</b> table. <b><br>
&minus;&minus;set&minus;tos</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Zeroes out the bits given by
<i>mask</i> (see NOTE below) and XORs <i>value</i> into the
TOS/Priority field. If <i>mask</i> is omitted, 0xFF is
assumed.</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;tos</b>
<i>symbol</i></p>

<p style="margin-left:22%;">You can specify a symbolic name
when using the TOS target for IPv4. It implies a mask of
0xFF (see NOTE below). The list of recognized TOS names can
be obtained by calling iptables with <b>&minus;j TOS
&minus;h</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
mnemonics are available: <b><br>
&minus;&minus;and&minus;tos</b> <i>bits</i></p>

<p style="margin-left:22%;">Binary AND the TOS value with
<i>bits</i>. (Mnemonic for <b>&minus;&minus;set&minus;tos
0/</b><i>invbits</i>, where <i>invbits</i> is the binary
negation of <i>bits</i>. See NOTE below.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;or&minus;tos</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary OR the TOS value with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;tos</b>
<i>bits</i><b>/</b><i>bits</i>. See NOTE below.)</p>


<p style="margin-left:11%;"><b>&minus;&minus;xor&minus;tos</b>
<i>bits</i></p>

<p style="margin-left:22%;">Binary XOR the TOS value with
<i>bits</i>. (Mnemonic for
<b>&minus;&minus;set&minus;tos</b> <i>bits</i><b>/0</b>. See
NOTE below.)</p>

<p style="margin-left:11%; margin-top: 1em">NOTE: In Linux
kernels up to and including 2.6.38, with the exception of
longterm releases 2.6.32 (&gt;=.42), 2.6.33 (&gt;=.15), and
2.6.35 (&gt;=.14), there is a bug whereby IPv6 TOS mangling
does not behave as documented and differs from the IPv4
version. The TOS mask indicates the bits one wants to zero
out, so it needs to be inverted before applying it to the
original TOS field. However, the aformentioned kernels forgo
the inversion which breaks --set-tos and its mnemonics.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TPROXY</b>
<br>
This target is only valid in the <b>mangle</b> table, in the
<b>PREROUTING</b> chain and user-defined chains which are
only called from this chain. It redirects the packet to a
local socket without changing the packet header in any way.
It can also change the mark value which can then be used in
advanced routing rules. It takes three options: <b><br>
&minus;&minus;on&minus;port</b> <i>port</i></p>

<p style="margin-left:22%;">This specifies a destination
port to use. It is a required option, 0 means the new
destination port is the same as the original. This is only
valid if the rule also specifies <b>&minus;p tcp</b> or
<b>&minus;p udp</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;on&minus;ip</b>
<i>address</i></p>

<p style="margin-left:22%;">This specifies a destination
address to use. By default the address is the IP address of
the incoming interface. This is only valid if the rule also
specifies <b>&minus;p tcp</b> or <b>&minus;p udp</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;tproxy&minus;mark</b>
<i>value</i>[<b>/</b><i>mask</i>]</p>

<p style="margin-left:22%;">Marks packets with the given
value/mask. The fwmark value set here can be used by
advanced routing. (Required for transparent proxying to
work: otherwise these packets will get forwarded, which is
probably not what you want.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>TRACE</b>
<br>
This target marks packets so that the kernel will log every
rule which match the packets as those traverse the tables,
chains, rules.</p>

<p style="margin-left:11%; margin-top: 1em">A logging
backend, such as ip(6)t_LOG or nfnetlink_log, must be loaded
for this to be visible. The packets are logged with the
string prefix: &quot;TRACE: tablename:chainname:type:rulenum
&quot; where type can be &quot;rule&quot; for plain rule,
&quot;return&quot; for implicit rule at the end of a user
defined chain and &quot;policy&quot; for the policy of the
built in chains. <br>
It can only be used in the <b>raw</b> table.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TTL
(IPv4-specific)</b> <br>
This is used to modify the IPv4 TTL header field. The TTL
field determines how many hops (routers) a packet can
traverse until it&rsquo;s time to live is exceeded.</p>

<p style="margin-left:11%; margin-top: 1em">Setting or
incrementing the TTL field can potentially be very
dangerous, so it should be avoided at any cost. This target
is only valid in <b>mangle</b> table.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Don&rsquo;t
ever set or increment the value on packets that leave your
local network! <br>
&minus;&minus;ttl&minus;set</b> <i>value</i></p>

<p style="margin-left:22%;">Set the TTL value to
&lsquo;value&rsquo;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ttl&minus;dec</b>
<i>value</i></p>

<p style="margin-left:22%;">Decrement the TTL value
&lsquo;value&rsquo; times.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ttl&minus;inc</b>
<i>value</i></p>

<p style="margin-left:22%;">Increment the TTL value
&lsquo;value&rsquo; times.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ULOG
(IPv4-specific)</b> <br>
This is the deprecated ipv4-only predecessor of the NFLOG
target. It provides userspace logging of matching packets.
When this target is set for a rule, the Linux kernel will
multicast this packet through a <i>netlink</i> socket. One
or more userspace processes may then subscribe to various
multicast groups and receive the packets. Like LOG, this is
a &quot;non-terminating target&quot;, i.e. rule traversal
continues at the next rule. <b><br>
&minus;&minus;ulog&minus;nlgroup</b> <i>nlgroup</i></p>

<p style="margin-left:22%;">This specifies the netlink
group (1-32) to which the packet is sent. Default value is
1.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ulog&minus;prefix</b>
<i>prefix</i></p>

<p style="margin-left:22%;">Prefix log messages with the
specified prefix; up to 32 characters long, and useful for
distinguishing messages in the logs.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ulog&minus;cprange</b>
<i>size</i></p>

<p style="margin-left:22%;">Number of bytes to be copied to
userspace. A value of 0 always copies the entire packet,
regardless of its size. Default is 0.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ulog&minus;qthreshold</b>
<i>size</i></p>

<p style="margin-left:22%;">Number of packet to queue
inside kernel. Setting this value to, e.g. 10 accumulates
ten packets inside the kernel and transmits them as one
netlink multipart message to userspace. Default is 1 (for
backwards compatibility).</p>
<hr>
</body>
</html>
