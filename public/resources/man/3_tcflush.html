<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:10:13 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TERMIOS</title>

</head>
<body>

<h1 align="center">TERMIOS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">termios,
tcgetattr, tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow,
cfmakeraw, cfgetospeed, cfgetispeed, cfsetispeed,
cfsetospeed, cfsetspeed &minus; get and set terminal
attributes, line control, get and set baud rate</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;termios.h&gt; <br>
#include &lt;unistd.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcgetattr(int</b> <i>fd</i><b>, struct termios
*</b><i>termios_p</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcsetattr(int</b> <i>fd</i><b>, int</b>
<i>optional_actions</i><b>, <br>
const struct termios *</b><i>termios_p</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcsendbreak(int</b> <i>fd</i><b>, int</b>
<i>duration</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcdrain(int</b> <i>fd</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcflush(int</b> <i>fd</i><b>, int</b>
<i>queue_selector</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
tcflow(int</b> <i>fd</i><b>, int</b>
<i>action</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
cfmakeraw(struct termios *</b><i>termios_p</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>speed_t
cfgetispeed(const struct termios
*</b><i>termios_p</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>speed_t
cfgetospeed(const struct termios
*</b><i>termios_p</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
cfsetispeed(struct termios *</b><i>termios_p</i><b>,
speed_t</b> <i>speed</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
cfsetospeed(struct termios *</b><i>termios_p</i><b>,
speed_t</b> <i>speed</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
cfsetspeed(struct termios *</b><i>termios_p</i><b>,
speed_t</b> <i>speed</i><b>);</b></p>

<p style="margin-left:5%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfsetspeed</b>(),
<b>cfmakeraw</b>(): _BSD_SOURCE</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The termios
functions describe a general terminal interface that is
provided to control asynchronous communications ports.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The termios
structure</b> <br>
Many of the functions described here have a <i>termios_p</i>
argument that is a pointer to a <i>termios</i> structure.
This structure contains at least the following members:</p>

<p style="margin-left:17%; margin-top: 1em">tcflag_t
c_iflag; /* input modes */ <br>
tcflag_t c_oflag; /* output modes */ <br>
tcflag_t c_cflag; /* control modes */ <br>
tcflag_t c_lflag; /* local modes */ <br>
cc_t c_cc[NCCS]; /* special characters */</p>

<p style="margin-left:11%; margin-top: 1em">The values that
may be assigned to these fields are described below. In the
case of the first four bit-mask fields, the definitions of
some of the associated flags that may be set are exposed
only if a specific feature test macro (see
<b>feature_test_macros</b>(7)) is defined, as noted in
brackets (&quot;[]&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">In the
descriptions below, &quot;not in POSIX&quot; means that the
value is not specified in POSIX.1-2001, and &quot;XSI&quot;
means that the value is specified in POSIX.1-2001 as part of
the XSI extension.</p>

<p style="margin-left:11%; margin-top: 1em"><i>c_iflag</i>
flag constants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IGNBRK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Ignore BREAK condition on input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>BRKINT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If <b>IGNBRK</b> is set, a BREAK is ignored. If it is
not set but <b>BRKINT</b> is set, then a BREAK causes the
input and output queues to be flushed, and if the terminal
is the controlling terminal of a foreground process group,
it will cause a <b>SIGINT</b> to be sent to this foreground
process group. When neither <b>IGNBRK</b> nor <b>BRKINT</b>
are set, a BREAK reads as a null byte ('\0'), except when
<b>PARMRK</b> is set, in which case it reads as the sequence
\377 \0 \0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IGNPAR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Ignore framing errors and parity errors.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>PARMRK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If <b>IGNPAR</b> is not set, prefix a character with a
parity error or framing error with \377 \0. If neither
<b>IGNPAR</b> nor <b>PARMRK</b> is set, read a character
with a parity error or framing error as \0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>INPCK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable input parity checking.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ISTRIP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Strip off eighth bit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>INLCR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Translate NL to CR on input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IGNCR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Ignore carriage return on input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ICRNL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Translate carriage return to newline on input (unless
<b>IGNCR</b> is set).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IUCLC</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) Map uppercase characters to lowercase on
input.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IXON</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable XON/XOFF flow control on output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IXANY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(XSI) Typing any character will restart stopped output.
(The default is to allow just the START character to restart
output.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IXOFF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable XON/XOFF flow control on input.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>IMAXBEL</b></p>

<p style="margin-left:22%;">(not in POSIX) Ring bell when
input queue is full. Linux does not implement this bit, and
acts as if it is always set.</p>

<p style="margin-left:11%;"><b>IUTF8</b> (since Linux
2.6.4)</p>

<p style="margin-left:22%;">(not in POSIX) Input is UTF8;
this allows character-erase to be correctly performed in
cooked mode.</p>

<p style="margin-left:11%; margin-top: 1em"><i>c_oflag</i>
flag constants defined in POSIX.1:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>OPOST</b></p></td>
<td width="4%"></td>
<td width="73%">


<p>Enable implementation-defined output processing.</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The remaining
<i>c_oflag</i> flag constants are defined in POSIX.1-2001,
unless marked otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>OLCUC</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">(not in POSIX) Map lowercase
characters to uppercase on output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ONLCR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(XSI) Map NL to CR-NL on output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>OCRNL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Map CR to NL on output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ONOCR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Don&rsquo;t output CR at column 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ONLRET</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Don&rsquo;t output CR.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>OFILL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Send fill characters for a delay, rather than using a
timed delay.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>OFDEL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) Fill character is ASCII DEL (0177). If
unset, fill character is ASCII NUL ('\0'). (Not implemented
on Linux.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>NLDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Newline delay mask. Values are <b>NL0</b> and
<b>NL1</b>. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b> or <b>_XOPEN_SOURCE</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CRDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Carriage return delay mask. Values are <b>CR0</b>,
<b>CR1</b>, <b>CR2</b>, or <b>CR3</b>. [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b> or
<b>_XOPEN_SOURCE</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TABDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Horizontal tab delay mask. Values are <b>TAB0</b>,
<b>TAB1</b>, <b>TAB2</b>, <b>TAB3</b> (or <b>XTABS</b>). A
value of TAB3, that is, XTABS, expands tabs to spaces (with
tab stops every eight columns). [requires <b>_BSD_SOURCE</b>
or <b>_SVID_SOURCE</b> or <b>_XOPEN_SOURCE</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>BSDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Backspace delay mask. Values are <b>BS0</b> or
<b>BS1</b>. (Has never been implemented.) [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b> or
<b>_XOPEN_SOURCE</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VTDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Vertical tab delay mask. Values are <b>VT0</b> or
<b>VT1</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>FFDLY</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Form feed delay mask. Values are <b>FF0</b> or
<b>FF1</b>. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b> or <b>_XOPEN_SOURCE</b>]</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>c_cflag</i>
flag constants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>CBAUD</b></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">(not in POSIX) Baud speed mask
(4+1 bits). [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b>]</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CBAUDEX</b></p>

<p style="margin-left:22%;">(not in POSIX) Extra baud speed
mask (1 bit), included in <b>CBAUD</b>. [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b>]</p>

<p style="margin-left:22%; margin-top: 1em">(POSIX says
that the baud speed is stored in the <i>termios</i>
structure without specifying where precisely, and provides
<b>cfgetispeed</b>() and <b>cfsetispeed</b>() for getting at
it. Some systems use bits selected by <b>CBAUD</b> in
<i>c_cflag</i>, other systems use separate fields, for
example, <i>sg_ispeed</i> and <i>sg_ospeed</i>.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CSIZE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Character size mask. Values are <b>CS5</b>, <b>CS6</b>,
<b>CS7</b>, or <b>CS8</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CSTOPB</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Set two stop bits, rather than one.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CREAD</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable receiver.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>PARENB</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable parity generation on output and parity checking
for input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>PARODD</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If set, then parity for input and output is odd;
otherwise even parity is used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>HUPCL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Lower modem control lines after last process closes the
device (hang up).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CLOCAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Ignore modem control lines.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>LOBLK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) Block output from a noncurrent shell
layer. For use by <b>shl</b> (shell layers). (Not
implemented on Linux.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CIBAUD</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) Mask for input speeds. The values for the
<b>CIBAUD</b> bits are the same as the values for the
<b>CBAUD</b> bits, shifted left <b>IBSHIFT</b> bits.
[requires <b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b>] (Not
implemented on Linux.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CMSPAR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) Use &quot;stick&quot; (mark/space) parity
(supported on certain serial devices): if <b>PARODD</b> is
set, the parity bit is always 1; if <b>PARODD</b> is not
set, then the parity bit is always 0). [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b>]</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CRTSCTS</b></p>

<p style="margin-left:22%;">(not in POSIX) Enable RTS/CTS
(hardware) flow control. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b>]</p>

<p style="margin-left:11%; margin-top: 1em"><i>c_lflag</i>
flag constants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ISIG</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>When any of the characters INTR, QUIT, SUSP, or DSUSP
are received, generate the corresponding signal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ICANON</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable canonical mode (described below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>XCASE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; not supported under Linux) If
<b>ICANON</b> is also set, terminal is uppercase only. Input
is converted to lowercase, except for characters preceded by
\. On output, uppercase characters are preceded by \ and
lowercase characters are converted to uppercase. [requires
_BSD_SOURCE or _SVID_SOURCE or _XOPEN_SOURCE]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ECHO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Echo input characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ECHOE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If <b>ICANON</b> is also set, the ERASE character erases
the preceding input character, and WERASE erases the
preceding word.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ECHOK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If <b>ICANON</b> is also set, the KILL character erases
the current line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ECHONL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If <b>ICANON</b> is also set, echo the NL character even
if ECHO is not set.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ECHOCTL</b></p>

<p style="margin-left:22%;">(not in POSIX) If <b>ECHO</b>
is also set, terminal special characters other than TAB, NL,
START, and STOP are echoed as <b>^X</b>, where X is the
character with ASCII code 0x40 greater than the special
character. For example, character 0x08 (BS) is echoed as
<b>^H</b>. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b>]</p>

<p style="margin-left:11%;"><b>ECHOPRT</b></p>

<p style="margin-left:22%;">(not in POSIX) If <b>ICANON</b>
and <b>ECHO</b> are also set, characters are printed as they
are being erased. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b>]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ECHOKE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX) If <b>ICANON</b> is also set, KILL is
echoed by erasing each character on the line, as specified
by <b>ECHOE</b> and <b>ECHOPRT</b>. [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b>]</p></td></tr>
</table>

<p style="margin-left:11%;"><b>DEFECHO</b></p>

<p style="margin-left:22%;">(not in POSIX) Echo only when a
process is reading. (Not implemented on Linux.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>FLUSHO</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; not supported under Linux) Output is
being flushed. This flag is toggled by typing the DISCARD
character. [requires <b>_BSD_SOURCE</b> or
<b>_SVID_SOURCE</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>NOFLSH</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Disable flushing the input and output queues when
generating signals for the INT, QUIT, and SUSP
characters.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TOSTOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Send the <b>SIGTTOU</b> signal to the process group of a
background process which tries to write to its controlling
terminal.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>PENDIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; not supported under Linux) All characters
in the input queue are reprinted when the next character is
read. (<b>bash</b>(1) handles typeahead this way.) [requires
<b>_BSD_SOURCE</b> or <b>_SVID_SOURCE</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>IEXTEN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Enable implementation-defined input processing. This
flag, as well as <b>ICANON</b> must be enabled for the
special characters EOL2, LNEXT, REPRINT, WERASE to be
interpreted, and for the <b>IUCLC</b> flag to be
effective.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The <i>c_cc</i>
array defines the terminal special characters. The symbolic
indices (initial values) and meaning are: <b><br>
VDISCARD</b></p>

<p style="margin-left:22%;">(not in POSIX; not supported
under Linux; 017, SI, Ctrl-O) Toggle: start/stop discarding
pending output. Recognized when <b>IEXTEN</b> is set, and
then not passed as input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VDSUSP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; not supported under Linux; 031, EM,
Ctrl-Y) Delayed suspend character (DSUSP): send
<b>SIGTSTP</b> signal when the character is read by the user
program. Recognized when <b>IEXTEN</b> and <b>ISIG</b> are
set, and the system supports job control, and then not
passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VEOF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(004, EOT, Ctrl-D) End-of-file character (EOF). More
precisely: this character causes the pending tty buffer to
be sent to the waiting user program without waiting for
end-of-line. If it is the first character of the line, the
<b>read</b>(2) in the user program returns 0, which
signifies end-of-file. Recognized when <b>ICANON</b> is set,
and then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VEOL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(0, NUL) Additional end-of-line character (EOL).
Recognized when <b>ICANON</b> is set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VEOL2</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; 0, NUL) Yet another end-of-line character
(EOL2). Recognized when <b>ICANON</b> is set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VERASE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(0177, DEL, rubout, or 010, BS, Ctrl-H, or also #) Erase
character (ERASE). This erases the previous not-yet-erased
character, but does not erase past EOF or beginning-of-line.
Recognized when <b>ICANON</b> is set, and then not passed as
input.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(003, ETX, Ctrl-C, or also 0177, DEL, rubout) Interrupt
character (INTR). Send a <b>SIGINT</b> signal. Recognized
when <b>ISIG</b> is set, and then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VKILL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(025, NAK, Ctrl-U, or Ctrl-X, or also @) Kill character
(KILL). This erases the input since the last EOF or
beginning-of-line. Recognized when <b>ICANON</b> is set, and
then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VLNEXT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; 026, SYN, Ctrl-V) Literal next (LNEXT).
Quotes the next input character, depriving it of a possible
special meaning. Recognized when <b>IEXTEN</b> is set, and
then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VMIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Minimum number of characters for noncanonical read
(MIN).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VQUIT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(034, FS, Ctrl-\) Quit character (QUIT). Send
<b>SIGQUIT</b> signal. Recognized when <b>ISIG</b> is set,
and then not passed as input.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>VREPRINT</b></p>

<p style="margin-left:22%;">(not in POSIX; 022, DC2,
Ctrl-R) Reprint unread characters (REPRINT). Recognized when
<b>ICANON</b> and <b>IEXTEN</b> are set, and then not passed
as input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VSTART</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(021, DC1, Ctrl-Q) Start character (START). Restarts
output stopped by the Stop character. Recognized when
<b>IXON</b> is set, and then not passed as input.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>VSTATUS</b></p>

<p style="margin-left:22%;">(not in POSIX; not supported
under Linux; status request: 024, DC4, Ctrl-T). Status
character (STATUS). Display status information at terminal,
including state of foreground process and amount of CPU time
it has consumed. Also sends a <b>SIGINFO</b> signal (not
supported on Linux) to the foreground process group.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VSTOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(023, DC3, Ctrl-S) Stop character (STOP). Stop output
until Start character typed. Recognized when <b>IXON</b> is
set, and then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VSUSP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(032, SUB, Ctrl-Z) Suspend character (SUSP). Send
<b>SIGTSTP</b> signal. Recognized when <b>ISIG</b> is set,
and then not passed as input.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VSWTCH</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(not in POSIX; not supported under Linux; 0, NUL) Switch
character (SWTCH). Used in System V to switch shells in
<i>shell layers</i>, a predecessor to shell job control.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>VTIME</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Timeout in deciseconds for noncanonical read (TIME).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>VWERASE</b></p>

<p style="margin-left:22%;">(not in POSIX; 027, ETB,
Ctrl-W) Word erase (WERASE). Recognized when <b>ICANON</b>
and <b>IEXTEN</b> are set, and then not passed as input.</p>

<p style="margin-left:11%; margin-top: 1em">An individual
terminal special character can be disabled by setting the
value of the corresponding <i>c_cc</i> element to
<b>_POSIX_VDISABLE</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The above
symbolic subscript values are all different, except that
<b>VTIME</b>, <b>VMIN</b> may have the same value as
<b>VEOL</b>, <b>VEOF</b>, respectively. In noncanonical mode
the special character meaning is replaced by the timeout
meaning. For an explanation of <b>VMIN</b> and <b>VTIME</b>,
see the description of noncanonical mode below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Retrieving
and changing terminal settings <br>
tcgetattr</b>() gets the parameters associated with the
object referred by <i>fd</i> and stores them in the
<i>termios</i> structure referenced by <i>termios_p</i>.
This function may be invoked from a background process;
however, the terminal attributes may be subsequently changed
by a foreground process.</p>


<p style="margin-left:11%; margin-top: 1em"><b>tcsetattr</b>()
sets the parameters associated with the terminal (unless
support is required from the underlying hardware that is not
available) from the <i>termios</i> structure referred to by
<i>termios_p</i>. <i>optional_actions</i> specifies when the
changes take effect: <b><br>
TCSANOW</b></p>

<p style="margin-left:22%;">the change occurs
immediately.</p>

<p style="margin-left:11%;"><b>TCSADRAIN</b></p>

<p style="margin-left:22%;">the change occurs after all
output written to <i>fd</i> has been transmitted. This
function should be used when changing parameters that affect
output.</p>

<p style="margin-left:11%;"><b>TCSAFLUSH</b></p>

<p style="margin-left:22%;">the change occurs after all
output written to the object referred by <i>fd</i> has been
transmitted, and all input that has been received but not
read will be discarded before the change is made.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Canonical
and noncanonical mode</b> <br>
The setting of the <b>ICANON</b> canon flag in
<i>c_lflag</i> determines whether the terminal is operating
in canonical mode (<b>ICANON</b> set) or noncanonical mode
(<b>ICANON</b> unset). By default, <b>ICANON</b> set.</p>

<p style="margin-left:11%; margin-top: 1em">In canonical
mode:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Input is made available line by line. An input line is
available when one of the line delimiters is typed (NL, EOL,
EOL2; or EOF at the start of line). Except in the case of
EOF, the line delimiter is included in the buffer returned
by <b>read</b>(2).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>Line editing is enabled (ERASE, KILL; and if the
<b>IEXTEN</b> flag is set: WERASE, REPRINT, LNEXT). A
<b>read</b>(2) returns at most one line of input; if the
<b>read</b>(2) requested fewer bytes than are available in
the current line of input, then only as many bytes as
requested are read, and the remaining characters will be
available for a future <b>read</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In noncanonical
mode input is available immediately (without the user having
to type a line-delimiter character), no input processing is
performed, and line editing is disabled. The settings of MIN
(<i>c_cc[VMIN]</i>) and TIME (<i>c_cc[VTIME]</i>) determine
the circumstances in which a <b>read</b>(2) completes; there
are four distinct cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">MIN == 0; TIME == 0: If data is
available, <b>read</b>(2) returns immediately, with the
lesser of the number of bytes available, or the number of
bytes requested. If no data is available, <b>read</b>(2)
returns 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>MIN &gt; 0; TIME == 0: <b>read</b>(2) blocks until the
lesser of MIN bytes or the number of bytes requested are
available, and returns the lesser of these two values.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>MIN == 0; TIME &gt; 0: TIME specifies the limit for a
timer in tenths of a second. The timer is started when
<b>read</b>(2) is called. <b>read</b>(2) returns either when
at least one byte of data is available, or when the timer
expires. If the timer expires without any input becoming
available, <b>read</b>(2) returns 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>MIN &gt; 0; TIME &gt; 0: TIME specifies the limit for a
timer in tenths of a second. Once an initial byte of input
becomes available, the timer is restarted after each further
byte is received. <b>read</b>(2) returns either when the
lesser of the number of bytes requested or MIN byte have
been read, or when the inter-byte timeout expires. Because
the timer is started only after the initial byte becomes
available, at least one byte will be read.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Raw mode
<br>
cfmakeraw</b>() sets the terminal to something like the
&quot;raw&quot; mode of the old Version 7 terminal driver:
input is available character by character, echoing is
disabled, and all special processing of terminal input and
output characters is disabled. The terminal attributes are
set as follows:</p>


<p style="margin-left:11%; margin-top: 1em">termios_p&minus;&gt;c_iflag
&amp;= ~(IGNBRK | BRKINT | PARMRK | ISTRIP <br>
| INLCR | IGNCR | ICRNL | IXON); <br>
termios_p&minus;&gt;c_oflag &amp;= ~OPOST; <br>
termios_p&minus;&gt;c_lflag &amp;= ~(ECHO | ECHONL | ICANON
| ISIG | IEXTEN); <br>
termios_p&minus;&gt;c_cflag &amp;= ~(CSIZE | PARENB); <br>
termios_p&minus;&gt;c_cflag |= CS8;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Line control
<br>
tcsendbreak</b>() transmits a continuous stream of
zero-valued bits for a specific duration, if the terminal is
using asynchronous serial data transmission. If
<i>duration</i> is zero, it transmits zero-valued bits for
at least 0.25 seconds, and not more that 0.5 seconds. If
<i>duration</i> is not zero, it sends zero-valued bits for
some implementation-defined length of time.</p>

<p style="margin-left:11%; margin-top: 1em">If the terminal
is not using asynchronous serial data transmission,
<b>tcsendbreak</b>() returns without taking any action.</p>


<p style="margin-left:11%; margin-top: 1em"><b>tcdrain</b>()
waits until all output written to the object referred to by
<i>fd</i> has been transmitted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>tcflush</b>()
discards data written to the object referred to by <i>fd</i>
but not transmitted, or data received but not read,
depending on the value of <i>queue_selector</i>: <b><br>
TCIFLUSH</b></p>

<p style="margin-left:22%;">flushes data received but not
read.</p>

<p style="margin-left:11%;"><b>TCOFLUSH</b></p>

<p style="margin-left:22%;">flushes data written but not
transmitted.</p>

<p style="margin-left:11%;"><b>TCIOFLUSH</b></p>

<p style="margin-left:22%;">flushes both data received but
not read, and data written but not transmitted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>tcflow</b>()
suspends transmission or reception of data on the object
referred to by <i>fd</i>, depending on the value of
<i>action</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TCOOFF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>suspends output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TCOON</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>restarts suspended output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TCIOFF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>transmits a STOP character, which stops the terminal
device from transmitting data to the system.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>TCION</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>transmits a START character, which starts the terminal
device transmitting data to the system.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The default on
open of a terminal file is that neither its input nor its
output is suspended.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Line
speed</b> <br>
The baud rate functions are provided for getting and setting
the values of the input and output baud rates in the
<i>termios</i> structure. The new values do not take effect
until <b>tcsetattr</b>() is successfully called.</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
speed to <b>B0</b> instructs the modem to &quot;hang
up&quot;. The actual bit rate corresponding to <b>B38400</b>
may be altered with <b>setserial</b>(8).</p>

<p style="margin-left:11%; margin-top: 1em">The input and
output baud rates are stored in the <i>termios</i>
structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfgetospeed</b>()
returns the output baud rate stored in the <i>termios</i>
structure pointed to by <i>termios_p</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfsetospeed</b>()
sets the output baud rate stored in the <i>termios</i>
structure pointed to by <i>termios_p</i> to <i>speed</i>,
which must be one of these constants:</p>

<p style="margin-left:11%; margin-top: 1em"><b>B0</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B50</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B75</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B110</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B134</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B150</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B200</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B300</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B600</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B1200</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B1800</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B2400</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B4800</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B9600</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B19200</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B38400</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B57600</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B115200</b></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><b>B230400</b></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The zero baud
rate, <b>B0</b>, is used to terminate the connection. If B0
is specified, the modem control lines shall no longer be
asserted. Normally, this will disconnect the line.
<b>CBAUDEX</b> is a mask for the speeds beyond those defined
in POSIX.1 (57600 and above). Thus, <b>B57600</b> &amp;
<b>CBAUDEX</b> is nonzero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfgetispeed</b>()
returns the input baud rate stored in the <i>termios</i>
structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfsetispeed</b>()
sets the input baud rate stored in the <i>termios</i>
structure to <i>speed</i>, which must be specified as one of
the <b>Bnnn</b> constants listed above for
<b>cfsetospeed</b>(). If the input baud rate is set to zero,
the input baud rate will be equal to the output baud
rate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfsetspeed</b>()
is a 4.4BSD extension. It takes the same arguments as
<b>cfsetispeed</b>(), and sets both input and output
speed.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>cfgetispeed</b>()
returns the input baud rate stored in the <i>termios</i>
structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfgetospeed</b>()
returns the output baud rate stored in the <i>termios</i>
structure.</p>

<p style="margin-left:11%; margin-top: 1em">All other
functions return:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">0</p></td>
<td width="8%"></td>
<td width="72%">


<p style="margin-top: 1em">on success.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;1</p></td>
<td width="8%"></td>
<td width="72%">


<p>on failure and set <i>errno</i> to indicate the
error.</p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>tcsetattr</b>() returns success if <i>any</i> of the
requested changes could be successfully carried out.
Therefore, when making multiple changes it may be necessary
to follow this call with a further call to
<b>tcgetattr</b>() to check that all changes have been
performed successfully.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>tcgetattr</b>(),
<b>tcsetattr</b>(), <b>tcsendbreak</b>(), <b>tcdrain</b>(),
<b>tcflush</b>(), <b>tcflow</b>(), <b>cfgetispeed</b>(),
<b>cfgetospeed</b>(), <b>cfsetispeed</b>(), and
<b>cfsetospeed</b>() are specified in POSIX.1-2001.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cfmakeraw</b>()
and <b>cfsetspeed</b>() are nonstandard, but available on
the BSDs.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">UNIX V7 and
several later systems have a list of baud rates where after
the fourteen values B0, ..., B9600 one finds the two
constants EXTA, EXTB (&quot;External A&quot; and
&quot;External B&quot;). Many systems extend the list with
much higher baud rates.</p>

<p style="margin-left:11%; margin-top: 1em">The effect of a
nonzero <i>duration</i> with <b>tcsendbreak</b>() varies.
SunOS specifies a break of <i>duration&nbsp;*&nbsp;N</i>
seconds, where <i>N</i> is at least 0.25, and not more than
0.5. Linux, AIX, DU, Tru64 send a break of <i>duration</i>
milliseconds. FreeBSD and NetBSD and HP-UX and MacOS ignore
the value of <i>duration</i>. Under Solaris and UnixWare,
<b>tcsendbreak</b>() with nonzero <i>duration</i> behaves
like <b>tcdrain</b>().</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>stty</b>(1),
<b>console_ioctl</b>(4), <b>tty_ioctl</b>(4),
<b>setserial</b>(8)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
