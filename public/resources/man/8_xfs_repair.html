<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:25:43 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>xfs_repair</title>

</head>
<body>

<h1 align="center">xfs_repair</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#EXIT STATUS">EXIT STATUS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">xfs_repair
&minus; repair an XFS filesystem</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>xfs_repair</b>
[ <b>&minus;dfLnPv</b> ] [ <b>&minus;m</b> <i>maxmem</i> ] [
<b>&minus;c</b> <i>subopt</i><b>=</b><i>value</i> ] [
<b>&minus;o</b> <i>subopt</i>[<b>=</b><i>value</i>] ] [
<b>&minus;t</b> <i>interval</i> ] [ <b>&minus;l</b>
<i>logdev</i> ] [ <b>&minus;r</b> <i>rtdev</i> ]
<i>device</i> <b><br>
xfs_repair &minus;V</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>xfs_repair</b>
repairs corrupt or damaged XFS filesystems (see
<b>xfs</b>(5)). The filesystem is specified using the
<i>device</i> argument which should be the device name of
the disk partition or volume containing the filesystem. If
given the name of a block device, <b>xfs_repair</b> will
attempt to find the raw device associated with the specified
block device and will use the raw device instead.</p>

<p style="margin-left:11%; margin-top: 1em">Regardless, the
filesystem to be repaired must be unmounted, otherwise, the
resulting filesystem may be inconsistent or corrupt.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;f</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Specifies that the filesystem
image to be processed is stored in a regular file at
<i>device</i> (see the <b>mkfs.xfs &minus;d</b> <i>file</i>
option). This might happen if an image copy of a filesystem
has been copied or written into an ordinary file. This
option implies that any external log or realtime section is
also in an ordinary file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;L</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Force Log Zeroing. Forces <b>xfs_repair</b> to zero the
log even if it is dirty (contains metadata changes). When
using this option the filesystem will likely appear to be
corrupt, and can cause the loss of user files and/or
data.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;l</b>
<i>logdev</i></p>

<p style="margin-left:22%;">Specifies the device special
file where the filesystem&rsquo;s external log resides. Only
for those filesystems which use an external log. See the
<b>mkfs.xfs &minus;l</b> option, and refer to <b>xfs</b>(5)
for a detailed description of the XFS log.</p>

<p style="margin-left:11%;"><b>&minus;r</b>
<i>rtdev</i></p>

<p style="margin-left:22%;">Specifies the device special
file where the filesystem&rsquo;s realtime section resides.
Only for those filesystems which use a realtime section. See
the <b>mkfs.xfs &minus;r</b> option, and refer to
<b>xfs</b>(5) for a detailed description of the XFS realtime
section.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>No modify mode. Specifies that <b>xfs_repair</b> should
not modify the filesystem but should only scan the
filesystem and indicate what repairs would have been
made.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;P</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Disable prefetching of inode and directory blocks. Use
this option if you find <b>xfs_repair</b> gets stuck and
stops proceeding. Interrupting a stuck <b>xfs_repair</b> is
safe.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;m</b>
<i>maxmem</i></p>

<p style="margin-left:22%;">Specifies the approximate
maximum amount of memory, in megabytes, to use for
<b>xfs_repair</b>. <b>xfs_repair</b> has its own internal
block cache which will scale out up to the lesser of the
process&rsquo;s virtual address limit or about 75% of the
system&rsquo;s physical RAM. This option overrides these
limits.</p>

<p style="margin-left:22%; margin-top: 1em"><b>NOTE:</b>
These memory limits are only approximate and may use more
than the specified limit.</p>

<p style="margin-left:11%;"><b>&minus;c</b>
<i>subopt</i><b>=</b><i>value</i></p>

<p style="margin-left:22%;">Change filesystem parameters.
Refer to <b>xfs_admin</b>(8) for information on changing
filesystem parameters.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;o</b></p></td>
<td width="1%"></td>
<td width="22%">



<p style="margin-top: 1em"><i>subopt</i>[<b>=</b><i>value</i>]</p> </td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:22%;">Override what the program might
conclude about the filesystem if left to its own
devices.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>subopt</i>ions supported are:</p>


<p style="margin-left:26%;"><b>bhash=</b><i>bhashsize</i></p>

<p style="margin-left:37%;">overrides the default buffer
cache hash size. The total number of buffer cache entries
are limited to 8 times this amount. The default size is set
to use up the remainder of 75% of the system&rsquo;s
physical RAM size.</p>


<p style="margin-left:26%;"><b>ag_stride=</b><i>ags_per_concat_unit</i></p>

<p style="margin-left:37%;">This creates additional
processing threads to parallel process AGs that span
multiple concat units. This can significantly reduce repair
times on concat based filesystems.</p>

<p style="margin-left:26%;"><b>force_geometry</b></p>

<p style="margin-left:37%;">Check the filesystem even if
geometry information could not be validated. Geometry
information can not be validated if only a single allocation
group exists and thus we do not have a backup superblock
available, or if there are two allocation groups and the two
superblocks do not agree on the filesystem geometry. Only
use this option if you validated the geometry yourself and
know what you are doing. If In doubt run in no modify mode
first.</p>

<p style="margin-left:11%;"><b>&minus;t interval</b></p>

<p style="margin-left:22%;">Modify reporting interval,
specified in seconds. During long runs <b>xfs_repair</b>
outputs its progress every 15 minutes. Reporting is only
activated when ag_stride is enabled.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Verbose output.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;d</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Repair dangerously. Allow <b>xfs_repair</b> to repair an
XFS filesystem mounted read only. This is typically done on
a root filesystem from single user mode, immediately
followed by a reboot.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Prints the version number and exits.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Checks
Performed</b> <br>
Inconsistencies corrected include the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Inode and inode blockmap
(addressing) checks: bad magic number in inode, bad magic
numbers in inode blockmap blocks, extents out of order,
incorrect number of records in inode blockmap blocks, blocks
claimed that are not in a legal data area of the filesystem,
blocks that are claimed by more than one inode.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Inode allocation map checks: bad magic number in inode
map blocks, inode state as indicated by map (free or in-use)
inconsistent with state indicated by the inode, inodes
referenced by the filesystem that do not appear in the inode
allocation map, inode allocation map referencing blocks that
do not appear to contain inodes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Size checks: number of blocks claimed by inode
inconsistent with inode size, directory size not block
aligned, inode size not consistent with inode format.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Directory checks: bad magic numbers in directory blocks,
incorrect number of entries in a directory block, bad
freespace information in a directory leaf block, entry
pointing to an unallocated (free) or out of range inode,
overlapping entries, missing or incorrect dot and dotdot
entries, entries out of hashvalue order, incorrect internal
directory pointers, directory type not consistent with inode
format and size.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Pathname checks: files or directories not referenced by
a pathname starting from the filesystem root, illegal
pathname components.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Link count checks: link counts that do not agree with
the number of directory references to the inode.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Freemap checks: blocks claimed free by the freemap but
also claimed by an inode, blocks unclaimed by any inode but
not appearing in the freemap.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Super Block checks: total free block and/or free i-node
count incorrect, filesystem geometry inconsistent, secondary
and primary superblocks contradictory.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Orphaned files
and directories (allocated, in-use but unreferenced) are
reconnected by placing them in the <i>lost+found</i>
directory. The name assigned is the inode number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Disk Errors
<br>
xfs_repair</b> aborts on most disk I/O errors. Therefore, if
you are trying to repair a filesystem that was damaged due
to a disk drive failure, steps should be taken to ensure
that all blocks in the filesystem are readable and writable
before attempting to use <b>xfs_repair</b> to repair the
filesystem. A possible method is using <b>dd</b>(8) to copy
the data onto a good disk.</p>


<p style="margin-left:11%; margin-top: 1em"><b>lost+found</b>
<br>
The directory <i>lost+found</i> does not have to already
exist in the filesystem being repaired. If the directory
does not exist, it is automatically created if required. If
it already exists, it will be checked for consistency and if
valid will be used for additional orphaned files. Invalid
<i>lost+found</i> directories are removed and recreated.
Existing files in a valid <i>lost+found</i> are not removed
or renamed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Corrupted
Superblocks</b> <br>
XFS has both primary and secondary superblocks.
<b>xfs_repair</b> uses information in the primary superblock
to automatically find and validate the primary superblock
against the secondary superblocks before proceeding. Should
the primary be too corrupted to be useful in locating the
secondary superblocks, the program scans the filesystem
until it finds and validates some secondary superblocks. At
that point, it generates a primary superblock.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Quotas</b>
<br>
If quotas are in use, it is possible that <b>xfs_repair</b>
will clear some or all of the filesystem quota information.
If so, the program issues a warning just before it
terminates. If all quota information is lost, quotas are
disabled and the program issues a warning to that
effect.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>xfs_repair</b> does not check the validity of quota
limits. It is recommended that you check the quota limit
information manually after <b>xfs_repair</b>. Also, space
usage information is automatically regenerated the next time
the filesystem is mounted with quotas turned on, so the next
quota mount of the filesystem may take some time.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>xfs_repair</b>
issues informative messages as it proceeds indicating what
it has found that is abnormal or any corrective action that
it has taken. Most of the messages are completely
understandable only to those who are knowledgeable about the
structure of the filesystem. Some of the more common
messages are explained here. Note that the language of the
messages is slightly different if <b>xfs_repair</b> is run
in no-modify mode because the program is not changing
anything on disk. No-modify mode indicates what it would do
to repair the filesystem if run without the no-modify
flag.</p>


<p style="margin-left:11%; margin-top: 1em"><b>disconnected
inode</b> <i>ino</i><b>, moving to lost+found</b></p>

<p style="margin-left:22%; margin-top: 1em">An inode
numbered <i>ino</i> was not connected to the filesystem
directory tree and was reconnected to the <i>lost+found</i>
directory. The inode is assigned the name of its inode
number (<i>ino</i>). If a <i>lost+found</i> directory does
not exist, it is automatically created.</p>


<p style="margin-left:11%; margin-top: 1em"><b>disconnected
dir inode</b> <i>ino</i><b>, moving to lost+found</b></p>

<p style="margin-left:22%; margin-top: 1em">As above only
the inode is a directory inode. If a directory inode is
attached to <i>lost+found</i>, all of its children (if any)
stay attached to the directory and therefore get
automatically reconnected when the directory is
reconnected.</p>

<p style="margin-left:11%; margin-top: 1em"><b>imap claims
in-use inode</b> <i>ino</i> <b>is free, correcting
imap</b></p>

<p style="margin-left:22%; margin-top: 1em">The inode
allocation map thinks that inode <i>ino</i> is free whereas
examination of the inode indicates that the inode may be in
use (although it may be disconnected). The program updates
the inode allocation map.</p>

<p style="margin-left:11%; margin-top: 1em"><b>imap claims
free inode</b> <i>ino</i> <b>is in use, correcting
imap</b></p>

<p style="margin-left:22%; margin-top: 1em">The inode
allocation map thinks that inode <i>ino</i> is in use
whereas examination of the inode indicates that the inode is
not in use and therefore is free. The program updates the
inode allocation map.</p>

<p style="margin-left:11%; margin-top: 1em"><b>resetting
inode</b> <i>ino</i> <b>nlinks from</b> <i>x</i> <b>to</b>
<i>y</i></p>

<p style="margin-left:22%; margin-top: 1em">The program
detected a mismatch between the number of valid directory
entries referencing inode <i>ino</i> and the number of
references recorded in the inode and corrected the the
number in the inode.</p>


<p style="margin-left:11%; margin-top: 1em"><i>fork-type</i>
<b>fork in ino</b> <i>ino</i> <b>claims used block</b>
<i>bno</i></p>

<p style="margin-left:22%; margin-top: 1em">Inode
<i>ino</i> claims a block <i>bno</i> that is used (claimed)
by either another inode or the filesystem itself for
metadata storage. The <i>fork-type</i> is either <b>data</b>
or <b>attr</b> indicating whether the problem lies in the
portion of the inode that tracks regular data or the portion
of the inode that stores XFS attributes. If the inode is a
real-time (rt) inode, the message says so. Any inode that
claims blocks used by the filesystem is deleted. If two or
more inodes claim the same block, they are both deleted.</p>


<p style="margin-left:11%; margin-top: 1em"><i>fork-type</i>
<b>fork in ino</b> <i>ino</i> <b>claims dup extent
...</b></p>

<p style="margin-left:22%; margin-top: 1em">Inode
<i>ino</i> claims a block in an extent known to be claimed
more than once. The offset in the inode, start and length of
the extent is given. The message is slightly different if
the inode is a real-time (rt) inode and the extent is
therefore a real-time (rt) extent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>inode</b>
<i>ino</i> <b>&minus; bad extent ...</b></p>

<p style="margin-left:22%; margin-top: 1em">An extent
record in the blockmap of inode <i>ino</i> claims blocks
that are out of the legal range of the filesystem. The
message supplies the start, end, and file offset of the
extent. The message is slightly different if the extent is a
real-time (rt) extent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bad</b>
<i>fork-type</i> <b>fork in inode</b> <i>ino</i></p>

<p style="margin-left:22%; margin-top: 1em">There was
something structurally wrong or inconsistent with the data
structures that map offsets to filesystem blocks.</p>

<p style="margin-left:11%; margin-top: 1em"><b>cleared
inode</b> <i>ino</i></p>

<p style="margin-left:22%; margin-top: 1em">There was
something wrong with the inode that was uncorrectable so the
program freed the inode. This usually happens because the
inode claims blocks that are used by something else or the
inode itself is badly corrupted. Typically, this message is
preceded by one or more messages indicating why the inode
needed to be cleared.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bad
attribute fork in inode</b> <i>ino</i>, <b>clearing attr
fork</b></p>

<p style="margin-left:22%; margin-top: 1em">There was
something wrong with the portion of the inode that stores
XFS attributes (the attribute fork) so the program reset the
attribute fork. As a result of this, all attributes on that
inode are lost.</p>

<p style="margin-left:11%; margin-top: 1em"><b>correcting
nextents for inode</b> <i>ino</i>, <b>was</b> <i>x</i>
<b>&minus; counted</b> <i>y</i></p>

<p style="margin-left:22%; margin-top: 1em">The program
found that the number of extents used to store the data in
the inode is wrong and corrected the number. The message
refers to nextents if the count is wrong on the number of
extents used to store attribute information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>entry</b>
<i>name</i> <b>in dir</b> <i>dir_ino</i> <b>not consistent
with .. value (</b><i>xxxx</i><b>) in dir ino</b>
<i>ino</i><b>, junking entry</b> <i>name</i> <b>in directory
inode</b> <i>dir_ino</i></p>

<p style="margin-left:22%; margin-top: 1em">The entry
<i>name</i> in directory inode <i>dir_ino</i> references a
directory inode <i>ino</i>. However, the .. entry in
directory <i>ino</i> does not point back to directory
<i>dir_ino</i>, so the program deletes the entry <i>name</i>
in directory inode <i>dir_ino</i>. If the directory inode
<i>ino</i> winds up becoming a disconnected inode as a
result of this, it is moved to <i>lost+found</i> later.</p>

<p style="margin-left:11%; margin-top: 1em"><b>entry</b>
<i>name</i> <b>in dir</b> <i>dir_ino</i> <b>references
already connected dir ino</b> <i>ino</i><b>, junking
entry</b> <i>name</i> <b>in directory inode</b>
<i>dir_ino</i></p>

<p style="margin-left:22%; margin-top: 1em">The entry
<i>name</i> in directory inode <i>dir_ino</i> points to a
directory inode <i>ino</i> that is known to be a child of
another directory. Therefore, the entry is invalid and is
deleted. This message refers to an entry in a small
directory. If this were a large directory, the last phrase
would read &quot;will clear entry&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>entry
references free inode</b> <i>ino</i> <b>in directory</b>
<i>dir_ino</i><b>, will clear entry</b></p>

<p style="margin-left:22%; margin-top: 1em">An entry in
directory inode <i>dir_ino</i> references an inode
<i>ino</i> that is known to be free. The entry is therefore
invalid and is deleted. This message refers to a large
directory. If the directory were small, the message would
read &quot;junking entry ...&quot;.</p>

<h2>EXIT STATUS
<a name="EXIT STATUS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xfs_repair
&minus;n</b> (no modify node) will return a status of 1 if
filesystem corruption was detected and 0 if no filesystem
corruption was detected. <b>xfs_repair</b> run without the
&minus;n option will always return a status code of 0.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The filesystem
to be checked and repaired must have been unmounted cleanly
using normal system administration procedures (the
<b>umount</b>(8) command or system shutdown), not as a
result of a crash or system reset. If the filesystem has not
been unmounted cleanly, mount it and unmount it cleanly
before running <b>xfs_repair</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>xfs_repair</b>
does not do a thorough job on XFS extended attributes. The
structure of the attribute fork will be consistent, but only
the contents of attribute forks that will fit into an inode
are checked. This limitation will be fixed in the
future.</p>

<p style="margin-left:11%; margin-top: 1em">The no-modify
mode (<b>&minus;n</b> option) is not completely accurate. It
does not catch inconsistencies in the freespace and inode
maps, particularly lost blocks or subtly corrupted maps
(trees).</p>

<p style="margin-left:11%; margin-top: 1em">The no-modify
mode can generate repeated warnings about the same problems
because it cannot fix the problems as they are
encountered.</p>

<p style="margin-left:11%; margin-top: 1em">If a filesystem
fails to be repaired, a metadump image can be generated with
<b>xfs_metadump</b>(8) and be sent to an XFS maintainer to
be analysed and <b>xfs_repair</b> fixed and/or improved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>dd</b>(1),
<b>mkfs.xfs</b>(8), <b>umount</b>(8), <b>xfs_admin</b>(8),
<b>xfs_metadump</b>(8), <b>xfs</b>(5).</p>
<hr>
</body>
</html>
