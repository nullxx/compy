<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:16:18 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PTHREAD_MUTEXATTR_DESTROY</title>

</head>
<body>

<h1 align="center">PTHREAD_MUTEXATTR_DESTROY</h1>

<a href="#PROLOG">PROLOG</a><br>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#APPLICATION USAGE">APPLICATION USAGE</a><br>
<a href="#RATIONALE">RATIONALE</a><br>
<a href="#FUTURE DIRECTIONS">FUTURE DIRECTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>PROLOG
<a name="PROLOG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This manual
page is part of the POSIX Programmer&rsquo;s Manual. The
Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux
behavior), or the interface may not be implemented on
Linux.</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">pthread_mutexattr_destroy,
pthread_mutexattr_init &minus; destroy and initialize the
mutex attributes object</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;pthread.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
pthread_mutexattr_destroy(pthread_mutexattr_t
*</b><i>attr</i><b>); <br>
int pthread_mutexattr_init(pthread_mutexattr_t
*</b><i>attr</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>pthread_mutexattr_destroy</i>() function shall destroy a
mutex attributes object; the object becomes, in effect,
uninitialized. An implementation may cause
<i>pthread_mutexattr_destroy</i>() to set the object
referenced by <i>attr</i> to an invalid value. A destroyed
<i>attr</i> attributes object can be reinitialized using
<i>pthread_mutexattr_init</i>(); the results of otherwise
referencing the object after it has been destroyed are
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>pthread_mutexattr_init</i>() function shall initialize a
mutex attributes object <i>attr</i> with the default value
for all of the attributes defined by the implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Results are
undefined if <i>pthread_mutexattr_init</i>() is called
specifying an already initialized <i>attr</i> attributes
object.</p>

<p style="margin-left:11%; margin-top: 1em">After a mutex
attributes object has been used to initialize one or more
mutexes, any function affecting the attributes object
(including destruction) shall not affect any previously
initialized mutexes.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Upon successful
completion, <i>pthread_mutexattr_destroy</i>() and
<i>pthread_mutexattr_init</i>() shall return zero;
otherwise, an error number shall be returned to indicate the
error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>pthread_mutexattr_destroy</i>() function may fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="60%">


<p>The value specified by <i>attr</i> is invalid.</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>pthread_mutexattr_init</i>() function shall fail if:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Insufficient memory exists to
initialize the mutex attributes object.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These functions
shall not return an error code of [EINTR].</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
following sections are informative.</i></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>APPLICATION USAGE
<a name="APPLICATION USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>RATIONALE
<a name="RATIONALE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<i>pthread_attr_init</i>() for a general explanation of
attributes. Attributes objects allow implementations to
experiment with useful extensions and permit extension of
this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 without
changing the existing functions. Thus, they provide for
future extensibility of this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 and reduce the temptation to
standardize prematurely on semantics that are not yet widely
implemented or understood.</p>

<p style="margin-left:11%; margin-top: 1em">Examples of
possible additional mutex attributes that have been
discussed are <i>spin_only</i>, <i>limited_spin</i>,
<i>no_spin</i>, <i>recursive</i>, and <i>metered</i>. (To
explain what the latter attributes might mean: recursive
mutexes would allow for multiple re-locking by the current
owner; metered mutexes would transparently keep records of
queue length, wait time, and so on.) Since there is not yet
wide agreement on the usefulness of these resulting from
shared implementation and usage experience, they are not yet
specified in this volume of IEEE&nbsp;Std&nbsp;1003.1-2001.
Mutex attributes objects, however, make it possible to test
out these concepts for possible standardization at a later
time.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mutex
Attributes and Performance</b> <br>
Care has been taken to ensure that the default values of the
mutex attributes have been defined such that mutexes
initialized with the defaults have simple enough semantics
so that the locking and unlocking can be done with the
equivalent of a test-and-set instruction (plus possibly a
few other basic instructions).</p>

<p style="margin-left:11%; margin-top: 1em">There is at
least one implementation method that can be used to reduce
the cost of testing at lock-time if a mutex has non-default
attributes. One such method that an implementation can
employ (and this can be made fully transparent to fully
conforming POSIX applications) is to secretly pre-lock any
mutexes that are initialized to non-default attributes. Any
later attempt to lock such a mutex causes the implementation
to branch to the &quot;slow path&quot; as if the mutex were
unavailable; then, on the slow path, the implementation can
do the &quot;real work&quot; to lock a non-default mutex.
The underlying unlock operation is more complicated since
the implementation never really wants to release the
pre-lock on this kind of mutex. This illustrates that,
depending on the hardware, there may be certain
optimizations that can be used so that whatever mutex
attributes are considered &quot;most frequently used&quot;
can be processed most efficiently.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process
Shared Memory and Synchronization</b> <br>
The existence of memory mapping functions in this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 leads to the possibility that
an application may allocate the synchronization objects from
this section in memory that is accessed by multiple
processes (and therefore, by threads of multiple
processes).</p>

<p style="margin-left:11%; margin-top: 1em">In order to
permit such usage, while at the same time keeping the usual
case (that is, usage within a single process) efficient, a
<i>process-shared</i> option has been defined.</p>

<p style="margin-left:11%; margin-top: 1em">If an
implementation supports the _POSIX_THREAD_PROCESS_SHARED
option, then the <i>process-shared</i> attribute can be used
to indicate that mutexes or condition variables may be
accessed by threads of multiple processes.</p>

<p style="margin-left:11%; margin-top: 1em">The default
setting of PTHREAD_PROCESS_PRIVATE has been chosen for the
<i>process-shared</i> attribute so that the most efficient
forms of these synchronization objects are created by
default.</p>


<p style="margin-left:11%; margin-top: 1em">Synchronization
variables that are initialized with the
PTHREAD_PROCESS_PRIVATE <i>process-shared</i> attribute may
only be operated on by threads in the process that
initialized them. Synchronization variables that are
initialized with the PTHREAD_PROCESS_SHARED
<i>process-shared</i> attribute may be operated on by any
thread in any process that has access to it. In particular,
these processes may exist beyond the lifetime of the
initializing process. For example, the following code
implements a simple counting semaphore in a mapped file that
may be used by many processes.</p>

<p style="margin-left:22%; margin-top: 1em"><b>/* sem.h */
<br>
struct semaphore { <br>
pthread_mutex_t lock; <br>
pthread_cond_t nonzero; <br>
unsigned count; <br>
}; <br>
typedef struct semaphore semaphore_t;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semaphore_t
*semaphore_create(char *semaphore_name); <br>
semaphore_t *semaphore_open(char *semaphore_name); <br>
void semaphore_post(semaphore_t *semap); <br>
void semaphore_wait(semaphore_t *semap); <br>
void semaphore_close(semaphore_t *semap);</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/* sem.c */
<br>
#include &lt;sys/types.h&gt; <br>
#include &lt;sys/stat.h&gt; <br>
#include &lt;sys/mman.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;pthread.h&gt; <br>
#include &quot;sem.h&quot;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semaphore_t
* <br>
semaphore_create(char *semaphore_name) <br>
{ <br>
int fd; <br>
semaphore_t *semap; <br>
pthread_mutexattr_t psharedm; <br>
pthread_condattr_t psharedc;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>fd =
open(semaphore_name, O_RDWR | O_CREAT | O_EXCL, 0666); <br>
if (fd &lt; 0) <br>
return (NULL); <br>
(void) ftruncate(fd, sizeof(semaphore_t)); <br>
(void) pthread_mutexattr_init(&amp;psharedm); <br>
(void) pthread_mutexattr_setpshared(&amp;psharedm, <br>
PTHREAD_PROCESS_SHARED); <br>
(void) pthread_condattr_init(&amp;psharedc); <br>
(void) pthread_condattr_setpshared(&amp;psharedc, <br>
PTHREAD_PROCESS_SHARED); <br>
semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t), <br>
PROT_READ | PROT_WRITE, MAP_SHARED, <br>
fd, 0); <br>
close (fd); <br>
(void) pthread_mutex_init(&amp;semap-&gt;lock,
&amp;psharedm); <br>
(void) pthread_cond_init(&amp;semap-&gt;nonzero,
&amp;psharedc); <br>
semap-&gt;count = 0; <br>
return (semap); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semaphore_t
* <br>
semaphore_open(char *semaphore_name) <br>
{ <br>
int fd; <br>
semaphore_t *semap;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>fd =
open(semaphore_name, O_RDWR, 0666); <br>
if (fd &lt; 0) <br>
return (NULL); <br>
semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t), <br>
PROT_READ | PROT_WRITE, MAP_SHARED, <br>
fd, 0); <br>
close (fd); <br>
return (semap); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>void <br>
semaphore_post(semaphore_t *semap) <br>
{ <br>
pthread_mutex_lock(&amp;semap-&gt;lock); <br>
if (semap-&gt;count == 0) <br>
pthread_cond_signal(&amp;semapx-&gt;nonzero); <br>
semap-&gt;count++; <br>
pthread_mutex_unlock(&amp;semap-&gt;lock); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>void <br>
semaphore_wait(semaphore_t *semap) <br>
{ <br>
pthread_mutex_lock(&amp;semap-&gt;lock); <br>
while (semap-&gt;count == 0) <br>
pthread_cond_wait(&amp;semap-&gt;nonzero,
&amp;semap-&gt;lock); <br>
semap-&gt;count--; <br>
pthread_mutex_unlock(&amp;semap-&gt;lock); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>void <br>
semaphore_close(semaphore_t *semap) <br>
{ <br>
munmap((void *) semap, sizeof(semaphore_t)); <br>
}</b></p>

<p style="margin-left:11%; margin-top: 1em">The following
code is for three separate processes that create, post, and
wait on a semaphore in the file <b>/tmp/semaphore</b>. Once
the file is created, the post and wait programs increment
and decrement the counting semaphore (waiting and waking as
required) even though they did not initialize the
semaphore.</p>

<p style="margin-left:22%; margin-top: 1em"><b>/* create.c
*/ <br>
#include &quot;pthread.h&quot; <br>
#include &quot;sem.h&quot;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>int <br>
main() <br>
{ <br>
semaphore_t *semap;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semap =
semaphore_create(&quot;/tmp/semaphore&quot;); <br>
if (semap == NULL) <br>
exit(1); <br>
semaphore_close(semap); <br>
return (0); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/* post */
<br>
#include &quot;pthread.h&quot; <br>
#include &quot;sem.h&quot;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>int <br>
main() <br>
{ <br>
semaphore_t *semap;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semap =
semaphore_open(&quot;/tmp/semaphore&quot;); <br>
if (semap == NULL) <br>
exit(1); <br>
semaphore_post(semap); <br>
semaphore_close(semap); <br>
return (0); <br>
}</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>/* wait */
<br>
#include &quot;pthread.h&quot; <br>
#include &quot;sem.h&quot;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>int <br>
main() <br>
{ <br>
semaphore_t *semap;</b></p>

<p style="margin-left:22%; margin-top: 1em"><b>semap =
semaphore_open(&quot;/tmp/semaphore&quot;); <br>
if (semap == NULL) <br>
exit(1); <br>
semaphore_wait(semap); <br>
semaphore_close(semap); <br>
return (0); <br>
}</b></p>

<h2>FUTURE DIRECTIONS
<a name="FUTURE DIRECTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>pthread_cond_destroy</i>(),
<i>pthread_create</i>(), <i>pthread_mutex_destroy</i>(),
pthread_mutexattr_destroy, the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <i>&lt;pthread.h&gt;</i></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Portions of
this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information
Technology -- Portable Operating System Interface (POSIX),
The Open Group Base Specifications Issue 6, Copyright (C)
2001-2003 by the Institute of Electrical and Electronics
Engineers, Inc and The Open Group. In the event of any
discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open
Group Standard is the referee document. The original
Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>
<hr>
</body>
</html>
