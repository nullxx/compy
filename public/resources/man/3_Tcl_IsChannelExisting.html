<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:50 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_CreateChannel</title>

</head>
<body>

<h1 align="center">Tcl_CreateChannel</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#TCL_CHANNELTYPE">TCL_CHANNELTYPE</a><br>
<a href="#TCL_BADCHANNELOPTION">TCL_BADCHANNELOPTION</a><br>
<a href="#OLD CHANNEL TYPES">OLD CHANNEL TYPES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_CreateChannel,
Tcl_GetChannelInstanceData, Tcl_GetChannelType,
Tcl_GetChannelName, Tcl_GetChannelHandle,
Tcl_GetChannelMode, Tcl_GetChannelBufferSize,
Tcl_SetChannelBufferSize, Tcl_NotifyChannel,
Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion,
Tcl_ChannelBlockModeProc, Tcl_ChannelCloseProc,
Tcl_ChannelClose2Proc, Tcl_ChannelInputProc,
Tcl_ChannelOutputProc, Tcl_ChannelSeekProc,
Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc,
Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc,
Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc,
Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc,
Tcl_ChannelThreadActionProc, Tcl_IsChannelShared,
Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel,
Tcl_IsChannelExisting, Tcl_ClearChannelHandlers,
Tcl_GetChannelThread, Tcl_ChannelBuffered &minus; procedures
for creating and manipulating channels</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_CreateChannel</b>(<i>typePtr, channelName, instanceData,
mask</i>)</p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_GetChannelInstanceData</b>(<i>channel</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_ChannelType
* <b><br>
Tcl_GetChannelType</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_GetChannelName</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelHandle</b>(<i>channel, direction,
handlePtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_ThreadId
<b><br>
Tcl_GetChannelThread</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelMode</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_GetChannelBufferSize</b>(<i>channel</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SetChannelBufferSize</b>(<i>channel,
size</i>)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_NotifyChannel</b>(<i>channel,
mask</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_BadChannelOption</b>(<i>interp, optionName,
optionList</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_IsChannelShared</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_IsChannelRegistered</b>(<i>interp, channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_IsChannelExisting</b>(<i>channelName</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_CutChannel</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_SpliceChannel</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_ClearChannelHandlers</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_ChannelBuffered</b>(<i>channel</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_ChannelName</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_ChannelTypeVersion
<b><br>
Tcl_ChannelVersion</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverBlockModeProc
* <b><br>
Tcl_ChannelBlockModeProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverCloseProc
* <b><br>
Tcl_ChannelCloseProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverClose2Proc
* <b><br>
Tcl_ChannelClose2Proc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverInputProc
* <b><br>
Tcl_ChannelInputProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverOutputProc
* <b><br>
Tcl_ChannelOutputProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverSeekProc
* <b><br>
Tcl_ChannelSeekProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverWideSeekProc
* <b><br>
Tcl_ChannelWideSeekProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverThreadActionProc
* <b><br>
Tcl_ChannelThreadActionProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverTruncateProc
* <big>&#9474;</big> <b><br>
Tcl_ChannelTruncateProc</b>(<i>typePtr</i>)
<big>&#9474;</big></p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverSetOptionProc
* <b><br>
Tcl_ChannelSetOptionProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverGetOptionProc
* <b><br>
Tcl_ChannelGetOptionProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverWatchProc
* <b><br>
Tcl_ChannelWatchProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverGetHandleProc
* <b><br>
Tcl_ChannelGetHandleProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverFlushProc
* <b><br>
Tcl_ChannelFlushProc</b>(<i>typePtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_DriverHandlerProc
* <b><br>
Tcl_ChannelHandlerProc</b>(<i>typePtr</i>)</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p style="margin-top: 1em">const Tcl_ChannelType
<i>*typePtr</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p style="margin-top: 1em">Points to a structure containing
the addresses of procedures that can be called to perform
I/O and other functions on the channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>const char <i>*channelName</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>The name of this channel, such as <b>file3</b>; must not
be in use by any other channel. Can be NULL, in which case
the channel is created without a name.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>ClientData <i>instanceData</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>Arbitrary one-word value to be associated with this
channel. This value is passed to procedures in
<i>typePtr</i> when they are invoked.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>int <i>mask</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>OR-ed combination of <b>TCL_READABLE</b> and
<b>TCL_WRITABLE</b> to indicate whether a channel is
readable and writable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>Tcl_Channel <i>channel</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>The channel to operate on.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>int <i>direction</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p><b>TCL_READABLE</b> means the input handle is wanted;
<b>TCL_WRITABLE</b> means the output handle is wanted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>ClientData <i>*handlePtr</i> (out)</p></td>
<td width="21%"></td>
<td width="14%">


<p>Points to the location where the desired OS-specific
handle should be stored.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>int <i>size</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>The size, in bytes, of buffers to allocate in this
channel.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>int <i>mask</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>An OR-ed combination of <b>TCL_READABLE</b>,
<b>TCL_WRITABLE</b> and <b>TCL_EXCEPTION</b> that indicates
events that have occurred on this channel.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>Tcl_Interp <i>*interp</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>Current interpreter. (can be NULL)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>const char <i>*optionName</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>Name of the invalid option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="54%">


<p>const char <i>*optionList</i> (in)</p></td>
<td width="21%"></td>
<td width="14%">


<p>Specific options list (space separated words, without
&ldquo;&minus;&rdquo;) to append to the standard generic
options list. Can be NULL for generic options error message
only.</p> </td></tr>
</table>


<p style="margin-left:86%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl uses a
two-layered channel architecture. It provides a generic
upper layer to enable C and Tcl programs to perform input
and output using the same APIs for a variety of files,
devices, sockets etc. The generic C APIs are described in
the manual entry for <b>Tcl_OpenFileChannel</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The lower layer
provides type-specific channel drivers for each type of
device supported on each platform. This manual entry
describes the C APIs used to communicate between the generic
layer and the type-specific channel drivers. It also
explains how new types of channels can be added by providing
new channel drivers.</p>

<p style="margin-left:11%; margin-top: 1em">Channel drivers
consist of a number of components: First, each channel
driver provides a <b>Tcl_ChannelType</b> structure
containing pointers to functions implementing the various
operations used by the generic layer to communicate with the
channel driver. The <b>Tcl_ChannelType</b> structure and the
functions referenced by it are described in the section
<b>TCL_CHANNELTYPE</b>, below.</p>

<p style="margin-left:11%; margin-top: 1em">Second, channel
drivers usually provide a Tcl command to create instances of
that type of channel. For example, the Tcl <b>open</b>
command creates channels that use the file and command
channel drivers, and the Tcl <b>socket</b> command creates
channels that use TCP sockets for network communication.</p>

<p style="margin-left:11%; margin-top: 1em">Third, a
channel driver optionally provides a C function to open
channel instances of that type. For example,
<b>Tcl_OpenFileChannel</b> opens a channel that uses the
file channel driver, and <b>Tcl_OpenTcpClient</b> opens a
channel that uses the TCP network protocol. These creation
functions typically use <b>Tcl_CreateChannel</b> internally
to open the channel.</p>

<p style="margin-left:11%; margin-top: 1em">To add a new
type of channel you must implement a C API or a Tcl command
that opens a channel by invoking <b>Tcl_CreateChannel</b>.
When your driver calls <b>Tcl_CreateChannel</b> it passes in
a <b>Tcl_ChannelType</b> structure describing the
driver&rsquo;s I/O procedures. The generic layer will then
invoke the functions referenced in that structure to perform
operations on the channel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateChannel</b>
opens a new channel and associates the supplied
<i>typePtr</i> and <i>instanceData</i> with it. The channel
is opened in the mode indicated by <i>mask</i>. For a
discussion of channel drivers, their operations and the
<b>Tcl_ChannelType</b> structure, see the section
<b>TCL_CHANNELTYPE</b>, below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CreateChannel</b>
interacts with the code managing the standard channels. Once
a standard channel was initialized either through a call to
<b>Tcl_GetStdChannel</b> or a call to
<b>Tcl_SetStdChannel</b> closing this standard channel will
cause the next call to <b>Tcl_CreateChannel</b> to make the
new channel the new standard channel too. See
<b>Tcl_StandardChannels</b> for a general treatise about
standard channels and the behaviour of the Tcl library with
regard to them.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelInstanceData</b>
returns the instance data associated with the channel in
<i>channel</i>. This is the same as the <i>instanceData</i>
argument in the call to <b>Tcl_CreateChannel</b> that
created this channel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelType</b>
returns a pointer to the <b>Tcl_ChannelType</b> structure
used by the channel in the <i>channel</i> argument. This is
the same as the <i>typePtr</i> argument in the call to
<b>Tcl_CreateChannel</b> that created this channel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelName</b>
returns a string containing the name associated with the
channel, or NULL if the <i>channelName</i> argument to
<b>Tcl_CreateChannel</b> was NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelHandle</b>
places the OS-specific device handle associated with
<i>channel</i> for the given <i>direction</i> in the
location specified by <i>handlePtr</i> and returns
<b>TCL_OK</b>. If the channel does not have a device handle
for the specified direction, then <b>TCL_ERROR</b> is
returned instead. Different channel drivers will return
different types of handle. Refer to the manual entries for
each driver to determine what type of handle is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelThread</b>
returns the id of the thread currently managing the
specified <i>channel</i>. This allows channel drivers to
send their file events to the correct event queue even for a
multi-threaded core.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelMode</b>
returns an OR-ed combination of <b>TCL_READABLE</b> and
<b>TCL_WRITABLE</b>, indicating whether the channel is open
for input and output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_GetChannelBufferSize</b>
returns the size, in bytes, of buffers allocated to store
input or output in <i>channel</i>. If the value was not set
by a previous call to <b>Tcl_SetChannelBufferSize</b>,
described below, then the default value of 4096 is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SetChannelBufferSize</b>
sets the size, in bytes, of buffers that will be allocated
in subsequent operations on the channel to store input or
output. The <i>size</i> argument should be between ten and
one million, allowing buffers of ten bytes to one million
bytes. If <i>size</i> is outside this range,
<b>Tcl_SetChannelBufferSize</b> sets the buffer size to
4096.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_NotifyChannel</b>
is called by a channel driver to indicate to the generic
layer that the events specified by <i>mask</i> have occurred
on the channel. Channel drivers are responsible for invoking
this function whenever the channel handlers need to be
called for the channel. See <b>WATCHPROC</b> below for more
details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_BadChannelOption</b>
is called from driver specific <i>setOptionProc</i> or
<i>getOptionProc</i> to generate a complete error
message.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ChannelBuffered</b>
returns the number of bytes of input currently buffered in
the internal buffer (push back area) of the channel itself.
It does not report about the data in the overall buffers for
the stack of channels the supplied channel is part of.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_IsChannelShared</b>
checks the refcount of the specified <i>channel</i> and
returns whether the <i>channel</i> was shared among multiple
interpreters (result == 1) or not (result == 0).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_IsChannelRegistered</b>
checks whether the specified <i>channel</i> is registered in
the given <i>interp</i>reter (result == 1) or not (result ==
0).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_IsChannelExisting</b>
checks whether a channel with the specified name is
registered in the (thread)-global list of all channels
(result == 1) or not (result == 0).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_CutChannel</b>
removes the specified <i>channel</i> from the (thread)global
list of all channels (of the current thread). Application to
a channel still registered in some interpreter is not
allowed. Also notifies the <big>&#9474;</big> driver if the
<b>Tcl_ChannelType</b> version is
<b>TCL_CHANNEL_VERSION_4</b> (or <big>&#9474;</big> higher),
and <b>Tcl_DriverThreadActionProc</b> is defined for it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_SpliceChannel</b>
adds the specified <i>channel</i> to the (thread)global list
of all channels (of the current thread). Application to a
channel registered in some interpreter is not allowed. Also
notifies the <big>&#9474;</big> driver if the
<b>Tcl_ChannelType</b> version is
<b>TCL_CHANNEL_VERSION_4</b> (or <big>&#9474;</big> higher),
and <b>Tcl_DriverThreadActionProc</b> is defined for it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_ClearChannelHandlers</b>
removes all channel handlers and event scripts associated
with the specified <i>channel</i>, thus shutting down all
event processing for this channel.</p>

<h2>TCL_CHANNELTYPE
<a name="TCL_CHANNELTYPE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A channel
driver provides a <b>Tcl_ChannelType</b> structure that
contains pointers to functions that implement the various
operations on a channel; these operations are invoked as
needed by the generic layer. The structure was versioned
starting in Tcl 8.3.2/8.4 to correct a problem with stacked
channel drivers. See the <b>OLD CHANNEL TYPES</b> section
below for details about the old structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_ChannelType</b> structure contains the following
fields:</p>

<p style="margin-left:22%;">typedef struct Tcl_ChannelType
{ <br>
char *<i>typeName</i>; <br>
Tcl_ChannelTypeVersion <i>version</i>; <br>
Tcl_DriverCloseProc *<i>closeProc</i>; <br>
Tcl_DriverInputProc *<i>inputProc</i>; <br>
Tcl_DriverOutputProc *<i>outputProc</i>; <br>
Tcl_DriverSeekProc *<i>seekProc</i>; <br>
Tcl_DriverSetOptionProc *<i>setOptionProc</i>; <br>
Tcl_DriverGetOptionProc *<i>getOptionProc</i>; <br>
Tcl_DriverWatchProc *<i>watchProc</i>; <br>
Tcl_DriverGetHandleProc *<i>getHandleProc</i>; <br>
Tcl_DriverClose2Proc *<i>close2Proc</i>; <br>
Tcl_DriverBlockModeProc *<i>blockModeProc</i>; <br>
Tcl_DriverFlushProc *<i>flushProc</i>; <br>
Tcl_DriverHandlerProc *<i>handlerProc</i>; <br>
Tcl_DriverWideSeekProc *<i>wideSeekProc</i>; <br>
Tcl_DriverThreadActionProc *<i>threadActionProc</i>; <br>
Tcl_DriverTruncateProc *<i>truncateProc</i>;
<big>&#9474;</big> <br>
} Tcl_ChannelType;</p>

<p style="margin-left:11%; margin-top: 1em">It is not
necessary to provide implementations for all channel
operations. Those which are not necessary may be set to NULL
in the struct: <i>blockModeProc</i>, <i>seekProc</i>,
<i>setOptionProc</i>, <i>getOptionProc</i>, and
<i>close2Proc</i>, in addition to <i>flushProc</i>,
<i>handlerProc</i>, <i>threadActionProc</i>, and
<i>truncateProc</i>. Other functions that cannot be
implemented in a meaningful way should return <b>EINVAL</b>
when called, to indicate that the operations they represent
are not available. Also note that <i>wideSeekProc</i> can be
NULL if <i>seekProc</i> is.</p>

<p style="margin-left:11%; margin-top: 1em">The user should
only use the above structure for <b>Tcl_ChannelType</b>
instantiation. When referencing fields in a
<b>Tcl_ChannelType</b> structure, the following functions
should be used to obtain the values: <b>Tcl_ChannelName</b>,
<b>Tcl_ChannelVersion</b>, <b>Tcl_ChannelBlockModeProc</b>,
<b>Tcl_ChannelCloseProc</b>, <b>Tcl_ChannelClose2Proc</b>,
<b>Tcl_ChannelInputProc</b>, <b>Tcl_ChannelOutputProc</b>,
<b>Tcl_ChannelSeekProc</b>, <b>Tcl_ChannelWideSeekProc</b>,
<b>Tcl_ChannelThreadActionProc</b>,
<b>Tcl_ChannelTruncateProc</b>, <big>&#9474;</big>
<b>Tcl_ChannelSetOptionProc</b>,
<b>Tcl_ChannelGetOptionProc</b>,
<b>Tcl_ChannelWatchProc</b>,
<b>Tcl_ChannelGetHandleProc</b>,
<b>Tcl_ChannelFlushProc</b>, or
<b>Tcl_ChannelHandlerProc</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The change to
the structures was made in such a way that standard channel
types are binary compatible. However, channel types that use
stacked channels (i.e. TLS, Trf) have new versions to
correspond to the above change since the previous code for
stacked channels had problems.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TYPENAME</b>
<br>
The <i>typeName</i> field contains a null-terminated string
that identifies the type of the device implemented by this
driver, e.g. <b>file</b> or <b>socket</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelName</b>, which returns a
pointer to the string.</p>

<p style="margin-left:11%; margin-top: 1em"><b>VERSION</b>
<br>
The <i>version</i> field should be set to the version of the
structure that you require. <b>TCL_CHANNEL_VERSION_2</b> is
the minimum recommended. <b>TCL_CHANNEL_VERSION_3</b> must
be set to specify the <i>wideSeekProc</i> member.
<b>TCL_CHANNEL_VERSION_4</b> must be set to specify the
<i>threadActionProc</i> member (includes
<i>wideSeekProc</i>). <b>TCL_CHANNEL_VERSION_5</b> must be
set to <big>&#9474;</big> specify the <i>truncateProc</i>
members (includes <i>wideSeekProc</i> and <big>&#9474;</big>
<i>threadActionProc</i>). If it is not set to any of these,
then this <b>Tcl_ChannelType</b> is assumed to have the
original structure. See <b>OLD CHANNEL TYPES</b> for more
details. While Tcl will recognize and function with either
structures, stacked channels must be of at least
<b>TCL_CHANNEL_VERSION_2</b> to function correctly.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelVersion</b>, which returns
one of <b>TCL_CHANNEL_VERSION_5</b>,
<b>TCL_CHANNEL_VERSION_4</b>, <b>TCL_CHANNEL_VERSION_3</b>,
<big>&#9474;</big> <b>TCL_CHANNEL_VERSION_2</b> or
<b>TCL_CHANNEL_VERSION_1</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BLOCKMODEPROC</b>
<br>
The <i>blockModeProc</i> field contains the address of a
function called by the generic layer to set blocking and
nonblocking mode on the device. <i>BlockModeProc</i> should
match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverBlockModeProc( <br>
ClientData <i>instanceData</i>, <br>
int <i>mode</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>instanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>mode</i> argument is either <b>TCL_MODE_BLOCKING</b> or
<b>TCL_MODE_NONBLOCKING</b> to set the device into blocking
or nonblocking mode. The function should return zero if the
operation was successful, or a nonzero POSIX error code if
the operation failed.</p>

<p style="margin-left:11%; margin-top: 1em">If the
operation is successful, the function can modify the
supplied <i>instanceData</i> to record that the channel
entered blocking or nonblocking mode and to implement the
blocking or nonblocking behavior. For some device types, the
blocking and nonblocking behavior can be implemented by the
underlying operating system; for other device types, the
behavior must be emulated in the channel driver.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelBlockModeProc</b>, which
returns a pointer to the function.</p>

<p style="margin-left:11%; margin-top: 1em">A channel
driver <b>not</b> supplying a <i>blockModeProc</i> has to be
very, very careful. It has to tell the generic layer exactly
which blocking mode is acceptable to it, and should this
also document for the user so that the blocking mode of the
channel is not changed to an unacceptable value. Any
confusion here may lead the interpreter into a (spurious and
difficult to find) deadlock.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CLOSEPROC
AND CLOSE2PROC</b> <br>
The <i>closeProc</i> field contains the address of a
function called by the generic layer to clean up
driver-related information when the channel is closed.
<i>CloseProc</i> must match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverCloseProc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_Interp *<i>interp</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>instanceData</i> argument is the same as the value
provided to <b>Tcl_CreateChannel</b> when the channel was
created. The function should release any storage maintained
by the channel driver for this channel, and close the input
and output devices encapsulated by this channel. All queued
output will have been flushed to the device before this
function is called, and no further driver operations will be
invoked on this instance after calling the <i>closeProc</i>.
If the close operation is successful, the procedure should
return zero; otherwise it should return a nonzero POSIX
error code. In addition, if an error occurs and
<i>interp</i> is not NULL, the procedure should store an
error message in the interpreter&rsquo;s result.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
channels that support closing the read and write sides
independently may set <i>closeProc</i> to
<b>TCL_CLOSE2PROC</b> and set <i>close2Proc</i> to the
address of a function that matches the following
prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverClose2Proc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_Interp *<i>interp</i>, <br>
int <i>flags</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>close2Proc</i> will be called with <i>flags</i> set to an
OR&rsquo;ed combination of <b>TCL_CLOSE_READ</b> or
<b>TCL_CLOSE_WRITE</b> to indicate that the driver should
close the read and/or write side of the channel. The channel
driver may be invoked to perform additional operations on
the channel after <i>close2Proc</i> is called to close one
or both sides of the channel. If <i>flags</i> is <b>0</b>
(zero), the driver should close the channel in the manner
described above for <i>closeProc</i>. No further operations
will be invoked on this instance after <i>close2Proc</i> is
called with all flags cleared. In all cases, the
<i>close2Proc</i> function should return zero if the close
operation was successful; otherwise it should return a
nonzero POSIX error code. In addition, if an error occurs
and <i>interp</i> is not NULL, the procedure should store an
error message in the interpreter&rsquo;s result.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>closeProc</i> and <i>close2Proc</i> values can be
retrieved with <b>Tcl_ChannelCloseProc</b> or
<b>Tcl_ChannelClose2Proc</b>, which return a pointer to the
respective function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INPUTPROC</b>
<br>
The <i>inputProc</i> field contains the address of a
function called by the generic layer to read data from the
file or device and store it in an internal buffer.
<i>InputProc</i> must match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverInputProc( <br>
ClientData <i>instanceData</i>, <br>
char *<i>buf</i>, <br>
int <i>bufSize</i>, <br>
int *<i>errorCodePtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when the channel was created. The <i>buf</i> argument points
to an array of bytes in which to store input from the
device, and the <i>bufSize</i> argument indicates how many
bytes are available at <i>buf</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer. If an error occurs, the
function should set the variable to a POSIX error code that
identifies the error that occurred.</p>

<p style="margin-left:11%; margin-top: 1em">The function
should read data from the input device encapsulated by the
channel and store it at <i>buf</i>. On success, the function
should return a nonnegative integer indicating how many
bytes were read from the input device and stored at
<i>buf</i>. On error, the function should return -1. If an
error occurs after some data has been read from the device,
that data is lost.</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>inputProc</i> can determine that the input device has
some data available but less than requested by the
<i>bufSize</i> argument, the function should only attempt to
read as much data as is available and return without
blocking. If the input device has no data available
whatsoever and the channel is in nonblocking mode, the
function should return an <b>EAGAIN</b> error. If the input
device has no data available whatsoever and the channel is
in blocking mode, the function should block for the shortest
possible time until at least one byte of data can be read
from the device; then, it should return as much data as it
can read without blocking.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelInputProc</b>, which returns
a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OUTPUTPROC</b>
<br>
The <i>outputProc</i> field contains the address of a
function called by the generic layer to transfer data from
an internal buffer to the output device. <i>OutputProc</i>
must match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverOutputProc( <br>
ClientData <i>instanceData</i>, <br>
const char *<i>buf</i>, <br>
int <i>toWrite</i>, <br>
int *<i>errorCodePtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when the channel was created. The <i>buf</i> argument
contains an array of bytes to be written to the device, and
the <i>toWrite</i> argument indicates how many bytes are to
be written from the <i>buf</i> argument.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer. If an error occurs, the
function should set this variable to a POSIX error code that
identifies the error.</p>

<p style="margin-left:11%; margin-top: 1em">The function
should write the data at <i>buf</i> to the output device
encapsulated by the channel. On success, the function should
return a nonnegative integer indicating how many bytes were
written to the output device. The return value is normally
the same as <i>toWrite</i>, but may be less in some cases
such as if the output operation is interrupted by a signal.
If an error occurs the function should return -1. In case of
error, some data may have been written to the device.</p>

<p style="margin-left:11%; margin-top: 1em">If the channel
is nonblocking and the output device is unable to absorb any
data whatsoever, the function should return -1 with an
<b>EAGAIN</b> error without writing any data.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelOutputProc</b>, which
returns a pointer to the function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SEEKPROC AND
WIDESEEKPROC</b> <br>
The <i>seekProc</i> field contains the address of a function
called by the generic layer to move the access point at
which subsequent input or output operations will be applied.
<i>SeekProc</i> must match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverSeekProc( <br>
ClientData <i>instanceData</i>, <br>
long <i>offset</i>, <br>
int <i>seekMode</i>, <br>
int *<i>errorCodePtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>instanceData</i> argument is the same as the value given
to <b>Tcl_CreateChannel</b> when this channel was created.
<i>Offset</i> and <i>seekMode</i> have the same meaning as
for the <b>Tcl_Seek</b> procedure (described in the manual
entry for <b>Tcl_OpenFileChannel</b>).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>errorCodePtr</i> argument points to an integer variable
provided by the generic layer for returning <b>errno</b>
values from the function. The function should set this
variable to a POSIX error code if an error occurs. The
function should store an <b>EINVAL</b> error code if the
channel type does not implement seeking.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is the new access point or -1 in case of error. If an
error occurred, the function should not move the access
point.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
non-NULL <i>seekProc</i> field, the <i>wideSeekProc</i>
field may contain the address of an alternative function to
use which handles wide (i.e. larger than 32-bit) offsets, so
allowing seeks within files larger than 2GB. The
<i>wideSeekProc</i> will be called in preference to the
<i>seekProc</i>, but both must be defined if the
<i>wideSeekProc</i> is defined. <i>WideSeekProc</i> must
match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_WideInt Tcl_DriverWideSeekProc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_WideInt <i>offset</i>, <br>
int <i>seekMode</i>, <br>
int *<i>errorCodePtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
and return values mean the same thing as with
<i>seekProc</i> above, except that the type of offsets and
the return type are different.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>seekProc</i> value can be retrieved with
<b>Tcl_ChannelSeekProc</b>, which returns a pointer to the
function, and similarly the <i>wideSeekProc</i> can be
retrieved with <b>Tcl_ChannelWideSeekProc</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SETOPTIONPROC</b>
<br>
The <i>setOptionProc</i> field contains the address of a
function called by the generic layer to set a channel type
specific option on a channel. <i>setOptionProc</i> must
match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverSetOptionProc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_Interp *<i>interp</i>, <br>
const char *<i>optionName</i>, <br>
const char *<i>newValue</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>optionName</i>
is the name of an option to set, and <i>newValue</i> is the
new value for that option, as a string. The
<i>instanceData</i> is the same as the value given to
<b>Tcl_CreateChannel</b> when this channel was created. The
function should do whatever channel type specific action is
required to implement the new value of the option.</p>

<p style="margin-left:11%; margin-top: 1em">Some options
are handled by the generic code and this function is never
called to set them, e.g. <b>&minus;blockmode</b>. Other
options are specific to each channel type and the
<i>setOptionProc</i> procedure of the channel driver will
get called to implement them. The <i>setOptionProc</i> field
can be NULL, which indicates that this channel type supports
no type specific options.</p>

<p style="margin-left:11%; margin-top: 1em">If the option
value is successfully modified to the new value, the
function returns <b>TCL_OK</b>. It should call
<b>Tcl_BadChannelOption</b> which itself returns
<b>TCL_ERROR</b> if the <i>optionName</i> is unrecognized.
If <i>newValue</i> specifies a value for the option that is
not supported or if a system call error occurs, the function
should leave an error message in the <i>result</i> field of
<i>interp</i> if <i>interp</i> is not NULL. The function
should also call <b>Tcl_SetErrno</b> to store an appropriate
POSIX error code.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelSetOptionProc</b>, which
returns a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GETOPTIONPROC</b>
<br>
The <i>getOptionProc</i> field contains the address of a
function called by the generic layer to get the value of a
channel type specific option on a channel.
<i>getOptionProc</i> must match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverGetOptionProc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_Interp *<i>interp</i>, <br>
const char *<i>optionName</i>, <br>
Tcl_DString *<i>optionValue</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>OptionName</i>
is the name of an option supported by this type of channel.
If the option name is not NULL, the function stores its
current value, as a string, in the Tcl dynamic string
<i>optionValue</i>. If <i>optionName</i> is NULL, the
function stores in <i>optionValue</i> an alternating list of
all supported options and their current values. On success,
the function returns <b>TCL_OK</b>. It should call
<b>Tcl_BadChannelOption</b> which itself returns
<b>TCL_ERROR</b> if the <i>optionName</i> is unrecognized.
If a system call error occurs, the function should leave an
error message in the result of <i>interp</i> if
<i>interp</i> is not NULL. The function should also call
<b>Tcl_SetErrno</b> to store an appropriate POSIX error
code.</p>

<p style="margin-left:11%; margin-top: 1em">Some options
are handled by the generic code and this function is never
called to retrieve their value, e.g.
<b>&minus;blockmode</b>. Other options are specific to each
channel type and the <i>getOptionProc</i> procedure of the
channel driver will get called to implement them. The
<i>getOptionProc</i> field can be NULL, which indicates that
this channel type supports no type specific options.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelGetOptionProc</b>, which
returns a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>WATCHPROC</b>
<br>
The <i>watchProc</i> field contains the address of a
function called by the generic layer to initialize the event
notification mechanism to notice events of interest on this
channel. <i>WatchProc</i> should match the following
prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_DriverWatchProc( <br>
ClientData <i>instanceData</i>, <br>
int <i>mask</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>instanceData</i> is the same as the value passed to
<b>Tcl_CreateChannel</b> when this channel was created. The
<i>mask</i> argument is an OR-ed combination of
<b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and
<b>TCL_EXCEPTION</b>; it indicates events the caller is
interested in noticing on this channel.</p>

<p style="margin-left:11%; margin-top: 1em">The function
should initialize device type specific mechanisms to notice
when an event of interest is present on the channel. When
one or more of the designated events occurs on the channel,
the channel driver is responsible for calling
<b>Tcl_NotifyChannel</b> to inform the generic channel
module. The driver should take care not to starve other
channel drivers or sources of callbacks by invoking
Tcl_NotifyChannel too frequently. Fairness can be insured by
using the Tcl event queue to allow the channel event to be
scheduled in sequence with other events. See the description
of <b>Tcl_QueueEvent</b> for details on how to queue an
event.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelWatchProc</b>, which returns
a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GETHANDLEPROC</b>
<br>
The <i>getHandleProc</i> field contains the address of a
function called by the generic layer to retrieve a
device-specific handle from the channel.
<i>GetHandleProc</i> should match the following
prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverGetHandleProc( <br>
ClientData <i>instanceData</i>, <br>
int <i>direction</i>, <br>
ClientData *<i>handlePtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when this channel was created. The <i>direction</i> argument
is either <b>TCL_READABLE</b> to retrieve the handle used
for input, or <b>TCL_WRITABLE</b> to retrieve the handle
used for output.</p>

<p style="margin-left:11%; margin-top: 1em">If the channel
implementation has device-specific handles, the function
should retrieve the appropriate handle associated with the
channel, according the <i>direction</i> argument. The handle
should be stored in the location referred to by
<i>handlePtr</i>, and <b>TCL_OK</b> should be returned. If
the channel is not open for the specified direction, or if
the channel implementation does not use device handles, the
function should return <b>TCL_ERROR</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelGetHandleProc</b>, which
returns a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>FLUSHPROC</b>
<br>
The <i>flushProc</i> field is currently reserved for future
use. It should be set to NULL. <i>FlushProc</i> should match
the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverFlushProc( <br>
ClientData <i>instanceData</i>);</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelFlushProc</b>, which returns
a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>HANDLERPROC</b>
<br>
The <i>handlerProc</i> field contains the address of a
function called by the generic layer to notify the channel
that an event occurred. It should be defined for stacked
channel drivers that wish to be notified of events that
occur on the underlying (stacked) channel.
<i>HandlerProc</i> should match the following prototype:</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverHandlerProc( <br>
ClientData <i>instanceData</i>, <br>
int <i>interestMask</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when this channel was created. The <i>interestMask</i> is an
OR-ed combination of <b>TCL_READABLE</b> or
<b>TCL_WRITABLE</b>; it indicates what type of event
occurred on this channel.</p>

<p style="margin-left:11%; margin-top: 1em">This value can
be retrieved with <b>Tcl_ChannelHandlerProc</b>, which
returns a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>THREADACTIONPROC</b>
<br>
The <i>threadActionProc</i> field contains the address of
the function called by the generic layer when a channel is
created, closed, or going to move to a different thread,
i.e. whenever thread-specific driver state might have to
initialized or updated. It can be NULL. The action
<i>TCL_CHANNEL_THREAD_REMOVE</i> is used to notify the
driver that it should update or remove any thread-specific
data it might be maintaining for the channel.</p>

<p style="margin-left:11%; margin-top: 1em">The action
<i>TCL_CHANNEL_THREAD_INSERT</i> is used to notify the
driver that it should update or initialize any
thread-specific data it might be maintaining using the
calling thread as the associate. See <b>Tcl_CutChannel</b>
and <b>Tcl_SpliceChannel</b> for more detail.</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_DriverThreadActionProc( <br>
ClientData <i>instanceData</i>, <br>
int <i>action</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when this channel was created.</p>

<p style="margin-left:11%; margin-top: 1em">These values
can be retrieved with <b>Tcl_ChannelThreadActionProc</b>,
which returns a pointer to the function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TRUNCATEPROC</b>
<br>
The <i>truncateProc</i> field contains the address of the
function called by the generic layer when a channel is
truncated to some length. It can be NULL.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_DriverTruncateProc( <br>
ClientData <i>instanceData</i>, <br>
Tcl_WideInt <i>length</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><i>InstanceData</i>
is the same as the value passed to <b>Tcl_CreateChannel</b>
when this channel was created, and <i>length</i> is the new
length of the underlying file, which should not be negative.
The result should be 0 on success or an errno code (suitable
for use with <b>Tcl_SetErrno</b>) on failure.</p>

<p style="margin-left:11%; margin-top: 1em">These values
can be retrieved with <b>Tcl_ChannelTruncateProc</b>, which
returns a pointer to the function.</p>

<h2>TCL_BADCHANNELOPTION
<a name="TCL_BADCHANNELOPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This procedure
generates a &ldquo;bad option&rdquo; error message in an
(optional) interpreter. It is used by channel drivers when
an invalid Set/Get option is requested. Its purpose is to
concatenate the generic options list to the specific ones
and factorize the generic options error message string.</p>

<p style="margin-left:11%; margin-top: 1em">It always
returns <b>TCL_ERROR</b></p>

<p style="margin-left:11%; margin-top: 1em">An error
message is generated in <i>interp</i>&rsquo;s result object
to indicate that a command was invoked with a bad option.
The message has the form</p>

<p style="margin-left:22%;">bad option &quot;blah&quot;:
should be one of <br>
&lt;...generic options...&gt;+&lt;...specific
options...&gt;</p>

<p style="margin-left:11%;">so you get for instance:</p>

<p style="margin-left:22%;">bad option &quot;-blah&quot;:
should be one of -blocking, <br>
-buffering, -buffersize, -eofchar, -translation, <br>
-peername, or -sockname</p>

<p style="margin-left:11%;">when called with
<i>optionList</i> equal to &ldquo;peername
sockname&rdquo;</p>


<p style="margin-left:11%; margin-top: 1em">&ldquo;blah&rdquo;
is the <i>optionName</i> argument and &ldquo;&lt;specific
options&gt;&rdquo; is a space separated list of specific
option words. The function takes good care of inserting
minus signs before each option, commas after, and an
&ldquo;or&rdquo; before the last option.</p>

<h2>OLD CHANNEL TYPES
<a name="OLD CHANNEL TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The original
(8.3.1 and below) <b>Tcl_ChannelType</b> structure contains
the following fields:</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
Tcl_ChannelType { <br>
char *<i>typeName</i>; <br>
Tcl_DriverBlockModeProc *<i>blockModeProc</i>; <br>
Tcl_DriverCloseProc *<i>closeProc</i>; <br>
Tcl_DriverInputProc *<i>inputProc</i>; <br>
Tcl_DriverOutputProc *<i>outputProc</i>; <br>
Tcl_DriverSeekProc *<i>seekProc</i>; <br>
Tcl_DriverSetOptionProc *<i>setOptionProc</i>; <br>
Tcl_DriverGetOptionProc *<i>getOptionProc</i>; <br>
Tcl_DriverWatchProc *<i>watchProc</i>; <br>
Tcl_DriverGetHandleProc *<i>getHandleProc</i>; <br>
Tcl_DriverClose2Proc *<i>close2Proc</i>; <br>
} Tcl_ChannelType;</p>

<p style="margin-left:11%; margin-top: 1em">It is still
possible to create channel with the above structure. The
internal channel code will determine the version. It is
imperative to use the new <b>Tcl_ChannelType</b> structure
if you are creating a stacked channel driver, due to
problems with the earlier stacked channel implementation (in
8.2.0 to 8.3.1).</p>

<p style="margin-left:11%; margin-top: 1em">Prior to 8.4.0
(i.e. during the later releases of 8.3 and early part of the
8.4 development cycle) the <b>Tcl_ChannelType</b> structure
contained the following fields:</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
Tcl_ChannelType { <br>
char *<i>typeName</i>; <br>
Tcl_ChannelTypeVersion <i>version</i>; <br>
Tcl_DriverCloseProc *<i>closeProc</i>; <br>
Tcl_DriverInputProc *<i>inputProc</i>; <br>
Tcl_DriverOutputProc *<i>outputProc</i>; <br>
Tcl_DriverSeekProc *<i>seekProc</i>; <br>
Tcl_DriverSetOptionProc *<i>setOptionProc</i>; <br>
Tcl_DriverGetOptionProc *<i>getOptionProc</i>; <br>
Tcl_DriverWatchProc *<i>watchProc</i>; <br>
Tcl_DriverGetHandleProc *<i>getHandleProc</i>; <br>
Tcl_DriverClose2Proc *<i>close2Proc</i>; <br>
Tcl_DriverBlockModeProc *<i>blockModeProc</i>; <br>
Tcl_DriverFlushProc *<i>flushProc</i>; <br>
Tcl_DriverHandlerProc *<i>handlerProc</i>; <br>
Tcl_DriverTruncateProc *<i>truncateProc</i>; <br>
} Tcl_ChannelType;</p>

<p style="margin-left:11%; margin-top: 1em">When the above
structure is registered as a channel type, the
<i>version</i> field should always be
<b>TCL_CHANNEL_VERSION_2</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl_Close(3),
Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3),
Tcl_StackChannel(3), Tcl_GetStdChannel(3)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">blocking,
channel driver, channel registration, channel type,
nonblocking</p>
<hr>
</body>
</html>
