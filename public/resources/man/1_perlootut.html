<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:20 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLOOTUT</title>

</head>
<body>

<h1 align="center">PERLOOTUT</h1>

<a href="#NAME">NAME</a><br>
<a href="#DATE">DATE</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OBJECT-ORIENTED FUNDAMENTALS">OBJECT-ORIENTED FUNDAMENTALS</a><br>
<a href="#PERL OO SYSTEMS">PERL OO SYSTEMS</a><br>
<a href="#CONCLUSION">CONCLUSION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlootut
&minus; Object&minus;Oriented Programming in Perl
Tutorial</p>

<h2>DATE
<a name="DATE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
was created in February, 2011.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
provides an introduction to object-oriented programming in
Perl. It begins with a brief overview of the concepts behind
object oriented design. Then it introduces several different
<small>OO</small> systems from <small>CPAN</small>
&lt;http://search.cpan.org&gt; which build on top of what
Perl provides.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Perl&rsquo;s built-in <small>OO</small> system is very
minimal, leaving you to do most of the work. This minimalism
made a lot of sense in 1994, but in the years since Perl 5.0
we&rsquo;ve seen a number of common patterns emerge in Perl
<small>OO</small> . Fortunately, Perl&rsquo;s flexibility
has allowed a rich ecosystem of Perl <small>OO</small>
systems to flourish.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
know how Perl <small>OO</small> works under the hood, the
perlobj document explains the nitty gritty details.</p>

<p style="margin-left:11%; margin-top: 1em">This document
assumes that you already understand the basics of Perl
syntax, variable types, operators, and subroutine calls. If
you don&rsquo;t understand these concepts yet, please read
perlintro first. You should also read the perlsyn, perlop,
and perlsub documents.</p>

<h2>OBJECT-ORIENTED FUNDAMENTALS
<a name="OBJECT-ORIENTED FUNDAMENTALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most object
systems share a number of common concepts. You&rsquo;ve
probably heard terms like &quot;class&quot;, &quot;object,
&quot;method&quot;, and &quot;attribute&quot; before.
Understanding the concepts will make it much easier to read
and write object-oriented code. If you&rsquo;re already
familiar with these terms, you should still skim this
section, since it explains each concept in terms of
Perl&rsquo;s <small>OO</small> implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
<small>OO</small> system is class-based. Class-based
<small>OO</small> is fairly common. It&rsquo;s used by Java,
C <small>++</small> , C#, Python, Ruby, and many other
languages. There are other object orientation paradigms as
well. JavaScript is the most popular language to use another
paradigm. JavaScript&rsquo;s <small>OO</small> system is
prototype-based.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Object</b>
<br>
An <b>object</b> is a data structure that bundles together
data and subroutines which operate on that data. An
object&rsquo;s data is called <b>attributes</b>, and its
subroutines are called <b>methods</b>. An object can be
thought of as a noun (a person, a web service, a
computer).</p>

<p style="margin-left:11%; margin-top: 1em">An object
represents a single discrete thing. For example, an object
might represent a file. The attributes for a file object
might include its path, content, and last modification time.
If we created an object to represent <i>/etc/hostname</i> on
a machine named &quot;foo.example.com&quot;, that
object&rsquo;s path would be &quot;/etc/hostname&quot;, its
content would be &quot;foo\n&quot;, and it&rsquo;s last
modification time would be 1304974868 seconds since the
beginning of the epoch.</p>

<p style="margin-left:11%; margin-top: 1em">The methods
associated with a file might include
<tt>&quot;rename()&quot;</tt> and
<tt>&quot;write()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl most
objects are hashes, but the <small>OO</small> systems we
recommend keep you from having to worry about this. In
practice, it&rsquo;s best to consider an object&rsquo;s
internal data structure opaque.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Class</b>
<br>
A <b>class</b> defines the behavior of a category of
objects. A class is a name for a category (like
&quot;File&quot;), and a class also defines the behavior of
objects in that category.</p>

<p style="margin-left:11%; margin-top: 1em">All objects
belong to a specific class. For example, our
<i>/etc/hostname</i> object belongs to the
<tt>&quot;File&quot;</tt> class. When we want to create a
specific object, we start with its class, and
<b>construct</b> or <b>instantiate</b> an object. A specific
object is often referred to as an <b>instance</b> of a
class.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl, any
package can be a class. The difference between a package
which is a class and one which isn&rsquo;t is based on how
the package is used. Here&rsquo;s our &quot;class
declaration&quot; for the <tt>&quot;File&quot;</tt>
class:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;</pre>


<p style="margin-left:11%; margin-top: 1em">In Perl, there
is no special keyword for constructing an object. However,
most <small>OO</small> modules on <small>CPAN</small> use a
method named <tt>&quot;new()&quot;</tt> to construct a new
object:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $hostname = File&minus;&gt;new(
      path          =&gt; '/etc/hostname',
      content       =&gt; &quot;foo\n&quot;,
      last_mod_time =&gt; 1304974868,
  );</pre>


<p style="margin-left:11%; margin-top: 1em">(Don&rsquo;t
worry about that <tt>&quot;&minus;&gt;&quot;</tt> operator,
it will be explained later.)</p>


<p style="margin-left:11%; margin-top: 1em"><i>Blessing</i></p>

<p style="margin-left:11%; margin-top: 1em">As we said
earlier, most Perl objects are hashes, but an object can be
an instance of any Perl data type (scalar, array, etc.).
Turning a plain data structure into an object is done by
<b>blessing</b> that data structure using Perl&rsquo;s
<tt>&quot;bless&quot;</tt> function.</p>

<p style="margin-left:11%; margin-top: 1em">While we
strongly suggest you don&rsquo;t build your objects from
scratch, you should know the term <b>bless</b>. A
<b>blessed</b> data structure (aka &quot;a referent&quot;)
is an object. We sometimes say that an object has been
&quot;blessed into a class&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Once a referent
has been blessed, the <tt>&quot;blessed&quot;</tt> function
from the Scalar::Util core module can tell us its class
name. This subroutine returns an object&rsquo;s class when
passed an object, and false otherwise.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Scalar::Util 'blessed';
  print blessed($hash);      # undef
  print blessed($hostname);  # File</pre>



<p style="margin-left:11%; margin-top: 1em"><i>Constructor</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<b>constructor</b> creates a new object. In Perl, a
class&rsquo;s constructor is just another method, unlike
some other languages, which provide syntax for constructors.
Most Perl classes use <tt>&quot;new&quot;</tt> as the name
for their constructor:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $file = File&minus;&gt;new(...);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Methods</b>
<br>
You already learned that a <b>method</b> is a subroutine
that operates on an object. You can think of a method as the
things that an object can <i>do</i>. If an object is a noun,
then methods are its verbs (save, print, open).</p>

<p style="margin-left:11%; margin-top: 1em">In Perl,
methods are simply subroutines that live in a class&rsquo;s
package. Methods are always written to receive the object as
their first argument:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub print_info {
      my $self = shift;
      print &quot;This file is at &quot;, $self&minus;&gt;path, &quot;\n&quot;;
  }
  $file&minus;&gt;print_info;
  # The file is at /etc/hostname</pre>


<p style="margin-left:11%; margin-top: 1em">What makes a
method special is <i>how it&rsquo;s called</i>. The arrow
operator (<tt>&quot;&minus;&gt;&quot;</tt>) tells Perl that
we are calling a method.</p>

<p style="margin-left:11%; margin-top: 1em">When we make a
method call, Perl arranges for the method&rsquo;s
<b>invocant</b> to be passed as the first argument.
<b>Invocant</b> is a fancy name for the thing on the left
side of the arrow. The invocant can either be a class name
or an object. We can also pass additional arguments to the
method:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub print_info {
      my $self   = shift;
      my $prefix = shift // &quot;This file is at &quot;;
      print $prefix, &quot;, &quot;, $self&minus;&gt;path, &quot;\n&quot;;
  }
  $file&minus;&gt;print_info(&quot;The file is located at &quot;);
  # The file is located at /etc/hostname</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Attributes</b>
<br>
Each class can define its <b>attributes</b>. When we
instantiate an object, we assign values to those attributes.
For example, every <tt>&quot;File&quot;</tt> object has a
path. Attributes are sometimes called <b>properties</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Perl has no
special syntax for attributes. Under the hood, attributes
are often stored as keys in the object&rsquo;s underlying
hash, but don&rsquo;t worry about this.</p>

<p style="margin-left:11%; margin-top: 1em">We recommend
that you only access attributes via <b>accessor</b> methods.
These are methods that can get or set the value of each
attribute. We saw this earlier in the
<tt>&quot;print_info()&quot;</tt> example, which calls
<tt>&quot;$self&minus;&gt;path&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">You might also
see the terms <b>getter</b> and <b>setter</b>. These are two
types of accessors. A getter gets the attribute&rsquo;s
value, while a setter sets it. Another term for a setter is
<b>mutator</b></p>

<p style="margin-left:11%; margin-top: 1em">Attributes are
typically defined as read-only or read-write. Read-only
attributes can only be set when the object is first created,
while read-write attributes can be altered at any time.</p>

<p style="margin-left:11%; margin-top: 1em">The value of an
attribute may itself be another object. For example, instead
of returning its last mod time as a number, the
<tt>&quot;File&quot;</tt> class could return a DateTime
object representing that value.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
possible to have a class that does not expose any publicly
settable attributes. Not every class has attributes and
methods.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Polymorphism
<br>
Polymorphism</b> is a fancy way of saying that objects from
two different classes share an <small>API</small> . For
example, we could have <tt>&quot;File&quot;</tt> and
<tt>&quot;WebPage&quot;</tt> classes which both have a
<tt>&quot;print_content()&quot;</tt> method. This method
might produce different output for each class, but they
share a common interface.</p>

<p style="margin-left:11%; margin-top: 1em">While the two
classes may differ in many ways, when it comes to the
<tt>&quot;print_content()&quot;</tt> method, they are the
same. This means that we can try to call the
<tt>&quot;print_content()&quot;</tt> method on an object of
either class, and <b>we don&rsquo;t have to know what class
the object belongs to!</b></p>

<p style="margin-left:11%; margin-top: 1em">Polymorphism is
one of the key concepts of object-oriented design.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Inheritance
<br>
Inheritance</b> lets you create a specialized version of an
existing class. Inheritance lets the new class to reuse the
methods and attributes of another class.</p>

<p style="margin-left:11%; margin-top: 1em">For example, we
could create an <tt>&quot;File::MP3&quot;</tt> class which
<b>inherits</b> from <tt>&quot;File&quot;</tt>. An
<tt>&quot;File::MP3&quot;</tt> <b>is-a</b> <i>more
specific</i> type of <tt>&quot;File&quot;</tt>. All mp3
files are files, but not all files are mp3 files.</p>

<p style="margin-left:11%; margin-top: 1em">We often refer
to inheritance relationships as <b>parent-child</b> or
<tt>&quot;superclass/subclass&quot;</tt> relationships.
Sometimes we say that the child has an <b>is-a</b>
relationship with its parent class.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;File&quot;</tt>
is a <b>superclass</b> of <tt>&quot;File::MP3&quot;</tt>,
and <tt>&quot;File::MP3&quot;</tt> is a <b>subclass</b> of
<tt>&quot;File&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">  package File::MP3;
  use parent 'File';</pre>


<p style="margin-left:11%; margin-top: 1em">The parent
module is one of several ways that Perl lets you define
inheritance relationships.</p>

<p style="margin-left:11%; margin-top: 1em">Perl allows
multiple inheritance, which means that a class can inherit
from multiple parents. While this is possible, we strongly
recommend against it. Generally, you can use <b>roles</b> to
do everything you can do with multiple inheritance, but in a
cleaner way.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
there&rsquo;s nothing wrong with defining multiple
subclasses of a given class. This is both common and safe.
For example, we might define
<tt>&quot;File::MP3::FixedBitrate&quot;</tt> and
<tt>&quot;File::MP3::VariableBitrate&quot;</tt> classes to
distinguish between different types of mp3 file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Overriding
methods and method resolution</i></p>

<p style="margin-left:11%; margin-top: 1em">Inheritance
allows two classes to share code. By default, every method
in the parent class is also available in the child. The
child can explicitly <b>override</b> a parent&rsquo;s method
to provide its own implementation. For example, if we have
an <tt>&quot;File::MP3&quot;</tt> object, it has the
<tt>&quot;print_info()&quot;</tt> method from
<tt>&quot;File&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $cage = File::MP3&minus;&gt;new(
      path          =&gt; 'mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3',
      content       =&gt; $mp3_data,
      last_mod_time =&gt; 1304974868,
      title         =&gt; 'My Body Is a Cage',
  );
  $cage&minus;&gt;print_info;
  # The file is at mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3</pre>


<p style="margin-left:11%; margin-top: 1em">If we wanted to
include the mp3&rsquo;s title in the greeting, we could
override the method:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File::MP3;
  use parent 'File';
  sub print_info {
      my $self = shift;
      print &quot;This file is at &quot;, $self&minus;&gt;path, &quot;\n&quot;;
      print &quot;Its title is &quot;, $self&minus;&gt;title, &quot;\n&quot;;
  }
  $cage&minus;&gt;print_info;
  # The file is at mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3
  # Its title is My Body Is a Cage</pre>


<p style="margin-left:11%; margin-top: 1em">The process of
determining what method should be used is called <b>method
resolution</b>. What Perl does is look at the object&rsquo;s
class first (<tt>&quot;File::MP3&quot;</tt> in this case).
If that class defines the method, then that class&rsquo;s
version of the method is called. If not, Perl looks at each
parent class in turn. For <tt>&quot;File::MP3&quot;</tt>,
its only parent is <tt>&quot;File&quot;</tt>. If
<tt>&quot;File::MP3&quot;</tt> does not define the method,
but <tt>&quot;File&quot;</tt> does, then Perl calls the
method in <tt>&quot;File&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;File&quot;</tt> inherited from
<tt>&quot;DataSource&quot;</tt>, which inherited from
<tt>&quot;Thing&quot;</tt>, then Perl would keep looking
&quot;up the chain&quot; if necessary.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to explicitly call a parent method from a child:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File::MP3;
  use parent 'File';
  sub print_info {
      my $self = shift;
      $self&minus;&gt;SUPER::print_info();
      print &quot;Its title is &quot;, $self&minus;&gt;title, &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;SUPER::&quot;</tt> bit tells Perl to look for the
<tt>&quot;print_info()&quot;</tt> in the
<tt>&quot;File::MP3&quot;</tt> class&rsquo;s inheritance
chain. When it finds the parent class that implements this
method, the method is called.</p>

<p style="margin-left:11%; margin-top: 1em">We mentioned
multiple inheritance earlier. The main problem with multiple
inheritance is that it greatly complicates method
resolution. See perlobj for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Encapsulation
<br>
Encapsulation</b> is the idea that an object is opaque. When
another developer uses your class, they don&rsquo;t need to
know <i>how</i> it is implemented, they just need to know
<i>what</i> it does.</p>

<p style="margin-left:11%; margin-top: 1em">Encapsulation
is important for several reasons. First, it allows you to
separate the public <small>API</small> from the private
implementation. This means you can change that
implementation without breaking the <small>API</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Second, when
classes are well encapsulated, they become easier to
subclass. Ideally, a subclass uses the same APIs to access
object data that its parent class uses. In reality,
subclassing sometimes involves violating encapsulation, but
a good <small>API</small> can minimize the need to do
this.</p>

<p style="margin-left:11%; margin-top: 1em">We mentioned
earlier that most Perl objects are implemented as hashes
under the hood. The principle of encapsulation tells us that
we should not rely on this. Instead, we should use accessor
methods to access the data in that hash. The object systems
that we recommend below all automate the generation of
accessor methods. If you use one of them, you should never
have to access the object as a hash directly.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Composition</b>
<br>
In object-oriented code, we often find that one object
references another object. This is called
<b>composition</b>, or a <b>has-a</b> relationship.</p>

<p style="margin-left:11%; margin-top: 1em">Earlier, we
mentioned that the <tt>&quot;File&quot;</tt> class&rsquo;s
<tt>&quot;last_mod_time&quot;</tt> accessor could return a
DateTime object. This is a perfect example of composition.
We could go even further, and make the
<tt>&quot;path&quot;</tt> and <tt>&quot;content&quot;</tt>
accessors return objects as well. The
<tt>&quot;File&quot;</tt> class would then be
<b>composed</b> of several other objects.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Roles <br>
Roles</b> are something that a class <i>does</i>, rather
than something that it <i>is</i>. Roles are relatively new
to Perl, but have become rather popular. Roles are
<b>applied</b> to classes. Sometimes we say that classes
<b>consume</b> roles.</p>

<p style="margin-left:11%; margin-top: 1em">Roles are an
alternative to inheritance for providing polymorphism.
Let&rsquo;s assume we have two classes,
<tt>&quot;Radio&quot;</tt> and
<tt>&quot;Computer&quot;</tt>. Both of these things have
on/off switches. We want to model that in our class
definitions.</p>

<p style="margin-left:11%; margin-top: 1em">We could have
both classes inherit from a common parent, like
<tt>&quot;Machine&quot;</tt>, but not all machines have
on/off switches. We could create a parent class called
<tt>&quot;HasOnOffSwitch&quot;</tt>, but that is very
artificial. Radios and computers are not specializations of
this parent. This parent is really a rather ridiculous
creation.</p>

<p style="margin-left:11%; margin-top: 1em">This is where
roles come in. It makes a lot of sense to create a
<tt>&quot;HasOnOffSwitch&quot;</tt> role and apply it to
both classes. This role would define a known
<small>API</small> like providing
<tt>&quot;turn_on()&quot;</tt> and
<tt>&quot;turn_off()&quot;</tt> methods.</p>

<p style="margin-left:11%; margin-top: 1em">Perl does not
have any built-in way to express roles. In the past, people
just bit the bullet and used multiple inheritance. Nowadays,
there are several good choices on <small>CPAN</small> for
using roles.</p>

<p style="margin-left:11%; margin-top: 1em"><b>When to Use
<small>OO</small></b> <br>
Object Orientation is not the best solution to every
problem. In <i>Perl Best Practices</i> (copyright 2004,
Published by O&rsquo;Reilly Media, Inc.), Damian Conway
provides a list of criteria to use when deciding if
<small>OO</small> is the right fit for your problem:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The system being designed is large, or is likely to
become large.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The data can be aggregated into obvious structures,
especially if there&rsquo;s a large amount of data in each
aggregate.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The various types of data aggregate form a natural
hierarchy that facilitates the use of inheritance and
polymorphism.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have a piece of data on which many different
operations are applied.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You need to perform the same general operations on
related types of data, but with slight variations depending
on the specific type of data the operations are applied
to.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>It&rsquo;s likely you&rsquo;ll have to add new data
types later.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The typical interactions between pieces of data are best
represented by operators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The implementation of individual components of the
system is likely to change over time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The system design is already object-oriented.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Large numbers of other programmers will be using your
code modules.</p></td></tr>
</table>

<h2>PERL OO SYSTEMS
<a name="PERL OO SYSTEMS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As we mentioned
before, Perl&rsquo;s built-in <small>OO</small> system is
very minimal, but also quite flexible. Over the years, many
people have developed systems which build on top of
Perl&rsquo;s built-in system to provide more features and
convenience.</p>

<p style="margin-left:11%; margin-top: 1em">We strongly
recommend that you use one of these systems. Even the most
minimal of them eliminates a lot of repetitive boilerplate.
There&rsquo;s really no good reason to write your classes
from scratch in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
interested in the guts underlying these systems, check out
perlobj.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Moose</b>
<br>
Moose bills itself as a &quot;postmodern object system for
Perl 5&quot;. Don&rsquo;t be scared, the
&quot;postmodern&quot; label is a callback to Larry&rsquo;s
description of Perl as &quot;the first postmodern computer
language&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
provides a complete, modern <small>OO</small> system. Its
biggest influence is the Common Lisp Object System, but it
also borrows ideas from Smalltalk and several other
languages. <tt>&quot;Moose&quot;</tt> was created by Stevan
Little, and draws heavily from his work on the Perl 6
<small>OO</small> design.</p>

<p style="margin-left:11%; margin-top: 1em">Here is our
<tt>&quot;File&quot;</tt> class using
<tt>&quot;Moose&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  use Moose;
  has path          =&gt; ( is =&gt; 'ro' );
  has content       =&gt; ( is =&gt; 'ro' );
  has last_mod_time =&gt; ( is =&gt; 'ro' );
  sub print_info {
      my $self = shift;
      print &quot;This file is at &quot;, $self&minus;&gt;path, &quot;\n&quot;;
  }</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Moose&quot;
provides a number of features:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em">Declarative sugar</p></td>
<td width="57%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
provides a layer of declarative &quot;sugar&quot; for
defining classes. That sugar is just a set of exported
functions that make declaring how your class works simpler
and more palatable. This lets you describe <i>what</i> your
class is, rather than having to tell Perl <i>how</i> to
implement your class.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;has()&quot;</tt> subroutine declares an attribute,
and <tt>&quot;Moose&quot;</tt> automatically creates
accessors for these attributes. It also takes care of
creating a <tt>&quot;new()&quot;</tt> method for you. This
constructor knows about the attributes you declared, so you
can set them when creating a new
<tt>&quot;File&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Roles built-in</p></td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
lets you define roles the same way you define classes:</p>

<pre style="margin-left:17%; margin-top: 1em">  package HasOnOfSwitch;
  use Moose::Role;
  has is_on =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );
  sub turn_on {
      my $self = shift;
      $self&minus;&gt;is_on(1);
  }
  sub turn_off {
      my $self = shift;
      $self&minus;&gt;is_on(0);
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">A miniature type system</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In the example
above, you can see that we passed <tt>&quot;isa =&gt;
'Bool'&quot;</tt> to <tt>&quot;has()&quot;</tt> when
creating our <tt>&quot;is_on&quot;</tt> attribute. This
tells <tt>&quot;Moose&quot;</tt> that this attribute must be
a boolean value. If we try to set it to an invalid value,
our code will throw an error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em">Full introspection and
manipulation</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Perl&rsquo;s
built-in introspection features are fairly minimal.
<tt>&quot;Moose&quot;</tt> builds on top of them and creates
a full introspection layer for your classes. This lets you
ask questions like &quot;what methods does the File class
implement?&quot; It also lets you modify your classes
programmatically.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">Self-hosted and extensible</p></td>
<td width="43%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
describes itself using its own introspection
<small>API</small> . Besides being a cool trick, this means
that you can extend <tt>&quot;Moose&quot;</tt> using
<tt>&quot;Moose&quot;</tt> itself.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Rich ecosystem</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">There is a rich
ecosystem of <tt>&quot;Moose&quot;</tt> extensions on
<small>CPAN</small> under the MooseX
&lt;http://search.cpan.org/search?query=MooseX&amp;mode=dist&gt;
namespace. In addition, many modules on <small>CPAN</small>
already use <tt>&quot;Moose&quot;</tt>, providing you with
lots of examples to learn from.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">Many more features</p></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
is a very powerful tool, and we can&rsquo;t cover all of its
features here. We encourage you to learn more by reading the
<tt>&quot;Moose&quot;</tt> documentation, starting with
Moose::Manual
&lt;http://search.cpan.org/perldoc?Moose::Manual&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Of course,
<tt>&quot;Moose&quot;</tt> isn&rsquo;t perfect.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
can make your code slower to load.
<tt>&quot;Moose&quot;</tt> itself is not small, and it does
a <i>lot</i> of code generation when you define your class.
This code generation means that your runtime code is as fast
as it can be, but you pay for this when your modules are
first loaded.</p>

<p style="margin-left:11%; margin-top: 1em">This load time
hit can be a problem when startup speed is important, such
as with a command-line script or a &quot;plain vanilla&quot;
<small>CGI</small> script that must be loaded each time it
is executed.</p>

<p style="margin-left:11%; margin-top: 1em">Before you
panic, know that many people do use
<tt>&quot;Moose&quot;</tt> for command-line tools and other
startup-sensitive code. We encourage you to try
<tt>&quot;Moose&quot;</tt> out first before worrying about
startup speed.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
also has several dependencies on other modules. Most of
these are small stand-alone modules, a number of which have
been spun off from <tt>&quot;Moose&quot;</tt>.
<tt>&quot;Moose&quot;</tt> itself, and some of its
dependencies, require a compiler. If you need to install
your software on a system without a compiler, or if having
<i>any</i> dependencies is a problem, then
<tt>&quot;Moose&quot;</tt> may not be right for you.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Mouse</i></p>

<p style="margin-left:11%; margin-top: 1em">If you try
<tt>&quot;Moose&quot;</tt> and find that one of these issues
is preventing you from using <tt>&quot;Moose&quot;</tt>, we
encourage you to consider Mouse next.
<tt>&quot;Mouse&quot;</tt> implements a subset of
<tt>&quot;Moose&quot;</tt>&rsquo;s functionality in a
simpler package. For all features that it does implement,
the end-user <small>API</small> is <i>identical</i> to
<tt>&quot;Moose&quot;</tt>, meaning you can switch from
<tt>&quot;Mouse&quot;</tt> to <tt>&quot;Moose&quot;</tt>
quite easily.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Mouse&quot;</tt>
does not implement most of
<tt>&quot;Moose&quot;</tt>&rsquo;s introspection
<small>API</small> , so it&rsquo;s often faster when loading
your modules. Additionally, all of its <i>required</i>
dependencies ship with the Perl core, and it can run without
a compiler. If you do have a compiler,
<tt>&quot;Mouse&quot;</tt> will use it to compile some of
its code for a speed boost.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, it
ships with a <tt>&quot;Mouse::Tiny&quot;</tt> module that
takes most of <tt>&quot;Mouse&quot;</tt>&rsquo;s features
and bundles them up in a single module file. You can copy
this module file into your application&rsquo;s library
directory for easy bundling.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;Moose&quot;</tt> authors hope that one day
<tt>&quot;Mouse&quot;</tt> can be made obsolete by improving
<tt>&quot;Moose&quot;</tt> enough, but for now it provides a
worthwhile alternative to <tt>&quot;Moose&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Class::Accessor</b>
<br>
Class::Accessor is the polar opposite of
<tt>&quot;Moose&quot;</tt>. It provides very few features,
nor is it self-hosting.</p>

<p style="margin-left:11%; margin-top: 1em">It is, however,
very simple, pure Perl, and it has no non-core dependencies.
It also provides a &quot;Moose-like&quot; <small>API</small>
on demand for the features it supports.</p>

<p style="margin-left:11%; margin-top: 1em">Even though it
doesn&rsquo;t do much, it is still preferable to writing
your own classes from scratch.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
our <tt>&quot;File&quot;</tt> class with
<tt>&quot;Class::Accessor&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  use Class::Accessor 'antlers';
  has path          =&gt; ( is =&gt; 'ro' );
  has content       =&gt; ( is =&gt; 'ro' );
  has last_mod_time =&gt; ( is =&gt; 'ro' );
  sub print_info {
      my $self = shift;
      print &quot;This file is at &quot;, $self&minus;&gt;path, &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;antlers&quot;</tt> import flag tells
<tt>&quot;Class::Accessor&quot;</tt> that you want to define
your attributes using <tt>&quot;Moose&quot;</tt>&minus;like
syntax. The only parameter that you can pass to
<tt>&quot;has&quot;</tt> is <tt>&quot;is&quot;</tt>. We
recommend that you use this Moose-like syntax if you choose
<tt>&quot;Class::Accessor&quot;</tt> since it means you will
have a smoother upgrade path if you later decide to move to
<tt>&quot;Moose&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Like
<tt>&quot;Moose&quot;</tt>,
<tt>&quot;Class::Accessor&quot;</tt> generates accessor
methods and a constructor for your class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Object::Tiny</b>
<br>
Finally, we have Object::Tiny. This module truly lives up to
its name. It has an incredibly minimal <small>API</small>
and absolutely no dependencies (core or not). Still, we
think it&rsquo;s a lot easier to use than writing your own
<small>OO</small> code from scratch.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
our <tt>&quot;File&quot;</tt> class once more:</p>

<pre style="margin-left:11%; margin-top: 1em">  package File;
  use Object::Tiny qw( path content last_mod_time );
  sub print_info {
      my $self = shift;
      print &quot;This file is at &quot;, $self&minus;&gt;path, &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
it!</p>

<p style="margin-left:11%; margin-top: 1em">With
<tt>&quot;Object::Tiny&quot;</tt>, all accessors are
read-only. It generates a constructor for you, as well as
the accessors you define.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Role::Tiny</b>
<br>
As we mentioned before, roles provide an alternative to
inheritance, but Perl does not have any built-in role
support. If you choose to use Moose, it comes with a
full-fledged role implementation. However, if you use one of
our other recommended <small>OO</small> modules, you can
still use roles with Role::Tiny</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Role::Tiny&quot;</tt>
provides some of the same features as Moose&rsquo;s role
system, but in a much smaller package. Most notably, it
doesn&rsquo;t support any sort of attribute declaration, so
you have to do that by hand. Still, it&rsquo;s useful, and
works well with <tt>&quot;Class::Accessor&quot;</tt> and
<tt>&quot;Object::Tiny&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b><small>OO</small>
System Summary</b> <br>
Here&rsquo;s a brief recap of the options we covered:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em">Moose</p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Moose&quot;</tt>
is the maximal option. It has a lot of features, a big
ecosystem, and a thriving user base. We also covered Mouse
briefly. <tt>&quot;Mouse&quot;</tt> is
<tt>&quot;Moose&quot;</tt> lite, and a reasonable
alternative when Moose doesn&rsquo;t work for your
application.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">Class::Accessor</p></td>
<td width="60%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Class::Accessor&quot;</tt>
does a lot less than <tt>&quot;Moose&quot;</tt>, and is a
nice alternative if you find <tt>&quot;Moose&quot;</tt>
overwhelming. It&rsquo;s been around a long time and is well
battle-tested. It also has a minimal
<tt>&quot;Moose&quot;</tt> compatibility mode which makes
moving from <tt>&quot;Class::Accessor&quot;</tt> to
<tt>&quot;Moose&quot;</tt> easy.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p style="margin-top: 1em">Object::Tiny</p></td>
<td width="65%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;Object::Tiny&quot;</tt>
is the absolute minimal option. It has no dependencies, and
almost no syntax to learn. It&rsquo;s a good option for a
super minimal environment and for throwing something
together quickly without having to worry about details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">Role::Tiny</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use
<tt>&quot;Role::Tiny&quot;</tt> with
<tt>&quot;Class::Accessor&quot;</tt> or
<tt>&quot;Object::Tiny&quot;</tt> if you find yourself
considering multiple inheritance. If you go with
<tt>&quot;Moose&quot;</tt>, it comes with its own role
implementation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
<small>OO</small> Systems</b> <br>
There are literally dozens of other OO-related modules on
<small>CPAN</small> besides those covered here, and
you&rsquo;re likely to run across one or more of them if you
work with other people&rsquo;s code.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
plenty of code in the wild does all of its <small>OO</small>
&quot;by hand&quot;, using just the Perl built-in
<small>OO</small> features. If you need to maintain such
code, you should read perlobj to understand exactly how
Perl&rsquo;s built-in <small>OO</small> works.</p>

<h2>CONCLUSION
<a name="CONCLUSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As we said
before, Perl&rsquo;s minimal <small>OO</small> system has
led to a profusion of <small>OO</small> systems on
<small>CPAN</small> . While you can still drop down to the
bare metal and write your classes by hand, there&rsquo;s
really no reason to do that with modern Perl.</p>

<p style="margin-left:11%; margin-top: 1em">For small
systems, Object::Tiny and Class::Accessor both provide
minimal object systems that take care of basic boilerplate
for you.</p>

<p style="margin-left:11%; margin-top: 1em">For bigger
projects, Moose provides a rich set of features that will
let you focus on implementing your business logic.</p>

<p style="margin-left:11%; margin-top: 1em">We encourage
you to play with and evaluate Moose, Class::Accessor, and
Object::Tiny to see which <small>OO</small> system is right
for you.</p>
<hr>
</body>
</html>
