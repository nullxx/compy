<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:06:17 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XkbApplyCompatMapToKey</title>

</head>
<body>

<h1 align="center">XkbApplyCompatMapToKey</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XkbApplyCompatMapToKey
&minus; Apply the new compatibility mapping to an individual
key to get its semantics updated</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p style="margin-top: 1em"><b>Bool
XkbApplyCompatMapToKey</b></p> </td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><b>(XkbDescPtr</b>
<i>xkb</i><b>, KeyCode</b> <i>key</i><b>,
XkbChangesPtr</b></p> </td></tr>
</table>

<p style="margin-left:11%;"><i>changes</i><b>);</b></p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b><i>&minus; xkb</i></b></p></td>
<td width="4%"></td>
<td width="52%">


<p style="margin-top: 1em">keyboard description to be
updated</p> </td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>&minus; key</i></p></td>
<td width="4%"></td>
<td width="52%">


<p>key to be updated</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%;"><i>&minus; changes</i></p>

<p style="margin-left:22%;">notes changes to the Xkb
keyboard description</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>XkbApplyCompatMapToKey</i>
essentially performs the operation described in Core
Keyboard Mapping to Xkb Keyboard Mapping Transformation to a
specific key. This updates the behavior, actions, repeat
status, and virtual modifier bindings of the key.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Core
Keyboard Mapping to Xkb Keyboard Mapping
Transformation</b></p>

<p style="margin-left:11%; margin-top: 1em">When a core
protocol keyboard mapping request is received by the server,
the server&rsquo;s core keyboard map is updated, and then
the Xkb map maintained by the server is updated. Because a
client may have explicitly configured some of the Xkb
keyboard mapping in the server, this automatic regeneration
of the Xkb keyboard mapping from the core protocol keyboard
mapping should not modify any components of the Xkb keyboard
mapping that were explicitly set by a client. The client
must set explicit override controls to prevent this from
happening (see Explicit Components-Avoiding Automatic
Remapping by the Server). The core-to-Xkb mapping is done as
follows:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Explicit
Components-Avoiding Automatic Remapping by the
Server</b></p>

<p style="margin-left:11%; margin-top: 1em">Whenever a
client remaps the keyboard using core protocol requests, Xkb
examines the map to determine likely default values for the
components that cannot be specified using the core
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">This automatic
remapping might replace definitions explicitly requested by
an application, so the Xkb keyboard description defines an
explicit components mask for each key. Any aspects of the
automatic remapping listed in the explicit components mask
for a key are not changed by the automatic keyboard
mapping.</p>

<p style="margin-left:11%; margin-top: 1em">The explicit
components masks are held in the <i>explicit</i> field of
the server map, which is an array indexed by keycode. Each
entry in this array is a mask that is a bitwise inclusive OR
of the values shown in Table 1.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Map the symbols from the keys in
the core keyboard map to groups and symbols on keys in the
Xkb keyboard map. The core keyboard mapping is of fixed
width, so each key in the core mapping has the same number
of symbols associated with it. The Xkb mapping allows a
different number of symbols to be associated with each key;
those symbols may be divided into a different number of
groups (1-4) for each key. For each key, this process
therefore involves partitioning the fixed number of symbols
from the core mapping into a set of variable-length groups
with a variable number of symbols in each group. For
example, if the core protocol map is of width five, the
partition for one key might result in one group with two
symbols and another with three symbols. A different key
might result in two groups with two symbols plus a third
group with one symbol. The core protocol map requires at
least two symbols in each of the first two groups.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>1a.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each changed key, determine the number of groups
represented in the new core keyboard map. This results in a
tentative group count for each key in the Xkb map.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>1b.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each changed key, determine the number of symbols in
each of the groups found in step 1a. There is one explicit
override control associated with each of the four possible
groups for each Xkb key, ExplicitKeyType1 through
ExplicitKeyType4. If no explicit override control is set for
a group, the number of symbols used for that group from the
core map is two. If the explicit override control is set for
a group on the key, the number of symbols used for that Xkb
group from the core map is the width of the Xkb group with
one exception: because of the core protocol requirement for
at least two symbols in each of groups one and two, the
number of symbols used for groups one and two is the maximum
of 2 or the width of the Xkb group.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>1c.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each changed key, assign the symbols in the core map
to the appropriate group on the key. If the total number of
symbols required by the Xkb map for a particular key needs
more symbols than the core protocol map contains, the
additional symbols are taken to be NoSymbol keysyms appended
to the end of the core set. If the core map contains more
symbols than are needed by the Xkb map, trailing symbols in
the core map are discarded. In the absence of an explicit
override for group one or two, symbols are assigned in order
by group; the first symbols in the core map are assigned to
group one, in order, followed by group two, and so on. For
example, if the core map contained eight symbols per key,
and a particular Xkb map contained 2 symbols for G1 and G2
and three for G3, the symbols would be assigned as (G is
group, L is shift level):</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">G1L1 G1L2 G2L1
G2L2 G3L1 G3L2 G3L3</p>

<p style="margin-left:17%; margin-top: 1em">If an explicit
override control is set for group one or two, the symbols
are taken from the core set in a somewhat different order.
The first four symbols from the core set are assigned to
G1L1, G1L2, G2L1, G2L2, respectively. If group one requires
more symbols, they are taken next, and then any additional
symbols needed by group two. Group three and four symbols
are taken in complete sequence after group two. For example,
a key with four groups and three symbols in each group would
take symbols from the core set in the following order:</p>

<p style="margin-left:17%; margin-top: 1em">G1L1 G1L2 G2L1
G2L2 G1L3 G2L3 G3L1 G3L2 G3L3 G4L1 G4L2 G4L3</p>

<p style="margin-left:17%; margin-top: 1em">As previously
noted, the core protocol map requires at lease two symbols
in groups one and two. Because of this, if an explicit
override control for an Xkb key is set and group one and /
or group two is of width one, it is not possible to generate
the symbols taken from the core protocol set and assigned to
position G1L2 and / or G2L2.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">1d.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">For each group on each changed
key, assign a key type appropriate for the symbols in the
group.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>1e.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each changed key, remove any empty or redundant
groups.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">At this point,
the groups and their associated symbols have been assigned
to the corresponding key definitions in the Xkb map.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">2.</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Apply symbol interpretations to
modify key operation. This phase is completely skipped if
the ExplicitInterpret override control bit is set in the
explicit controls mask for the Xkb key (see Explicit
Components-Avoiding Automatic Remapping by the Server).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>2a.</p></td>
<td width="2%"></td>
<td width="83%">


<p>For each symbol on each changed key, attempt to match
the symbol and modifiers from the Xkb map to a symbol
interpretation describing how to generate the symbol.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>2b.</p></td>
<td width="2%"></td>
<td width="83%">


<p>When a match is found in step 2a, apply the symbol
interpretation to change the semantics associated with the
symbol in the Xkb key map. If no match is found, apply a
default interpretation.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The symbol
interpretations used in step 2 are configurable and may be
specified using XkbSymInterpretRec structures referenced by
the sym_interpret field of an XkbCompatMapRec.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Symbol
Interpretations - the XkbSymInterpretRec Structure</b></p>

<p style="margin-left:11%; margin-top: 1em">Symbol
interpretations are used to guide the X server when it
modifies the Xkb keymap in step 2. An initial set of symbol
interpretations is loaded by the server when it starts. A
client may add new ones using XkbSetCompatMap.</p>

<p style="margin-left:11%; margin-top: 1em">Symbol
interpretations result in key semantics being set. When a
symbol interpretation is applied, the following components
of server key event processing may be modified for the
particular key involved:</p>

<p style="margin-left:11%; margin-top: 1em">Virtual
modifier map <br>
Auto repeat <br>
Key behavior (may be set to XkbKB_Lock) <br>
Key action</p>

<p style="margin-left:11%; margin-top: 1em">The
XkbSymInterpretRec structure specifies a symbol
interpretation:</p>

<p style="margin-left:11%; margin-top: 1em">typedef struct
{ <br>
KeySym sym; /&lowast; keysym of interest or NULL */ <br>
unsigned char flags; /&lowast; XkbSI_AutoRepeat,
XkbSI_LockingKey */ <br>
unsigned char match; /&lowast; specifies how mods is
interpreted */ <br>
unsigned char mods; /&lowast; modifier bits, correspond to
eight real modifiers */ <br>
unsigned char virtual_mod; /&lowast; 1 modifier to add to
key virtual mod map */ <br>
XkbAnyAction act; /&lowast; action to bind to symbol
position on key */ <br>
} XkbSymInterpretRec,*XkbSymInterpretPtr;</p>

<p style="margin-left:11%; margin-top: 1em">If sym is not
NULL, it limits the symbol interpretation to keys on which
that particular keysym is selected by the modifiers matching
the criteria specified by <i>mods</i> and <i>match.</i> If
<i>sym</i> is NULL, the interpretation may be applied to any
symbol selected on a key when the modifiers match the
criteria specified by <i>mods</i> and <i>match.</i></p>

<p style="margin-left:11%; margin-top: 1em"><i>match</i>
must be one of the values shown in Table 2 and specifies how
the real modifiers specified in <i>mods</i> are to be
interpreted.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the above bits, <i>match</i> may contain the
XkbSI_LevelOneOnly bit, in which case the modifier match
criteria specified by <i>mods</i> and <i>match</i> applies
only if <i>sym</i> is in level one of its group; otherwise,
<i>mods</i> and <i>match</i> are ignored and the symbol
matches a condition where no modifiers are set.</p>

<p style="margin-left:11%; margin-top: 1em">#define
XkbSI_LevelOneOnly (0x80) /&lowast; use mods + match only if
sym is level 1 */</p>

<p style="margin-left:11%; margin-top: 1em">If no matching
symbol interpretation is found, the server uses a default
interpretation where:</p>

<p style="margin-left:11%; margin-top: 1em">sym = 0 <br>
flags = XkbSI_AutoRepeat <br>
match = XkbSI_AnyOfOrNone <br>
mods = 0 <br>
virtual_mod = XkbNoModifier <br>
act = SA_NoAction</p>

<p style="margin-left:11%; margin-top: 1em">When a matching
symbol interpretation is found in step 2a, the
interpretation is applied to modify the Xkb map as
follows.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>act</i>
field specifies a single action to be bound to the symbol
position; any key event that selects the symbol causes the
action to be taken. Valid actions are defined in Key
Actions.</p>

<p style="margin-left:11%; margin-top: 1em">If the Xkb
keyboard map for the key does not have its ExplicitVModMap
control set, the XkbSI_LevelOneOnly bit and symbol position
are examined. If the XkbSI_LevelOneOnly bit is not set in
<i>match</i> or the symbol is in position G1L1, the
<i>virtual_mod</i> field is examined. If <i>virtual_mod</i>
is not XkbNoModifier, <i>virtual_mod</i> specifies a single
virtual modifier to be added to the virtual modifier map for
the key. <i>virtual_mod</i> is specified as an index in the
range [0..15].</p>

<p style="margin-left:11%; margin-top: 1em">If the matching
symbol is in position G1L1 of the key, two bits in the flags
field potentially specify additional behavior
modifications:</p>

<p style="margin-left:11%; margin-top: 1em">#define
XkbSI_AutoRepeat (1&lt;&lt;0) /&lowast; key repeats if sym
is in position G1L1 */ <br>
#define XkbSI_LockingKey (1&lt;&lt;1) /&lowast; set KB_Lock
behavior if sym is in psn G1L1 */</p>

<p style="margin-left:11%; margin-top: 1em">If the Xkb
keyboard map for the key does not have its
ExplicitAutoRepeat control set, its auto repeat behavior is
set based on the value of the XkbSI_AutoRepeat bit. If the
XkbSI_AutoRepeat bit is set, the auto-repeat behavior of the
key is turned on; otherwise, it is turned off.</p>

<p style="margin-left:11%; margin-top: 1em">If the Xkb
keyboard map for the key does not have its ExplicitBehavior
control set, its locking behavior is set based on the value
of the XkbSI_LockingKey bit. If XkbSI_LockingKey is set, the
key behavior is set to KB_Lock; otherwise, it is turned
off.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XkbKeyAction</b>(3),
<b>XkbKeyActionEntry</b>(3), <b>XkbKeyActionsPtr</b>(3),
<b>XkbKeyHasActions</b>(3), <b>XkbKeyNumActions</b>(3)</p>
<hr>
</body>
</html>
