<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:59:34 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLUNICODE</title>

</head>
<body>

<h1 align="center">PERLUNICODE</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlunicode
&minus; Unicode support in Perl</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Important
Caveats</b> <br>
Unicode support is an extensive requirement. While Perl does
not implement the Unicode standard or the accompanying
technical reports from cover to cover, Perl does support
many Unicode features.</p>

<p style="margin-left:11%; margin-top: 1em">People who want
to learn to use Unicode in Perl, should probably read the
Perl Unicode tutorial, perlunitut and perluniintro, before
reading this reference document.</p>

<p style="margin-left:11%; margin-top: 1em">Also, the use
of Unicode may present security issues that aren&rsquo;t
obvious. Read Unicode Security Considerations
&lt;http://www.unicode.org/reports/tr36&gt;. <br>
Safest if you &quot;use feature
&rsquo;unicode_strings&rsquo;&quot;</p>

<p style="margin-left:17%;">In order to preserve backward
compatibility, Perl does not turn on full internal Unicode
support unless the pragma <tt>&quot;use feature
'unicode_strings'&quot;</tt> is specified. (This is
automatically selected if you use <tt>&quot;use
5.012&quot;</tt> or higher.) Failure to do this can trigger
unexpected surprises. See &quot;The &quot;Unicode
Bug&quot;&quot; below.</p>

<p style="margin-left:17%; margin-top: 1em">This pragma
doesn&rsquo;t affect I/O, and there are still several places
where Unicode isn&rsquo;t fully supported, such as in
filenames.</p>

<p style="margin-left:11%;">Input and Output Layers</p>

<p style="margin-left:17%;">Perl knows when a filehandle
uses Perl&rsquo;s internal Unicode encodings (
<small>UTF&minus;8</small> , or UTF-EBCDIC if in
<small>EBCDIC</small> ) if the filehandle is opened with the
&quot;:encoding(utf8)&quot; layer. Other encodings can be
converted to Perl&rsquo;s encoding on input or from
Perl&rsquo;s encoding on output by use of the
&quot;:encoding(...)&quot; layer. See open.</p>

<p style="margin-left:17%; margin-top: 1em">To indicate
that Perl source itself is in <small>UTF&minus;8</small> ,
use <tt>&quot;use utf8;&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;use utf8&quot; still
needed to enable <small>UTF&minus;8/UTF&minus;EBCDIC</small>
in scripts</p>

<p style="margin-left:17%;">As a compatibility measure, the
<tt>&quot;use utf8&quot;</tt> pragma must be explicitly
included to enable recognition of <small>UTF&minus;8</small>
in the Perl scripts themselves (in string or regular
expression literals, or in identifier names) on ASCII-based
machines or to recognize UTF-EBCDIC on EBCDIC-based
machines. <b>These are the only times when an explicit
&quot;use utf8&quot; is needed.</b> See utf8.</p>

<p style="margin-left:11%;">BOM-marked scripts and
<small>UTF&minus;16</small> scripts autodetected</p>

<p style="margin-left:17%;">If a Perl script begins marked
with the Unicode <small>BOM</small> (
<small>UTF&minus;16LE</small> ,
<small>UTF16&minus;BE</small> , or
<small>UTF&minus;8</small> ), or if the script looks like
non-BOM-marked <small>UTF&minus;16</small> of either
endianness, Perl will correctly read in the script as
Unicode. (BOMless <small>UTF&minus;8</small> cannot be
effectively recognized or differentiated from
<small>ISO</small> 8859&minus;1 or other eight-bit
encodings.)</p>

<p style="margin-left:11%;">&quot;use encoding&quot; needed
to upgrade non&minus;Latin&minus;1 byte strings</p>

<p style="margin-left:17%;">By default, there is a
fundamental asymmetry in Perl&rsquo;s Unicode model:
implicit upgrading from byte strings to Unicode strings
assumes that they were encoded in <i><small>ISO</small>
8859&minus;1 (Latin&minus;1)</i>, but Unicode strings are
downgraded with <small>UTF&minus;8</small> encoding. This
happens because the first 256 codepoints in Unicode happens
to agree with Latin&minus;1.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;Byte
and Character Semantics&quot; for more details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Byte and
Character Semantics</b> <br>
Beginning with version 5.6, Perl uses logically-wide
characters to represent strings internally.</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
Perl 5.14, Perl-level operations work with characters rather
than bytes within the scope of a <tt>&quot;use feature
'unicode_strings'&quot;</tt> (or equivalently <tt>&quot;use
5.012&quot;</tt> or higher). (This is not true if bytes have
been explicitly requested by <tt>&quot;use bytes&quot;</tt>,
nor necessarily true for interactions with the
platform&rsquo;s operating system.)</p>

<p style="margin-left:11%; margin-top: 1em">For earlier
Perls, and when <tt>&quot;unicode_strings&quot;</tt> is not
in effect, Perl provides a fairly safe environment that can
handle both types of semantics in programs. For operations
where Perl can unambiguously decide that the input data are
characters, Perl switches to character semantics. For
operations where this determination cannot be made without
additional information from the user, Perl decides in favor
of compatibility and chooses to use byte semantics.</p>

<p style="margin-left:11%; margin-top: 1em">When
<tt>&quot;use locale&quot;</tt> (but not <tt>&quot;use
locale ':not_characters'&quot;</tt>) is in effect, Perl uses
the semantics associated with the current locale.
(<tt>&quot;use locale&quot;</tt> overrides <tt>&quot;use
feature 'unicode_strings'&quot;</tt> in the same scope;
while <tt>&quot;use locale ':not_characters'&quot;</tt>
effectively also selects <tt>&quot;use feature
'unicode_strings'&quot;</tt> in its scope; see perllocale.)
Otherwise, Perl uses the platform&rsquo;s native byte
semantics for characters whose code points are less than
256, and Unicode semantics for those greater than 255. On
<small>EBCDIC</small> platforms, this is almost seamless, as
the <small>EBCDIC</small> code pages that Perl handles are
equivalent to Unicode&rsquo;s first 256 code points. (The
exception is that <small>EBCDIC</small> regular expression
case-insensitive matching rules are not as as robust as
Unicode&rsquo;s.) But on <small>ASCII</small> platforms,
Perl uses US-ASCII (or Basic Latin in Unicode terminology)
byte semantics, meaning that characters whose ordinal
numbers are in the range 128 &minus; 255 are undefined
except for their ordinal numbers. This means that none have
case (upper and lower), nor are any a member of character
classes, like <tt>&quot;[:alpha:]&quot;</tt> or
<tt>&quot;\w&quot;</tt>. (But all do belong to the
<tt>&quot;\W&quot;</tt> class or the Perl regular expression
extension <tt>&quot;[:^alpha:]&quot;</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">This behavior
preserves compatibility with earlier versions of Perl, which
allowed byte semantics in Perl operations only if none of
the program&rsquo;s inputs were marked as being a source of
Unicode character data. Such data may come from filehandles,
from calls to external programs, from information provided
by the system (such as <tt>%ENV</tt>), or from literals and
constants in the source text.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;utf8&quot;</tt> pragma is primarily a
compatibility device that enables recognition of
<small>UTF&minus;</small> (8|EBCDIC) in literals encountered
by the parser. Note that this pragma is only required while
Perl defaults to byte semantics; when character semantics
become the default, this pragma may become a no-op. See
utf8.</p>

<p style="margin-left:11%; margin-top: 1em">If strings
operating under byte semantics and strings with Unicode
character data are concatenated, the new string will have
character semantics. This can cause surprises: See &quot;
<small>BUGS</small> &quot;, below. You can choose to be
warned when this happens. See encoding::warnings.</p>

<p style="margin-left:11%; margin-top: 1em">Under character
semantics, many operations that formerly operated on bytes
now operate on characters. A character in Perl is logically
just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes
internally, but this internal detail is mostly hidden for
Perl code. See perluniintro for more.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Effects of
Character Semantics</b> <br>
Character semantics have the following effects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Strings--including hash keys--and regular expression
patterns may contain characters that have an ordinal value
larger than 255.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If you use a
Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in
<small>UTF&minus;8</small> encoding, or
<small>UTF&minus;16</small> . (The former requires a
<small>BOM</small> or <tt>&quot;use utf8&quot;</tt>, the
latter requires a <small>BOM</small> .)</p>

<p style="margin-left:17%; margin-top: 1em">Unicode
characters can also be added to a string by using the
<tt>&quot;\N{U+...}&quot;</tt> notation. The Unicode code
for the desired character, in hexadecimal, should be placed
in the braces, after the <tt>&quot;U&quot;</tt>. For
instance, a smiley face is
<tt>&quot;\N{U+263A}&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Alternatively,
you can use the <tt>&quot;\x{...}&quot;</tt> notation for
characters 0x100 and above. For characters below 0x100 you
may get byte semantics instead of character semantics; see
&quot;The &quot;Unicode Bug&quot;&quot;. On
<small>EBCDIC</small> machines there is the additional
problem that the value for such characters gives the
<small>EBCDIC</small> character rather than the Unicode one,
thus it is more portable to use
<tt>&quot;\N{U+...}&quot;</tt> instead.</p>

<p style="margin-left:17%; margin-top: 1em">Additionally,
you can use the <tt>&quot;\N{...}&quot;</tt> notation and
put the official Unicode character name within the braces,
such as <tt>&quot;\N{WHITE SMILING FACE}&quot;</tt>. This
automatically loads the charnames module with the
<tt>&quot;:full&quot;</tt> and <tt>&quot;:short&quot;</tt>
options. If you prefer different options for this module,
you can instead, before the <tt>&quot;\N{...}&quot;</tt>,
explicitly load it with your desired options; for
example,</p>

<pre style="margin-left:17%; margin-top: 1em">   use charnames ':loose';</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If an appropriate encoding is
specified, identifiers within the Perl script may contain
Unicode alphanumeric characters, including ideographs. Perl
does not currently attempt to canonicalize variable
names.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Regular expressions match characters instead of bytes.
&quot;.&quot; matches a character instead of a byte.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Bracketed character classes in regular expressions match
characters instead of bytes and match against the character
properties specified in the Unicode properties database.
<tt>&quot;\w&quot;</tt> can be used to match a Japanese
ideograph, for instance.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Named Unicode properties, scripts, and block ranges may
be used (like bracketed character classes) by using the
<tt>&quot;\p{}&quot;</tt> &quot;matches property&quot;
construct and the <tt>&quot;\P{}&quot;</tt> negation,
&quot;doesn&rsquo;t match property&quot;. See &quot;Unicode
Character Properties&quot; for more details.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You can define
your own character properties and use them in the regular
expression with the <tt>&quot;\p{}&quot;</tt> or
<tt>&quot;\P{}&quot;</tt> construct. See &quot;User-Defined
Character Properties&quot; for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The special pattern
<tt>&quot;\X&quot;</tt> matches a logical character, an
&quot;extended grapheme cluster&quot; in Standardese. In
Unicode what appears to the user to be a single character,
for example an accented <tt>&quot;G&quot;</tt>, may in fact
be composed of a sequence of characters, in this case a
<tt>&quot;G&quot;</tt> followed by an accent character.
<tt>&quot;\X&quot;</tt> will match the entire sequence.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <tt>&quot;tr///&quot;</tt> operator translates
characters instead of bytes. Note that the
<tt>&quot;tr///CU&quot;</tt> functionality has been removed.
For similar functionality see pack(&rsquo;U0&rsquo;, ...)
and pack(&rsquo;C0&rsquo;, ...).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Case translation operators use the Unicode case
translation tables when character input is provided. Note
that <tt>&quot;uc()&quot;</tt>, or <tt>&quot;\U&quot;</tt>
in interpolated strings, translates to uppercase, while
<tt>&quot;ucfirst&quot;</tt>, or <tt>&quot;\u&quot;</tt> in
interpolated strings, translates to titlecase in languages
that make the distinction (which is equivalent to uppercase
in languages without the distinction).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Most operators that deal with positions or lengths in a
string will automatically switch to using character
positions, including <tt>&quot;chop()&quot;</tt>,
<tt>&quot;chomp()&quot;</tt>, <tt>&quot;substr()&quot;</tt>,
<tt>&quot;pos()&quot;</tt>, <tt>&quot;index()&quot;</tt>,
<tt>&quot;rindex()&quot;</tt>,
<tt>&quot;sprintf()&quot;</tt>,
<tt>&quot;write()&quot;</tt>, and
<tt>&quot;length()&quot;</tt>. An operator that specifically
does not switch is <tt>&quot;vec()&quot;</tt>. Operators
that really don&rsquo;t care include operators that treat
strings as a bucket of bits such as
<tt>&quot;sort()&quot;</tt>, and operators dealing with
filenames.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The
<tt>&quot;pack()&quot;</tt>/<tt>&quot;unpack()&quot;</tt>
letter <tt>&quot;C&quot;</tt> does <i>not</i> change, since
it is often used for byte-oriented formats. Again, think
<tt>&quot;char&quot;</tt> in the C language.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">There is a new
<tt>&quot;U&quot;</tt> specifier that converts between
Unicode characters and code points. There is also a
<tt>&quot;W&quot;</tt> specifier that is the equivalent of
<tt>&quot;chr&quot;</tt>/<tt>&quot;ord&quot;</tt> and
properly handles character values even if they are above
255.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The <tt>&quot;chr()&quot;</tt>
and <tt>&quot;ord()&quot;</tt> functions work on characters,
similar to <tt>&quot;pack(&quot;W&quot;)&quot;</tt> and
<tt>&quot;unpack(&quot;W&quot;)&quot;</tt>, <i>not</i>
<tt>&quot;pack(&quot;C&quot;)&quot;</tt> and
<tt>&quot;unpack(&quot;C&quot;)&quot;</tt>.
<tt>&quot;pack(&quot;C&quot;)&quot;</tt> and
<tt>&quot;unpack(&quot;C&quot;)&quot;</tt> are methods for
emulating byte-oriented <tt>&quot;chr()&quot;</tt> and
<tt>&quot;ord()&quot;</tt> on Unicode strings. While these
methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at
all.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The bit string operators, <tt>&quot;&amp; | ^
~&quot;</tt>, can operate on character data. However, for
backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal
value, one should not use <tt>&quot;~&quot;</tt> (the bit
complement) with characters of both values less than 256 and
values greater than 256. Most importantly, DeMorgan&rsquo;s
laws (<tt>&quot;~($x|$y) eq ~$x&amp;~$y&quot;</tt> and
<tt>&quot;~($x&amp;$y) eq ~$x|~$y&quot;</tt>) will not hold.
The reason for this mathematical <i>faux pas</i> is that the
complement cannot return <b>both</b> the 8&minus;bit
(byte-wide) bit complement <b>and</b> the full
character-wide bit complement.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>There is a <small>CPAN</small> module, Unicode::Casing,
which allows you to define your own mappings to be used in
<tt>&quot;lc()&quot;</tt>, <tt>&quot;lcfirst()&quot;</tt>,
<tt>&quot;uc()&quot;</tt>, <tt>&quot;ucfirst()&quot;</tt>,
and <tt>&quot;fc&quot;</tt> (or their double-quoted string
inlined versions such as <tt>&quot;\U&quot;</tt>). (Prior to
Perl 5.16, this functionality was partially provided in the
Perl core, but suffered from a number of insurmountable
drawbacks, so the <small>CPAN</small> module was written
instead.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>And finally, <tt>&quot;scalar reverse()&quot;</tt>
reverses by character rather than by byte.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode
Character Properties</b> <br>
(The only time that Perl considers a sequence of individual
code points as a single logical character is in the
<tt>&quot;\X&quot;</tt> construct, already mentioned above.
Therefore &quot;character&quot; in this discussion means a
single Unicode code point.)</p>

<p style="margin-left:11%; margin-top: 1em">Very nearly all
Unicode character properties are accessible through regular
expressions by using the <tt>&quot;\p{}&quot;</tt>
&quot;matches property&quot; construct and the
<tt>&quot;\P{}&quot;</tt> &quot;doesn&rsquo;t match
property&quot; for its negation.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
<tt>&quot;\p{Uppercase}&quot;</tt> matches any single
character with the Unicode &quot;Uppercase&quot; property,
while <tt>&quot;\p{L}&quot;</tt> matches any character with
a General_Category of &quot;L&quot; (letter) property.
Brackets are not required for single letter property names,
so <tt>&quot;\p{L}&quot;</tt> is equivalent to
<tt>&quot;\pL&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">More formally,
<tt>&quot;\p{Uppercase}&quot;</tt> matches any single
character whose Unicode Uppercase property value is True,
and <tt>&quot;\P{Uppercase}&quot;</tt> matches any character
whose Uppercase property value is False, and they could have
been written as <tt>&quot;\p{Uppercase=True}&quot;</tt> and
<tt>&quot;\p{Uppercase=False}&quot;</tt>, respectively.</p>

<p style="margin-left:11%; margin-top: 1em">This formality
is needed when properties are not binary; that is, if they
can take on more values than just True and False. For
example, the Bidi_Class (see &quot;Bidirectional Character
Types&quot; below), can take on several different values,
such as Left, Right, Whitespace, and others. To match these,
one needs to specify both the property name (Bidi_Class),
<small>AND</small> the value being matched against (Left,
Right, etc.). This is done, as in the examples above, by
having the two components separated by an equal sign (or
interchangeably, a colon), like <tt>&quot;\p{Bidi_Class:
Left}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">All
Unicode-defined character properties may be written in these
compound forms of <tt>&quot;\p{property=value}&quot;</tt> or
<tt>&quot;\p{property:value}&quot;</tt>, but Perl provides
some additional properties that are written only in the
single form, as well as single-form short-cuts for all
binary properties and certain others described below, in
which you may omit the property name and the equals or colon
separator.</p>

<p style="margin-left:11%; margin-top: 1em">Most Unicode
character properties have at least two synonyms (or aliases
if you prefer): a short one that is easier to type and a
longer one that is more descriptive and hence easier to
understand. Thus the &quot;L&quot; and &quot;Letter&quot;
properties above are equivalent and can be used
interchangeably. Likewise, &quot;Upper&quot; is a synonym
for &quot;Uppercase&quot;, and we could have written
<tt>&quot;\p{Uppercase}&quot;</tt> equivalently as
<tt>&quot;\p{Upper}&quot;</tt>. Also, there are typically
various synonyms for the values the property can be. For
binary properties, &quot;True&quot; has 3 synonyms:
&quot;T&quot;, &quot;Yes&quot;, and &quot;Y&quot;; and
&quot;False has correspondingly &quot;F&quot;,
&quot;No&quot;, and &quot;N&quot;. But be careful. A short
form of a value for one property may not mean the same thing
as the same short form for another. Thus, for the
General_Category property, &quot;L&quot; means
&quot;Letter&quot;, but for the Bidi_Class property,
&quot;L&quot; means &quot;Left&quot;. A complete list of
properties and synonyms is in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em">Upper/lower
case differences in property names and values are
irrelevant; thus <tt>&quot;\p{Upper}&quot;</tt> means the
same thing as <tt>&quot;\p{upper}&quot;</tt> or even
<tt>&quot;\p{UpPeR}&quot;</tt>. Similarly, you can add or
subtract underscores anywhere in the middle of a word, so
that these are also equivalent to
<tt>&quot;\p{U_p_p_e_r}&quot;</tt>. And white space is
irrelevant adjacent to non-word characters, such as the
braces and the equals or colon separators, so <tt>&quot;\p{
Upper }&quot;</tt> and <tt>&quot;\p{ Upper_case : Y
}&quot;</tt> are equivalent to these as well. In fact, white
space and even hyphens can usually be added or deleted
anywhere. So even <tt>&quot;\p{ Up&minus;per case =
Yes}&quot;</tt> is equivalent. All this is called
&quot;loose-matching&quot; by Unicode. The few places where
stricter matching is used is in the middle of numbers, and
in the Perl extension properties that begin or end with an
underscore. Stricter matching cares about white space
(except adjacent to non-word characters), hyphens, and
non-interior underscores.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use negation in both <tt>&quot;\p{}&quot;</tt> and
<tt>&quot;\P{}&quot;</tt> by introducing a caret (^) between
the first brace and the property name:
<tt>&quot;\p{^Tamil}&quot;</tt> is equal to
<tt>&quot;\P{Tamil}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Almost all
properties are immune to case-insensitive matching. That is,
adding a <tt>&quot;/i&quot;</tt> regular expression modifier
does not change what they match. There are two sets that are
affected. The first set is
<tt>&quot;Uppercase_Letter&quot;</tt>,
<tt>&quot;Lowercase_Letter&quot;</tt>, and
<tt>&quot;Titlecase_Letter&quot;</tt>, all of which match
<tt>&quot;Cased_Letter&quot;</tt> under
<tt>&quot;/i&quot;</tt> matching. And the second set is
<tt>&quot;Uppercase&quot;</tt>,
<tt>&quot;Lowercase&quot;</tt>, and
<tt>&quot;Titlecase&quot;</tt>, all of which match
<tt>&quot;Cased&quot;</tt> under <tt>&quot;/i&quot;</tt>
matching. This set also includes its subsets
<tt>&quot;PosixUpper&quot;</tt> and
<tt>&quot;PosixLower&quot;</tt> both of which under
<tt>&quot;/i&quot;</tt> matching match
<tt>&quot;PosixAlpha&quot;</tt>. (The difference between
these sets is that some things, such as Roman numerals, come
in both upper and lower case so they are
<tt>&quot;Cased&quot;</tt>, but aren&rsquo;t considered
letters, so they aren&rsquo;t
<tt>&quot;Cased_Letter&quot;</tt>s.)</p>

<p style="margin-left:11%; margin-top: 1em">The result is
undefined if you try to match a non-Unicode code point (that
is, one above 0x10FFFF) against a Unicode property.
Currently, a warning is raised, and the match will fail. In
some cases, this is counterintuitive, as both these
fail:</p>

<pre style="margin-left:11%; margin-top: 1em"> chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Fails!</pre>



<p style="margin-left:11%; margin-top: 1em"><b><i>General_Category</i></b></p>

<p style="margin-left:11%; margin-top: 1em">Every Unicode
character is assigned a general category, which is the
&quot;most usual categorization of a character&quot; (from
&lt;http://www.unicode.org/reports/tr44&gt;).</p>

<p style="margin-left:11%; margin-top: 1em">The compound
way of writing these is like
<tt>&quot;\p{General_Category=Number}&quot;</tt> (short,
<tt>&quot;\p{gc:n}&quot;</tt>). But Perl furnishes shortcuts
in which everything up through the equal or colon separator
is omitted. So you can instead just write
<tt>&quot;\pN&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Here are the
short and long forms of the General Category properties:</p>

<pre style="margin-left:11%; margin-top: 1em">    Short       Long
    L           Letter
    LC, L&amp;      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter
    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark
    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number
    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation
    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol
    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator
    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned</pre>


<p style="margin-left:11%; margin-top: 1em">Single-letter
properties match all characters in any of the two-letter
sub-properties starting with the same letter.
<tt>&quot;LC&quot;</tt> and <tt>&quot;L&amp;&quot;</tt> are
special: both are aliases for the set consisting of
everything matched by <tt>&quot;Ll&quot;</tt>,
<tt>&quot;Lu&quot;</tt>, and <tt>&quot;Lt&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>Bidirectional
Character Types</i></b></p>

<p style="margin-left:11%; margin-top: 1em">Because scripts
differ in their directionality (Hebrew and Arabic are
written right to left, for example) Unicode supplies these
properties in the Bidi_Class class:</p>

<pre style="margin-left:11%; margin-top: 1em">    Property    Meaning
    L           Left&minus;to&minus;Right
    LRE         Left&minus;to&minus;Right Embedding
    LRO         Left&minus;to&minus;Right Override
    R           Right&minus;to&minus;Left
    AL          Arabic Letter
    RLE         Right&minus;to&minus;Left Embedding
    RLO         Right&minus;to&minus;Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non&minus;Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals</pre>


<p style="margin-left:11%; margin-top: 1em">This property
is always written in the compound form. For example,
<tt>&quot;\p{Bidi_Class:R}&quot;</tt> matches characters
that are normally written right to left.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>Scripts</i></b></p>

<p style="margin-left:11%; margin-top: 1em">The
world&rsquo;s languages are written in many different
scripts. This sentence (unless you&rsquo;re reading it in
translation) is written in Latin, while Russian is written
in Cyrillic, and Greek is written in, well, Greek; Japanese
mainly in Hiragana or Katakana. There are many more.</p>

<p style="margin-left:11%; margin-top: 1em">The Unicode
Script and Script_Extensions properties give what script a
given character is in. Either property can be specified with
the compound form like
<tt>&quot;\p{Script=Hebrew}&quot;</tt> (short:
<tt>&quot;\p{sc=hebr}&quot;</tt>), or
<tt>&quot;\p{Script_Extensions=Javanese}&quot;</tt> (short:
<tt>&quot;\p{scx=java}&quot;</tt>). In addition, Perl
furnishes shortcuts for all <tt>&quot;Script&quot;</tt>
property names. You can omit everything up through the
equals (or colon), and simply write
<tt>&quot;\p{Latin}&quot;</tt> or
<tt>&quot;\P{Cyrillic}&quot;</tt>. (This is not true for
<tt>&quot;Script_Extensions&quot;</tt>, which is required to
be written in the compound form.)</p>

<p style="margin-left:11%; margin-top: 1em">The difference
between these two properties involves characters that are
used in multiple scripts. For example the digits
&rsquo;0&rsquo; through &rsquo;9&rsquo; are used in many
parts of the world. These are placed in a script named
<tt>&quot;Common&quot;</tt>. Other characters are used in
just a few scripts. For example, the &quot;KATAKANA-HIRAGANA
<small>DOUBLE HYPHEN</small> &quot; is used in both Japanese
scripts, Katakana and Hiragana, but nowhere else. The
<tt>&quot;Script&quot;</tt> property places all characters
that are used in multiple scripts in the
<tt>&quot;Common&quot;</tt> script, while the
<tt>&quot;Script_Extensions&quot;</tt> property places those
that are used in only a few scripts into each of those
scripts; while still using <tt>&quot;Common&quot;</tt> for
those used in many scripts. Thus both these match:</p>

<pre style="margin-left:11%; margin-top: 1em"> &quot;0&quot; =~ /\p{sc=Common}/     # Matches
 &quot;0&quot; =~ /\p{scx=Common}/    # Matches</pre>


<p style="margin-left:11%; margin-top: 1em">and only the
first of these match:</p>

<pre style="margin-left:11%; margin-top: 1em"> &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Common}  # Matches
 &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Common} # No match</pre>


<p style="margin-left:11%; margin-top: 1em">And only the
last two of these match:</p>

<pre style="margin-left:11%; margin-top: 1em"> &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Hiragana}  # No match
 &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Katakana}  # No match
 &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Hiragana} # Matches
 &quot;\N{KATAKANA&minus;HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Katakana} # Matches</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;Script_Extensions&quot;
is thus an improved <tt>&quot;Script&quot;</tt>, in which
there are fewer characters in the
<tt>&quot;Common&quot;</tt> script, and correspondingly more
in other scripts. It is new in Unicode version 6.0, and its
data are likely to change significantly in later releases,
as things get sorted out.</p>

<p style="margin-left:11%; margin-top: 1em">(Actually,
besides <tt>&quot;Common&quot;</tt>, the
<tt>&quot;Inherited&quot;</tt> script, contains characters
that are used in multiple scripts. These are modifier
characters which modify other characters, and inherit the
script value of the controlling character. Some of these are
used in many scripts, and so go into
<tt>&quot;Inherited&quot;</tt> in both
<tt>&quot;Script&quot;</tt> and
<tt>&quot;Script_Extensions&quot;</tt>. Others are used in
just a few scripts, so are in <tt>&quot;Inherited&quot;</tt>
in <tt>&quot;Script&quot;</tt>, but not in
<tt>&quot;Script_Extensions&quot;</tt>.)</p>

<p style="margin-left:11%; margin-top: 1em">It is worth
stressing that there are several different sets of digits in
Unicode that are equivalent to 0&minus;9 and are matchable
by <tt>&quot;\d&quot;</tt> in a regular expression. If they
are used in a single language only, they are in that
language&rsquo;s <tt>&quot;Script&quot;</tt> and
<tt>&quot;Script_Extension&quot;</tt>. If they are used in
more than one script, they will be in
<tt>&quot;sc=Common&quot;</tt>, but only if they are used in
many scripts should they be in
<tt>&quot;scx=Common&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">A complete list
of scripts and their shortcuts is in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em"><b><i>Use of
&quot;Is&quot; Prefix</i></b></p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility (with Perl 5.6), all properties mentioned so
far may have <tt>&quot;Is&quot;</tt> or
<tt>&quot;Is_&quot;</tt> prepended to their name, so
<tt>&quot;\P{Is_Lu}&quot;</tt>, for example, is equal to
<tt>&quot;\P{Lu}&quot;</tt>, and
<tt>&quot;\p{IsScript:Arabic}&quot;</tt> is equal to
<tt>&quot;\p{Arabic}&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>Blocks</i></b></p>

<p style="margin-left:11%; margin-top: 1em">In addition to
<b>scripts</b>, Unicode also defines <b>blocks</b> of
characters. The difference between scripts and blocks is
that the concept of scripts is closer to natural languages,
while the concept of blocks is more of an artificial
grouping based on groups of Unicode characters with
consecutive ordinal values. For example, the &quot;Basic
Latin&quot; block is all characters whose ordinals are
between 0 and 127, inclusive; in other words, the
<small>ASCII</small> characters. The &quot;Latin&quot;
script contains some letters from this as well as several
other blocks, like &quot;Latin&minus;1 Supplement&quot;,
&quot;Latin Extended-A&quot;, etc., but it does not contain
all the characters from those blocks. It does not, for
example, contain the digits 0&minus;9, because those digits
are shared across many scripts, and hence are in the
<tt>&quot;Common&quot;</tt> script.</p>

<p style="margin-left:11%; margin-top: 1em">For more about
scripts versus blocks, see UAX#24 &quot;Unicode Script
Property&quot;:
&lt;http://www.unicode.org/reports/tr24&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;Script&quot;</tt> or
<tt>&quot;Script_Extensions&quot;</tt> properties are likely
to be the ones you want to use when processing natural
language; the Block property may occasionally be useful in
working with the nuts and bolts of Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">Block names are
matched in the compound form, like <tt>&quot;\p{Block:
Arrows}&quot;</tt> or <tt>&quot;\p{Blk=Hebrew}&quot;</tt>.
Unlike most other properties, only a few block names have a
Unicode-defined short name. But Perl does provide a (slight)
shortcut: You can say, for example
<tt>&quot;\p{In_Arrows}&quot;</tt> or
<tt>&quot;\p{In_Hebrew}&quot;</tt>. For backwards
compatibility, the <tt>&quot;In&quot;</tt> prefix may be
omitted if there is no naming conflict with a script or any
other property, and you can even use an
<tt>&quot;Is&quot;</tt> prefix instead in those cases. But
it is not a good idea to do this, for a couple reasons:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">It is confusing. There are many
naming conflicts, and you may forget some. For example,
<tt>&quot;\p{Hebrew}&quot;</tt> means the <i>script</i>
Hebrew, and <small>NOT</small> the <i>block</i> Hebrew. But
would you remember that 6 months from now?</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>It is unstable. A new version of Unicode may pre-empt
the current meaning by creating a property with the same
name. There was a time in very early Unicode releases when
<tt>&quot;\p{Hebrew}&quot;</tt> would have matched the
<i>block</i> Hebrew; now it doesn&rsquo;t.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Some people
prefer to always use <tt>&quot;\p{Block: foo}&quot;</tt> and
<tt>&quot;\p{Script: bar}&quot;</tt> instead of the
shortcuts, whether for clarity, because they can&rsquo;t
remember the difference between &rsquo;In&rsquo; and
&rsquo;Is&rsquo; anyway, or they aren&rsquo;t confident that
those who eventually will read their code will know that
difference.</p>

<p style="margin-left:11%; margin-top: 1em">A complete list
of blocks and their shortcuts is in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em"><b><i>Other
Properties</i></b></p>

<p style="margin-left:11%; margin-top: 1em">There are many
more properties than the very basic ones described here. A
complete list is in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode defines
all its properties in the compound form, so all single-form
properties are Perl extensions. Most of these are just
synonyms for the Unicode ones, but some are genuine
extensions, including several that are in the compound form.
And quite a few of these are actually recommended by Unicode
(in &lt;http://www.unicode.org/reports/tr18&gt;).</p>

<p style="margin-left:11%; margin-top: 1em">This section
gives some details on all extensions that aren&rsquo;t just
synonyms for compound-form Unicode properties (for those
properties, you&rsquo;ll have to refer to the Unicode
Standard &lt;http://www.unicode.org/reports/tr44&gt;.
<b><br>
&quot;\p{All}&quot;</b></p>

<p style="margin-left:17%;">This matches any of the
1_114_112 Unicode code points. It is a synonym for
<tt>&quot;\p{Any}&quot;</tt>.</p>


<p style="margin-left:11%;"><b>&quot;\p{Alnum}&quot;</b></p>

<p style="margin-left:17%;">This matches any
<tt>&quot;\p{Alphabetic}&quot;</tt> or
<tt>&quot;\p{Decimal_Number}&quot;</tt> character.</p>

<p style="margin-left:11%;"><b>&quot;\p{Any}&quot;</b></p>

<p style="margin-left:17%;">This matches any of the
1_114_112 Unicode code points. It is a synonym for
<tt>&quot;\p{All}&quot;</tt>.</p>


<p style="margin-left:11%;"><b>&quot;\p{ASCII}&quot;</b></p>

<p style="margin-left:17%;">This matches any of the 128
characters in the US-ASCII character set, which is a subset
of Unicode.</p>


<p style="margin-left:11%;"><b>&quot;\p{Assigned}&quot;</b></p>

<p style="margin-left:17%;">This matches any assigned code
point; that is, any code point whose general category is not
Unassigned (or equivalently, not Cn).</p>


<p style="margin-left:11%;"><b>&quot;\p{Blank}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\h&quot;</tt> and
<tt>&quot;\p{HorizSpace}&quot;</tt>: A character that
changes the spacing horizontally.</p>


<p style="margin-left:11%;"><b>&quot;\p{Decomposition_Type:
Non_Canonical}&quot;</b> (Short:
&quot;\p{Dt=NonCanon}&quot;)</p>

<p style="margin-left:17%;">Matches a character that has a
non-canonical decomposition.</p>

<p style="margin-left:17%; margin-top: 1em">To understand
the use of this rarely used property=value combination, it
is necessary to know some basics about decomposition.
Consider a character, say H. It could appear with various
marks around it, such as an acute accent, or a circumflex,
or various hooks, circles, arrows, <i>etc.</i>, above,
below, to one side or the other, etc. There are many
possibilities among the world&rsquo;s languages. The number
of combinations is astronomical, and if there were a
character for each combination, it would soon exhaust
Unicode&rsquo;s more than a million possible characters. So
Unicode took a different approach: there is a character for
the base H, and a character for each of the possible marks,
and these can be variously combined to get a final logical
character. So a logical character--what appears to be a
single character--can be a sequence of more than one
individual characters. This is called an &quot;extended
grapheme cluster&quot;; Perl furnishes the
<tt>&quot;\X&quot;</tt> regular expression construct to
match such sequences.</p>

<p style="margin-left:17%; margin-top: 1em">But
Unicode&rsquo;s intent is to unify the existing character
set standards and practices, and several pre-existing
standards have single characters that mean the same thing as
some of these combinations. An example is
<small>ISO&minus;8859&minus;1</small> , which has quite a
few of these in the Latin&minus;1 range, an example being
&quot; <small>LATIN CAPITAL LETTER</small> E <small>WITH
ACUTE</small> &quot;. Because this character was in this
pre-existing standard, Unicode added it to its repertoire.
But this character is considered by Unicode to be equivalent
to the sequence consisting of the character &quot;
<small>LATIN CAPITAL LETTER</small> E&quot; followed by the
character &quot; <small>COMBINING ACUTE ACCENT</small>
&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;
<small>LATIN CAPITAL LETTER</small> E <small>WITH
ACUTE</small> &quot; is called a &quot;pre-composed&quot;
character, and its equivalence with the sequence is called
canonical equivalence. All pre-composed characters are said
to have a decomposition (into the equivalent sequence), and
the decomposition type is also called canonical.</p>

<p style="margin-left:17%; margin-top: 1em">However, many
more characters have a different type of decomposition, a
&quot;compatible&quot; or &quot;non-canonical&quot;
decomposition. The sequences that form these decompositions
are not considered canonically equivalent to the
pre-composed character. An example, again in the
Latin&minus;1 range, is the &quot; <small>SUPERSCRIPT
ONE</small> &quot;. It is somewhat like a regular digit 1,
but not exactly; its decomposition into the digit 1 is
called a &quot;compatible&quot; decomposition, specifically
a &quot;super&quot; decomposition. There are several such
compatibility decompositions (see
&lt;http://www.unicode.org/reports/tr44&gt;), including one
called &quot;compat&quot;, which means some miscellaneous
type of decomposition that doesn&rsquo;t fit into the
decomposition categories that Unicode has chosen.</p>

<p style="margin-left:17%; margin-top: 1em">Note that most
Unicode characters don&rsquo;t have a decomposition, so
their decomposition type is &quot;None&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For your
convenience, Perl has added the
<tt>&quot;Non_Canonical&quot;</tt> decomposition type to
mean any of the several compatibility decompositions.</p>


<p style="margin-left:11%;"><b>&quot;\p{Graph}&quot;</b></p>

<p style="margin-left:17%;">Matches any character that is
graphic. Theoretically, this means a character that on a
printer would cause ink to be used.</p>


<p style="margin-left:11%;"><b>&quot;\p{HorizSpace}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\h&quot;</tt> and <tt>&quot;\p{Blank}&quot;</tt>:
a character that changes the spacing horizontally.</p>


<p style="margin-left:11%;"><b>&quot;\p{In=*}&quot;</b></p>

<p style="margin-left:17%;">This is a synonym for
<tt>&quot;\p{Present_In=*}&quot;</tt></p>


<p style="margin-left:11%;"><b>&quot;\p{PerlSpace}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\s&quot;</tt>, restricted to <small>ASCII</small>
, namely <tt>&quot;[&nbsp;\f\n\r\t]&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
Perl&rsquo;s (original) space</p>


<p style="margin-left:11%;"><b>&quot;\p{PerlWord}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\w&quot;</tt>, restricted to <small>ASCII</small>
, namely
<tt>&quot;[A&minus;Za&minus;z0&minus;9_]&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
Perl&rsquo;s (original) word.</p>


<p style="margin-left:11%;"><b>&quot;\p{Posix...}&quot;</b></p>

<p style="margin-left:17%;">There are several of these,
which are equivalents using the <tt>&quot;\p&quot;</tt>
notation for Posix classes and are described in &quot;
<small>POSIX</small> Character Classes&quot; in
perlrecharclass.</p>

<p style="margin-left:11%;"><b>&quot;\p{Present_In:
*}&quot;</b> (Short: &quot;\p{In=*}&quot;)</p>

<p style="margin-left:17%;">This property is used when you
need to know in what Unicode version(s) a character is.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;*&quot; above stands for some two digit Unicode
version number, such as <tt>1.1</tt> or <tt>4.0</tt>; or the
&quot;*&quot; can also be <tt>&quot;Unassigned&quot;</tt>.
This property will match the code points whose final
disposition has been settled as of the Unicode release given
by the version number; <tt>&quot;\p{Present_In:
Unassigned}&quot;</tt> will match those code points whose
meaning has yet to be assigned.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
<tt>&quot;U+0041&quot;</tt> &quot; <small>LATIN CAPITAL
LETTER</small> A&quot; was present in the very first Unicode
release available, which is <tt>1.1</tt>, so this property
is true for all valid &quot;*&quot; versions. On the other
hand, <tt>&quot;U+1EFF&quot;</tt> was not assigned until
version 5.1 when it became &quot; <small>LATIN SMALL
LETTER</small> Y <small>WITH LOOP</small> &quot;, so the
only &quot;*&quot; that would match it are 5.1, 5.2, and
later.</p>

<p style="margin-left:17%; margin-top: 1em">Unicode
furnishes the <tt>&quot;Age&quot;</tt> property from which
this is derived. The problem with Age is that a strict
interpretation of it (which Perl takes) has it matching the
precise release a code point&rsquo;s meaning is introduced
in. Thus <tt>&quot;U+0041&quot;</tt> would match only 1.1;
and <tt>&quot;U+1EFF&quot;</tt> only 5.1. This is not
usually what you want.</p>

<p style="margin-left:17%; margin-top: 1em">Some non-Perl
implementations of the Age property may change its meaning
to be the same as the Perl Present_In property; just be
aware of that.</p>

<p style="margin-left:17%; margin-top: 1em">Another
confusion with both these properties is that the definition
is not that the code point has been <i>assigned</i>, but
that the meaning of the code point has been
<i>determined</i>. This is because 66 code points will
always be unassigned, and so the Age for them is the Unicode
version in which the decision to make them so was made. For
example, <tt>&quot;U+FDD0&quot;</tt> is to be permanently
unassigned to a character, and the decision to do that was
made in version 3.1, so <tt>&quot;\p{Age=3.1}&quot;</tt>
matches this character, as also does
<tt>&quot;\p{Present_In: 3.1}&quot;</tt> and up.</p>


<p style="margin-left:11%;"><b>&quot;\p{Print}&quot;</b></p>

<p style="margin-left:17%;">This matches any character that
is graphical or blank, except controls.</p>


<p style="margin-left:11%;"><b>&quot;\p{SpacePerl}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\s&quot;</tt>, including beyond
<small>ASCII</small> .</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
Space, as modified by Perl. (It doesn&rsquo;t include the
vertical tab which both the Posix standard and Unicode
consider white space.)</p>

<p style="margin-left:11%;"><b>&quot;\p{Title}&quot;</b>
and <b>&quot;\p{Titlecase}&quot;</b></p>

<p style="margin-left:17%;">Under case-sensitive matching,
these both match the same code points as
<tt>&quot;\p{General Category=Titlecase_Letter}&quot;</tt>
(<tt>&quot;\p{gc=lt}&quot;</tt>). The difference is that
under <tt>&quot;/i&quot;</tt> caseless matching, these match
the same as <tt>&quot;\p{Cased}&quot;</tt>, whereas
<tt>&quot;\p{gc=lt}&quot;</tt> matches
<tt>&quot;\p{Cased_Letter&quot;</tt>).</p>


<p style="margin-left:11%;"><b>&quot;\p{VertSpace}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\v&quot;</tt>: A character that changes the
spacing vertically.</p>


<p style="margin-left:11%;"><b>&quot;\p{Word}&quot;</b></p>

<p style="margin-left:17%;">This is the same as
<tt>&quot;\w&quot;</tt>, including over 100_000 characters
beyond <small>ASCII</small> .</p>


<p style="margin-left:11%;"><b>&quot;\p{XPosix...}&quot;</b></p>

<p style="margin-left:17%;">There are several of these,
which are the standard Posix classes extended to the full
Unicode range. They are described in &quot;
<small>POSIX</small> Character Classes&quot; in
perlrecharclass.</p>


<p style="margin-left:11%; margin-top: 1em"><b>User-Defined
Character Properties</b> <br>
You can define your own binary character properties by
defining subroutines whose names begin with &quot;In&quot;
or &quot;Is&quot;. The subroutines can be defined in any
package. The user-defined properties can be used in the
regular expression <tt>&quot;\p&quot;</tt> and
<tt>&quot;\P&quot;</tt> constructs; if you are using a
user-defined property from a package other than the one you
are in, you must specify its package in the
<tt>&quot;\p&quot;</tt> or <tt>&quot;\P&quot;</tt>
construct.</p>

<pre style="margin-left:11%; margin-top: 1em">    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }
    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
effect is compile-time and immutable once defined. However,
the subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and non-zero if
caseless matching is in effect. The subroutine may return
different values depending on the value of the flag, and one
set of values will immutably be in effect for all
case-sensitive matches, and the other set for all
case-insensitive matches.</p>

<p style="margin-left:11%; margin-top: 1em">Note that if
the regular expression is tainted, then Perl will die rather
than calling the subroutine, where the name of the
subroutine is determined by the tainted data.</p>

<p style="margin-left:11%; margin-top: 1em">The subroutines
must return a specially-formatted string, with one or more
newline-separated lines. Each line must be one of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A single hexadecimal number denoting a Unicode code
point to include.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Two hexadecimal numbers separated by horizontal
whitespace (space or tabular characters) denoting a range of
Unicode code points to include.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Something to include, prefixed by &quot;+&quot;: a
built-in character property (prefixed by &quot;utf8::&quot;)
or a fully qualified (including package name) user-defined
character property, to represent all the characters in that
property; two hexadecimal code points for a range; or a
single hexadecimal code point.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Something to exclude, prefixed by &quot;&minus;&quot;:
an existing character property (prefixed by
&quot;utf8::&quot;) or a fully qualified (including package
name) user-defined character property, to represent all the
characters in that property; two hexadecimal code points for
a range; or a single hexadecimal code point.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Something to negate, prefixed &quot;!&quot;: an existing
character property (prefixed by &quot;utf8::&quot;) or a
fully qualified (including package name) user-defined
character property, to represent all the characters in that
property; two hexadecimal code points for a range; or a
single hexadecimal code point.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Something to intersect with, prefixed by
&quot;&amp;&quot;: an existing character property (prefixed
by &quot;utf8::&quot;) or a fully qualified (including
package name) user-defined character property, for all the
characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">For example, to
define a property that covers both the Japanese syllabaries
(hiragana and katakana), you can define</p>

<pre style="margin-left:11%; margin-top: 1em">    sub InKana {
        return &lt;&lt;END;
    3040\t309F
    30A0\t30FF
    END
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Imagine that
the here-doc end marker is at the beginning of the line. Now
you can use <tt>&quot;\p{InKana}&quot;</tt> and
<tt>&quot;\P{InKana}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">You could also
have used the existing block property names:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Suppose you
wanted to match only the allocated characters, not the raw
block ranges: in other words, you want to remove the
non-characters:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    &minus;utf8::IsCn
    END
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The negation is
useful for defining (surprise!) negated classes.</p>

<pre style="margin-left:11%; margin-top: 1em">    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    &minus;utf8::InKatakana
    +utf8::IsCn
    END
    }</pre>


<p style="margin-left:11%; margin-top: 1em">This will match
all non-Unicode code points, since every one of them is not
in Kana. You can use intersection to exclude these, if
desired, as this modified example shows:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    &minus;utf8::InKatakana
    +utf8::IsCn
    &amp;utf8::Any
    END
    }</pre>


<p style="margin-left:11%; margin-top: 1em">&amp;utf8::Any
must be the last line in the definition.</p>

<p style="margin-left:11%; margin-top: 1em">Intersection is
used generally for getting the common characters matched by
two (or more) classes. It&rsquo;s important to remember not
to use &quot;&amp;&quot; for the first set; that would be
intersecting with nothing, resulting in an empty set.</p>

<p style="margin-left:11%; margin-top: 1em">(Note that
official Unicode properties differ from these in that they
automatically exclude non-Unicode code points and a warning
is raised if a match is attempted on one of those.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>User-Defined
Case Mappings (for serious hackers only) <br>
This feature has been removed as of Perl 5.16.</b> The
<small>CPAN</small> module Unicode::Casing provides better
functionality without the drawbacks that this feature had.
If you are using a Perl earlier than 5.16, this feature was
most fully documented in the 5.14 version of this pod:
http://perldoc.perl.org/5.14.0/perlunicode.html#User&minus;Defined&minus;Case&minus;Mappings&minus;%28for&minus;serious&minus;hackers&minus;only%29
&lt;http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Character
Encodings for Input and Output</b> <br>
See Encode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode
Regular Expression Support Level</b> <br>
The following list of Unicode supported features for regular
expressions describes all features currently directly
supported by core Perl. The references to &quot;Level
N&quot; and the section numbers refer to the Unicode
Technical Standard #18, &quot;Unicode Regular
Expressions&quot;, version 13, from August 2008.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="48%">


<p style="margin-top: 1em">Level 1 &minus; Basic Unicode
Support</p> </td>
<td width="35%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> RL1.1   Hex Notation                     &minus; done          [1]
 RL1.2   Properties                       &minus; done          [2][3]
 RL1.2a  Compatibility Properties         &minus; done          [4]
 RL1.3   Subtraction and Intersection     &minus; MISSING       [5]
 RL1.4   Simple Word Boundaries           &minus; done          [6]
 RL1.5   Simple Loose Matches             &minus; done          [7]
 RL1.6   Line Boundaries                  &minus; MISSING       [8][9]
 RL1.7   Supplementary Code Points        &minus; done          [10]
 [1]  \x{...}
 [2]  \p{...} \P{...}
 [3]  supports not only minimal list, but all Unicode character
      properties (see Unicode Character Properties above)
 [4]  \d \D \s \S \w \W \X [:prop:] [:^prop:]
 [5]  can use regular expression look&minus;ahead [a] or
      user&minus;defined character properties [b] to emulate set
      operations
 [6]  \b \B
 [7]  note that Perl does Full case&minus;folding in matching (but with
      bugs), not Simple: for example U+1F88 is equivalent to
      U+1F00 U+03B9, instead of just U+1F80.  This difference
      matters mainly for certain Greek capital letters with certain
      modifiers: the Full case&minus;folding decomposes the letter,
      while the Simple case&minus;folding would map it to a single
      character.
 [8]  should do ^ and $ also on U+000B (\v in C), FF (\f), CR
      (\r), CRLF (\r\n), NEL (U+0085), LS (U+2028), and PS
      (U+2029); should also affect &lt;&gt;, $., and script line
      numbers; should not split lines within CRLF [c] (i.e. there
      is no empty line between \r and \n)
 [9]  Linebreaking conformant with UAX#14 &quot;Unicode Line Breaking
      Algorithm&quot; is available through the Unicode::LineBreaking
      module.
 [10] UTF&minus;8/UTF&minus;EBDDIC used in Perl allows not only U+10000 to
      U+10FFFF but also beyond U+10FFFF</pre>


<p style="margin-left:17%; margin-top: 1em">[a] You can
mimic class subtraction using lookahead. For example, what
UTS#18 might write as</p>

<pre style="margin-left:17%; margin-top: 1em">    [{Greek}&minus;[{UNASSIGNED}]]</pre>


<p style="margin-left:17%; margin-top: 1em">in Perl can be
written as:</p>

<pre style="margin-left:17%; margin-top: 1em">    (?!\p{Unassigned})\p{InGreekAndCoptic}
    (?=\p{Assigned})\p{InGreekAndCoptic}</pre>


<p style="margin-left:17%; margin-top: 1em">But in this
particular example, you probably really want</p>

<pre style="margin-left:17%; margin-top: 1em">    \p{GreekAndCoptic}</pre>


<p style="margin-left:17%; margin-top: 1em">which will
match assigned characters known to be part of the Greek
script.</p>

<p style="margin-left:17%; margin-top: 1em">Also see the
Unicode::Regex::Set module; it does implement the full
UTS#18 grouping, intersection, union, and removal
(subtraction) syntax.</p>

<p style="margin-left:17%; margin-top: 1em">[b]
&rsquo;+&rsquo; for union, &rsquo;&minus;&rsquo; for removal
(set-difference), &rsquo;&amp;&rsquo; for intersection (see
&quot;User-Defined Character Properties&quot;)</p>

<p style="margin-left:17%; margin-top: 1em">[c] Try the
<tt>&quot;:crlf&quot;</tt> layer (see PerlIO).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="52%">


<p style="margin-top: 1em">Level 2 &minus; Extended Unicode
Support</p> </td>
<td width="31%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> RL2.1   Canonical Equivalents           &minus; MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       &minus; MISSING       [12]
 RL2.3   Default Word Boundaries         &minus; MISSING       [14]
 RL2.4   Default Loose Matches           &minus; MISSING       [15]
 RL2.5   Name Properties                 &minus; DONE
 RL2.6   Wildcard Properties             &minus; MISSING
 [10] see UAX#15 &quot;Unicode Normalization Forms&quot;
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X but we don't have a &quot;Grapheme Cluster Mode&quot;
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">Level 3 &minus; Tailored
Support</p> </td>
<td width="43%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> RL3.1   Tailored Punctuation            &minus; MISSING
 RL3.2   Tailored Grapheme Clusters      &minus; MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        &minus; MISSING
 RL3.4   Tailored Loose Matches          &minus; MISSING
 RL3.5   Tailored Ranges                 &minus; MISSING
 RL3.6   Context Matching                &minus; MISSING       [19]
 RL3.7   Incremental Matches             &minus; MISSING
      ( RL3.8   Unicode Set Sharing )
 RL3.9   Possible Match Sets             &minus; MISSING
 RL3.10  Folded Matching                 &minus; MISSING       [20]
 RL3.11  Submatchers                     &minus; MISSING
 [17] see UAX#10 &quot;Unicode Collation Algorithms&quot;
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?&lt;=x) and (?=x), but look&minus;aheads or look&minus;behinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      &quot;Character Foldings&quot;)</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Unicode
Encodings</b> <br>
Unicode characters are assigned to <i>code points</i>, which
are abstract numbers. To use these numbers, various
encodings are needed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><small>UTF&minus;8</small></p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>UTF&minus;8</small>
is a variable-length (1 to 4 bytes), byte-order independent
encoding. For <small>ASCII</small> (and we really do mean
7&minus;bit <small>ASCII</small> , not another 8&minus;bit
encoding), <small>UTF&minus;8</small> is transparent.</p>

<p style="margin-left:17%; margin-top: 1em">The following
table is from Unicode 3.2.</p>

<pre style="margin-left:17%; margin-top: 1em"> Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte
   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF</pre>


<p style="margin-left:17%; margin-top: 1em">Note the gaps
marked by &quot;*&quot; before several of the byte entries
above. These are caused by legal <small>UTF&minus;8</small>
avoiding non-shortest encodings: it is technically possible
to UTF&minus;8&minus;encode a single code point in different
ways, but that is explicitly forbidden, and the shortest
possible encoding should always be used (and that is what
Perl does).</p>

<p style="margin-left:17%; margin-top: 1em">Another way to
look at it is via bits:</p>

<pre style="margin-left:17%; margin-top: 1em">                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte
                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa</pre>


<p style="margin-left:17%; margin-top: 1em">As you can see,
the continuation bytes all begin with &quot;10&quot;, and
the leading bits of the start byte tell how many bytes there
are in the encoded character.</p>

<p style="margin-left:17%; margin-top: 1em">The original
<small>UTF&minus;8</small> specification allowed up to 6
bytes, to allow encoding of numbers up to 0x7FFF_FFFF. Perl
continues to allow those, and has extended that up to 13
bytes to encode code points up to what can fit in a
64&minus;bit word. However, Perl will warn if you output any
of these as being non-portable; and under strict
<small>UTF&minus;8</small> input protocols, they are
forbidden.</p>

<p style="margin-left:17%; margin-top: 1em">The Unicode
non-character code points are also disallowed in
<small>UTF&minus;8</small> in &quot;open interchange&quot;.
See &quot;Non-character code points&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">UTF-EBCDIC</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Like
<small>UTF&minus;8</small> but EBCDIC-safe, in the way that
<small>UTF&minus;8</small> is ASCII-safe.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><small>UTF&minus;16</small> ,
<small>UTF&minus;16BE</small> ,
<small>UTF&minus;16LE</small> , Surrogates, and BOMs (Byte
Order Marks)</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The followings
items are mostly for reference and general Unicode
knowledge, Perl doesn&rsquo;t use these constructs
internally.</p>

<p style="margin-left:17%; margin-top: 1em">Like
<small>UTF&minus;8</small> , <small>UTF&minus;16</small> is
a variable-width encoding, but where
<small>UTF&minus;8</small> uses 8&minus;bit code units,
<small>UTF&minus;16</small> uses 16&minus;bit code units.
All code points occupy either 2 or 4 bytes in
<small>UTF&minus;16:</small> code points
<tt>&quot;U+0000..U+FFFF&quot;</tt> are stored in a single
16&minus;bit unit, and code points
<tt>&quot;U+10000..U+10FFFF&quot;</tt> in two 16&minus;bit
units. The latter case is using <i>surrogates</i>, the first
16&minus;bit unit being the <i>high surrogate</i>, and the
second being the <i>low surrogate</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Surrogates are
code points set aside to encode the
<tt>&quot;U+10000..U+10FFFF&quot;</tt> range of Unicode code
points in pairs of 16&minus;bit units. The <i>high
surrogates</i> are the range
<tt>&quot;U+D800..U+DBFF&quot;</tt> and the <i>low
surrogates</i> are the range
<tt>&quot;U+DC00..U+DFFF&quot;</tt>. The surrogate encoding
is</p>

<pre style="margin-left:17%; margin-top: 1em">    $hi = ($uni &minus; 0x10000) / 0x400 + 0xD800;
    $lo = ($uni &minus; 0x10000) % 0x400 + 0xDC00;</pre>


<p style="margin-left:17%; margin-top: 1em">and the
decoding is</p>

<pre style="margin-left:17%; margin-top: 1em">    $uni = 0x10000 + ($hi &minus; 0xD800) * 0x400 + ($lo &minus; 0xDC00);</pre>


<p style="margin-left:17%; margin-top: 1em">Because of the
16&minus;bitness, <small>UTF&minus;16</small> is byte-order
dependent. <small>UTF&minus;16</small> itself can be used
for in-memory computations, but if storage or transfer is
required either <small>UTF&minus;16BE</small> (big-endian)
or <small>UTF&minus;16LE</small> (little-endian) encodings
must be chosen.</p>

<p style="margin-left:17%; margin-top: 1em">This introduces
another problem: what if you just know that your data is
<small>UTF&minus;16</small> , but you don&rsquo;t know which
endianness? Byte Order Marks, or BOMs, are a solution to
this. A special character has been reserved in Unicode to
function as a byte order marker: the character with the code
point <tt>&quot;U+FEFF&quot;</tt> is the <small>BOM</small>
.</p>

<p style="margin-left:17%; margin-top: 1em">The trick is
that if you read a <small>BOM</small> , you will know the
byte order, since if it was written on a big-endian
platform, you will read the bytes <tt>&quot;0xFE
0xFF&quot;</tt>, but if it was written on a little-endian
platform, you will read the bytes <tt>&quot;0xFF
0xFE&quot;</tt>. (And if the originating platform was
writing in <small>UTF&minus;8</small> , you will read the
bytes <tt>&quot;0xEF 0xBB 0xBF&quot;</tt>.)</p>

<p style="margin-left:17%; margin-top: 1em">The way this
trick works is that the character with the code point
<tt>&quot;U+FFFE&quot;</tt> is not supposed to be in input
streams, so the sequence of bytes <tt>&quot;0xFF
0xFE&quot;</tt> is unambiguously &quot; <small>BOM</small> ,
represented in little-endian format&quot; and cannot be
<tt>&quot;U+FFFE&quot;</tt>, represented in big-endian
format&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Surrogates have
no meaning in Unicode outside their use in pairs to
represent other code points. However, Perl allows them to be
represented individually internally, for example by saying
<tt>&quot;chr(0xD801)&quot;</tt>, so that all code points,
not just those valid for open interchange, are
representable. Unicode does define semantics for them, such
as their General Category is &quot;Cs&quot;. But because
their use is somewhat dangerous, Perl will warn (using the
warning category &quot;surrogate&quot;, which is a
sub-category of &quot;utf8&quot;) if an attempt is made to
do things like take the lower case of one, or match
case-insensitively, or to output them. (But don&rsquo;t try
this on Perls before 5.14.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em"><small>UTF&minus;32</small> ,
<small>UTF&minus;32BE</small> ,
<small>UTF&minus;32LE</small></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The
<small>UTF&minus;32</small> family is pretty much like the
<small>UTF&minus;16</small> family, expect that the units
are 32&minus;bit, and therefore the surrogate scheme is not
needed. <small>UTF&minus;32</small> is a fixed-width
encoding. The <small>BOM</small> signatures are
<tt>&quot;0x00 0x00 0xFE 0xFF&quot;</tt> for
<small>BE</small> and <tt>&quot;0xFF 0xFE 0x00
0x00&quot;</tt> for <small>LE</small> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p style="margin-top: 1em"><small>UCS&minus;2</small> ,
<small>UCS&minus;4</small></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Legacy,
fixed-width encodings defined by the <small>ISO</small>
10646 standard. <small>UCS&minus;2</small> is a 16&minus;bit
encoding. Unlike <small>UTF&minus;16</small> ,
<small>UCS&minus;2</small> is not extensible beyond
<tt>&quot;U+FFFF&quot;</tt>, because it does not use
surrogates. <small>UCS&minus;4</small> is a 32&minus;bit
encoding, functionally identical to
<small>UTF&minus;32</small> (the difference being that
<small>UCS&minus;4</small> forbids neither surrogates nor
code points larger than 0x10_FFFF).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><small>UTF&minus;7</small></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A seven-bit
safe (non-eight-bit) encoding, which is useful if the
transport or storage is not eight-bit safe. Defined by
<small>RFC</small> 2152.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Non-character
code points</b> <br>
66 code points are set aside in Unicode as
&quot;non-character code points&quot;. These all have the
Unassigned (Cn) General Category, and they never will be
assigned. These are never supposed to be in legal Unicode
input streams, so that code can use them as sentinels that
can be mixed in with character data, and they always will be
distinguishable from that data. To keep them out of Perl
input streams, strict <small>UTF&minus;8</small> should be
specified, such as by using the layer
<tt>&quot;:encoding('UTF&minus;8')&quot;</tt>. The
non-character code points are the 32 between U+FDD0 and
U+FDEF, and the 34 code points U+FFFE, U+FFFF, U+1FFFE,
U+1FFFF, ... U+10FFFE, U+10FFFF. Some people are under the
mistaken impression that these are &quot;illegal&quot;, but
that is not true. An application or cooperating set of
applications can legally use them at will internally; but
these code points are &quot;illegal for open
interchange&quot;. Therefore, Perl will not accept these
from input streams unless lax rules are being used, and will
warn (using the warning category &quot;nonchar&quot;, which
is a sub-category of &quot;utf8&quot;) if an attempt is made
to output them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Beyond
Unicode code points</b> <br>
The maximum Unicode code point is U+10FFFF. But Perl accepts
code points up to the maximum permissible unsigned number
available on the platform. However, Perl will not accept
these from input streams unless lax rules are being used,
and will warn (using the warning category
&quot;non_unicode&quot;, which is a sub-category of
&quot;utf8&quot;) if an attempt is made to operate on or
output them. For example, <tt>&quot;uc(0x11_0000)&quot;</tt>
will generate this warning, returning the input parameter as
its result, as the upper case of every non-Unicode code
point is the code point itself.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Security
Implications of Unicode</b> <br>
Read Unicode Security Considerations
&lt;http://www.unicode.org/reports/tr36&gt;. Also, note the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">Malformed
<small>UTF&minus;8</small></p> </td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Unfortunately,
the original specification of <small>UTF&minus;8</small>
leaves some room for interpretation of how many bytes of
encoded output one should generate from one input Unicode
character. Strictly speaking, the shortest possible sequence
of <small>UTF&minus;8</small> bytes should be generated,
because otherwise there is potential for an input buffer
overflow at the receiving end of a
<small>UTF&minus;8</small> connection. Perl always generates
the shortest length <small>UTF&minus;8</small> , and with
warnings on, Perl will warn about non-shortest length
<small>UTF&minus;8</small> along with other malformations,
such as the surrogates, which are not Unicode code points
valid for interchange.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Regular expression pattern
matching may surprise you if you&rsquo;re not accustomed to
Unicode. Starting in Perl 5.14, several pattern modifiers
are available to control this, called the character set
modifiers. Details are given in &quot;Character set
modifiers&quot; in perlre.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As discussed
elsewhere, Perl has one foot (two hooves?) planted in each
of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when
necessary. If your legacy code does not explicitly use
Unicode, no automatic switch-over to characters should
happen. Characters shouldn&rsquo;t get downgraded to bytes,
either. It is possible to accidentally mix bytes and
characters, however (see perluniintro), in which case
<tt>&quot;\w&quot;</tt> in regular expressions might start
behaving differently (unless the <tt>&quot;/a&quot;</tt>
modifier is in effect). Review your code. Use warnings and
the <tt>&quot;strict&quot;</tt> pragma.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode in
Perl on <small>EBCDIC</small></b> <br>
The way Unicode is handled on <small>EBCDIC</small>
platforms is still experimental. On such platforms,
references to <small>UTF&minus;8</small> encoding in this
document and elsewhere should be read as meaning the
UTF-EBCDIC specified in Unicode Technical Report 16, unless
<small>ASCII</small> vs. <small>EBCDIC</small> issues are
specifically discussed. There is no
<tt>&quot;utfebcdic&quot;</tt> pragma or
&quot;:utfebcdic&quot; layer; rather, &quot;utf8&quot; and
&quot;:utf8&quot; are reused to mean the platform&rsquo;s
&quot;natural&quot; 8&minus;bit encoding of Unicode. See
perlebcdic for more discussion of the issues.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Locales</b>
<br>
See &quot;Unicode and <small>UTF&minus;8</small> &quot; in
perllocale</p>

<p style="margin-left:11%; margin-top: 1em"><b>When Unicode
Does Not Happen</b> <br>
While Perl does have extensive ways to input and output in
Unicode, and a few other &quot;entry points&quot; like the
<tt>@ARGV</tt> array (which can sometimes be interpreted as
<small>UTF&minus;8</small> ), there are still many places
where Unicode (in some encoding or another) could be given
as arguments or received as results, or both, but it is
not.</p>

<p style="margin-left:11%; margin-top: 1em">The following
are such interfaces. Also, see &quot;The &quot;Unicode
Bug&quot;&quot;. For all of these interfaces Perl currently
(as of 5.8.3) simply assumes byte strings both as arguments
and results, or <small>UTF&minus;8</small> strings if the
(problematic) <tt>&quot;encoding&quot;</tt> pragma has been
used.</p>

<p style="margin-left:11%; margin-top: 1em">One reason that
Perl does not attempt to resolve the role of Unicode in
these situations is that the answers are highly dependent on
the operating system and the file system(s). For example,
whether filenames can be in Unicode and in exactly what kind
of encoding, is not exactly a portable concept. Similarly
for <tt>&quot;qx&quot;</tt> and <tt>&quot;system&quot;</tt>:
how well will the &quot;command-line interface&quot; (and
which of them?) handle Unicode?</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">chdir, chmod, chown, chroot,
exec, link, lstat, mkdir, rename, rmdir, stat, symlink,
truncate, unlink, utime, &minus;X</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>%ENV</tt></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>glob (aka the &lt;*&gt;)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>open, opendir, sysopen</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>qx (aka the backtick operator), system</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>readdir, readlink</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>The
&quot;Unicode Bug&quot;</b> <br>
The term, &quot;Unicode bug&quot; has been applied to an
inconsistency on <small>ASCII</small> platforms with the
Unicode code points in the Latin&minus;1 Supplement block,
that is, between 128 and 255. Without a locale specified,
unlike all other characters or code points, these characters
have very different semantics in byte semantics versus
character semantics, unless <tt>&quot;use feature
'unicode_strings'&quot;</tt> is specified, directly or
indirectly. (It is indirectly specified by a <tt>&quot;use
v5.12&quot;</tt> or higher.)</p>

<p style="margin-left:11%; margin-top: 1em">In character
semantics these upper&minus;Latin1 characters are
interpreted as Unicode code points, which means they have
the same semantics as Latin&minus;1 (
<small>ISO&minus;8859&minus;1</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">In byte
semantics (without <tt>&quot;unicode_strings&quot;</tt>),
they are considered to be unassigned characters, meaning
that the only semantics they have is their ordinal numbers,
and that they are not members of various character classes.
None are considered to match <tt>&quot;\w&quot;</tt> for
example, but all match <tt>&quot;\W&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Perl 5.12.0
added <tt>&quot;unicode_strings&quot;</tt> to force
character semantics on these code points in some
circumstances, which fixed portions of the bug; Perl 5.14.0
fixed almost all of it; and Perl 5.16.0 fixed the remainder
(so far as we know, anyway). The lesson here is to enable
<tt>&quot;unicode_strings&quot;</tt> to avoid the headaches
described below.</p>

<p style="margin-left:11%; margin-top: 1em">The old,
problematic behavior affects these areas:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Changing the case of a scalar,
that is, using <tt>&quot;uc()&quot;</tt>,
<tt>&quot;ucfirst()&quot;</tt>, <tt>&quot;lc()&quot;</tt>,
and <tt>&quot;lcfirst()&quot;</tt>, or
<tt>&quot;\L&quot;</tt>, <tt>&quot;\U&quot;</tt>,
<tt>&quot;\u&quot;</tt> and <tt>&quot;\l&quot;</tt> in
double-quotish contexts, such as regular expression
substitutions. Under <tt>&quot;unicode_strings&quot;</tt>
starting in Perl 5.12.0, character semantics are generally
used. See &quot;lc&quot; in perlfunc for details on how this
works in combination with various other pragmas.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Using caseless (<tt>&quot;/i&quot;</tt>) regular
expression matching. Starting in Perl 5.14.0, regular
expressions compiled within the scope of
<tt>&quot;unicode_strings&quot;</tt> use character semantics
even when executed or compiled into larger regular
expressions outside the scope.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Matching any of several properties in regular
expressions, namely <tt>&quot;\b&quot;</tt>,
<tt>&quot;\B&quot;</tt>, <tt>&quot;\s&quot;</tt>,
<tt>&quot;\S&quot;</tt>, <tt>&quot;\w&quot;</tt>,
<tt>&quot;\W&quot;</tt>, and all the Posix character classes
<i>except</i> <tt>&quot;[[:ascii:]]&quot;</tt>. Starting in
Perl 5.14.0, regular expressions compiled within the scope
of <tt>&quot;unicode_strings&quot;</tt> use character
semantics even when executed or compiled into larger regular
expressions outside the scope.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In <tt>&quot;quotemeta&quot;</tt> or its inline
equivalent <tt>&quot;\Q&quot;</tt>, no code points above 127
are quoted in <small>UTF&minus;8</small> encoded strings,
but in byte encoded strings, code points between
128&minus;255 are always quoted. Starting in Perl 5.16.0,
consistent quoting rules are used within the scope of
<tt>&quot;unicode_strings&quot;</tt>, as described in
&quot;quotemeta&quot; in perlfunc.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This behavior
can lead to unexpected results in which a string&rsquo;s
semantics suddenly change if a code point above 255 is
appended to or removed from it, which changes the
string&rsquo;s semantics from byte to character or vice
versa. As an example, consider the following program and its
output:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ perl &minus;le'
     no feature 'unicode_strings';
     $s1 = &quot;\xC2&quot;;
     $s2 = &quot;\x{2660}&quot;;
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1</pre>


<p style="margin-left:11%; margin-top: 1em">If
there&rsquo;s no <tt>&quot;\w&quot;</tt> in
<tt>&quot;s1&quot;</tt> or in <tt>&quot;s2&quot;</tt>, why
does their concatenation have one?</p>

<p style="margin-left:11%; margin-top: 1em">This anomaly
stems from Perl&rsquo;s attempt to not disturb older
programs that didn&rsquo;t use Unicode, and hence had no
semantics for characters outside of the <small>ASCII</small>
range (except in a locale), along with Perl&rsquo;s desire
to add Unicode support seamlessly. The result wasn&rsquo;t
seamless: these characters were orphaned.</p>

<p style="margin-left:11%; margin-top: 1em">For Perls
earlier than those described above, or when a string is
passed to a function outside the subpragma&rsquo;s scope, a
workaround is to always call
<tt>&quot;utf8::upgrade($string)&quot;</tt>, or to use the
standard module Encode. Also, a scalar that has any
characters whose ordinal is above 0x100, or which were
specified using either of the <tt>&quot;\N{...}&quot;</tt>
notations, will automatically have character semantics.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Forcing
Unicode in Perl (Or Unforcing Unicode in Perl)</b> <br>
Sometimes (see &quot;When Unicode Does Not Happen&quot; or
&quot;The &quot;Unicode Bug&quot;&quot;) there are
situations where you simply need to force a byte string into
<small>UTF&minus;8</small> , or vice versa. The low-level
calls utf8::upgrade($bytestring) and
utf8::downgrade($utf8string[, <small>FAIL_OK</small> ]) are
the answers.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<i>utf8::downgrade()</i> can fail if the string contains
characters that don&rsquo;t fit into a byte.</p>

<p style="margin-left:11%; margin-top: 1em">Calling either
function on a string that already is in the desired state is
a no-op.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
Unicode in <small>XS</small></b> <br>
If you want to handle Perl Unicode in <small>XS</small>
extensions, you may find the following C APIs useful. See
also &quot;Unicode Support&quot; in perlguts for an
explanation about Unicode at the <small>XS</small> level,
and perlapi for the <small>API</small> details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">



<p style="margin-top: 1em"><tt>&quot;DO_UTF8(sv)&quot;</tt>
returns true if the <tt>&quot;UTF8&quot;</tt> flag is on and
the bytes pragma is not in effect.
<tt>&quot;SvUTF8(sv)&quot;</tt> returns true if the
<tt>&quot;UTF8&quot;</tt> flag is on; the bytes pragma is
ignored. The <tt>&quot;UTF8&quot;</tt> flag being on does
<b>not</b> mean that there are any characters of code points
greater than 255 (or 127) in the scalar or that there are
even any characters in the scalar. What the
<tt>&quot;UTF8&quot;</tt> flag means is that the sequence of
octets in the representation of the scalar is the sequence
of <small>UTF&minus;8</small> encoded code points of the
characters of a string. The <tt>&quot;UTF8&quot;</tt> flag
being off means that each octet in this representation
encodes a single character with code point 0..255 within the
string. Perl&rsquo;s Unicode model is not to use
<small>UTF&minus;8</small> until it is absolutely
necessary.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;uvchr_to_utf8(buf, chr)&quot;</tt> writes a
Unicode character code point into a buffer encoding the code
point as <small>UTF&minus;8</small> , and returns a pointer
pointing after the <small>UTF&minus;8</small> bytes. It
works appropriately on <small>EBCDIC</small> machines.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;utf8_to_uvchr_buf(buf, bufend,
lenp)&quot;</tt> reads <small>UTF&minus;8</small> encoded
bytes from a buffer and returns the Unicode character code
point and, optionally, the length of the
<small>UTF&minus;8</small> byte sequence. It works
appropriately on <small>EBCDIC</small> machines.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;utf8_length(start, end)&quot;</tt> returns the
length of the <small>UTF&minus;8</small> encoded buffer in
characters. <tt>&quot;sv_len_utf8(sv)&quot;</tt> returns the
length of the <small>UTF&minus;8</small> encoded scalar.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;sv_utf8_upgrade(sv)&quot;</tt> converts the
string of the scalar to its <small>UTF&minus;8</small>
encoded form. <tt>&quot;sv_utf8_downgrade(sv)&quot;</tt>
does the opposite, if possible.
<tt>&quot;sv_utf8_encode(sv)&quot;</tt> is like
sv_utf8_upgrade except that it does not set the
<tt>&quot;UTF8&quot;</tt> flag.
<tt>&quot;sv_utf8_decode()&quot;</tt> does the opposite of
<tt>&quot;sv_utf8_encode()&quot;</tt>. Note that none of
these are to be used as general-purpose encoding or decoding
interfaces: <tt>&quot;use Encode&quot;</tt> for that.
<tt>&quot;sv_utf8_upgrade()&quot;</tt> is affected by the
encoding pragma but <tt>&quot;sv_utf8_downgrade()&quot;</tt>
is not (since the encoding pragma is designed to be a
one-way street).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;is_utf8_string(buf, len)&quot;</tt> returns
true if <tt>&quot;len&quot;</tt> bytes of the buffer are
valid <small>UTF&minus;8</small> .</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>is_utf8_char(s)</tt> returns true if the pointer
points to a valid <small>UTF&minus;8</small> character.
However, this function should not be used because of
security concerns. Instead, use
<tt>&quot;is_utf8_string()&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;UTF8SKIP(buf)&quot;</tt> will return the
number of bytes in the <small>UTF&minus;8</small> encoded
character in the buffer. <tt>&quot;UNISKIP(chr)&quot;</tt>
will return the number of bytes required to
UTF&minus;8&minus;encode the Unicode character code point.
<tt>&quot;UTF8SKIP()&quot;</tt> is useful for example for
iterating over the characters of a
<small>UTF&minus;8</small> encoded buffer;
<tt>&quot;UNISKIP()&quot;</tt> is useful, for example, in
computing the size required for a <small>UTF&minus;8</small>
encoded buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;utf8_distance(a, b)&quot;</tt> will tell the
distance in characters between the two pointers pointing to
the same <small>UTF&minus;8</small> encoded buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;utf8_hop(s, off)&quot;</tt> will return a
pointer to a <small>UTF&minus;8</small> encoded buffer that
is <tt>&quot;off&quot;</tt> (positive or negative) Unicode
characters displaced from the <small>UTF&minus;8</small>
buffer <tt>&quot;s&quot;</tt>. Be careful not to overstep
the buffer: <tt>&quot;utf8_hop()&quot;</tt> will merrily run
off the end or the beginning of the buffer if told to do
so.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;pv_uni_display(dsv, spv, len, pvlim,
flags)&quot;</tt> and <tt>&quot;sv_uni_display(dsv, ssv,
pvlim, flags)&quot;</tt> are useful for debugging the output
of Unicode strings and scalars. By default they are useful
only for debugging--they display <b>all</b> characters as
hexadecimal code points--but with the flags
<tt>&quot;UNI_DISPLAY_ISPRINT&quot;</tt>,
<tt>&quot;UNI_DISPLAY_BACKSLASH&quot;</tt>, and
<tt>&quot;UNI_DISPLAY_QQ&quot;</tt> you can make the output
more readable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><tt>&quot;foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2,
u2)&quot;</tt> can be used to compare two strings
case-insensitively in Unicode. For case-sensitive
comparisons you can just use <tt>&quot;memEQ()&quot;</tt>
and <tt>&quot;memNE()&quot;</tt> as usual, except if one
string is in utf8 and the other isn&rsquo;t.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">For more
information, see perlapi, and <i>utf8.c</i> and
<i>utf8.h</i> in the Perl source code distribution.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Hacking Perl
to work on earlier Unicode versions (for very serious
hackers only)</b> <br>
Perl by default comes with the latest supported Unicode
version built in, but you can change to use any earlier
one.</p>

<p style="margin-left:11%; margin-top: 1em">Download the
files in the desired version of Unicode from the Unicode web
site &lt;http://www.unicode.org&gt;). These should replace
the existing files in <i>lib/unicore</i> in the Perl source
tree. Follow the instructions in <i><small>README</small>
.perl</i> in that directory to change some of their names,
and then build perl (see <small>INSTALL</small> ).</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Interaction
with Locales</b> <br>
See &quot;Unicode and <small>UTF&minus;8</small> &quot; in
perllocale</p>

<p style="margin-left:11%; margin-top: 1em"><b>Problems
with characters in the Latin&minus;1 Supplement range</b>
<br>
See &quot;The &quot;Unicode Bug&quot;&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interaction
with Extensions</b> <br>
When Perl exchanges data with an extension, the extension
should be able to understand the <small>UTF8</small> flag
and act accordingly. If the extension doesn&rsquo;t
recognize that flag, it&rsquo;s likely that the extension
will return incorrectly-flagged data.</p>

<p style="margin-left:11%; margin-top: 1em">So if
you&rsquo;re working with Unicode data, consult the
documentation of every module you&rsquo;re using if there
are any issues with Unicode data exchange. If the
documentation does not talk about Unicode at all, suspect
the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl
shouldn&rsquo;t cause problems. Modules that directly or
indirectly access code written in other programming
languages are at risk.</p>

<p style="margin-left:11%; margin-top: 1em">For affected
functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit.
Choose an encoding that you know the extension can handle.
Convert arguments passed to the extensions to that encoding
and convert results back from that encoding. Write wrapper
functions that do the conversions for you, so you can later
change the functions when the extension catches up.</p>

<p style="margin-left:11%; margin-top: 1em">To provide an
example, let&rsquo;s say the popular Foo::Bar::escape_html
function doesn&rsquo;t deal with Unicode data yet. The
wrapper function would convert the argument to raw
<small>UTF&minus;8</small> and convert the result back to
Perl&rsquo;s internal representation like so:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Sometimes, when
the extension does not convert data but just stores and
retrieves them, you will be able to use the otherwise
dangerous <i>Encode::_utf8_on()</i> function. Let&rsquo;s
say the popular <tt>&quot;Foo::Bar&quot;</tt> extension,
written in C, provides a <tt>&quot;param&quot;</tt> method
that lets you store and retrieve data according to these
prototypes:</p>

<pre style="margin-left:11%; margin-top: 1em">    $self&minus;&gt;param($name, $value);            # set a scalar
    $value = $self&minus;&gt;param($name);           # retrieve a scalar</pre>


<p style="margin-left:11%; margin-top: 1em">If it does not
yet provide support for any encoding, one could write a
derived class with such a <tt>&quot;param&quot;</tt>
method:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF&minus;8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF&minus;8 encoded
        return $self&minus;&gt;SUPER::param($name,$value);
      } else {
        my $ret = $self&minus;&gt;SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF&minus;8 encoded
        return $ret;
      }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Some extensions
provide filters on data entry/exit points, such as
DB_File::filter_store_key and family. Look out for such
filters in the documentation of your extensions, they can
make the transition to Unicode data much easier.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Speed</b>
<br>
Some functions are slower when working on
<small>UTF&minus;8</small> encoded strings than on byte
encoded strings. All functions that need to hop over
characters such as <i>length()</i>, <i>substr()</i> or
<i>index()</i>, or matching regular expressions can work
<b>much</b> faster when the underlying data are
byte-encoded.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl 5.8.0
the slowness was often quite spectacular; in Perl 5.8.1 a
caching scheme was introduced which will hopefully make the
slowness somewhat less spectacular, at least for some
operations. In general, operations with
<small>UTF&minus;8</small> encoded strings are still slower.
As an example, the Unicode properties (character classes)
like <tt>&quot;\p{Nd}&quot;</tt> are known to be quite a bit
slower (5&minus;20 times) than their simpler counterparts
like <tt>&quot;\d&quot;</tt> (then again, there are hundreds
of Unicode characters matching <tt>&quot;Nd&quot;</tt>
compared with the 10 <small>ASCII</small> characters
matching <tt>&quot;d&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Problems on
<small>EBCDIC</small> platforms</b> <br>
There are several known problems with Perl on
<small>EBCDIC</small> platforms. If you want to use Perl
there, send email to perlbug@perl.org.</p>

<p style="margin-left:11%; margin-top: 1em">In earlier
versions, when byte and character data were concatenated,
the new string was sometimes created by decoding the byte
strings as <i><small>ISO</small> 8859&minus;1
(Latin&minus;1)</i>, even if the old Unicode string used
<small>EBCDIC</small> .</p>

<p style="margin-left:11%; margin-top: 1em">If you find any
of these, please report them as bugs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Porting code
from perl&minus;5.6.X</b> <br>
Perl 5.8 has a different Unicode model from 5.6. In 5.6 the
programmer was required to use the <tt>&quot;utf8&quot;</tt>
pragma to declare that a given scope expected to deal with
Unicode data and had to make sure that only Unicode data
were reaching that scope. If you have code that is working
with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will
continue to work under 5.6, so you should be safe to try
them out.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="68%">


<p style="margin-top: 1em">A filehandle that should read or
write <small>UTF&minus;8</small></p></td>
<td width="17%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">  if ($] &gt; 5.007) {
    binmode $fh, &quot;:encoding(utf8)&quot;;
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="82%">


<p style="margin-top: 1em">A scalar that is going to be
passed to some extension</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">Be it
Compress::Zlib, Apache::Request or any extension that has no
mention of Unicode in the manpage, you need to make sure
that the <small>UTF8</small> flag is stripped off. Note that
at the time of this writing (October 2002) the mentioned
modules are not UTF&minus;8&minus;aware. Please check the
documentation to verify if this is still true.</p>

<pre style="margin-left:15%; margin-top: 1em">  if ($] &gt; 5.007) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="59%">


<p style="margin-top: 1em">A scalar we got back from an
extension</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">If you believe
the scalar comes back as <small>UTF&minus;8</small> , you
will most likely want the <small>UTF8</small> flag
restored:</p>

<pre style="margin-left:15%; margin-top: 1em">  if ($] &gt; 5.007) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="71%">


<p style="margin-top: 1em">Same thing, if you are really
sure it is <small>UTF&minus;8</small></p></td>
<td width="14%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">  if ($] &gt; 5.007) {
    require Encode;
    Encode::_utf8_on($val);
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="76%">


<p style="margin-top: 1em">A wrapper for fetchrow_array and
fetchrow_hashref</p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">When the
database contains only <small>UTF&minus;8</small> , a
wrapper function or method is a convenient way to replace
all your fetchrow_array and fetchrow_hashref calls. A
wrapper function will also make it easier to adapt to future
enhancements in your database driver. Note that at the time
of this writing (October 2002), the <small>DBI</small> has
no standardized way to deal with <small>UTF&minus;8</small>
data. Please check the documentation to verify if that is
still true.</p>

<pre style="margin-left:15%; margin-top: 1em">  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] &lt; 5.007) {
      return $sth&minus;&gt;$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth&minus;&gt;$what;
        for (@arr) {
          defined &amp;&amp; /[^\000&minus;\177]/ &amp;&amp; Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth&minus;&gt;$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            &amp;&amp; /[^\000&minus;\177]/
            &amp;&amp; Encode::_utf8_on($_) for $ret&minus;&gt;{$k};
          }
          return $ret;
        } else {
          defined &amp;&amp; /[^\000&minus;\177]/ &amp;&amp; Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="79%">


<p style="margin-top: 1em">A large scalar that you know can
only contain <small>ASCII</small></p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">Scalars that
contain only <small>ASCII</small> and are marked as
<small>UTF&minus;8</small> are sometimes a drag to your
program. If you recognize such a situation, just remove the
<small>UTF8</small> flag:</p>

<pre style="margin-left:15%; margin-top: 1em">  utf8::downgrade($val) if $] &gt; 5.007;</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlunitut,
perluniintro, perluniprops, Encode, open, utf8, bytes,
perlretut, &quot;${^UNICODE}&quot; in perlvar
&lt;http://www.unicode.org/reports/tr44&gt;).</p>
<hr>
</body>
</html>
