<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:25:53 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>interp</title>

</head>
<body>

<h1 align="center">interp</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#THE INTERP COMMAND">THE INTERP COMMAND</a><br>
<a href="#SLAVE COMMAND">SLAVE COMMAND</a><br>
<a href="#SAFE INTERPRETERS">SAFE INTERPRETERS</a><br>
<a href="#ALIAS INVOCATION">ALIAS INVOCATION</a><br>
<a href="#HIDDEN COMMANDS">HIDDEN COMMANDS</a><br>
<a href="#RESOURCE LIMITS">RESOURCE LIMITS</a><br>
<a href="#BACKGROUND ERROR HANDLING">BACKGROUND ERROR HANDLING</a><br>
<a href="#CREDITS">CREDITS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">interp &minus;
Create and manipulate Tcl interpreters</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>interp</b>
<i>subcommand</i> ?<i>arg arg ...</i>?
_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This command
makes it possible to create one or more new Tcl interpreters
that co-exist with the creating interpreter in the same
application. The creating interpreter is called the
<i>master</i> and the new interpreter is called a
<i>slave</i>. A master can create any number of slaves, and
each slave can itself create additional slaves for which it
is master, resulting in a hierarchy of interpreters.</p>

<p style="margin-left:11%; margin-top: 1em">Each
interpreter is independent from the others: it has its own
name space for commands, procedures, and global variables. A
master interpreter may create connections between its slaves
and itself using a mechanism called an <i>alias</i>. An
<i>alias</i> is a command in a slave interpreter which, when
invoked, causes a command to be invoked in its master
interpreter or in another slave interpreter. The only other
connections between interpreters are through environment
variables (the <b>env</b> variable), which are normally
shared among all interpreters in the application, and by
resource limit exceeded callbacks. Note that the
<big>&#9474;</big> name space for files (such as the names
returned by the <b>open</b> command) is no longer shared
between interpreters. Explicit commands are provided to
share files and to transfer references to open files from
one interpreter to another.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>interp</b> command also provides support for <i>safe</i>
interpreters. A safe interpreter is a slave whose functions
have been greatly restricted, so that it is safe to execute
untrusted scripts without fear of them damaging other
interpreters or the application&rsquo;s environment. For
example, all IO channel creation commands and subprocess
creation commands are made inaccessible to safe
interpreters. See <b>SAFE INTERPRETERS</b> below for more
information on what features are present in a safe
interpreter. The dangerous functionality is not removed from
the safe interpreter; instead, it is <i>hidden</i>, so that
only trusted interpreters can obtain access to it. For a
detailed explanation of hidden commands, see <b>HIDDEN
COMMANDS</b>, below. The alias mechanism can be used for
protected communication (analogous to a kernel call) between
a slave interpreter and its master. See <b>ALIAS
INVOCATION</b>, below, for more details on how the alias
mechanism works.</p>

<p style="margin-left:11%; margin-top: 1em">A qualified
interpreter name is a proper Tcl lists containing a subset
of its ancestors in the interpreter hierarchy, terminated by
the string naming the interpreter in its immediate master.
Interpreter names are relative to the interpreter in which
they are used. For example, if <b>a</b> is a slave of the
current interpreter and it has a slave <b>a1</b>, which in
turn has a slave <b>a11</b>, the qualified name of
<b>a11</b> in <b>a</b> is the list <b>a1 a11</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>interp</b> command, described below, accepts qualified
interpreter names as arguments; the interpreter in which the
command is being evaluated can always be referred to as
<b>{}</b> (the empty list or string). Note that it is
impossible to refer to a master (ancestor) interpreter by
name in a slave interpreter except through aliases. Also,
there is no global name by which one can refer to the first
interpreter created in an application. Both restrictions are
motivated by safety concerns.</p>

<h2>THE INTERP COMMAND
<a name="THE INTERP COMMAND"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>interp</b> command is used to create, delete, and
manipulate slave interpreters, and to share or transfer
channels between interpreters. It can have any of several
forms, depending on the <i>subcommand</i> argument: <b><br>
interp alias</b> <i>srcPath srcToken</i></p>

<p style="margin-left:22%;">Returns a Tcl list whose
elements are the <i>targetCmd</i> and <i>arg</i>s associated
with the alias represented by <i>srcToken</i> (this is the
value returned when the alias was created; it is possible
that the name of the source command in the slave is
different from <i>srcToken</i>).</p>

<p style="margin-left:11%;"><b>interp alias</b> <i>srcPath
srcToken</i> <b>{}</b></p>

<p style="margin-left:22%;">Deletes the alias for
<i>srcToken</i> in the slave interpreter identified by
<i>srcPath</i>. <i>srcToken</i> refers to the value returned
when the alias was created; if the source command has been
renamed, the renamed command will be deleted.</p>

<p style="margin-left:11%;"><b>interp alias</b> <i>srcPath
srcCmd targetPath targetCmd</i> ?<i>arg arg ...</i>?</p>

<p style="margin-left:22%;">This command creates an alias
between one slave and another (see the <b>alias</b> slave
command below for creating aliases between a slave and its
master). In this command, either of the slave interpreters
may be anywhere in the hierarchy of interpreters under the
interpreter invoking the command. <i>SrcPath</i> and
<i>srcCmd</i> identify the source of the alias.
<i>SrcPath</i> is a Tcl list whose elements select a
particular interpreter. For example, &ldquo;<b>a
b</b>&rdquo; identifies an interpreter <b>b</b>, which is a
slave of interpreter <b>a</b>, which is a slave of the
invoking interpreter. An empty list specifies the
interpreter invoking the command. <i>srcCmd</i> gives the
name of a new command, which will be created in the source
interpreter. <i>TargetPath</i> and <i>targetCmd</i> specify
a target interpreter and command, and the <i>arg</i>
arguments, if any, specify additional arguments to
<i>targetCmd</i> which are prepended to any arguments
specified in the invocation of <i>srcCmd</i>.
<i>TargetCmd</i> may be undefined at the time of this call,
or it may already exist; it is not created by this command.
The alias arranges for the given target command to be
invoked in the target interpreter whenever the given source
command is invoked in the source interpreter. See <b>ALIAS
INVOCATION</b> below for more details. The command returns a
token that uniquely identifies the command created
<i>srcCmd</i>, even if the command is renamed afterwards.
The token may but does not have to be equal to
<i>srcCmd</i>.</p>

<p style="margin-left:11%;"><b>interp aliases</b>
?<i>path</i>?</p>

<p style="margin-left:22%;">This command returns a Tcl list
of the tokens of all the source commands for aliases defined
in the interpreter identified by <i>path</i>. The tokens
correspond to the values returned when the aliases were
created (which may not be the same as the current names of
the commands).</p>

<p style="margin-left:11%;"><b>interp bgerror</b>
<i>path</i> ?<i>cmdPrefix</i>?</p>

<p style="margin-left:22%;">This command either gets or
sets the current background error <big>&#9474;</big> handler
for the interpreter identified by <i>path</i>. If
<i>cmdPrefix</i> is <big>&#9474;</big> absent, the current
background error handler is returned, and if
<big>&#9474;</big> it is present, it is a list of words (of
minimum length one) <big>&#9474;</big> that describes what
to set the interpreter&rsquo;s background error
<big>&#9474;</big> to. See the <b>BACKGROUND ERROR
HANDLING</b> section for more details.</p>

<p style="margin-left:11%;"><b>interp create</b>
?<b>&minus;safe</b>? ?<b>&minus;&minus;</b>?
?<i>path</i>?</p>

<p style="margin-left:22%;">Creates a slave interpreter
identified by <i>path</i> and a new command, called a
<i>slave command</i>. The name of the slave command is the
last component of <i>path</i>. The new slave interpreter and
the slave command are created in the interpreter identified
by the path obtained by removing the last component from
<i>path</i>. For example, if <i>path</i> is <b>a b c</b>
then a new slave interpreter and slave command named
<b>c</b> are created in the interpreter identified by the
path <b>a b</b>. The slave command may be used to manipulate
the new interpreter as described below. If <i>path</i> is
omitted, Tcl creates a unique name of the form
<b>interp</b><i>x</i>, where <i>x</i> is an integer, and
uses it for the interpreter and the slave command. If the
<b>&minus;safe</b> switch is specified (or if the master
interpreter is a safe interpreter), the new slave
interpreter will be created as a safe interpreter with
limited functionality; otherwise the slave will include the
full set of Tcl built-in commands and variables. The
<b>&minus;&minus;</b> switch can be used to mark the end of
switches; it may be needed if <i>path</i> is an unusual
value such as <b>&minus;safe</b>. The result of the command
is the name of the new interpreter. The name of a slave
interpreter must be unique among all the slaves for its
master; an error occurs if a slave interpreter by the given
name already exists in this master. The initial recursion
limit of the slave interpreter is set to the current
recursion limit of its parent interpreter.</p>

<p style="margin-left:11%;"><b>interp debug</b> <i>path</i>
?<i>&minus;frame</i> ?<i>bool</i>??</p>

<p style="margin-left:22%;">Controls whether frame-level
stack information is captured in the slave interpreter
identified by <i>path</i>. If no arguments are given, option
and current setting are returned. If <i>&minus;frame</i> is
given, the debug setting is set to the given boolean if
provided and the current setting is returned. This only
effects the output of <b>info frame</b>, in that exact
frame-level information for command invocation at the
bytecode level is only captured with this setting on.</p>

<p style="margin-left:22%; margin-top: 1em">For example,
with code like</p>

<p style="margin-left:32%; margin-top: 1em"><b>proc</b>
mycontrol {... script} { <br>
... <b><br>
uplevel</b> 1 $script <br>
... <br>
}</p>

<p style="margin-left:32%; margin-top: 1em"><b>proc</b>
dosomething {...} { <br>
... <br>
mycontrol { <br>
somecode <br>
} <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">the standard
setting will provide a relative line number for the command
<b>somecode</b> and the relevant frame will be of type
<b>eval</b>. With frame-debug active on the other hand the
tracking extends so far that the system will be able to
determine the file and absolute line number of this command,
and return a frame of type <b>source</b>. This more exact
information is paid for with slower execution of all
commands.</p>

<p style="margin-left:11%;"><b>interp delete</b> ?<i>path
...?</i></p>

<p style="margin-left:22%;">Deletes zero or more
interpreters given by the optional <i>path</i> arguments,
and for each interpreter, it also deletes its slaves. The
command also deletes the slave command for each interpreter
deleted. For each <i>path</i> argument, if no interpreter by
that name exists, the command raises an error.</p>

<p style="margin-left:11%;"><b>interp eval</b> <i>path
arg</i> ?<i>arg ...</i>?</p>

<p style="margin-left:22%;">This command concatenates all
of the <i>arg</i> arguments in the same fashion as the
<b>concat</b> command, then evaluates the resulting string
as a Tcl script in the slave interpreter identified by
<i>path</i>. The result of this evaluation (including all
<b>return</b> options, such as <b>&minus;errorinfo</b> and
<b>&minus;errorcode</b> information, if an error occurs) is
returned to the invoking interpreter. Note that the script
will be executed in the current context stack frame of the
<i>path</i> interpreter; this is so that the implementations
(in a master interpreter) of aliases in a slave interpreter
can execute scripts in the slave that find out information
about the slave&rsquo;s current state and stack frame.</p>

<p style="margin-left:11%;"><b>interp exists</b>
<i>path</i></p>

<p style="margin-left:22%;">Returns <b>1</b> if a slave
interpreter by the specified <i>path</i> exists in this
master, <b>0</b> otherwise. If <i>path</i> is omitted, the
invoking interpreter is used.</p>

<p style="margin-left:11%;"><b>interp expose</b> <i>path
hiddenName</i> ?<i>exposedCmdName</i>?</p>

<p style="margin-left:22%;">Makes the hidden command
<i>hiddenName</i> exposed, eventually bringing it back under
a new <i>exposedCmdName</i> name (this name is currently
accepted only if it is a valid global name space name
without any ::), in the interpreter denoted by <i>path</i>.
If an exposed command with the targeted name already exists,
this command fails. Hidden commands are explained in more
detail in <b>HIDDEN COMMANDS</b>, below.</p>

<p style="margin-left:11%;"><b>interp hide</b> <i>path
exposedCmdName</i> ?<i>hiddenCmdName</i>?</p>

<p style="margin-left:22%;">Makes the exposed command
<i>exposedCmdName</i> hidden, renaming it to the hidden
command <i>hiddenCmdName</i>, or keeping the same name if
<i>hiddenCmdName</i> is not given, in the interpreter
denoted by <i>path</i>. If a hidden command with the
targeted name already exists, this command fails. Currently
both <i>exposedCmdName</i> and <i>hiddenCmdName</i> can not
contain namespace qualifiers, or an error is raised.
Commands to be hidden by <b>interp hide</b> are looked up in
the global namespace even if the current namespace is not
the global one. This prevents slaves from fooling a master
interpreter into hiding the wrong command, by making the
current namespace be different from the global one. Hidden
commands are explained in more detail in <b>HIDDEN
COMMANDS</b>, below.</p>

<p style="margin-left:11%;"><b>interp hidden</b>
<i>path</i></p>

<p style="margin-left:22%;">Returns a list of the names of
all hidden commands in the interpreter identified by
<i>path</i>.</p>

<p style="margin-left:11%;"><b>interp invokehidden</b>
<i>path</i> ?<i>&minus;option ...</i>? <i>hiddenCmdName</i>
?<i>arg ...</i>?</p>

<p style="margin-left:22%;">Invokes the hidden command
<i>hiddenCmdName</i> with the arguments supplied in the
interpreter denoted by <i>path</i>. No substitutions or
evaluation are applied to the arguments. Three
<i>&minus;option</i>s are supported, all of which start with
<b>&minus;</b>: <b>&minus;namespace</b> (which takes a
single argument afterwards, <i>nsName</i>),
<b>&minus;global</b>, and <b>&minus;&minus;</b>. If the
<b>&minus;namespace</b> flag is present, the hidden command
is invoked in the namespace called <i>nsName</i> in the
target interpreter. If the <b>&minus;global</b> flag is
present, the hidden command is invoked at the global level
in the target interpreter; otherwise it is invoked at the
current call frame and can access local variables in that
and outer call frames. The <b>&minus;&minus;</b> flag allows
the <i>hiddenCmdName</i> argument to start with a
&ldquo;&minus;&rdquo; character, and is otherwise
unnecessary. If both the <b>&minus;namespace</b> and
<b>&minus;global</b> flags are present, the
<b>&minus;namespace</b> flag is ignored. Note that the
hidden command will be executed (by default) in the current
context stack frame of the <i>path</i> interpreter. Hidden
commands are explained in more detail in <b>HIDDEN
COMMANDS</b>, below.</p>

<p style="margin-left:11%;"><b>interp limit</b> <i>path
limitType</i> ?<i>&minus;option</i>? ?<i>value ...</i>?</p>

<p style="margin-left:22%;">Sets up, manipulates and
queries the configuration of the <big>&#9474;</big> resource
limit <i>limitType</i> for the interpreter denoted by
<i>path</i>. <big>&#9474;</big> If no <i>&minus;option</i>
is specified, return the current configuration of
<big>&#9474;</big> the limit. If <i>&minus;option</i> is the
sole argument, return the value of <big>&#9474;</big> that
option. Otherwise, a list of
<i>&minus;option</i>/<i>value</i> argument pairs
<big>&#9474;</big> must supplied. See <b>RESOURCE LIMITS</b>
below for a more detailed <big>&#9474;</big> explanation of
what limits and options are supported.</p>

<p style="margin-left:11%;"><b>interp issafe</b>
?<i>path</i>?</p>

<p style="margin-left:22%;">Returns <b>1</b> if the
interpreter identified by the specified <i>path</i> is safe,
<b>0</b> otherwise.</p>

<p style="margin-left:11%;"><b>interp marktrusted</b>
<i>path</i></p>

<p style="margin-left:22%;">Marks the interpreter
identified by <i>path</i> as trusted. Does not expose the
hidden commands. This command can only be invoked from a
trusted interpreter. The command has no effect if the
interpreter identified by <i>path</i> is already
trusted.</p>

<p style="margin-left:11%;"><b>interp recursionlimit</b>
<i>path</i> ?<i>newlimit</i>?</p>

<p style="margin-left:22%;">Returns the maximum allowable
nesting depth for the interpreter specified by <i>path</i>.
If <i>newlimit</i> is specified, the interpreter recursion
limit will be set so that nesting of more than
<i>newlimit</i> calls to <b>Tcl_Eval()</b> and related
procedures in that interpreter will return an error. The
<i>newlimit</i> value is also returned. The <i>newlimit</i>
value must be a positive integer between 1 and the maximum
value of a non-long integer on the platform.</p>

<p style="margin-left:22%; margin-top: 1em">The command
sets the maximum size of the Tcl call stack only. It cannot
by itself prevent stack overflows on the C stack being used
by the application. If your machine has a limit on the size
of the C stack, you may get stack overflows before reaching
the limit set by the command. If this happens, see if there
is a mechanism in your system for increasing the maximum
size of the C stack.</p>

<p style="margin-left:11%;"><b>interp share</b> <i>srcPath
channelId destPath</i></p>

<p style="margin-left:22%;">Causes the IO channel
identified by <i>channelId</i> to become shared between the
interpreter identified by <i>srcPath</i> and the interpreter
identified by <i>destPath</i>. Both interpreters have the
same permissions on the IO channel. Both interpreters must
close it to close the underlying IO channel; IO channels
accessible in an interpreter are automatically closed when
an interpreter is destroyed.</p>

<p style="margin-left:11%;"><b>interp slaves</b>
?<i>path</i>?</p>

<p style="margin-left:22%;">Returns a Tcl list of the names
of all the slave interpreters associated with the
interpreter identified by <i>path</i>. If <i>path</i> is
omitted, the invoking interpreter is used.</p>

<p style="margin-left:11%;"><b>interp target</b> <i>path
alias</i></p>

<p style="margin-left:22%;">Returns a Tcl list describing
the target interpreter for an alias. The alias is specified
with an interpreter path and source command name, just as in
<b>interp alias</b> above. The name of the target
interpreter is returned as an interpreter path, relative to
the invoking interpreter. If the target interpreter for the
alias is the invoking interpreter then an empty list is
returned. If the target interpreter for the alias is not the
invoking interpreter or one of its descendants then an error
is generated. The target command does not have to be defined
at the time of this invocation.</p>

<p style="margin-left:11%;"><b>interp transfer</b>
<i>srcPath channelId destPath</i></p>

<p style="margin-left:22%;">Causes the IO channel
identified by <i>channelId</i> to become available in the
interpreter identified by <i>destPath</i> and unavailable in
the interpreter identified by <i>srcPath</i>.</p>

<h2>SLAVE COMMAND
<a name="SLAVE COMMAND"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For each slave
interpreter created with the <b>interp</b> command, a new
Tcl command is created in the master interpreter with the
same name as the new interpreter. This command may be used
to invoke various operations on the interpreter. It has the
following general form:</p>

<p style="margin-left:22%;"><i>slave command</i> ?<i>arg
arg ...</i>?</p>

<p style="margin-left:11%;"><i>Slave</i> is the name of the
interpreter, and <i>command</i> and the <i>arg</i>s
determine the exact behavior of the command. The valid forms
of this command are: <i><br>
slave</i> <b>aliases</b></p>

<p style="margin-left:22%;">Returns a Tcl list whose
elements are the tokens of all the aliases in <i>slave</i>.
The tokens correspond to the values returned when the
aliases were created (which may not be the same as the
current names of the commands).</p>

<p style="margin-left:11%;"><i>slave</i> <b>alias</b>
<i>srcToken</i></p>

<p style="margin-left:22%;">Returns a Tcl list whose
elements are the <i>targetCmd</i> and <i>arg</i>s associated
with the alias represented by <i>srcToken</i> (this is the
value returned when the alias was created; it is possible
that the actual source command in the slave is different
from <i>srcToken</i>).</p>

<p style="margin-left:11%;"><i>slave</i> <b>alias</b>
<i>srcToken</i> <b>{}</b></p>

<p style="margin-left:22%;">Deletes the alias for
<i>srcToken</i> in the slave interpreter. <i>srcToken</i>
refers to the value returned when the alias was created; if
the source command has been renamed, the renamed command
will be deleted.</p>

<p style="margin-left:11%;"><i>slave</i> <b>alias</b>
<i>srcCmd targetCmd</i> ?<i>arg ..</i>?</p>

<p style="margin-left:22%;">Creates an alias such that
whenever <i>srcCmd</i> is invoked in <i>slave</i>,
<i>targetCmd</i> is invoked in the master. The <i>arg</i>
arguments will be passed to <i>targetCmd</i> as additional
arguments, prepended before any arguments passed in the
invocation of <i>srcCmd</i>. See <b>ALIAS INVOCATION</b>
below for details. The command returns a token that uniquely
identifies the command created <i>srcCmd</i>, even if the
command is renamed afterwards. The token may but does not
have to be equal to <i>srcCmd</i>.</p>

<p style="margin-left:11%;"><i>slave</i> <b>bgerror</b>
?<i>cmdPrefix</i>?</p>

<p style="margin-left:22%;">This command either gets or
sets the current background error <big>&#9474;</big> handler
for the <i>slave</i> interpreter. If <i>cmdPrefix</i> is
absent, the <big>&#9474;</big> current background error
handler is returned, and if it is <big>&#9474;</big>
present, it is a list of words (of minimum length one) that
<big>&#9474;</big> describes what to set the
interpreter&rsquo;s background error to. See
<big>&#9474;</big> the <b>BACKGROUND ERROR HANDLING</b>
section for more details.</p>

<p style="margin-left:11%;"><i>slave</i> <b>eval</b>
<i>arg</i> ?<i>arg ..</i>?</p>

<p style="margin-left:22%;">This command concatenates all
of the <i>arg</i> arguments in the same fashion as the
<b>concat</b> command, then evaluates the resulting string
as a Tcl script in <i>slave</i>. The result of this
evaluation (including all <b>return</b> options, such as
<b>&minus;errorinfo</b> and <b>&minus;errorcode</b>
information, if an error occurs) is returned to the invoking
interpreter. Note that the script will be executed in the
current context stack frame of <i>slave</i>; this is so that
the implementations (in a master interpreter) of aliases in
a slave interpreter can execute scripts in the slave that
find out information about the slave&rsquo;s current state
and stack frame.</p>

<p style="margin-left:11%;"><i>slave</i> <b>expose</b>
<i>hiddenName</i> ?<i>exposedCmdName</i>?</p>

<p style="margin-left:22%;">This command exposes the hidden
command <i>hiddenName</i>, eventually bringing it back under
a new <i>exposedCmdName</i> name (this name is currently
accepted only if it is a valid global name space name
without any ::), in <i>slave</i>. If an exposed command with
the targeted name already exists, this command fails. For
more details on hidden commands, see <b>HIDDEN COMMANDS</b>,
below.</p>

<p style="margin-left:11%;"><i>slave</i> <b>hide</b>
<i>exposedCmdName</i> ?<i>hiddenCmdName</i>?</p>

<p style="margin-left:22%;">This command hides the exposed
command <i>exposedCmdName</i>, renaming it to the hidden
command <i>hiddenCmdName</i>, or keeping the same name if
the argument is not given, in the <i>slave</i> interpreter.
If a hidden command with the targeted name already exists,
this command fails. Currently both <i>exposedCmdName</i> and
<i>hiddenCmdName</i> can not contain namespace qualifiers,
or an error is raised. Commands to be hidden are looked up
in the global namespace even if the current namespace is not
the global one. This prevents slaves from fooling a master
interpreter into hiding the wrong command, by making the
current namespace be different from the global one. For more
details on hidden commands, see <b>HIDDEN COMMANDS</b>,
below.</p>

<p style="margin-left:11%;"><i>slave</i> <b>hidden</b></p>

<p style="margin-left:22%;">Returns a list of the names of
all hidden commands in <i>slave</i>.</p>

<p style="margin-left:11%;"><i>slave</i>
<b>invokehidden</b> ?<i>&minus;option ...</i>?
<i>hiddenName</i> ?<i>arg ..</i>?</p>

<p style="margin-left:22%;">This command invokes the hidden
command <i>hiddenName</i> with the supplied arguments, in
<i>slave</i>. No substitutions or evaluations are applied to
the arguments. Three <i>&minus;option</i>s are supported,
all of which start with <b>&minus;</b>:
<b>&minus;namespace</b> (which takes a single argument
afterwards, <i>nsName</i>), <b>&minus;global</b>, and
<b>&minus;&minus;</b>. If the <b>&minus;namespace</b> flag
is given, the hidden command is invoked in the specified
namespace in the slave. If the <b>&minus;global</b> flag is
given, the command is invoked at the global level in the
slave; otherwise it is invoked at the current call frame and
can access local variables in that or outer call frames. The
<b>&minus;&minus;</b> flag allows the <i>hiddenCmdName</i>
argument to start with a &ldquo;&minus;&rdquo; character,
and is otherwise unnecessary. If both the
<b>&minus;namespace</b> and <b>&minus;global</b> flags are
given, the <b>&minus;namespace</b> flag is ignored. Note
that the hidden command will be executed (by default) in the
current context stack frame of <i>slave</i>. For more
details on hidden commands, see <b>HIDDEN COMMANDS</b>,
below.</p>

<p style="margin-left:11%;"><i>slave</i> <b>issafe</b></p>

<p style="margin-left:22%;">Returns <b>1</b> if the slave
interpreter is safe, <b>0</b> otherwise.</p>

<p style="margin-left:11%;"><i>slave</i> <b>limit</b>
<i>limitType</i> ?<i>&minus;option</i>? ?<i>value
...</i>?</p>

<p style="margin-left:22%;">Sets up, manipulates and
queries the configuration of the <big>&#9474;</big> resource
limit <i>limitType</i> for the slave interpreter. If no
<big>&#9474;</big> <i>&minus;option</i> is specified, return
the current configuration of the <big>&#9474;</big> limit.
If <i>&minus;option</i> is the sole argument, return the
value of <big>&#9474;</big> that option. Otherwise, a list
of <i>&minus;option</i>/<i>value</i> argument pairs
<big>&#9474;</big> must supplied. See <b>RESOURCE LIMITS</b>
below for a more detailed <big>&#9474;</big> explanation of
what limits and options are supported.</p>

<p style="margin-left:11%;"><i>slave</i>
<b>marktrusted</b></p>

<p style="margin-left:22%;">Marks the slave interpreter as
trusted. Can only be invoked by a trusted interpreter. This
command does not expose any hidden commands in the slave
interpreter. The command has no effect if the slave is
already trusted.</p>

<p style="margin-left:11%;"><i>slave</i>
<b>recursionlimit</b> ?<i>newlimit</i>?</p>

<p style="margin-left:22%;">Returns the maximum allowable
nesting depth for the <i>slave</i> interpreter. If
<i>newlimit</i> is specified, the recursion limit in
<i>slave</i> will be set so that nesting of more than
<i>newlimit</i> calls to <b>Tcl_Eval()</b> and related
procedures in <i>slave</i> will return an error. The
<i>newlimit</i> value is also returned. The <i>newlimit</i>
value must be a positive integer between 1 and the maximum
value of a non-long integer on the platform.</p>

<p style="margin-left:22%; margin-top: 1em">The command
sets the maximum size of the Tcl call stack only. It cannot
by itself prevent stack overflows on the C stack being used
by the application. If your machine has a limit on the size
of the C stack, you may get stack overflows before reaching
the limit set by the command. If this happens, see if there
is a mechanism in your system for increasing the maximum
size of the C stack.</p>

<h2>SAFE INTERPRETERS
<a name="SAFE INTERPRETERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A safe
interpreter is one with restricted functionality, so that is
safe to execute an arbitrary script from your worst enemy
without fear of that script damaging the enclosing
application or the rest of your computing environment. In
order to make an interpreter safe, certain commands and
variables are removed from the interpreter. For example,
commands to create files on disk are removed, and the
<b>exec</b> command is removed, since it could be used to
cause damage through subprocesses. Limited access to these
facilities can be provided, by creating aliases to the
master interpreter which check their arguments carefully and
provide restricted access to a safe subset of facilities.
For example, file creation might be allowed in a particular
subdirectory and subprocess invocation might be allowed for
a carefully selected and fixed set of programs.</p>

<p style="margin-left:11%; margin-top: 1em">A safe
interpreter is created by specifying the <b>&minus;safe</b>
switch to the <b>interp create</b> command. Furthermore, any
slave created by a safe interpreter will also be safe.</p>

<p style="margin-left:11%; margin-top: 1em">A safe
interpreter is created with exactly the following set of
built-in commands: <b>after append apply array binary break
catch chan clock close concat continue dict eof error eval
expr fblocked fcopy fileevent flush for foreach format gets
global if incr info interp join lappend lassign lindex
linsert list llength lrange lrepeat lreplace lsearch lset
lsort namespace package pid proc puts read regexp regsub
rename return scan seek set split string subst switch tell
time trace unset update uplevel upvar variable vwait
while</b> The following commands are hidden by <b>interp
create</b> when it creates a safe interpreter: <b>cd
encoding exec exit fconfigure file glob load open pwd socket
source unload</b> These commands can be recreated later as
Tcl procedures or aliases, or re-exposed by <b>interp
expose</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
commands from Tcl&rsquo;s library of support procedures are
not present in a safe interpreter: <b>auto_exec_ok
auto_import auto_load auto_load_index auto_qualify
unknown</b> Note in particular that safe interpreters have
no default <b>unknown</b> command, so Tcl&rsquo;s default
autoloading facilities are not available. Autoload access to
Tcl&rsquo;s commands that are normally autoloaded:
<b>auto_mkindex auto_mkindex_old auto_reset history parray
pkg_mkIndex ::pkg::create ::safe::interpAddToAccessPath
::safe::interpCreate ::safe::interpConfigure
::safe::interpDelete ::safe::interpFindInAccessPath
::safe::interpInit ::safe::setLogCmd tcl_endOfWord
tcl_findLibrary tcl_startOfNextWord tcl_startOfPreviousWord
tcl_wordBreakAfter tcl_wordBreakBefore</b> can only be
provided by explicit definition of an <b>unknown</b> command
in the safe interpreter. This will involve exposing the
<b>source</b> command. This is most easily accomplished by
creating the safe interpreter with Tcl&rsquo;s
<b>Safe&minus;Tcl</b> mechanism. <b>Safe&minus;Tcl</b>
provides safe versions of <b>source</b>, <b>load</b>, and
other Tcl commands needed to support autoloading of commands
and the loading of packages.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
the <b>env</b> variable is not present in a safe
interpreter, so it cannot share environment variables with
other interpreters. The <b>env</b> variable poses a security
risk, because users can store sensitive information in an
environment variable. For example, the PGP manual recommends
storing the PGP private key protection password in the
environment variable <i>PGPPASS</i>. Making this variable
available to untrusted code executing in a safe interpreter
would incur a security risk.</p>

<p style="margin-left:11%; margin-top: 1em">If extensions
are loaded into a safe interpreter, they may also restrict
their own functionality to eliminate unsafe commands. For a
discussion of management of extensions for safety see the
manual entries for <b>Safe&minus;Tcl</b> and the <b>load</b>
Tcl command.</p>

<p style="margin-left:11%; margin-top: 1em">A safe
interpreter may not alter the recursion limit of any
interpreter, including itself.</p>

<h2>ALIAS INVOCATION
<a name="ALIAS INVOCATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The alias
mechanism has been carefully designed so that it can be used
safely when an untrusted script is executing in a safe slave
and the target of the alias is a trusted master. The most
important thing in guaranteeing safety is to ensure that
information passed from the slave to the master is never
evaluated or substituted in the master; if this were to
occur, it would enable an evil script in the slave to invoke
arbitrary functions in the master, which would compromise
security.</p>

<p style="margin-left:11%; margin-top: 1em">When the source
for an alias is invoked in the slave interpreter, the usual
Tcl substitutions are performed when parsing that command.
These substitutions are carried out in the source
interpreter just as they would be for any other command
invoked in that interpreter. The command procedure for the
source command takes its arguments and merges them with the
<i>targetCmd</i> and <i>arg</i>s for the alias to create a
new array of arguments. If the words of <i>srcCmd</i> were
&ldquo;<i>srcCmd arg1 arg2 ... argN</i>&rdquo;, the new set
of words will be &ldquo;<i>targetCmd arg arg ... arg arg1
arg2 ... argN</i>&rdquo;, where <i>targetCmd</i> and
<i>arg</i>s are the values supplied when the alias was
created. <i>TargetCmd</i> is then used to locate a command
procedure in the target interpreter, and that command
procedure is invoked with the new set of arguments. An error
occurs if there is no command named <i>targetCmd</i> in the
target interpreter. No additional substitutions are
performed on the words: the target command procedure is
invoked directly, without going through the normal Tcl
evaluation mechanism. Substitutions are thus performed on
each word exactly once: <i>targetCmd</i> and <i>args</i>
were substituted when parsing the command that created the
alias, and <i>arg1 - argN</i> are substituted when the
alias&rsquo;s source command is parsed in the source
interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">When writing
the <i>targetCmd</i>s for aliases in safe interpreters, it
is very important that the arguments to that command never
be evaluated or substituted, since this would provide an
escape mechanism whereby the slave interpreter could execute
arbitrary code in the master. This in turn would compromise
the security of the system.</p>

<h2>HIDDEN COMMANDS
<a name="HIDDEN COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Safe
interpreters greatly restrict the functionality available to
Tcl programs executing within them. Allowing the untrusted
Tcl program to have direct access to this functionality is
unsafe, because it can be used for a variety of attacks on
the environment. However, there are times when there is a
legitimate need to use the dangerous functionality in the
context of the safe interpreter. For example, sometimes a
program must be <b>source</b>d into the interpreter. Another
example is Tk, where windows are bound to the hierarchy of
windows for a specific interpreter; some potentially
dangerous functions, e.g. window management, must be
performed on these windows within the interpreter
context.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>interp</b> command provides a solution to this problem in
the form of <i>hidden commands</i>. Instead of removing the
dangerous commands entirely from a safe interpreter, these
commands are hidden so they become unavailable to Tcl
scripts executing in the interpreter. However, such hidden
commands can be invoked by any trusted ancestor of the safe
interpreter, in the context of the safe interpreter, using
<b>interp invoke</b>. Hidden commands and exposed commands
reside in separate name spaces. It is possible to define a
hidden command and an exposed command by the same name
within one interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">Hidden commands
in a slave interpreter can be invoked in the body of
procedures called in the master during alias invocation. For
example, an alias for <b>source</b> could be created in a
slave interpreter. When it is invoked in the slave
interpreter, a procedure is called in the master interpreter
to check that the operation is allowable (e.g. it asks to
source a file that the slave interpreter is allowed to
access). The procedure then it invokes the hidden
<b>source</b> command in the slave interpreter to actually
source in the contents of the file. Note that two commands
named <b>source</b> exist in the slave interpreter: the
alias, and the hidden command.</p>

<p style="margin-left:11%; margin-top: 1em">Because a
master interpreter may invoke a hidden command as part of
handling an alias invocation, great care must be taken to
avoid evaluating any arguments passed in through the alias
invocation. Otherwise, malicious slave interpreters could
cause a trusted master interpreter to execute dangerous
commands on their behalf. See the section on <b>ALIAS
INVOCATION</b> for a more complete discussion of this topic.
To help avoid this problem, no substitutions or evaluations
are applied to arguments of <b>interp invokehidden</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Safe
interpreters are not allowed to invoke hidden commands in
themselves or in their descendants. This prevents safe
slaves from gaining access to hidden functionality in
themselves or their descendants.</p>

<p style="margin-left:11%; margin-top: 1em">The set of
hidden commands in an interpreter can be manipulated by a
trusted interpreter using <b>interp expose</b> and <b>interp
hide</b>. The <b>interp expose</b> command moves a hidden
command to the set of exposed commands in the interpreter
identified by <i>path</i>, potentially renaming the command
in the process. If an exposed command by the targeted name
already exists, the operation fails. Similarly, <b>interp
hide</b> moves an exposed command to the set of hidden
commands in that interpreter. Safe interpreters are not
allowed to move commands between the set of hidden and
exposed commands, in either themselves or their
descendants.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, the
names of hidden commands cannot contain namespace
qualifiers, and you must first rename a command in a
namespace to the global namespace before you can hide it.
Commands to be hidden by <b>interp hide</b> are looked up in
the global namespace even if the current namespace is not
the global one. This prevents slaves from fooling a master
interpreter into hiding the wrong command, by making the
current namespace be different from the global one.</p>

<h2>RESOURCE LIMITS
<a name="RESOURCE LIMITS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Every
interpreter has two kinds of resource limits that may be
imposed <big>&#9474;</big> by any master interpreter upon
its slaves. Command limits (of type <big>&#9474;</big>
<b>command</b>) restrict the total number of Tcl commands
that may be executed <big>&#9474;</big> by an interpreter
(as can be inspected via the <b>info cmdcount</b> command),
<big>&#9474;</big> and time limits (of type <b>time</b>)
place a limit by which execution within <big>&#9474;</big>
the interpreter must complete. Note that time limits are
expressed as <big>&#9474;</big> <i>absolute</i> times (as in
<b>clock seconds</b>) and not relative times (as in
<big>&#9474;</big> <b>after</b>) because they may be
modified after creation. <big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">When a limit is
exceeded for an interpreter, first any handler
<big>&#9474;</big> callbacks defined by master interpreters
are called. If those callbacks <big>&#9474;</big> increase
or remove the limit, execution within the (previously)
limited <big>&#9474;</big> interpreter continues. If the
limit is still in force, an error is <big>&#9474;</big>
generated at that point and normal processing of errors
within the <big>&#9474;</big> interpreter (by the
<b>catch</b> command) is disabled, so the error propagates
<big>&#9474;</big> outwards (building a stack-trace as it
goes) to the point where the <big>&#9474;</big> limited
interpreter was invoked (e.g. by <b>interp eval</b>) where
it becomes <big>&#9474;</big> the responsibility of the
calling code to catch and handle. <big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>LIMIT
OPTIONS</b> <big>&#9474;</big> <br>
Every limit has a number of options associated with it, some
of which <big>&#9474;</big> are common across all kinds of
limits, and others of which are <big>&#9474;</big>
particular to the kind of limit. <b><br>
&minus;command</b></p>

<p style="margin-left:22%;">This option (common for all
limit types) specifies (if <big>&#9474;</big> non-empty) a
Tcl script to be executed in the global namespace
<big>&#9474;</big> of the interpreter reading and writing
the option when the <big>&#9474;</big> particular limit in
the limited interpreter is exceeded. The <big>&#9474;</big>
callback may modify the limit on the interpreter if it
wishes <big>&#9474;</big> the limited interpreter to
continue executing. If the callback <big>&#9474;</big>
generates an error, it is reported through the background
error <big>&#9474;</big> mechanism (see <b>BACKGROUND ERROR
HANDLING</b>). Note that the <big>&#9474;</big> callbacks
defined by one interpreter are completely isolated
<big>&#9474;</big> from the callbacks defined by another,
and that the order in <big>&#9474;</big> which those
callbacks are called is undefined.</p>

<p style="margin-left:11%;"><b>&minus;granularity</b></p>

<p style="margin-left:22%;">This option (common for all
limit types) specifies how <big>&#9474;</big> frequently
(out of the points when the Tcl interpreter is in a
<big>&#9474;</big> consistent state where limit checking is
possible) that the <big>&#9474;</big> limit is actually
checked. This allows the tuning of how <big>&#9474;</big>
frequently a limit is checked, and hence how often the
<big>&#9474;</big> limit-checking overhead (which may be
substantial in the case of <big>&#9474;</big> time limits)
is incurred.</p>

<p style="margin-left:11%;"><b>&minus;milliseconds</b></p>

<p style="margin-left:22%;">This option specifies the
number of milliseconds after the <big>&#9474;</big> moment
defined in the <b>&minus;seconds</b> option that the time
limit will <big>&#9474;</big> fire. It should only ever be
specified in conjunction with the <big>&#9474;</big>
<b>&minus;seconds</b> option (whether it was set previously
or is being set <big>&#9474;</big> this invocation.)</p>

<p style="margin-left:11%;"><b>&minus;seconds</b></p>

<p style="margin-left:22%;">This option specifies the
number of seconds after the epoch (see <big>&#9474;</big>
<b>clock seconds</b>) that the time limit for the
interpreter will be <big>&#9474;</big> triggered. The limit
will be triggered at the start of the <big>&#9474;</big>
second unless specified at a sub-second level using the
<big>&#9474;</big> <b>&minus;milliseconds</b> option. This
option may be the empty string, which <big>&#9474;</big>
indicates that a time limit is not set for the
interpreter.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;value</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This option specifies the number of commands that the
<big>&#9474;</big> interpreter may execute before triggering
the command limit. <big>&#9474;</big> This option may be the
empty string, which indicates that a <big>&#9474;</big>
command limit is not set for the interpreter.
<big>&#9474;</big></p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Where an
interpreter with a resource limit set on it creates a slave
<big>&#9474;</big> interpreter, that slave interpreter will
have resource limits imposed <big>&#9474;</big> on it that
are at least as restrictive as the limits on the creating
<big>&#9474;</big> master interpreter. If the master
interpreter of the limited master <big>&#9474;</big> wishes
to relax these conditions, it should hide the <b>interp</b>
command in <big>&#9474;</big> the child and then use aliases
and the <b>interp invokehidden</b> subcommand
<big>&#9474;</big> to provide such access as it chooses to
the <b>interp</b> command to the <big>&#9474;</big> limited
master as necessary. <big>&#9474;</big></p>

<h2>BACKGROUND ERROR HANDLING
<a name="BACKGROUND ERROR HANDLING"></a>
</h2>


<p style="margin-top: 1em"><big>&#9474;</big></p>

<p style="margin-left:11%;">When an error happens in a
situation where it cannot be reported <big>&#9474;</big>
directly up the stack (e.g. when processing events in an
<b>update</b> or <big>&#9474;</big> <b>vwait</b> call) the
error is instead reported through the background error
<big>&#9474;</big> handling mechanism. Every interpreter has
a background error handler <big>&#9474;</big> registered;
the default error handler arranges for the <b>bgerror</b>
command <big>&#9474;</big> in the interpreter&rsquo;s global
namespace to be called, but other error <big>&#9474;</big>
handlers may be installed and process background errors in
<big>&#9474;</big> substantially different ways.
<big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">A background
error handler consists of a non-empty list of words to
<big>&#9474;</big> which will be appended two further words
at invocation time. The first <big>&#9474;</big> word will
be the error message string, and the second will a
dictionary <big>&#9474;</big> of return options (this is
also the sort of information that can be <big>&#9474;</big>
obtained by trapping a normal error using <b>catch</b> of
course.) The <big>&#9474;</big> resulting list will then be
executed in the interpreter&rsquo;s global
<big>&#9474;</big> namespace without further substitutions
being performed.</p>

<h2>CREDITS
<a name="CREDITS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The safe
interpreter mechanism is based on the Safe-Tcl prototype
implemented by Nathaniel Borenstein and Marshall Rose.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Creating and
using an alias for a command in the current interpreter:</p>

<p style="margin-left:22%;"><b>interp alias</b> {} getIndex
{} lsearch {alpha beta gamma delta} <br>
set idx [getIndex delta]</p>

<p style="margin-left:11%; margin-top: 1em">Executing an
arbitrary command in a safe interpreter where every
invocation of <b>lappend</b> is logged:</p>

<p style="margin-left:22%;">set i [<b>interp create</b>
-safe] <b><br>
interp hide</b> $i lappend <b><br>
interp alias</b> $i lappend {} loggedLappend $i <br>
proc loggedLappend {i args} { <br>
puts &quot;logged invocation of lappend $args&quot; <b><br>
interp invokehidden</b> $i lappend {*}$args <br>
} <b><br>
interp eval</b> $i $someUntrustedScript</p>

<p style="margin-left:11%; margin-top: 1em">Setting a
resource limit on an interpreter so that an infinite loop
<big>&#9474;</big> terminates. <big>&#9474;</big></p>

<p style="margin-left:22%;">set i [<b>interp create</b>]
<big>&#9474;</big> <b><br>
interp limit</b> $i command -value 1000 <big>&#9474;</big>
<b><br>
interp eval</b> $i { <big>&#9474;</big> <br>
set x 0 <big>&#9474;</big> <br>
while {1} { <big>&#9474;</big> <br>
puts &quot;Counting up... [incr x]&quot; <big>&#9474;</big>
<br>
} <big>&#9474;</big> <br>
} <big>&#9474;</big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">bgerror(n),
load(n), safe(n), Tcl_CreateSlave(3)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">alias, master
interpreter, safe interpreter, slave interpreter</p>
<hr>
</body>
</html>
