<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:01:31 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FCNTL</title>

</head>
<body>

<h1 align="center">FCNTL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fcntl &minus;
manipulate file descriptor</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;unistd.h&gt; <br>
#include &lt;fcntl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
fcntl(int</b> <i>fd</i><b>, int</b> <i>cmd</i><b>, ...
/*</b> <i>arg</i> <b>*/ );</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>fcntl</b>()
performs one of the operations described below on the open
file descriptor <i>fd</i>. The operation is determined by
<i>cmd</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>fcntl</b>()
can take an optional third argument. Whether or not this
argument is required is determined by <i>cmd</i>. The
required argument type is indicated in parentheses after
each <i>cmd</i> name (in most cases, the required type is
<i>int</i>, and we identify the argument using the name
<i>arg</i>), or <i>void</i> is specified if the argument is
not required.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Duplicating
a file descriptor <br>
F_DUPFD</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Find the lowest numbered
available file descriptor greater than or equal to
<i>arg</i> and make it be a copy of <i>fd</i>. This is
different from <b>dup2</b>(2), which uses exactly the
descriptor specified.</p>

<p style="margin-left:22%; margin-top: 1em">On success, the
new descriptor is returned.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>dup</b>(2) for further details.</p>

<p style="margin-left:11%;"><b>F_DUPFD_CLOEXEC</b>
(<i>int</i>; since Linux 2.6.24)</p>

<p style="margin-left:22%;">As for <b>F_DUPFD</b>, but
additionally set the close-on-exec flag for the duplicate
descriptor. Specifying this flag permits a program to avoid
an additional <b>fcntl</b>() <b>F_SETFD</b> operation to set
the <b>FD_CLOEXEC</b> flag. For an explanation of why this
flag is useful, see the description of <b>O_CLOEXEC</b> in
<b>open</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
descriptor flags</b> <br>
The following commands manipulate the flags associated with
a file descriptor. Currently, only one such flag is defined:
<b>FD_CLOEXEC</b>, the close-on-exec flag. If the
<b>FD_CLOEXEC</b> bit is 0, the file descriptor will remain
open across an <b>execve</b>(2), otherwise it will be
closed. <b><br>
F_GETFD</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Read the file descriptor flags;
<i>arg</i> is ignored.</p>

<p style="margin-left:11%;"><b>F_SETFD</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set the file descriptor flags
to the value specified by <i>arg</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File status
flags</b> <br>
Each open file description has certain associated status
flags, initialized by <b>open</b>(2) and possibly modified
by <b>fcntl</b>(). Duplicated file descriptors (made with
<b>dup</b>(2), <b>fcntl</b>(F_DUPFD), <b>fork</b>(2), etc.)
refer to the same open file description, and thus share the
same file status flags.</p>

<p style="margin-left:11%; margin-top: 1em">The file status
flags and their semantics are described in <b>open</b>(2).
<b><br>
F_GETFL</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Get the file access mode and
the file status flags; <i>arg</i> is ignored.</p>

<p style="margin-left:11%;"><b>F_SETFL</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set the file status flags to
the value specified by <i>arg</i>. File access mode
(<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file
creation flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>,
<b>O_NOCTTY</b>, <b>O_TRUNC</b>) in <i>arg</i> are ignored.
On Linux this command can change only the <b>O_APPEND</b>,
<b>O_ASYNC</b>, <b>O_DIRECT</b>, <b>O_NOATIME</b>, and
<b>O_NONBLOCK</b> flags.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Advisory
locking <br>
F_GETLK</b>, <b>F_SETLK</b> and <b>F_SETLKW</b> are used to
acquire, release, and test for the existence of record locks
(also known as file-segment or file-region locks). The third
argument, <i>lock</i>, is a pointer to a structure that has
at least the following fields (in unspecified order).</p>

<p style="margin-left:17%; margin-top: 1em">struct flock {
<br>
... <br>
short l_type; /* Type of lock: F_RDLCK, <br>
F_WRLCK, F_UNLCK */ <br>
short l_whence; /* How to interpret l_start: <br>
SEEK_SET, SEEK_CUR, SEEK_END */ <br>
off_t l_start; /* Starting offset for lock */ <br>
off_t l_len; /* Number of bytes to lock */ <br>
pid_t l_pid; /* PID of process blocking our lock <br>
(F_GETLK only) */ <br>
... <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of
this structure specify the range of bytes we wish to lock.
Bytes past the end of the file may be locked, but not bytes
before the start of the file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>l_start</i>
is the starting offset for the lock, and is interpreted
relative to either: the start of the file (if
<i>l_whence</i> is <b>SEEK_SET</b>); the current file offset
(if <i>l_whence</i> is <b>SEEK_CUR</b>); or the end of the
file (if <i>l_whence</i> is <b>SEEK_END</b>). In the final
two cases, <i>l_start</i> can be a negative number provided
the offset does not lie before the start of the file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>l_len</i>
specifies the number of bytes to be locked. If <i>l_len</i>
is positive, then the range to be locked covers bytes
<i>l_start</i> up to and including
<i>l_start</i>+<i>l_len</i>&minus;<i>1</i>. Specifying 0 for
<i>l_len</i> has the special meaning: lock all bytes
starting at the location specified by <i>l_whence</i> and
<i>l_start</i> through to the end of file, no matter how
large the file grows.</p>

<p style="margin-left:11%; margin-top: 1em">POSIX.1-2001
allows (but does not require) an implementation to support a
negative <i>l_len</i> value; if <i>l_len</i> is negative,
the interval described by <i>lock</i> covers bytes
<i>l_start</i>+<i>l_len</i> up to and including
<i>l_start</i>&minus;1. This is supported by Linux since
kernel versions 2.4.21 and 2.5.49.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>l_type</i> field can be used to place a read
(<b>F_RDLCK</b>) or a write (<b>F_WRLCK</b>) lock on a file.
Any number of processes may hold a read lock (shared lock)
on a file region, but only one process may hold a write lock
(exclusive lock). An exclusive lock excludes all other
locks, both shared and exclusive. A single process can hold
only one type of lock on a file region; if a new lock is
applied to an already-locked region, then the existing lock
is converted to the new lock type. (Such conversions may
involve splitting, shrinking, or coalescing with an existing
lock if the byte range specified by the new lock does not
precisely coincide with the range of the existing lock.)
<b><br>
F_SETLK</b> (<i>struct flock *</i>)</p>

<p style="margin-left:22%;">Acquire a lock (when
<i>l_type</i> is <b>F_RDLCK</b> or <b>F_WRLCK</b>) or
release a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the
bytes specified by the <i>l_whence</i>, <i>l_start</i>, and
<i>l_len</i> fields of <i>lock</i>. If a conflicting lock is
held by another process, this call returns &minus;1 and sets
<i>errno</i> to <b>EACCES</b> or <b>EAGAIN</b>.</p>

<p style="margin-left:11%;"><b>F_SETLKW</b> (<i>struct
flock *</i>)</p>

<p style="margin-left:22%;">As for <b>F_SETLK</b>, but if a
conflicting lock is held on the file, then wait for that
lock to be released. If a signal is caught while waiting,
then the call is interrupted and (after the signal handler
has returned) returns immediately (with return value
&minus;1 and <i>errno</i> set to <b>EINTR</b>; see
<b>signal</b>(7)).</p>

<p style="margin-left:11%;"><b>F_GETLK</b> (<i>struct flock
*</i>)</p>

<p style="margin-left:22%;">On input to this call,
<i>lock</i> describes a lock we would like to place on the
file. If the lock could be placed, <b>fcntl</b>() does not
actually place it, but returns <b>F_UNLCK</b> in the
<i>l_type</i> field of <i>lock</i> and leaves the other
fields of the structure unchanged. If one or more
incompatible locks would prevent this lock being placed,
then <b>fcntl</b>() returns details about one of these locks
in the <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and
<i>l_len</i> fields of <i>lock</i> and sets <i>l_pid</i> to
be the PID of the process holding that lock.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
place a read lock, <i>fd</i> must be open for reading. In
order to place a write lock, <i>fd</i> must be open for
writing. To place both types of lock, open a file
read-write.</p>

<p style="margin-left:11%; margin-top: 1em">As well as
being removed by an explicit <b>F_UNLCK</b>, record locks
are automatically released when the process terminates or if
it closes <i>any</i> file descriptor referring to a file on
which locks are held. This is bad: it means that a process
can lose the locks on a file like <i>/etc/passwd</i> or
<i>/etc/mtab</i> when for some reason a library function
decides to open, read and close it.</p>

<p style="margin-left:11%; margin-top: 1em">Record locks
are not inherited by a child created via <b>fork</b>(2), but
are preserved across an <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Because of the
buffering performed by the <b>stdio</b>(3) library, the use
of record locking with routines in that package should be
avoided; use <b>read</b>(2) and <b>write</b>(2) instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mandatory
locking</b> <br>
(Non-POSIX.) The above record locks may be either advisory
or mandatory, and are advisory by default.</p>

<p style="margin-left:11%; margin-top: 1em">Advisory locks
are not enforced and are useful only between cooperating
processes.</p>

<p style="margin-left:11%; margin-top: 1em">Mandatory locks
are enforced for all processes. If a process tries to
perform an incompatible access (e.g., <b>read</b>(2) or
<b>write</b>(2)) on a file region that has an incompatible
mandatory lock, then the result depends upon whether the
<b>O_NONBLOCK</b> flag is enabled for its open file
description. If the <b>O_NONBLOCK</b> flag is not enabled,
then system call is blocked until the lock is removed or
converted to a mode that is compatible with the access. If
the <b>O_NONBLOCK</b> flag is enabled, then the system call
fails with the error <b>EAGAIN</b>.</p>

<p style="margin-left:11%; margin-top: 1em">To make use of
mandatory locks, mandatory locking must be enabled both on
the file system that contains the file to be locked, and on
the file itself. Mandatory locking is enabled on a file
system using the &quot;&minus;o mand&quot; option to
<b>mount</b>(8), or the <b>MS_MANDLOCK</b> flag for
<b>mount</b>(2). Mandatory locking is enabled on a file by
disabling group execute permission on the file and enabling
the set-group-ID permission bit (see <b>chmod</b>(1) and
<b>chmod</b>(2)).</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
implementation of mandatory locking is unreliable. See BUGS
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Managing
signals <br>
F_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>,
<b>F_SETOWN_EX</b>, <b>F_GETSIG</b> and <b>F_SETSIG</b> are
used to manage I/O availability signals: <b><br>
F_GETOWN</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the process ID or process group currently receiving
<b>SIGIO</b> and <b>SIGURG</b> signals for events on file
descriptor <i>fd</i>. Process IDs are returned as positive
values; process group IDs are returned as negative values
(but see BUGS below). <i>arg</i> is ignored.</p>

<p style="margin-left:11%;"><b>F_SETOWN</b>
(<i>int</i>)</p>

<p style="margin-left:22%;">Set the process ID or process
group ID that will receive <b>SIGIO</b> and <b>SIGURG</b>
signals for events on file descriptor <i>fd</i> to the ID
given in <i>arg</i>. A process ID is specified as a positive
value; a process group ID is specified as a negative value.
Most commonly, the calling process specifies itself as the
owner (that is, <i>arg</i> is specified as
<b>getpid</b>(2)).</p>

<p style="margin-left:22%; margin-top: 1em">If you set the
<b>O_ASYNC</b> status flag on a file descriptor by using the
<b>F_SETFL</b> command of <b>fcntl</b>(), a <b>SIGIO</b>
signal is sent whenever input or output becomes possible on
that file descriptor. <b>F_SETSIG</b> can be used to obtain
delivery of a signal other than <b>SIGIO</b>. If this
permission check fails, then the signal is silently
discarded.</p>

<p style="margin-left:22%; margin-top: 1em">Sending a
signal to the owner process (group) specified by
<b>F_SETOWN</b> is subject to the same permissions checks as
are described for <b>kill</b>(2), where the sending process
is the one that employs <b>F_SETOWN</b> (but see BUGS
below).</p>

<p style="margin-left:22%; margin-top: 1em">If the file
descriptor <i>fd</i> refers to a socket, <b>F_SETOWN</b>
also selects the recipient of <b>SIGURG</b> signals that are
delivered when out-of-band data arrives on that socket.
(<b>SIGURG</b> is sent in any situation where
<b>select</b>(2) would report the socket as having an
&quot;exceptional condition&quot;.)</p>

<p style="margin-left:22%; margin-top: 1em">The following
was true in 2.6.x kernels up to and including kernel
2.6.11:</p>

<p style="margin-left:32%; margin-top: 1em">If a nonzero
value is given to <b>F_SETSIG</b> in a multithreaded process
running with a threading library that supports thread groups
(e.g., NPTL), then a positive value given to <b>F_SETOWN</b>
has a different meaning: instead of being a process ID
identifying a whole process, it is a thread ID identifying a
specific thread within a process. Consequently, it may be
necessary to pass <b>F_SETOWN</b> the result of
<b>gettid</b>(2) instead of <b>getpid</b>(2) to get sensible
results when <b>F_SETSIG</b> is used. (In current Linux
threading implementations, a main thread&rsquo;s thread ID
is the same as its process ID. This means that a
single-threaded program can equally use <b>gettid</b>(2) or
<b>getpid</b>(2) in this scenario.) Note, however, that the
statements in this paragraph do not apply to the
<b>SIGURG</b> signal generated for out-of-band data on a
socket: this signal is always sent to either a process or a
process group, depending on the value given to
<b>F_SETOWN</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The above
behavior was accidentally dropped in Linux 2.6.12, and
won&rsquo;t be restored. From Linux 2.6.32 onward, use
<b>F_SETOWN_EX</b> to target <b>SIGIO</b> and <b>SIGURG</b>
signals at a particular thread.</p>

<p style="margin-left:11%;"><b>F_GETOWN_EX</b> (struct
f_owner_ex *) (since Linux 2.6.32)</p>

<p style="margin-left:22%;">Return the current file
descriptor owner settings as defined by a previous
<b>F_SETOWN_EX</b> operation. The information is returned in
the structure pointed to by <i>arg</i>, which has the
following form:</p>

<p style="margin-left:28%; margin-top: 1em">struct
f_owner_ex { <br>
int type; <br>
pid_t pid; <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">The <i>type</i>
field will have one of the values <b>F_OWNER_TID</b>,
<b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>. The <i>pid</i>
field is a positive integer representing a thread ID,
process ID, or process group ID. See <b>F_SETOWN_EX</b> for
more details.</p>

<p style="margin-left:11%;"><b>F_SETOWN_EX</b> (struct
f_owner_ex *) (since Linux 2.6.32)</p>

<p style="margin-left:22%;">This operation performs a
similar task to <b>F_SETOWN</b>. It allows the caller to
direct I/O availability signals to a specific thread,
process, or process group. The caller specifies the target
of signals via <i>arg</i>, which is a pointer to a
<i>f_owner_ex</i> structure. The <i>type</i> field has one
of the following values, which define how <i>pid</i> is
interpreted: <b><br>
F_OWNER_TID</b></p>

<p style="margin-left:32%;">Send the signal to the thread
whose thread ID (the value returned by a call to
<b>clone</b>(2) or <b>gettid</b>(2)) is specified in
<i>pid</i>.</p>

<p style="margin-left:22%;"><b>F_OWNER_PID</b></p>

<p style="margin-left:32%;">Send the signal to the process
whose ID is specified in <i>pid</i>.</p>

<p style="margin-left:22%;"><b>F_OWNER_PGRP</b></p>

<p style="margin-left:32%;">Send the signal to the process
group whose ID is specified in <i>pid</i>. (Note that,
unlike with <b>F_SETOWN</b>, a process group ID is specified
as a positive value here.)</p>

<p style="margin-left:11%;"><b>F_GETSIG</b>
(<i>void</i>)</p>

<p style="margin-left:22%;">Return (as the function result)
the signal sent when input or output becomes possible. A
value of zero means <b>SIGIO</b> is sent. Any other value
(including <b>SIGIO</b>) is the signal sent instead, and in
this case additional info is available to the signal handler
if installed with <b>SA_SIGINFO</b>. <i>arg</i> is
ignored.</p>

<p style="margin-left:11%;"><b>F_SETSIG</b>
(<i>int</i>)</p>

<p style="margin-left:22%;">Set the signal sent when input
or output becomes possible to the value given in <i>arg</i>.
A value of zero means to send the default <b>SIGIO</b>
signal. Any other value (including <b>SIGIO</b>) is the
signal to send instead, and in this case additional info is
available to the signal handler if installed with
<b>SA_SIGINFO</b>.</p>

<p style="margin-left:22%; margin-top: 1em">By using
<b>F_SETSIG</b> with a nonzero value, and setting
<b>SA_SIGINFO</b> for the signal handler (see
<b>sigaction</b>(2)), extra information about I/O events is
passed to the handler in a <i>siginfo_t</i> structure. If
the <i>si_code</i> field indicates the source is
<b>SI_SIGIO</b>, the <i>si_fd</i> field gives the file
descriptor associated with the event. Otherwise, there is no
indication which file descriptors are pending, and you
should use the usual mechanisms (<b>select</b>(2),
<b>poll</b>(2), <b>read</b>(2) with <b>O_NONBLOCK</b> set
etc.) to determine which file descriptors are available for
I/O.</p>

<p style="margin-left:22%; margin-top: 1em">By selecting a
real time signal (value &gt;= <b>SIGRTMIN</b>), multiple I/O
events may be queued using the same signal numbers. (Queuing
is dependent on available memory). Extra information is
available if <b>SA_SIGINFO</b> is set for the signal
handler, as above.</p>

<p style="margin-left:22%; margin-top: 1em">Note that Linux
imposes a limit on the number of real-time signals that may
be queued to a process (see <b>getrlimit</b>(2) and
<b>signal</b>(7)) and if this limit is reached, then the
kernel reverts to delivering <b>SIGIO</b>, and this signal
is delivered to the entire process rather than to a specific
thread.</p>

<p style="margin-left:11%; margin-top: 1em">Using these
mechanisms, a program can implement fully asynchronous I/O
without using <b>select</b>(2) or <b>poll</b>(2) most of the
time.</p>

<p style="margin-left:11%; margin-top: 1em">The use of
<b>O_ASYNC</b>, <b>F_GETOWN</b>, <b>F_SETOWN</b> is specific
to BSD and Linux. <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>,
<b>F_GETSIG</b>, and <b>F_SETSIG</b> are Linux-specific.
POSIX has asynchronous I/O and the <i>aio_sigevent</i>
structure to achieve similar things; these are also
available in Linux as part of the GNU C Library (Glibc).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Leases <br>
F_SETLEASE</b> and <b>F_GETLEASE</b> (Linux 2.4 onward) are
used (respectively) to establish a new lease, and retrieve
the current lease, on the open file description referred to
by the file descriptor <i>fd</i>. A file lease provides a
mechanism whereby the process holding the lease (the
&quot;lease holder&quot;) is notified (via delivery of a
signal) when a process (the &quot;lease breaker&quot;) tries
to <b>open</b>(2) or <b>truncate</b>(2) the file referred to
by that file descriptor. <b><br>
F_SETLEASE</b> (<i>int</i>)</p>

<p style="margin-left:22%;">Set or remove a file lease
according to which of the following values is specified in
the integer <i>arg</i>: <b><br>
F_RDLCK</b></p>

<p style="margin-left:32%;">Take out a read lease. This
will cause the calling process to be notified when the file
is opened for writing or is truncated. A read lease can be
placed only on a file descriptor that is opened
read-only.</p>

<p style="margin-left:22%;"><b>F_WRLCK</b></p>

<p style="margin-left:32%;">Take out a write lease. This
will cause the caller to be notified when the file is opened
for reading or writing or is truncated. A write lease may be
placed on a file only if there are no other open file
descriptors for the file.</p>

<p style="margin-left:22%;"><b>F_UNLCK</b></p>

<p style="margin-left:32%;">Remove our lease from the
file.</p>

<p style="margin-left:11%; margin-top: 1em">Leases are
associated with an open file description (see
<b>open</b>(2)). This means that duplicate file descriptors
(created by, for example, <b>fork</b>(2) or <b>dup</b>(2))
refer to the same lease, and this lease may be modified or
released using any of these descriptors. Furthermore, the
lease is released by either an explicit <b>F_UNLCK</b>
operation on any of these duplicate descriptors, or when all
such descriptors have been closed.</p>

<p style="margin-left:11%; margin-top: 1em">Leases may be
taken out only on regular files. An unprivileged process may
take out a lease only on a file whose UID (owner) matches
the file system UID of the process. A process with the
<b>CAP_LEASE</b> capability may take out leases on arbitrary
files. <b><br>
F_GETLEASE</b> (<i>void</i>)</p>

<p style="margin-left:22%;">Indicates what type of lease is
associated with the file descriptor <i>fd</i> by returning
either <b>F_RDLCK</b>, <b>F_WRLCK</b>, or <b>F_UNLCK</b>,
indicating, respectively, a read lease , a write lease, or
no lease. <i>arg</i> is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">When a process
(the &quot;lease breaker&quot;) performs an <b>open</b>(2)
or <b>truncate</b>(2) that conflicts with a lease
established via <b>F_SETLEASE</b>, the system call is
blocked by the kernel and the kernel notifies the lease
holder by sending it a signal (<b>SIGIO</b> by default). The
lease holder should respond to receipt of this signal by
doing whatever cleanup is required in preparation for the
file to be accessed by another process (e.g., flushing
cached buffers) and then either remove or downgrade its
lease. A lease is removed by performing an <b>F_SETLEASE</b>
command specifying <i>arg</i> as <b>F_UNLCK</b>. If the
lease holder currently holds a write lease on the file, and
the lease breaker is opening the file for reading, then it
is sufficient for the lease holder to downgrade the lease to
a read lease. This is done by performing an
<b>F_SETLEASE</b> command specifying <i>arg</i> as
<b>F_RDLCK</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the lease
holder fails to downgrade or remove the lease within the
number of seconds specified in
<i>/proc/sys/fs/lease-break-time</i> then the kernel
forcibly removes or downgrades the lease holder&rsquo;s
lease.</p>

<p style="margin-left:11%; margin-top: 1em">Once a lease
break has been initiated, <b>F_GETLEASE</b> returns the
target lease type (either <b>F_RDLCK</b> or <b>F_UNLCK</b>,
depending on what would be compatible with the lease
breaker) until the lease holder voluntarily downgrades or
removes the lease or the kernel forcibly does so after the
lease break timer expires.</p>

<p style="margin-left:11%; margin-top: 1em">Once the lease
has been voluntarily or forcibly removed or downgraded, and
assuming the lease breaker has not unblocked its system
call, the kernel permits the lease breaker&rsquo;s system
call to proceed.</p>

<p style="margin-left:11%; margin-top: 1em">If the lease
breaker&rsquo;s blocked <b>open</b>(2) or <b>truncate</b>(2)
is interrupted by a signal handler, then the system call
fails with the error <b>EINTR</b>, but the other steps still
occur as described above. If the lease breaker is killed by
a signal while blocked in <b>open</b>(2) or
<b>truncate</b>(2), then the other steps still occur as
described above. If the lease breaker specifies the
<b>O_NONBLOCK</b> flag when calling <b>open</b>(2), then the
call immediately fails with the error <b>EWOULDBLOCK</b>,
but the other steps still occur as described above.</p>

<p style="margin-left:11%; margin-top: 1em">The default
signal used to notify the lease holder is <b>SIGIO</b>, but
this can be changed using the <b>F_SETSIG</b> command to
<b>fcntl</b>(). If a <b>F_SETSIG</b> command is performed
(even one specifying <b>SIGIO</b>), and the signal handler
is established using <b>SA_SIGINFO</b>, then the handler
will receive a <i>siginfo_t</i> structure as its second
argument, and the <i>si_fd</i> field of this argument will
hold the descriptor of the leased file that has been
accessed by another process. (This is useful if the caller
holds leases against multiple files).</p>

<p style="margin-left:11%; margin-top: 1em"><b>File and
directory change notification (dnotify) <br>
F_NOTIFY</b> (<i>int</i>)</p>

<p style="margin-left:22%;">(Linux 2.4 onward) Provide
notification when the directory referred to by <i>fd</i> or
any of the files that it contains is changed. The events to
be notified are specified in <i>arg</i>, which is a bit mask
specified by ORing together zero or more of the following
bits:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_ACCESS</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>A file was accessed (read, pread, readv)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_MODIFY</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>A file was modified (write, pwrite, writev, truncate,
ftruncate).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_CREATE</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>A file was created (open, creat, mknod, mkdir, link,
symlink, rename).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_DELETE</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>A file was unlinked (unlink, rename to another
directory, rmdir).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_RENAME</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>A file was renamed within this directory (rename).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="13%">


<p><b>DN_ATTRIB</b></p></td>
<td width="5%"></td>
<td width="60%">


<p>The attributes of a file were changed (chown, chmod,
utime[s]).</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">(In order to
obtain these definitions, the <b>_GNU_SOURCE</b> feature
test macro must be defined before including <i>any</i>
header files.)</p>

<p style="margin-left:22%; margin-top: 1em">Directory
notifications are normally &quot;one-shot&quot;, and the
application must reregister to receive further
notifications. Alternatively, if <b>DN_MULTISHOT</b> is
included in <i>arg</i>, then notification will remain in
effect until explicitly removed.</p>

<p style="margin-left:22%; margin-top: 1em">A series of
<b>F_NOTIFY</b> requests is cumulative, with the events in
<i>arg</i> being added to the set already monitored. To
disable notification of all events, make an <b>F_NOTIFY</b>
call specifying <i>arg</i> as 0.</p>

<p style="margin-left:22%; margin-top: 1em">Notification
occurs via delivery of a signal. The default signal is
<b>SIGIO</b>, but this can be changed using the
<b>F_SETSIG</b> command to <b>fcntl</b>(). In the latter
case, the signal handler receives a <i>siginfo_t</i>
structure as its second argument (if the handler was
established using <b>SA_SIGINFO</b>) and the <i>si_fd</i>
field of this structure contains the file descriptor which
generated the notification (useful when establishing
notification on multiple directories).</p>

<p style="margin-left:22%; margin-top: 1em">Especially when
using <b>DN_MULTISHOT</b>, a real time signal should be used
for notification, so that multiple notifications can be
queued.</p>

<p style="margin-left:22%; margin-top: 1em"><b>NOTE:</b>
New applications should use the <i>inotify</i> interface
(available since kernel 2.6.13), which provides a much
superior interface for obtaining notifications of file
system events. See <b>inotify</b>(7).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Changing the
capacity of a pipe <br>
F_SETPIPE_SZ</b> (<i>int</i>; since Linux 2.6.35)</p>

<p style="margin-left:22%;">Change the capacity of the pipe
referred to by <i>fd</i> to be at least <i>arg</i> bytes. An
unprivileged process can adjust the pipe capacity to any
value between the system page size and the limit defined in
<i>/proc/sys/fs/pipe-max-size</i> (see <b>proc</b>(5)).
Attempts to set the pipe capacity below the page size are
silently rounded up to the page size. Attempts by an
unprivileged process to set the pipe capacity above the
limit in <i>/proc/sys/fs/pipe-max-size</i> yield the error
<b>EPERM</b>; a privileged process (<b>CAP_SYS_RESOURCE</b>)
can override the limit. When allocating the buffer for the
pipe, the kernel may use a capacity larger than <i>arg</i>,
if that is convenient for the implementation. The
<b>F_GETPIPE_SZ</b> operation returns the actual size used.
Attempting to set the pipe capacity smaller than the amount
of buffer space currently used to store data produces the
error <b>EBUSY</b>.</p>

<p style="margin-left:11%;"><b>F_GETPIPE_SZ</b>
(<i>void</i>; since Linux 2.6.35)</p>

<p style="margin-left:22%;">Return (as the function result)
the capacity of the pipe referred to by <i>fd</i>.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For a
successful call, the return value depends on the
operation:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>F_DUPFD</b></p></td>
<td width="3%"></td>
<td width="47%">


<p>The new descriptor.</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>F_GETFD</b></p></td>
<td width="3%"></td>
<td width="47%">


<p>Value of file descriptor flags.</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>F_GETFL</b></p></td>
<td width="3%"></td>
<td width="47%">


<p>Value of file status flags.</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>F_GETLEASE</b></p>

<p style="margin-left:25%;">Type of lease held on file
descriptor.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>F_GETOWN</b></p></td>
<td width="2%"></td>
<td width="75%">


<p>Value of descriptor owner.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>F_GETSIG</b></p></td>
<td width="2%"></td>
<td width="75%">


<p>Value of signal sent when read or write becomes
possible, or zero for traditional <b>SIGIO</b> behavior.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>F_GETPIPE_SZ</b></p>

<p style="margin-left:25%;">The pipe capacity.</p>

<p style="margin-left:11%;">All other commands</p>

<p style="margin-left:25%;">Zero.</p>

<p style="margin-left:11%; margin-top: 1em">On error,
&minus;1 is returned, and <i>errno</i> is set
appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>EACCES</b>
or <b>EAGAIN</b></p>

<p style="margin-left:22%;">Operation is prohibited by
locks held by other processes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The operation is prohibited because the file has been
memory-mapped by another process.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>fd</i> is not an open file descriptor, or the command
was <b>F_SETLK</b> or <b>F_SETLKW</b> and the file
descriptor open mode doesn&rsquo;t match with the type of
lock requested.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>EDEADLK</b></p>

<p style="margin-left:22%;">It was detected that the
specified <b>F_SETLKW</b> command would cause a
deadlock.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>lock</i> is outside your accessible address
space.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINTR</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>For <b>F_SETLKW</b>, the command was interrupted by a
signal; see <b>signal</b>(7). For <b>F_GETLK</b> and
<b>F_SETLK</b>, the command was interrupted by a signal
before the lock was checked or acquired. Most likely when
locking a remote file (e.g., locking over NFS), but can
sometimes happen locally.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>For <b>F_DUPFD</b>, <i>arg</i> is negative or is greater
than the maximum allowable value. For <b>F_SETSIG</b>,
<i>arg</i> is not an allowable signal number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>For <b>F_DUPFD</b>, the process already has the maximum
number of file descriptors open.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOLCK</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Too many segment locks open, lock table is full, or a
remote locking protocol failed (e.g., locking over NFS).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Attempted to clear the <b>O_APPEND</b> flag on a file
that has the append-only attribute set.</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SVr4, 4.3BSD,
POSIX.1-2001. Only the operations <b>F_DUPFD</b>,
<b>F_GETFD</b>, <b>F_SETFD</b>, <b>F_GETFL</b>,
<b>F_SETFL</b>, <b>F_GETLK</b>, <b>F_SETLK</b> and
<b>F_SETLKW</b>, are specified in POSIX.1-2001.</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_GETOWN</b>
and <b>F_SETOWN</b> are specified in POSIX.1-2001. (To get
their definitions, define <b>BSD_SOURCE</b>, or
<b>_XOPEN_SOURCE</b> with the value 500 or greater, or
define <b>_POSIX_C_SOURCE</b> with the value 200809L or
greater.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_DUPFD_CLOEXEC</b>
is specified in POSIX.1-2008. (To get this definition,
define <b>_POSIX_C_SOURCE</b> with the value 200809L or
greater, or <b>_XOPEN_SOURCE</b> with the value 700 or
greater.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>F_GETOWN_EX</b>,
<b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>,
<b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>, <b>F_SETSIG</b>,
<b>F_NOTIFY</b>, <b>F_GETLEASE</b>, and <b>F_SETLEASE</b>
are Linux-specific. (Define the <b>_GNU_SOURCE</b> macro to
obtain these definitions.)</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The original
Linux <b>fcntl</b>() system call was not designed to handle
large file offsets (in the <i>flock</i> structure).
Consequently, an <b>fcntl64</b>() system call was added in
Linux 2.4. The newer system call employs a different
structure for file locking, <i>flock64</i>, and
corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>,
and <b>F_SETLKW64</b>. However, these details can be ignored
by applications using glibc, whose <b>fcntl</b>() wrapper
function transparently employs the more recent system call
where it is available.</p>

<p style="margin-left:11%; margin-top: 1em">The errors
returned by <b>dup2</b>(2) are different from those returned
by <b>F_DUPFD</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Since kernel
2.0, there is no interaction between the types of lock
placed by <b>flock</b>(2) and <b>fcntl</b>().</p>

<p style="margin-left:11%; margin-top: 1em">Several systems
have more fields in <i>struct flock</i> such as, for
example, <i>l_sysid</i>. Clearly, <i>l_pid</i> alone is not
going to be very useful if the process holding the lock may
live on a different machine.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A limitation of
the Linux system call conventions on some architectures
(notably i386) means that if a (negative) process group ID
to be returned by <b>F_GETOWN</b> falls in the range
&minus;1 to &minus;4095, then the return value is wrongly
interpreted by glibc as an error in the system call; that
is, the return value of <b>fcntl</b>() will be &minus;1, and
<i>errno</i> will contain the (positive) process group ID.
The Linux-specific <b>F_GETOWN_EX</b> operation avoids this
problem. Since glibc version 2.11, glibc makes the kernel
<b>F_GETOWN</b> problem invisible by implementing
<b>F_GETOWN</b> using <b>F_GETOWN_EX</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In Linux 2.4
and earlier, there is bug that can occur when an
unprivileged process uses <b>F_SETOWN</b> to specify the
owner of a socket file descriptor as a process (group) other
than the caller. In this case, <b>fcntl</b>() can return
&minus;1 with <i>errno</i> set to <b>EPERM</b>, even when
the owner process (group) is one that the caller has
permission to send signals to. Despite this error return,
the file descriptor owner is set, and signals will be sent
to the owner.</p>

<p style="margin-left:11%; margin-top: 1em">The
implementation of mandatory locking in all known versions of
Linux is subject to race conditions which render it
unreliable: a <b>write</b>(2) call that overlaps with a lock
may modify data after the mandatory lock is acquired; a
<b>read</b>(2) call that overlaps with a lock may detect
changes to data that were made only after a write lock was
acquired. Similar races exist between mandatory locks and
<b>mmap</b>(2). It is therefore inadvisable to rely on
mandatory locking.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>dup2</b>(2),
<b>flock</b>(2), <b>open</b>(2), <b>socket</b>(2),
<b>lockf</b>(3), <b>capabilities</b>(7),
<b>feature_test_macros</b>(7)</p>


<p style="margin-left:11%; margin-top: 1em"><i>locks.txt</i>,
<i>mandatory-locking.txt</i>, and <i>dnotify.txt</i> in the
Linux kernel source directory
<i>Documentation/filesystems/</i> (on older kernels, these
files are directly under the <i>Documentation/</i>
directory, and <i>mandatory-locking.txt</i> is called
<i>mandatory.txt</i>)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
