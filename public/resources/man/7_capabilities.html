<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:23:39 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CAPABILITIES</title>

</head>
<body>

<h1 align="center">CAPABILITIES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">capabilities
&minus; overview of Linux capabilities</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For the purpose
of performing permission checks, traditional UNIX
implementations distinguish two categories of processes:
<i>privileged</i> processes (whose effective user ID is 0,
referred to as superuser or root), and <i>unprivileged</i>
processes (whose effective UID is nonzero). Privileged
processes bypass all kernel permission checks, while
unprivileged processes are subject to full permission
checking based on the process&rsquo;s credentials (usually:
effective UID, effective GID, and supplementary group
list).</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
kernel 2.2, Linux divides the privileges traditionally
associated with superuser into distinct units, known as
<i>capabilities</i>, which can be independently enabled and
disabled. Capabilities are a per-thread attribute.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Capabilities
list</b> <br>
The following list shows the capabilities implemented on
Linux, and the operations or behaviors that each capability
permits: <b><br>
CAP_AUDIT_CONTROL</b> (since Linux 2.6.11)</p>

<p style="margin-left:22%;">Enable and disable kernel
auditing; change auditing filter rules; retrieve auditing
status and filtering rules.</p>

<p style="margin-left:11%;"><b>CAP_AUDIT_WRITE</b> (since
Linux 2.6.11)</p>

<p style="margin-left:22%;">Write records to kernel
auditing log.</p>

<p style="margin-left:11%;"><b>CAP_BLOCK_SUSPEND</b> (since
Linux 3.5)</p>

<p style="margin-left:22%;">Employ features that can block
system suspend (<b>epoll</b>(7) <b>EPOLLWAKEUP</b>,
<i>/proc/sys/wake_lock</i>).</p>

<p style="margin-left:11%;"><b>CAP_CHOWN</b></p>

<p style="margin-left:22%;">Make arbitrary changes to file
UIDs and GIDs (see <b>chown</b>(2)).</p>

<p style="margin-left:11%;"><b>CAP_DAC_OVERRIDE</b></p>

<p style="margin-left:22%;">Bypass file read, write, and
execute permission checks. (DAC is an abbreviation of
&quot;discretionary access control&quot;.)</p>

<p style="margin-left:11%;"><b>CAP_DAC_READ_SEARCH</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Bypass file read permission checks and directory read
and execute permission checks;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Invoke <b>open_by_handle_at</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_FOWNER</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Bypass permission checks on operations that normally
require the file system UID of the process to match the UID
of the file (e.g., <b>chmod</b>(2), <b>utime</b>(2)),
excluding those operations covered by
<b>CAP_DAC_OVERRIDE</b> and <b>CAP_DAC_READ_SEARCH</b>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set extended file attributes (see <b>chattr</b>(1)) on
arbitrary files;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set Access Control Lists (ACLs) on arbitrary files;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>ignore directory sticky bit on file deletion;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>specify <b>O_NOATIME</b> for arbitrary files in
<b>open</b>(2) and <b>fcntl</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_FSETID</b></p>

<p style="margin-left:22%;">Don&rsquo;t clear set-user-ID
and set-group-ID permission bits when a file is modified;
set the set-group-ID bit for a file whose GID does not match
the file system or any of the supplementary GIDs of the
calling process.</p>

<p style="margin-left:11%;"><b>CAP_IPC_LOCK</b></p>

<p style="margin-left:22%;">Lock memory (<b>mlock</b>(2),
<b>mlockall</b>(2), <b>mmap</b>(2), <b>shmctl</b>(2)).</p>

<p style="margin-left:11%;"><b>CAP_IPC_OWNER</b></p>

<p style="margin-left:22%;">Bypass permission checks for
operations on System V IPC objects.</p>

<p style="margin-left:11%;"><b>CAP_KILL</b></p>

<p style="margin-left:22%;">Bypass permission checks for
sending signals (see <b>kill</b>(2)). This includes use of
the <b>ioctl</b>(2) <b>KDSIGACCEPT</b> operation.</p>

<p style="margin-left:11%;"><b>CAP_LEASE</b> (since Linux
2.4)</p>

<p style="margin-left:22%;">Establish leases on arbitrary
files (see <b>fcntl</b>(2)).</p>

<p style="margin-left:11%;"><b>CAP_LINUX_IMMUTABLE</b></p>

<p style="margin-left:22%;">Set the <b>FS_APPEND_FL</b> and
<b>FS_IMMUTABLE_FL</b> i-node flags (see
<b>chattr</b>(1)).</p>

<p style="margin-left:11%;"><b>CAP_MAC_ADMIN</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">Override Mandatory Access
Control (MAC). Implemented for the Smack Linux Security
Module (LSM).</p>

<p style="margin-left:11%;"><b>CAP_MAC_OVERRIDE</b> (since
Linux 2.6.25)</p>

<p style="margin-left:22%;">Allow MAC configuration or
state changes. Implemented for the Smack LSM.</p>

<p style="margin-left:11%;"><b>CAP_MKNOD</b> (since Linux
2.4)</p>

<p style="margin-left:22%;">Create special files using
<b>mknod</b>(2).</p>

<p style="margin-left:11%;"><b>CAP_NET_ADMIN</b></p>

<p style="margin-left:22%;">Perform various network-related
operations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>interface configuration;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>administration of IP firewall, masquerading, and
accounting;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>modify routing tables;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>bind to any address for transparent proxying;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set type-of-service (TOS)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>clear driver statistics;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set promiscuous mode;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>enabling multicasting;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <b>setsockopt</b>(2) to set the following socket
options: <b>SO_DEBUG</b>, <b>SO_MARK</b>, <b>SO_PRIORITY</b>
(for a priority outside the range 0 to 6),
<b>SO_RCVBUFFORCE</b>, and <b>SO_SNDBUFFORCE</b>.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>CAP_NET_BIND_SERVICE</b></p>

<p style="margin-left:22%;">Bind a socket to Internet
domain privileged ports (port numbers less than 1024).</p>

<p style="margin-left:11%;"><b>CAP_NET_BROADCAST</b></p>

<p style="margin-left:22%;">(Unused) Make socket
broadcasts, and listen to multicasts.</p>

<p style="margin-left:11%;"><b>CAP_NET_RAW</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="69%">


<p>use RAW and PACKET sockets;</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="69%">


<p>bind to any address for transparent proxying.</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SETGID</b></p>

<p style="margin-left:22%;">Make arbitrary manipulations of
process GIDs and supplementary GID list; forge GID when
passing socket credentials via UNIX domain sockets.</p>

<p style="margin-left:11%;"><b>CAP_SETFCAP</b> (since Linux
2.6.24)</p>

<p style="margin-left:22%;">Set file capabilities.</p>

<p style="margin-left:11%;"><b>CAP_SETPCAP</b></p>

<p style="margin-left:22%;">If file capabilities are not
supported: grant or remove any capability in the
caller&rsquo;s permitted capability set to or from any other
process. (This property of <b>CAP_SETPCAP</b> is not
available when the kernel is configured to support file
capabilities, since <b>CAP_SETPCAP</b> has entirely
different semantics for such kernels.)</p>

<p style="margin-left:22%; margin-top: 1em">If file
capabilities are supported: add any capability from the
calling thread&rsquo;s bounding set to its inheritable set;
drop capabilities from the bounding set (via <b>prctl</b>(2)
<b>PR_CAPBSET_DROP</b>); make changes to the
<i>securebits</i> flags.</p>

<p style="margin-left:11%;"><b>CAP_SETUID</b></p>

<p style="margin-left:22%;">Make arbitrary manipulations of
process UIDs (<b>setuid</b>(2), <b>setreuid</b>(2),
<b>setresuid</b>(2), <b>setfsuid</b>(2)); make forged UID
when passing socket credentials via UNIX domain sockets.</p>

<p style="margin-left:11%;"><b>CAP_SYS_ADMIN</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Perform a range of system administration operations
including: <b>quotactl</b>(2), <b>mount</b>(2),
<b>umount</b>(2), <b>swapon</b>(2), <b>swapoff</b>(2),
<b>sethostname</b>(2), and <b>setdomainname</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform privileged <b>syslog</b>(2) operations (since
Linux 2.6.37, <b>CAP_SYSLOG</b> should be used to permit
such operations);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>VM86_REQUEST_IRQ vm86</b>(2) command;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>IPC_SET</b> and <b>IPC_RMID</b> operations on
arbitrary System V IPC objects;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform operations on <i>trusted</i> and <i>security</i>
Extended Attributes (see <b>attr</b>(5));</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <b>lookup_dcookie</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <b>ioprio_set</b>(2) to assign
<b>IOPRIO_CLASS_RT</b> and (before Linux 2.6.25)
<b>IOPRIO_CLASS_IDLE</b> I/O scheduling classes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>forge UID when passing socket credentials;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>exceed <i>/proc/sys/fs/file-max</i>, the system-wide
limit on the number of open files, in system calls that open
files (e.g., <b>accept</b>(2), <b>execve</b>(2),
<b>open</b>(2), <b>pipe</b>(2));</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ <b>CLONE_*</b> flags that create new namespaces
with <b>clone</b>(2) and <b>unshare</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <b>perf_event_open</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>access privileged <i>perf</i> event information;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <b>setns</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>call <b>fanotify_init</b>(2);</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>KEYCTL_CHOWN</b> and <b>KEYCTL_SETPERM
keyctl</b>(2) operations;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform <b>madvise</b>(2) <b>MADV_HWPOISON</b>
operation;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <b>TIOCSTI ioctl</b>(2) to insert characters
into the input queue of a terminal other than the
caller&rsquo;s controlling terminal.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the obsolete <b>nfsservctl</b>(2) system
call;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the obsolete <b>bdflush</b>(2) system call;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various privileged block-device <b>ioctl</b>(2)
operations;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various privileged file-system <b>ioctl</b>(2)
operations;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform administrative operations on many device
drivers.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_BOOT</b></p>

<p style="margin-left:22%;">Use <b>reboot</b>(2) and
<b>kexec_load</b>(2).</p>

<p style="margin-left:11%;"><b>CAP_SYS_CHROOT</b></p>

<p style="margin-left:22%;">Use <b>chroot</b>(2).</p>

<p style="margin-left:11%;"><b>CAP_SYS_MODULE</b></p>

<p style="margin-left:22%;">Load and unload kernel modules
(see <b>init_module</b>(2) and <b>delete_module</b>(2)); in
kernels before 2.6.25: drop capabilities from the
system-wide capability bounding set.</p>

<p style="margin-left:11%;"><b>CAP_SYS_NICE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Raise process nice value (<b>nice</b>(2),
<b>setpriority</b>(2)) and change the nice value for
arbitrary processes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set real-time scheduling policies for calling process,
and set scheduling policies and priorities for arbitrary
processes (<b>sched_setscheduler</b>(2),
<b>sched_setparam</b>(2));</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set CPU affinity for arbitrary processes
(<b>sched_setaffinity</b>(2));</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set I/O scheduling class and priority for arbitrary
processes (<b>ioprio_set</b>(2));</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>apply <b>migrate_pages</b>(2) to arbitrary processes and
allow processes to be migrated to arbitrary nodes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>apply <b>move_pages</b>(2) to arbitrary processes;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use the <b>MPOL_MF_MOVE_ALL</b> flag with
<b>mbind</b>(2) and <b>move_pages</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_PACCT</b></p>

<p style="margin-left:22%;">Use <b>acct</b>(2).</p>

<p style="margin-left:11%;"><b>CAP_SYS_PTRACE</b></p>

<p style="margin-left:22%;">Trace arbitrary processes using
<b>ptrace</b>(2); apply <b>get_robust_list</b>(2) to
arbitrary processes; inspect processes using
<b>kcmp</b>(2).</p>

<p style="margin-left:11%;"><b>CAP_SYS_RAWIO</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Perform I/O port operations (<b>iopl</b>(2) and
<b>ioperm</b>(2));</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>access <i>/proc/kcore</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ the <b>FIBMAP ioctl</b>(2) operation;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>open devices for accessing x86 model-specific registers
(MSRs, see <b>msr</b>(4))</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>update <i>/proc/sys/vm/mmap_min_addr</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>create memory mappings at addresses below the value
specified by <i>/proc/sys/vm/mmap_min_addr</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>map files in <i>/proc/bus/pci</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>open <i>/dev/mem</i> and <i>/dev/kmem</i>;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform various SCSI device commands;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform certain operations on <b>hpsa</b>(4) and
<b>cciss</b>(4) devices;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>perform a range of device-specific operations on other
devices.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_RESOURCE</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>Use reserved space on ext2 file systems;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>make <b>ioctl</b>(2) calls controlling ext3
journaling;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override disk quota limits;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>increase resource limits (see <b>setrlimit</b>(2));</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override <b>RLIMIT_NPROC</b> resource limit;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override maximum number of consoles on console
allocation;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override maximum number of keymaps;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>allow more than 64hz interrupts from the real-time
clock;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>raise <i>msg_qbytes</i> limit for a System V message
queue above the limit in <i>/proc/sys/kernel/msgmnb</i> (see
<b>msgop</b>(2) and <b>msgctl</b>(2));</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override the <i>/proc/sys/fs/pipe-size-max</i> limit
when setting the capacity of a pipe using the
<b>F_SETPIPE_SZ fcntl</b>(2) command.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>use <b>F_SETPIPE_SZ</b> to increase the capacity of a
pipe above the limit specified by
<i>/proc/sys/fs/pipe-max-size</i>;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>override <i>/proc/sys/fs/mqueue/queues_max</i> limit
when creating POSIX message queues (see
<b>mq_overview</b>(7));</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>employ <b>prctl</b>(2) <b>PR_SET_MM</b> operation;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="75%">


<p>set <i>/proc/PID/oom_score_adj</i> to a value lower than
the value last set by a process with
<b>CAP_SYS_RESOURCE</b>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_SYS_TIME</b></p>

<p style="margin-left:22%;">Set system clock
(<b>settimeofday</b>(2), <b>stime</b>(2),
<b>adjtimex</b>(2)); set real-time (hardware) clock.</p>

<p style="margin-left:11%;"><b>CAP_SYS_TTY_CONFIG</b></p>

<p style="margin-left:22%;">Use <b>vhangup</b>(2); employ
various privileged <b>ioctl</b>(2) operations on virtual
terminals.</p>

<p style="margin-left:11%;"><b>CAP_SYSLOG</b> (since Linux
2.6.37)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Perform privileged <b>syslog</b>(2) operations. See
<b>syslog</b>(2) for information on which operations require
privilege.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>View kernel addresses exposed via <i>/proc</i> and other
interfaces when <i>/proc/sys/kernel/kptr_restrict</i> has
the value 1. (See the discussion of the <i>kptr_restrict</i>
in <b>proc</b>(5).)</p></td></tr>
</table>

<p style="margin-left:11%;"><b>CAP_WAKE_ALARM</b> (since
Linux 3.0)</p>

<p style="margin-left:15%;">Trigger something that will
wake up the system (set <b>CLOCK_REALTIME_ALARM</b> and
<b>CLOCK_BOOTTIME_ALARM</b> timers).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Past and
current implementation</b> <br>
A full implementation of capabilities requires that:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>For all privileged operations, the kernel must check
whether the thread has the required capability in its
effective set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The kernel must provide system calls allowing a
thread&rsquo;s capability sets to be changed and
retrieved.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The file system must support attaching capabilities to
an executable file, so that a process gains those
capabilities when the file is executed.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Before kernel
2.6.24, only the first two of these requirements are met;
since kernel 2.6.24, all three requirements are met.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Thread
capability sets</b> <br>
Each thread has three capability sets containing zero or
more of the above capabilities: <i><br>
Permitted</i>:</p>

<p style="margin-left:22%;">This is a limiting superset for
the effective capabilities that the thread may assume. It is
also a limiting superset for the capabilities that may be
added to the inheritable set by a thread that does not have
the <b>CAP_SETPCAP</b> capability in its effective set.</p>

<p style="margin-left:22%; margin-top: 1em">If a thread
drops a capability from its permitted set, it can never
reacquire that capability (unless it <b>execve</b>(2)s
either a set-user-ID-root program, or a program whose
associated file capabilities grant that capability).</p>

<p style="margin-left:11%;"><i>Inheritable</i>:</p>

<p style="margin-left:22%;">This is a set of capabilities
preserved across an <b>execve</b>(2). It provides a
mechanism for a process to assign capabilities to the
permitted set of the new program during an
<b>execve</b>(2).</p>

<p style="margin-left:11%;"><i>Effective</i>:</p>

<p style="margin-left:22%;">This is the set of capabilities
used by the kernel to perform permission checks for the
thread.</p>

<p style="margin-left:11%; margin-top: 1em">A child created
via <b>fork</b>(2) inherits copies of its parent&rsquo;s
capability sets. See below for a discussion of the treatment
of capabilities during <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Using
<b>capset</b>(2), a thread may manipulate its own capability
sets (see below).</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
3.2, the file <i>/proc/sys/kernel/cap_last_cap</i> exposes
the numerical value of the highest capability supported by
the running kernel; this can be used to determine the
highest bit that may be set in a capability set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>File
capabilities</b> <br>
Since kernel 2.6.24, the kernel supports associating
capability sets with an executable file using
<b>setcap</b>(8). The file capability sets are stored in an
extended attribute (see <b>setxattr</b>(2)) named
<i>security.capability</i>. Writing to this extended
attribute requires the <b>CAP_SETFCAP</b> capability. The
file capability sets, in conjunction with the capability
sets of the thread, determine the capabilities of a thread
after an <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The three file
capability sets are: <i><br>
Permitted</i> (formerly known as <i>forced</i>):</p>

<p style="margin-left:22%;">These capabilities are
automatically permitted to the thread, regardless of the
thread&rsquo;s inheritable capabilities.</p>

<p style="margin-left:11%;"><i>Inheritable</i> (formerly
known as <i>allowed</i>):</p>

<p style="margin-left:22%;">This set is ANDed with the
thread&rsquo;s inheritable set to determine which
inheritable capabilities are enabled in the permitted set of
the thread after the <b>execve</b>(2).</p>

<p style="margin-left:11%;"><i>Effective</i>:</p>

<p style="margin-left:22%;">This is not a set, but rather
just a single bit. If this bit is set, then during an
<b>execve</b>(2) all of the new permitted capabilities for
the thread are also raised in the effective set. If this bit
is not set, then after an <b>execve</b>(2), none of the new
permitted capabilities is in the new effective set.</p>

<p style="margin-left:22%; margin-top: 1em">Enabling the
file effective capability bit implies that any file
permitted or inheritable capability that causes a thread to
acquire the corresponding permitted capability during an
<b>execve</b>(2) (see the transformation rules described
below) will also acquire that capability in its effective
set. Therefore, when assigning capabilities to a file
(<b>setcap</b>(8), <b>cap_set_file</b>(3),
<b>cap_set_fd</b>(3)), if we specify the effective flag as
being enabled for any capability, then the effective flag
must also be specified as enabled for all other capabilities
for which the corresponding permitted or inheritable flags
is enabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Transformation
of capabilities during execve()</b> <br>
During an <b>execve</b>(2), the kernel calculates the new
capabilities of the process using the following
algorithm:</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(permitted)
= (P(inheritable) &amp; F(inheritable)) | <br>
(F(permitted) &amp; cap_bset)</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(effective)
= F(effective) ? P&rsquo;(permitted) : 0</p>


<p style="margin-left:17%; margin-top: 1em">P&rsquo;(inheritable)
= P(inheritable) [i.e., unchanged]</p>

<p style="margin-left:11%; margin-top: 1em">where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>P</p></td>
<td width="3%"></td>
<td width="68%">


<p>denotes the value of a thread capability set before the
<b>execve</b>(2)</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>P&rsquo;</p></td>
<td width="3%"></td>
<td width="68%">


<p>denotes the value of a capability set after the
<b>execve</b>(2)</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>F</p></td>
<td width="3%"></td>
<td width="68%">


<p>denotes a file capability set</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>cap_bset</p></td>
<td width="3%"></td>
<td width="68%">


<p>is the value of the capability bounding set (described
below).</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Capabilities
and execution of programs by root</b> <br>
In order to provide an all-powerful <i>root</i> using
capability sets, during an <b>execve</b>(2):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If a set-user-ID-root program is
being executed, or the real user ID of the process is 0
(root) then the file inheritable and permitted sets are
defined to be all ones (i.e., all capabilities enabled).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If a set-user-ID-root program is being executed, then
the file effective bit is defined to be one (enabled).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The upshot of
the above rules, combined with the capabilities
transformations described above, is that when a process
<b>execve</b>(2)s a set-user-ID-root program, or when a
process with an effective UID of 0 <b>execve</b>(2)s a
program, it gains all capabilities in its permitted and
effective capability sets, except those masked out by the
capability bounding set. This provides semantics that are
the same as those provided by traditional UNIX systems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set</b> <br>
The capability bounding set is a security mechanism that can
be used to limit the capabilities that can be gained during
an <b>execve</b>(2). The bounding set is used in the
following ways:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">During an <b>execve</b>(2), the
capability bounding set is ANDed with the file permitted
capability set, and the result of this operation is assigned
to the thread&rsquo;s permitted capability set. The
capability bounding set thus places a limit on the permitted
capabilities that may be granted by an executable file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>(Since Linux 2.6.25) The capability bounding set acts as
a limiting superset for the capabilities that a thread can
add to its inheritable set using <b>capset</b>(2). This
means that if a capability is not in the bounding set, then
a thread can&rsquo;t add this capability to its inheritable
set, even if it was in its permitted capabilities, and
thereby cannot have this capability preserved in its
permitted set when it <b>execve</b>(2)s a file that has the
capability in its inheritable set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
bounding set masks the file permitted capabilities, but not
the inherited capabilities. If a thread maintains a
capability in its inherited set that is not in its bounding
set, then it can still gain that capability in its permitted
set by executing a file that has the capability in its
inherited set.</p>

<p style="margin-left:11%; margin-top: 1em">Depending on
the kernel version, the capability bounding set is either a
system-wide attribute, or a per-process attribute.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set prior to Linux 2.6.25</b></p>

<p style="margin-left:11%; margin-top: 1em">In kernels
before 2.6.25, the capability bounding set is a system-wide
attribute that affects all threads on the system. The
bounding set is accessible via the file
<i>/proc/sys/kernel/cap-bound</i>. (Confusingly, this bit
mask parameter is expressed as a signed decimal number in
<i>/proc/sys/kernel/cap-bound</i>.)</p>

<p style="margin-left:11%; margin-top: 1em">Only the
<b>init</b> process may set capabilities in the capability
bounding set; other than that, the superuser (more
precisely: programs with the <b>CAP_SYS_MODULE</b>
capability) may only clear capabilities from this set.</p>

<p style="margin-left:11%; margin-top: 1em">On a standard
system the capability bounding set always masks out the
<b>CAP_SETPCAP</b> capability. To remove this restriction
(dangerous!), modify the definition of
<b>CAP_INIT_EFF_SET</b> in <i>include/linux/capability.h</i>
and rebuild the kernel.</p>

<p style="margin-left:11%; margin-top: 1em">The system-wide
capability bounding set feature was added to Linux starting
with kernel version 2.2.11.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capability
bounding set from Linux 2.6.25 onward</b></p>

<p style="margin-left:11%; margin-top: 1em">From Linux
2.6.25, the <i>capability bounding set</i> is a per-thread
attribute. (There is no longer a system-wide capability
bounding set.)</p>

<p style="margin-left:11%; margin-top: 1em">The bounding
set is inherited at <b>fork</b>(2) from the thread&rsquo;s
parent, and is preserved across an <b>execve</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">A thread may
remove capabilities from its capability bounding set using
the <b>prctl</b>(2) <b>PR_CAPBSET_DROP</b> operation,
provided it has the <b>CAP_SETPCAP</b> capability. Once a
capability has been dropped from the bounding set, it cannot
be restored to that set. A thread can determine if a
capability is in its bounding set using the <b>prctl</b>(2)
<b>PR_CAPBSET_READ</b> operation.</p>

<p style="margin-left:11%; margin-top: 1em">Removing
capabilities from the bounding set is supported only if file
capabilities are compiled into the kernel. In kernels before
Linux 2.6.33, file capabilities were an optional feature
configurable via the CONFIG_SECURITY_FILE_CAPABILITIES
option. Since Linux 2.6.33, the configuration option has
been removed and file capabilities are always part of the
kernel. When file capabilities are compiled into the kernel,
the <b>init</b> process (the ancestor of all processes)
begins with a full bounding set. If file capabilities are
not compiled into the kernel, then <b>init</b> begins with a
full bounding set minus <b>CAP_SETPCAP</b>, because this
capability has a different meaning when there are no file
capabilities.</p>

<p style="margin-left:11%; margin-top: 1em">Removing a
capability from the bounding set does not remove it from the
thread&rsquo;s inherited set. However it does prevent the
capability from being added back into the thread&rsquo;s
inherited set in the future.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Effect of
user ID changes on capabilities</b> <br>
To preserve the traditional semantics for transitions
between 0 and nonzero user IDs, the kernel makes the
following changes to a thread&rsquo;s capability sets on
changes to the thread&rsquo;s real, effective, saved set,
and file system user IDs (using <b>setuid</b>(2),
<b>setresuid</b>(2), or similar):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If one or more of the real,
effective or saved set user IDs was previously 0, and as a
result of the UID changes all of these IDs have a nonzero
value, then all capabilities are cleared from the permitted
and effective capability sets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the effective user ID is changed from 0 to nonzero,
then all capabilities are cleared from the effective
set.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the effective user ID is changed from nonzero to 0,
then the permitted set is copied to the effective set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>If the file system user ID is changed from 0 to nonzero
(see <b>setfsuid</b>(2)) then the following capabilities are
cleared from the effective set: <b>CAP_CHOWN</b>,
<b>CAP_DAC_OVERRIDE</b>, <b>CAP_DAC_READ_SEARCH</b>,
<b>CAP_FOWNER</b>, <b>CAP_FSETID</b>,
<b>CAP_LINUX_IMMUTABLE</b> (since Linux 2.2.30),
<b>CAP_MAC_OVERRIDE</b>, and <b>CAP_MKNOD</b> (since Linux
2.2.30). If the file system UID is changed from nonzero to
0, then any of these capabilities that are enabled in the
permitted set are enabled in the effective set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If a thread
that has a 0 value for one or more of its user IDs wants to
prevent its permitted capability set being cleared when it
resets all of its user IDs to nonzero values, it can do so
using the <b>prctl</b>(2) <b>PR_SET_KEEPCAPS</b>
operation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Programmatically
adjusting capability sets</b> <br>
A thread can retrieve and change its capability sets using
the <b>capget</b>(2) and <b>capset</b>(2) system calls.
However, the use of <b>cap_get_proc</b>(3) and
<b>cap_set_proc</b>(3), both provided in the <i>libcap</i>
package, is preferred for this purpose. The following rules
govern changes to the thread capability sets:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">If the caller does not have the
<b>CAP_SETPCAP</b> capability, the new inheritable set must
be a subset of the combination of the existing inheritable
and permitted sets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>(Since Linux 2.6.25) The new inheritable set must be a
subset of the combination of the existing inheritable set
and the capability bounding set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new permitted set must be a subset of the existing
permitted set (i.e., it is not possible to acquire permitted
capabilities that the thread does not currently have).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The new effective set must be a subset of the new
permitted set.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>The
securebits flags: establishing a capabilities-only
environment</b> <br>
Starting with kernel 2.6.26, and with a kernel in which file
capabilities are enabled, Linux implements a set of
per-thread <i>securebits</i> flags that can be used to
disable special handling of capabilities for UID 0
(<i>root</i>). These flags are as follows: <b><br>
SECBIT_KEEP_CAPS</b></p>

<p style="margin-left:22%;">Setting this flag allows a
thread that has one or more 0 UIDs to retain its
capabilities when it switches all of its UIDs to a nonzero
value. If this flag is not set, then such a UID switch
causes the thread to lose all capabilities. This flag is
always cleared on an <b>execve</b>(2). (This flag provides
the same functionality as the older <b>prctl</b>(2)
<b>PR_SET_KEEPCAPS</b> operation.)</p>


<p style="margin-left:11%;"><b>SECBIT_NO_SETUID_FIXUP</b></p>

<p style="margin-left:22%;">Setting this flag stops the
kernel from adjusting capability sets when the
threads&rsquo;s effective and file system UIDs are switched
between zero and nonzero values. (See the subsection
<i>Effect of User ID Changes on Capabilities</i>.)</p>

<p style="margin-left:11%;"><b>SECBIT_NOROOT</b></p>

<p style="margin-left:22%;">If this bit is set, then the
kernel does not grant capabilities when a set-user-ID-root
program is executed, or when a process with an effective or
real UID of 0 calls <b>execve</b>(2). (See the subsection
<i>Capabilities and execution of programs by root</i>.)</p>

<p style="margin-left:11%; margin-top: 1em">Each of the
above &quot;base&quot; flags has a companion
&quot;locked&quot; flag. Setting any of the
&quot;locked&quot; flags is irreversible, and has the effect
of preventing further changes to the corresponding
&quot;base&quot; flag. The locked flags are:
<b>SECBIT_KEEP_CAPS_LOCKED</b>,
<b>SECBIT_NO_SETUID_FIXUP_LOCKED</b>, and
<b>SECBIT_NOROOT_LOCKED</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>securebits</i> flags can be modified and retrieved using
the <b>prctl</b>(2) <b>PR_SET_SECUREBITS</b> and
<b>PR_GET_SECUREBITS</b> operations. The <b>CAP_SETPCAP</b>
capability is required to modify the flags.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>securebits</i> flags are inherited by child processes.
During an <b>execve</b>(2), all of the flags are preserved,
except <b>SECBIT_KEEP_CAPS</b> which is always cleared.</p>

<p style="margin-left:11%; margin-top: 1em">An application
can use the following call to lock itself, and all of its
descendants, into an environment where the only way of
gaining capabilities is by executing a program with
associated file capabilities:</p>


<p style="margin-left:17%; margin-top: 1em">prctl(PR_SET_SECUREBITS,
<br>
SECBIT_KEEP_CAPS_LOCKED | <br>
SECBIT_NO_SETUID_FIXUP | <br>
SECBIT_NO_SETUID_FIXUP_LOCKED | <br>
SECBIT_NOROOT | <br>
SECBIT_NOROOT_LOCKED);</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No standards
govern capabilities, but the Linux capability implementation
is based on the withdrawn POSIX.1e draft standard; see
<a href="http://wt.tuxomania.net/publications/posix.1e/">http://wt.tuxomania.net/publications/posix.1e/</a>.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Since kernel
2.5.27, capabilities are an optional kernel component, and
can be enabled/disabled via the CONFIG_SECURITY_CAPABILITIES
kernel configuration option.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>/proc/PID/task/TID/status</i> file can be used to view
the capability sets of a thread. The <i>/proc/PID/status</i>
file shows the capability sets of a process&rsquo;s main
thread. Before Linux 3.8, nonexistent capabilities were
shown as being enabled (1) in these sets. Since Linux 3.8,
all non-existent capabilities (above <b>CAP_LAST_CAP</b>)
are shown as disabled (0).</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>libcap</i> package provides a suite of routines for
setting and getting capabilities that is more comfortable
and less likely to change than the interface provided by
<b>capset</b>(2) and <b>capget</b>(2). This package also
provides the <b>setcap</b>(8) and <b>getcap</b>(8) programs.
It can be found at <br>

<a href="http://www.kernel.org/pub/linux/libs/security/linux-privs">http://www.kernel.org/pub/linux/libs/security/linux-privs</a>.</p>

<p style="margin-left:11%; margin-top: 1em">Before kernel
2.6.24, and since kernel 2.6.24 if file capabilities are not
enabled, a thread with the <b>CAP_SETPCAP</b> capability can
manipulate the capabilities of threads other than itself.
However, this is only theoretically possible, since no
thread ever has <b>CAP_SETPCAP</b> in either of these
cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>In the pre-2.6.25 implementation the system-wide
capability bounding set, <i>/proc/sys/kernel/cap-bound</i>,
always masks out this capability, and this can not be
changed without modifying the kernel source and
rebuilding.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="2%"></td>
<td width="86%">


<p>If file capabilities are disabled in the current
implementation, then <b>init</b> starts out with this
capability removed from its per-process bounding set, and
that bounding set is inherited by all other processes
created on the system.</p></td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>capget</b>(2),
<b>prctl</b>(2), <b>setfsuid</b>(2), <b>cap_clear</b>(3),
<b>cap_copy_ext</b>(3), <b>cap_from_text</b>(3),
<b>cap_get_file</b>(3), <b>cap_get_proc</b>(3),
<b>cap_init</b>(3), <b>capgetp</b>(3), <b>capsetp</b>(3),
<b>libcap</b>(3), <b>credentials</b>(7), <b>pthreads</b>(7),
<b>getcap</b>(8), <b>setcap</b>(8)</p>


<p style="margin-left:11%; margin-top: 1em"><i>include/linux/capability.h</i>
in the Linux kernel source tree</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
