<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:58:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT&minus;PULL</title>

</head>
<body>

<h1 align="center">GIT&minus;PULL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#GIT URLS">GIT URLS</a><br>
<a href="#REMOTES">REMOTES</a><br>
<a href="#MERGE STRATEGIES">MERGE STRATEGIES</a><br>
<a href="#DEFAULT BEHAVIOUR">DEFAULT BEHAVIOUR</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-pull
&minus; Fetch from and merge with another repository or a
local branch</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git pull</i>
[options] [&lt;repository&gt; [&lt;refspec&gt;...]]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Incorporates
changes from a remote repository into the current branch. In
its default mode, git pull is shorthand for git fetch
followed by git merge FETCH_HEAD.</p>

<p style="margin-left:11%; margin-top: 1em">More precisely,
<i>git pull</i> runs <i>git fetch</i> with the given
parameters and calls <i>git merge</i> to merge the retrieved
branch heads into the current branch. With
&minus;&minus;rebase, it runs <i>git rebase</i> instead of
<i>git merge</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;repository&gt;
should be the name of a remote repository as passed to
<b>git-fetch</b>(1). &lt;refspec&gt; can name an arbitrary
remote ref (for example, the name of a tag) or even a
collection of refs with corresponding remote&minus;tracking
branches (e.g., refs/heads/*:refs/remotes/origin/*), but
usually it is the name of a branch in the remote
repository.</p>

<p style="margin-left:11%; margin-top: 1em">Default values
for &lt;repository&gt; and &lt;branch&gt; are read from the
&quot;remote&quot; and &quot;merge&quot; configuration for
the current branch as set by <b>git-branch</b>(1)
&minus;&minus;track.</p>

<p style="margin-left:11%; margin-top: 1em">Assume the
following history exists and the current branch is
&quot;master&quot;:</p>


<p style="margin-left:17%; margin-top: 1em">A&minus;&minus;&minus;B&minus;&minus;&minus;C
master on origin <br>
/ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;F&minus;&minus;&minus;G
master</p>

<p style="margin-left:11%; margin-top: 1em">Then &quot;git
pull&quot; will fetch and replay the changes from the remote
master branch since it diverged from the local master (i.e.,
E) until its current commit (C) on top of master and record
the result in a new commit along with the names of the two
parent commits and a log message from the user describing
the changes.</p>


<p style="margin-left:17%; margin-top: 1em">A&minus;&minus;&minus;B&minus;&minus;&minus;C
remotes/origin/master <br>
/ \ <br>

D&minus;&minus;&minus;E&minus;&minus;&minus;F&minus;&minus;&minus;G&minus;&minus;&minus;H
master</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>git-merge</b>(1) for details, including how conflicts are
presented and handled.</p>

<p style="margin-left:11%; margin-top: 1em">In Git 1.7.0 or
later, to cancel a conflicting merge, use git reset
&minus;&minus;merge. <b>Warning</b>: In older versions of
Git, running <i>git pull</i> with uncommitted changes is
discouraged: while possible, it leaves you in a state that
may be hard to back out of in the case of a conflict.</p>

<p style="margin-left:11%; margin-top: 1em">If any of the
remote changes overlap with local uncommitted changes, the
merge will be automatically cancelled and the work tree
untouched. It is generally best to get any local changes in
working order before pulling or stash them away with
<b>git-stash</b>(1).</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Options meant
for <i>git pull</i> itself and the underlying <i>git
merge</i> must be given before the options meant for <i>git
fetch</i>.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q,
&minus;&minus;quiet</p>

<p style="margin-left:17%;">This is passed to both
underlying git&minus;fetch to squelch reporting of during
transfer, and underlying git&minus;merge to squelch output
during merging.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v,
&minus;&minus;verbose</p>

<p style="margin-left:17%;">Pass &minus;&minus;verbose to
git&minus;fetch and git&minus;merge.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;[no&minus;]recurse&minus;submodules[=yes|on&minus;demand|no]</p>

<p style="margin-left:17%;">This option controls if new
commits of all populated submodules should be fetched too
(see <b>git-config</b>(1) and <b>gitmodules</b>(5)). That
might be necessary to get the data needed for merging
submodule commits, a feature Git learned in 1.7.3. Notice
that the result of a merge will not be checked out in the
submodule, &quot;git submodule update&quot; has to be called
afterwards to bring the work tree up to date with the merge
result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options
related to merging</b> <br>
&minus;&minus;commit, &minus;&minus;no&minus;commit</p>

<p style="margin-left:17%;">Perform the merge and commit
the result. This option can be used to override
&minus;&minus;no&minus;commit.</p>

<p style="margin-left:17%; margin-top: 1em">With
&minus;&minus;no&minus;commit perform the merge but pretend
the merge failed and do not autocommit, to give the user a
chance to inspect and further tweak the merge result before
committing.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;edit,
&minus;&minus;no&minus;edit</p>

<p style="margin-left:17%;">Invoke an editor before
committing successful mechanical merge to further edit the
auto&minus;generated merge message, so that the user can
explain and justify the merge. The
&minus;&minus;no&minus;edit option can be used to accept the
auto&minus;generated message (this is generally
discouraged). The &minus;&minus;edit option is still useful
if you are giving a draft message with the &minus;m option
from the command line and want to edit it in the editor.</p>

<p style="margin-left:17%; margin-top: 1em">Older scripts
may depend on the historical behaviour of not allowing the
user to edit the merge log message. They will see an editor
opened when they run git merge. To make it easier to adjust
such scripts to the updated behaviour, the environment
variable GIT_MERGE_AUTOEDIT can be set to no at the
beginning of them.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;ff</p>

<p style="margin-left:17%;">When the merge resolves as a
fast&minus;forward, only update the branch pointer, without
creating a merge commit. This is the default behavior.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;ff</p>

<p style="margin-left:17%;">Create a merge commit even when
the merge resolves as a fast&minus;forward. This is the
default behaviour when merging an annotated (and possibly
signed) tag.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;ff&minus;only</p>

<p style="margin-left:17%;">Refuse to merge and exit with a
non&minus;zero status unless the current HEAD is already
up&minus;to&minus;date or the merge can be resolved as a
fast&minus;forward.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;log[=&lt;n&gt;],
&minus;&minus;no&minus;log</p>

<p style="margin-left:17%;">In addition to branch names,
populate the log message with one&minus;line descriptions
from at most &lt;n&gt; actual commits that are being merged.
See also <b>git-fmt-merge-msg</b>(1).</p>

<p style="margin-left:17%; margin-top: 1em">With
&minus;&minus;no&minus;log do not list one&minus;line
descriptions from the actual commits being merged.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;stat,
&minus;n, &minus;&minus;no&minus;stat</p>

<p style="margin-left:17%;">Show a diffstat at the end of
the merge. The diffstat is also controlled by the
configuration option merge.stat.</p>

<p style="margin-left:17%; margin-top: 1em">With &minus;n
or &minus;&minus;no&minus;stat do not show a diffstat at the
end of the merge.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;squash,
&minus;&minus;no&minus;squash</p>

<p style="margin-left:17%;">Produce the working tree and
index state as if a real merge happened (except for the
merge information), but do not actually make a commit or
move the HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the
next git commit command to create a merge commit. This
allows you to create a single commit on top of the current
branch whose effect is the same as merging another branch
(or more in case of an octopus).</p>

<p style="margin-left:17%; margin-top: 1em">With
&minus;&minus;no&minus;squash perform the merge and commit
the result. This option can be used to override
&minus;&minus;squash.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;s
&lt;strategy&gt;,
&minus;&minus;strategy=&lt;strategy&gt;</p>

<p style="margin-left:17%;">Use the given merge strategy;
can be supplied more than once to specify them in the order
they should be tried. If there is no &minus;s option, a
built&minus;in list of strategies is used instead (<i>git
merge&minus;recursive</i> when merging a single head, <i>git
merge&minus;octopus</i> otherwise).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;X
&lt;option&gt;,
&minus;&minus;strategy&minus;option=&lt;option&gt;</p>

<p style="margin-left:17%;">Pass merge strategy specific
option through to the merge strategy.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;verify&minus;signatures,
&minus;&minus;no&minus;verify&minus;signatures</p>

<p style="margin-left:17%;">Verify that the commits being
merged have good and trusted GPG signatures and abort the
merge in case they do not.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;summary,
&minus;&minus;no&minus;summary</p>

<p style="margin-left:17%;">Synonyms to &minus;&minus;stat
and &minus;&minus;no&minus;stat; these are deprecated and
will be removed in the future.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q,
&minus;&minus;quiet</p>

<p style="margin-left:17%;">Operate quietly. Implies
&minus;&minus;no&minus;progress.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v,
&minus;&minus;verbose</p>

<p style="margin-left:17%;">Be verbose.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;progress,
&minus;&minus;no&minus;progress</p>

<p style="margin-left:17%;">Turn progress on/off
explicitly. If neither is specified, progress is shown if
standard error is connected to a terminal. Note that not all
merge strategies may support progress reporting.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;r,
&minus;&minus;rebase</p>

<p style="margin-left:17%;">Rebase the current branch on
top of the upstream branch after fetching. If there is a
remote&minus;tracking branch corresponding to the upstream
branch and the upstream branch was rebased since last
fetched, the rebase uses that information to avoid rebasing
non&minus;local changes.</p>

<p style="margin-left:17%; margin-top: 1em">See
pull.rebase, branch.&lt;name&gt;.rebase and
branch.autosetuprebase in <b>git-config</b>(1) if you want
to make git pull always use &minus;&minus;rebase instead of
merging.</p>


<p style="margin-left:23%; margin-top: 1em"><b><big>Note</big></b>
<br>
This is a potentially <i>dangerous</i> mode of operation. It
rewrites history, which does not bode well when you
published that history already. Do <b>not</b> use this
option unless you have read <b>git-rebase</b>(1)
carefully.</p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;no&minus;rebase</big></p>

<p style="margin-left:17%;"><big>Override earlier
&minus;&minus;rebase.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b>Options
related to fetching</b> <br>
&minus;&minus;all</big></p>

<p style="margin-left:17%;"><big>Fetch all
remotes.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>&minus;a,
&minus;&minus;append</big></p>

<p style="margin-left:17%;"><big>Append ref names and
object names of fetched refs to the existing contents of
.git/FETCH_HEAD. Without this option old data in
.git/FETCH_HEAD will be overwritten.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;depth=&lt;depth&gt;</big></p>

<p style="margin-left:17%;"><big>Deepen or shorten the
history of a <i>shallow</i> repository created by git clone
with &minus;&minus;depth=&lt;depth&gt; option (see
<b>git-clone</b>(1)) to the specified number of commits from
the tip of each remote branch history. Tags for the deepened
commits are not fetched.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;unshallow</big></p>

<p style="margin-left:17%;"><big>Convert a shallow
repository to a complete one, removing all the limitations
imposed by shallow repositories.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>&minus;f,
&minus;&minus;force</big></p>

<p style="margin-left:17%;"><big>When <i>git fetch</i> is
used with &lt;rbranch&gt;:&lt;lbranch&gt; refspec, it
refuses to update the local branch &lt;lbranch&gt; unless
the remote branch &lt;rbranch&gt; it fetches is a descendant
of &lt;lbranch&gt;. This option overrides that
check.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>&minus;k,
&minus;&minus;keep</big></p>

<p style="margin-left:17%;"><big>Keep downloaded
pack.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;no&minus;tags</big></p>

<p style="margin-left:17%;"><big>By default, tags that
point at objects that are downloaded from the remote
repository are fetched and stored locally. This option
disables this automatic tag following. The default behavior
for a remote may be specified with the
remote.&lt;name&gt;.tagopt setting. See
<b>git-config</b>(1).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>&minus;u,
&minus;&minus;update&minus;head&minus;ok</big></p>

<p style="margin-left:17%;"><big>By default <i>git
fetch</i> refuses to update the head which corresponds to
the current branch. This flag disables the check. This is
purely for the internal use for <i>git pull</i> to
communicate with <i>git fetch</i>, and unless you are
implementing your own Porcelain you are not supposed to use
it.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;upload&minus;pack
&lt;upload&minus;pack&gt;</big></p>

<p style="margin-left:17%;"><big>When given, and the
repository to fetch from is handled by <i>git
fetch&minus;pack</i>,
<i>&minus;&minus;exec=&lt;upload&minus;pack&gt;</i> is
passed to the command to specify non&minus;default path for
the command run on the other end.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&minus;&minus;progress</big></p>

<p style="margin-left:17%;"><big>Progress status is
reported on the standard error stream by default when it is
attached to a terminal, unless &minus;q is specified. This
flag forces progress status even if the standard error
stream is not directed to a terminal.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&lt;repository&gt;</big></p>

<p style="margin-left:17%;"><big>The &quot;remote&quot;
repository that is the source of a fetch or pull operation.
This parameter can be either a URL (see the section GIT URLS
below) or the name of a remote (see the section REMOTES
below).</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&lt;refspec&gt;</big></p>

<p style="margin-left:17%;"><big>The format of a
&lt;refspec&gt; parameter is an optional plus +, followed by
the source ref &lt;src&gt;, followed by a colon :, followed
by the destination ref &lt;dst&gt;.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The remote
ref that matches &lt;src&gt; is fetched, and if &lt;dst&gt;
is not empty string, the local ref that matches it is
fast&minus;forwarded using &lt;src&gt;. If the optional plus
+ is used, the local ref is updated even if it does not
result in a fast&minus;forward update.</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
If the remote branch from which you want to pull is modified
in non&minus;linear ways such as being rewound and rebased
frequently, then a pull will attempt a merge with an older
version of itself, likely conflict, and fail. It is under
these conditions that you would want to use the + sign to
indicate non&minus;fast&minus;forward updates will be
needed. There is currently no easy way to determine or
declare that a branch will be made available in a repository
with this behavior; the pulling user simply must know this
is the expected usage pattern for a branch.</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
You never do your own development on branches that appear on
the right hand side of a &lt;refspec&gt; colon on Pull:
lines; they are to be updated by <i>git fetch</i>. If you
intend to do development derived from a remote branch B,
have a Pull: line to track it (i.e. Pull: B:remote&minus;B),
and have a separate branch my&minus;B to do your development
on top of it. The latter is created by git branch my&minus;B
remote&minus;B (or its equivalent git checkout &minus;b
my&minus;B remote&minus;B). Run git fetch to keep track of
the progress of the remote side, and when you see something
new on the remote branch, merge it into your development
branch with git pull . remote&minus;B, while you are on
my&minus;B branch.</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
There is a difference between listing multiple
&lt;refspec&gt; directly on <i>git pull</i> command line and
having multiple Pull: &lt;refspec&gt; lines for a
&lt;repository&gt; and running <i>git pull</i> command
without any explicit &lt;refspec&gt; parameters.
&lt;refspec&gt; listed explicitly on the command line are
always merged into the current branch after fetching. In
other words, if you list more than one remote refs, you
would be making an Octopus. While <i>git pull</i> run
without any explicit &lt;refspec&gt; parameter takes default
&lt;refspec&gt;s from Pull: lines, it merges only the first
&lt;refspec&gt; found into the current branch, after
fetching all the remote refs. This is because making an
Octopus from remote refs is rarely done, while keeping track
of multiple remote heads in one&minus;go by fetching more
than one is often useful.</big></p>

<p style="margin-left:17%;"><big>Some short&minus;cut
notations are also supported.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; tag
&lt;tag&gt; means the same as
refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;; it requests
fetching everything up to the given tag.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull; A
parameter &lt;ref&gt; without a colon is equivalent to
&lt;ref&gt;: when pulling/fetching, so it merges &lt;ref&gt;
into the current branch without storing the remote branch
anywhere locally</big></p>

<h2>GIT URLS
<a name="GIT URLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>In
general, URLs contain information about the transport
protocol, the address of the remote server, and the path to
the repository. Depending on the transport protocol, some of
this information may be absent.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>Git
supports ssh, git, http, and https protocols (in addition,
ftp, and ftps can be used for fetching and rsync can be used
for fetching and pushing, but these are inefficient and
deprecated; do not use them).</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
following syntaxes may be used with them:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
ssh://[user@]host.xz[:port]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
git://host.xz[:port]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
http[s]://host.xz[:port]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
ftp[s]://host.xz[:port]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
rsync://host.xz/path/to/repo.git/</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>An
alternative scp&minus;like syntax may also be used with the
ssh protocol:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
[user@]host.xz:path/to/repo.git/</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
ssh and git protocols additionally support ~username
expansion:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
git://host.xz[:port]/~[user]/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
[user@]host.xz:/~[user]/path/to/repo.git/</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>For
local repositories, also supported by Git natively, the
following syntaxes may be used:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
/path/to/repo.git/</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
<b><font color="#0000FF">file:///path/to/repo.git/</font></b></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">These
two syntaxes are mostly equivalent, except when cloning,
when the former implies &minus;&minus;local option. See
<b>git-clone</b>(1) for details.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">When
Git doesn&rsquo;t know how to handle a certain transport
protocol, it attempts to use the
<i>remote&minus;&lt;transport&gt;</i> remote helper, if one
exists. To explicitly request a remote helper, the following
syntax may be used:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
&lt;transport&gt;::&lt;address&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">where
&lt;address&gt; may be a path, a server and path, or an
arbitrary URL&minus;like string recognized by the specific
remote helper being invoked. See <b>gitremote-helpers</b>(1)
for details.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">If
there are a large number of similarly&minus;named remote
repositories and you want to use a different format for them
(such that the URLs you use will be rewritten into URLs that
work), you can create a configuration section of the
form:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">[url
&quot;&lt;actual url base&gt;&quot;] <br>
insteadOf = &lt;other url base&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">For
example, with this:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">[url
&quot;git://git.host.xz/&quot;] <br>
insteadOf = host.xz:/path/to/ <br>
insteadOf = work:</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">a
URL like &quot;work:repo.git&quot; or like
&quot;host.xz:/path/to/repo.git&quot; will be rewritten in
any context that takes a URL to be
&quot;git://git.host.xz/repo.git&quot;.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">If
you want to rewrite URLs for push only, you can create a
configuration section of the form:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">[url
&quot;&lt;actual url base&gt;&quot;] <br>
pushInsteadOf = &lt;other url
base&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">For
example, with this:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">[url
&quot;ssh://example.org/&quot;] <br>
pushInsteadOf = git://example.org/</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">a
URL like &quot;git://example.org/path/to/repo.git&quot; will
be rewritten to
&quot;ssh://example.org/path/to/repo.git&quot; for pushes,
but pulls will still use the original
URL.</font></big></big></p>

<h2>REMOTES
<a name="REMOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">The
name of one of the following can be used instead of a URL as
&lt;repository&gt; argument:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
a remote in the Git configuration file:
$GIT_DIR/config,</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
a file in the $GIT_DIR/remotes directory,
or</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
a file in the $GIT_DIR/branches
directory.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">All
of these also allow you to omit the refspec from the command
line because they each contain a refspec which git will use
by default.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000"><b>Named
remote in configuration file</b> <br>
You can choose to provide the name of a remote which you had
previously configured using <b>git-remote</b>(1),
<b>git-config</b>(1) or even by a manual edit to the
$GIT_DIR/config file. The URL of this remote will be used to
access the repository. The refspec of this remote will be
used by default when you do not provide a refspec on the
command line. The entry in the config file would appear like
this:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">[remote
&quot;&lt;name&gt;&quot;] <br>
url = &lt;url&gt; <br>
pushurl = &lt;pushurl&gt; <br>
push = &lt;refspec&gt; <br>
fetch = &lt;refspec&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">The
&lt;pushurl&gt; is used for pushes only. It is optional and
defaults to &lt;url&gt;.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000"><b>Named
file in $GIT_DIR/remotes</b> <br>
You can choose to provide the name of a file in
$GIT_DIR/remotes. The URL in this file will be used to
access the repository. The refspec in this file will be used
as default when you do not provide a refspec on the command
line. This file should have the following
format:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">URL:
one of the above URL format <br>
Push: &lt;refspec&gt; <br>
Pull: &lt;refspec&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">Push:
lines are used by <i>git push</i> and Pull: lines are used
by <i>git pull</i> and <i>git fetch</i>. Multiple Push: and
Pull: lines may be specified for additional branch
mappings.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000"><b>Named
file in $GIT_DIR/branches</b> <br>
You can choose to provide the name of a file in
$GIT_DIR/branches. The URL in this file will be used to
access the repository. This file should have the following
format:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&lt;url&gt;#&lt;head&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">&lt;url&gt;
is required; #&lt;head&gt; is
optional.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">Depending
on the operation, git will use one of the following
refspecs, if you don&rsquo;t provide one on the command
line. &lt;branch&gt; is the name of this file in
$GIT_DIR/branches and &lt;head&gt; defaults to
master.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">git
fetch uses:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">git
push uses:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">HEAD:refs/heads/&lt;head&gt;</font></big></big></p>

<h2>MERGE STRATEGIES
<a name="MERGE STRATEGIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">The
merge mechanism (<i>git&minus;merge</i> and
<i>git&minus;pull</i> commands) allows the backend <i>merge
strategies</i> to be chosen with &minus;s option. Some
strategies can also take their own options, which can be
passed by giving &minus;X&lt;option&gt; arguments to
<i>git&minus;merge</i> and/or
<i>git&minus;pull</i>.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">resolve</font></big></big></p>


<p style="margin-left:17%;"><big><big><font color="#000000">This
can only resolve two heads (i.e. the current branch and
another branch you pulled from) using a 3&minus;way merge
algorithm. It tries to carefully detect criss&minus;cross
merge ambiguities and is considered generally safe and
fast.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">recursive</font></big></big></p>


<p style="margin-left:17%;"><big><big><font color="#000000">This
can only resolve two heads using a 3&minus;way merge
algorithm. When there is more than one common ancestor that
can be used for 3&minus;way merge, it creates a merged tree
of the common ancestors and uses that as the reference tree
for the 3&minus;way merge. This has been reported to result
in fewer merge conflicts without causing mis&minus;merges by
tests done on actual merge commits taken from Linux 2.6
kernel development history. Additionally this can detect and
handle merges involving renames. This is the default merge
strategy when pulling or merging one
branch.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">The
<i>recursive</i> strategy can take the following
options:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">ours</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">This
option forces conflicting hunks to be auto&minus;resolved
cleanly by favoring <i>our</i> version. Changes from the
other tree that do not conflict with our side are reflected
to the merge result. For a binary file, the entire contents
are taken from our side.</font></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><font color="#000000">This
should not be confused with the <i>ours</i> merge strategy,
which does not even look at what the other tree contains at
all. It discards everything the other tree did, declaring
<i>our</i> history contains all that happened in
it.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">theirs</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">This
is the opposite of <i>ours</i>.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">patience</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">With
this option, <i>merge&minus;recursive</i> spends a little
extra time to avoid mismerges that sometimes occur due to
unimportant matching lines (e.g., braces from distinct
functions). Use this when the branches to be merged have
diverged wildly. See also
<b>git-diff</b>(1)&minus;&minus;patience.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">diff&minus;algorithm=[patience|minimal|histogram|myers]</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">Tells
<i>merge&minus;recursive</i> to use a different diff
algorithm, which can help avoid mismerges that occur due to
unimportant matching lines (such as braces from distinct
functions). See also
<b>git-diff</b>(1)&minus;&minus;diff&minus;algorithm.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">ignore&minus;space&minus;change,
ignore&minus;all&minus;space,
ignore&minus;space&minus;at&minus;eol</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">Treats
lines with the indicated type of whitespace change as
unchanged for the sake of a three&minus;way merge.
Whitespace changes mixed with other changes to a line are
not ignored. See also <b>git-diff</b>(1)&minus;b, &minus;w,
and
&minus;&minus;ignore&minus;space&minus;at&minus;eol.</font></big></big></p>


<p style="margin-left:29%; margin-top: 1em"><big><big><font color="#000000">&bull;
If <i>their</i> version only introduces whitespace changes
to a line, <i>our</i> version is
used;</font></big></big></p>


<p style="margin-left:29%; margin-top: 1em"><big><big><font color="#000000">&bull;
If <i>our</i> version introduces whitespace changes but
<i>their</i> version includes a substantial change,
<i>their</i> version is used;</font></big></big></p>


<p style="margin-left:29%; margin-top: 1em"><big><big><font color="#000000">&bull;
Otherwise, the merge proceeds in the usual
way.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">renormalize</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">This
runs a virtual check&minus;out and check&minus;in of all
three stages of a file when resolving a three&minus;way
merge. This option is meant to be used when merging branches
with different clean filters or end&minus;of&minus;line
normalization rules. See &quot;Merging branches with
differing checkin/checkout attributes&quot; in
<b>gitattributes</b>(5) for details.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">no&minus;renormalize</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">Disables
the renormalize option. This overrides the merge.renormalize
configuration variable.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">rename&minus;threshold=&lt;n&gt;</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">Controls
the similarity threshold used for rename detection. See also
<b>git-diff</b>(1)&minus;M.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">subtree[=&lt;path&gt;]</font></big></big></p>


<p style="margin-left:23%;"><big><big><font color="#000000">This
option is a more advanced form of <i>subtree</i> strategy,
where the strategy makes a guess on how two trees must be
shifted to match with each other when merging. Instead, the
specified path is prefixed (or stripped from the beginning)
to make the shape of two trees to
match.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">octopus</font></big></big></p>


<p style="margin-left:17%;"><big><big><font color="#000000">This
resolves cases with more than two heads, but refuses to do a
complex merge that needs manual resolution. It is primarily
meant to be used for bundling topic branch heads together.
This is the default merge strategy when pulling or merging
more than one branch.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">ours</font></big></big></p>


<p style="margin-left:17%;"><big><big><font color="#000000">This
resolves any number of heads, but the resulting tree of the
merge is always that of the current branch head, effectively
ignoring all changes from all other branches. It is meant to
be used to supersede old development history of side
branches. Note that this is different from the &minus;Xours
option to the <i>recursive</i> merge
strategy.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">subtree</font></big></big></p>


<p style="margin-left:17%;"><big><big><font color="#000000">This
is a modified recursive strategy. When merging trees A and
B, if B corresponds to a subtree of A, B is first adjusted
to match the tree structure of A, instead of reading the
trees at the same level. This adjustment is also done to the
common ancestor tree.</font></big></big></p>

<h2>DEFAULT BEHAVIOUR
<a name="DEFAULT BEHAVIOUR"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">Often
people use git pull without giving any parameter.
Traditionally, this has been equivalent to saying git pull
origin. However, when configuration
branch.&lt;name&gt;.remote is present while on branch
&lt;name&gt;, that value is used instead of
origin.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">In
order to determine what URL to use to fetch from, the value
of the configuration remote.&lt;origin&gt;.url is consulted
and if there is not any such variable, the value on URL:
&lsquo; line in &lsquo;$GIT_DIR/remotes/&lt;origin&gt; file
is used.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">In
order to determine what remote branches to fetch (and
optionally store in the remote&minus;tracking branches) when
the command is run without any refspec parameters on the
command line, values of the configuration variable
remote.&lt;origin&gt;.fetch are consulted, and if there
aren&rsquo;t any, $GIT_DIR/remotes/&lt;origin&gt; file is
consulted and its &lsquo;Pull: &lsquo; lines are used. In
addition to the refspec formats described in the OPTIONS
section, you can have a globbing refspec that looks like
this:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">refs/heads/*:refs/remotes/origin/*</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">A
globbing refspec must have a non&minus;empty RHS (i.e. must
store what were fetched in remote&minus;tracking branches),
and its LHS and RHS must end with /*. The above specifies
that all remote branches are tracked using
remote&minus;tracking branches in refs/remotes/origin/
hierarchy under the same name.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">The
rule to determine which remote branch to merge after
fetching is a bit involved, in order not to break backward
compatibility.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">If
explicit refspecs were given on the command line of git
pull, they are all merged.</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">When
no refspec was given on the command line, then git pull uses
the refspec from the configuration or
$GIT_DIR/remotes/&lt;origin&gt;. In such cases, the
following rules apply:</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">1.
If branch.&lt;name&gt;.merge configuration for the current
branch &lt;name&gt; exists, that is the name of the branch
at the remote site that is merged.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">2.
If the refspec is a globbing one, nothing is
merged.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">3.
Otherwise the remote branch of the first refspec is
merged.</font></big></big></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
Update the remote&minus;tracking branches for the repository
you cloned from, then merge one of them into your current
branch:</font></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><font color="#000000">$
git pull, git pull origin</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">Normally
the branch merged in is the HEAD of the remote repository,
but the choice is determined by the
branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge
options; see <b>git-config</b>(1) for
details.</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">&bull;
Merge into the current branch the remote branch
next:</font></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><font color="#000000">$
git pull origin next</font></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><font color="#000000">This
leaves a copy of next temporarily in FETCH_HEAD, but does
not update any remote&minus;tracking branches. Using
remote&minus;tracking branches, the same can be done by
invoking fetch and merge:</font></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><font color="#000000">$
git fetch origin <br>
$ git merge origin/next</font></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">If
you tried a pull which resulted in complex conflicts and
would want to start over, you can recover with <i>git
reset</i>.</font></big></big></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">Using
&minus;&minus;recurse&minus;submodules can only fetch new
commits in already checked out submodules right now. When
e.g. upstream added a new submodule in the just fetched
commits of the superproject the submodule itself can not be
fetched, making it impossible to check out that submodule
later without having to do a fetch again. This is expected
to be fixed in a future Git version.</font></big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000"><b>git-fetch</b>(1),
<b>git-merge</b>(1),
<b>git-config</b>(1)</font></big></big></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><font color="#000000">Part
of the <b>git</b>(1) suite</font></big></big></p>
<hr>
</body>
</html>
