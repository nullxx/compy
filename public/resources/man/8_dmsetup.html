<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:24:39 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DMSETUP</title>

</head>
<body>

<h1 align="center">DMSETUP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#COMMANDS">COMMANDS</a><br>
<a href="#TABLE FORMAT">TABLE FORMAT</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">dmsetup &mdash;
low level logical volume management</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>dmsetup
clear</b> <i>device_name</i> <b><br>
dmsetup create</b> <i>device_name</i> [<b>&minus;u</b>
<i>uuid</i>]
[<b>&minus;n</b>|<b>&minus;&minus;notable</b>|<b>&minus;&minus;table</b>
&lt;<i>table</i>&gt;|</p>

<p style="margin-left:22%;"><i>table_file</i>]
[{<b>&minus;&minus;addnodeoncreate</b>|<b>&minus;&minus;addnodeonresume</b>}]
[<b>&minus;&minus;readahead</b>
[<i>+</i>]&lt;<i>sectors</i>&gt;|<i>auto</i>|<i>none</i>]</p>

<p style="margin-left:11%;"><b>dmsetup deps</b>
[<b>&minus;o</b> <i>options</i>] [<i>device_name</i>]
<b><br>
dmsetup help</b>
[<b>&minus;c</b>|<b>&minus;C</b>|<b>&minus;&minus;columns</b>]
<b><br>
dmsetup info</b> [<i>device_name</i>] <b><br>
dmsetup info
&minus;c</b>|<b>&minus;C</b>|<b>&minus;&minus;columns</b>
[<b>&minus;&minus;nameprefixes</b>]
[<b>&minus;&minus;noheadings</b>]
[<b>&minus;&minus;separator</b> <i>separator</i>]</p>

<p style="margin-left:22%;">[<b>&minus;o</b> <i>fields</i>]
[<b>&minus;O</b>|<b>&minus;&minus;sort</b>
<i>sort_fields</i>]
[<b>&minus;S</b>|<b>&minus;&minus;select</b>
<i>Selection</i>] [<b>&minus;&minus;interval</b>
<i>seconds</i>] [<b>&minus;&minus;count</b> <i>count</i>]
[<i>device_name</i>]</p>

<p style="margin-left:11%;"><b>dmsetup load</b>
<i>device_name</i> [<b>&minus;&minus;table</b>
&lt;<i>table</i>&gt;|<i>table_file</i>] <b><br>
dmsetup ls</b> [<b>&minus;&minus;target</b>
<i>target_type</i>] [<b>&minus;&minus;exec</b>
<i>command</i>] [<b>&minus;&minus;tree</b>]</p>

<p style="margin-left:22%;">[<b>&minus;o</b>
<i>options</i>]</p>

<p style="margin-left:11%;"><b>dmsetup message</b>
<i>device_name sector message</i> <b><br>
dmsetup mknodes</b> [<i>device_name</i>] <b><br>
dmsetup mangle</b> [<i>device_name</i>] <b><br>
dmsetup reload</b> <i>device_name</i>
[<b>&minus;&minus;table</b>
&lt;<i>table</i>&gt;|<i>table_file</i>] <b><br>
dmsetup wipe_table</b> <i>device_name</i> <b><br>
dmsetup remove</b>
[<b>&minus;f</b>|<b>&minus;&minus;force</b>]
[<b>&minus;&minus;retry</b>] [<b>&minus;&minus;deferred</b>]
<i>device_name</i> <b><br>
dmsetup remove_all</b>
[<b>&minus;f</b>|<b>&minus;&minus;force</b>]
[<b>&minus;&minus;deferred</b>] <b><br>
dmsetup rename</b> <i>device_name new_name</i> <b><br>
dmsetup rename</b> <i>device_name</i>
<b>&minus;&minus;setuuid</b> <i>uuid</i> <b><br>
dmsetup resume</b> <i>device_name</i>
[{<b>&minus;&minus;addnodeoncreate</b>|<b>&minus;&minus;addnodeonresume</b>}]</p>


<p style="margin-left:22%;">[<b>&minus;&minus;readahead</b>
[<i>+</i>]&lt;<i>sectors</i>&gt;|<i>auto</i>|<i>none</i>]</p>

<p style="margin-left:11%;"><b>dmsetup setgeometry</b>
<i>device_name cyl head sect start</i> <b><br>
dmsetup splitname</b> <i>device_name</i> [<i>subsystem</i>]
<b><br>
dmsetup status</b> [<b>&minus;&minus;target</b>
<i>target_type</i>] [<b>&minus;&minus;noflush</b>]
[<i>device_name</i>] <b><br>
dmsetup suspend</b> [<b>&minus;&minus;nolockfs</b>]
[<b>&minus;&minus;noflush</b>] <i>device_name</i> <b><br>
dmsetup table</b> [<b>&minus;&minus;target</b>
<i>target_type</i>] [<b>&minus;&minus;showkeys</b>]
[<i>device_name</i>] <b><br>
dmsetup targets <br>
dmsetup udevcomplete</b> <i>cookie</i> <b><br>
dmsetup udevcomplete_all</b> [<i>age_in_minutes</i>] <b><br>
dmsetup udevcookies <br>
dmsetup udevcreatecookie <br>
dmsetup udevflags</b> <i>cookie</i> <b><br>
dmsetup udevreleasecookie</b> [<i>cookie</i>] <b><br>
dmsetup version <br>
dmsetup wait</b> [<b>&minus;&minus;noflush</b>]
<i>device_name</i> [<i>event_nr</i>]</p>


<p style="margin-left:11%; margin-top: 1em"><b>devmap_name</b>
<i>major minor</i> <b><br>
devmap_name</b> <i>major:minor</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">dmsetup manages
logical devices that use the device-mapper driver. Devices
are created by loading a table that specifies a target for
each sector (512 bytes) in the logical device.</p>

<p style="margin-left:11%; margin-top: 1em">The first
argument to dmsetup is a command. The second argument is the
logical device name or uuid.</p>

<p style="margin-left:11%; margin-top: 1em">Invoking the
command as <b>devmap_name</b> is equivalent to <b><br>
dmsetup info &minus;c &minus;&minus;noheadings &minus;j</b>
<i>major</i> <b>&minus;m</b> <i>minor</i><b>.</b></p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;addnodeoncreate</b></p>

<p style="margin-left:22%;">Ensure /dev/mapper node exists
after dmsetup create.</p>


<p style="margin-left:11%;"><b>&minus;&minus;addnodeonresume</b></p>

<p style="margin-left:22%;">Ensure /dev/mapper node exists
after dmsetup resume (default with udev).</p>


<p style="margin-left:11%;"><b>&minus;&minus;checks</b></p>

<p style="margin-left:22%;">Perform additional checks on
the operations requested and report potential problems.
Useful when debugging scripts. In some cases these checks
may slow down operations noticeably.</p>


<p style="margin-left:11%;"><b>&minus;c</b>|<b>&minus;C</b>|<b>&minus;&minus;columns</b></p>

<p style="margin-left:22%;">Display output in columns
rather than as Field: Value lines.</p>

<p style="margin-left:11%;"><b>&minus;&minus;count</b>
<i>count</i></p>

<p style="margin-left:22%;">Specify the number of times to
repeat a report. Set this to zero continue until
interrupted. The default interval is one second.</p>


<p style="margin-left:11%;"><b>&minus;h</b>|<b>&minus;&minus;help</b></p>

<p style="margin-left:22%;">Outputs a summary of the
commands available, optionally including the list of report
fields (synonym with <b>help</b> command).</p>


<p style="margin-left:11%;"><b>&minus;&minus;inactive</b></p>

<p style="margin-left:22%;">When returning any table
information from the kernel report on the inactive table
instead of the live table. Requires kernel driver version
4.16.0 or above.</p>

<p style="margin-left:11%;"><b>&minus;&minus;interval</b>
<i>seconds</i></p>

<p style="margin-left:22%;">Specify the interval in seconds
between successive iterations for repeating reports. If
&minus;&minus;interval is specified but &minus;&minus;count
is not, reports will continue to repeat until interrupted.
The default interval is one second.</p>


<p style="margin-left:11%;"><b>&minus;&minus;manglename&nbsp;</b>{<i>none</i>|<i>hex</i>|<i>auto</i>}</p>

<p style="margin-left:22%;">Mangle any character not on a
whitelist using mangling_mode when processing device-mapper
device names and UUIDs. The names and UUIDs are mangled on
input and unmangled on output where the mangling mode is one
of: <i>none</i> (no mangling), <i>hex</i> (always do the
mangling) and <i>auto</i> (only do the mangling if not
mangled yet, do nothing if already mangled, error on mixed)
Default mode is <i>auto</i>. Character whitelist: 0-9, A-Z,
a-z, #+-.:=@_. This whitelist is also supported by udev. Any
character not on a whitelist is replaced with its hex value
(two digits) prefixed by \x. Mangling mode could be also set
through <b>DM_DEFAULT_NAME_MANGLING_MODE</b> environment
variable.</p>


<p style="margin-left:11%;"><b>&minus;j</b>|<b>&minus;&minus;major&nbsp;</b><i>major</i></p>

<p style="margin-left:22%;">Specify the major number.</p>


<p style="margin-left:11%;"><b>&minus;m</b>|<b>&minus;&minus;minor&nbsp;</b><i>minor</i></p>

<p style="margin-left:22%;">Specify the minor number.</p>


<p style="margin-left:11%;"><b>&minus;n</b>|<b>&minus;&minus;notable</b></p>

<p style="margin-left:22%;">When creating a device,
don&rsquo;t load any table.</p>


<p style="margin-left:11%;"><b>&minus;&minus;nameprefixes</b></p>

<p style="margin-left:22%;">Add a &quot;DM_&quot; prefix
plus the field name to the output. Useful with --noheadings
to produce a list of field=value pairs that can be used to
set environment variables (for example, in udev(7)
rules).</p>


<p style="margin-left:11%;"><b>&minus;&minus;noheadings</b></p>

<p style="margin-left:22%;">Suppress the headings line when
using columnar output.</p>


<p style="margin-left:11%;"><b>&minus;&minus;noopencount</b></p>

<p style="margin-left:22%;">Tell the kernel not to supply
the open reference count for the device.</p>


<p style="margin-left:11%;"><b>&minus;&minus;noudevrules</b></p>

<p style="margin-left:22%;">Do not allow udev to manage
nodes for devices in device-mapper directory.</p>


<p style="margin-left:11%;"><b>&minus;&minus;noudevsync</b></p>

<p style="margin-left:22%;">Do not synchronise with udev
when creating, renaming or removing devices.</p>


<p style="margin-left:11%;"><b>&minus;o</b>|<b>&minus;&minus;options</b></p>

<p style="margin-left:22%;">Specify which fields to
display.</p>


<p style="margin-left:11%;"><b>&minus;&minus;readahead&nbsp;</b>[<i>+</i>]&lt;<i>sectors</i>&gt;|<i>auto</i>|<i>none</i></p>

<p style="margin-left:22%;">Specify read ahead size in
units of sectors. The default value is <i>auto</i> which
allows the kernel to choose a suitable value automatically.
The <i>+</i> prefix lets you specify a minimum value which
will not be used if it is smaller than the value chosen by
the kernel. The value <i>none</i> is equivalent to
specifying zero.</p>


<p style="margin-left:11%;"><b>&minus;r</b>|<b>&minus;&minus;readonly</b></p>

<p style="margin-left:22%;">Set the table being loaded
read-only.</p>


<p style="margin-left:11%;"><b>&minus;S</b>|<b>&minus;&minus;select&nbsp;</b><i>Selection</i></p>

<p style="margin-left:22%;">Display only rows that match
Selection criteria. All rows are displayed with the
additional &quot;selected&quot; column (-o selected) showing
1 if the row matches the Selection and 0 otherwise. The
Selection criteria are defined by specifying column names
and their valid values while making use of supported
comparison operators. As a quick help and to see full list
of column names that can be used in Selection and the set of
supported selection operators, check the output of
<b>dmsetup info -c -S help</b> command.</p>


<p style="margin-left:11%;"><b>&minus;&minus;table&nbsp;</b>&lt;<i>table</i>&gt;</p>

<p style="margin-left:22%;">Specify a one-line table
directly on the command line.</p>


<p style="margin-left:11%;"><b>&minus;&minus;udevcookie</b>
<i>cookie</i></p>

<p style="margin-left:22%;">Use cookie for udev
synchronisation. Note: Same cookie should be used for same
type of operations i.e. creation of multiple different
devices. It&rsquo;s not adviced to combine different
operations on the single device.</p>


<p style="margin-left:11%;"><b>&minus;u</b>|<b>&minus;&minus;uuid</b></p>

<p style="margin-left:22%;">Specify the uuid.</p>


<p style="margin-left:11%;"><b>&minus;y</b>|<b>&minus;&minus;yes</b></p>

<p style="margin-left:22%;">Answer yes to all prompts
automatically.</p>


<p style="margin-left:11%;"><b>&minus;v</b>|<b>&minus;&minus;verbose&nbsp;</b>[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]</p>

<p style="margin-left:22%;">Produce additional output.</p>


<p style="margin-left:11%;"><b>&minus;&minus;verifyudev</b></p>

<p style="margin-left:22%;">If udev synchronisation is
enabled, verify that udev operations get performed correctly
and try to fix up the device nodes afterwards if not.</p>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:22%;">Display the library and kernel
driver version.</p>

<h2>COMMANDS
<a name="COMMANDS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>clear</b></p></td>
<td width="4%"></td>
<td width="16%">


<p style="margin-top: 1em"><i>device_name</i></p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:22%;">Destroys the table in the
inactive table slot for device_name.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>create</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>device_name</i>
[<b>&minus;u</b> <i>uuid</i>]
[<b>&minus;n</b>|<b>&minus;&minus;notable</b>|<b>&minus;&minus;table</b>
&lt;<i>table</i>&gt;|<i>table_file</i>]
[{<b>&minus;&minus;addnodeoncreate</b>|<b>&minus;&minus;addnodeonresume</b>}]
[<b>&minus;&minus;readahead</b>
[<i>+</i>]&lt;<i>sectors</i>&gt;|<i>auto</i>|<i>none</i>]</p> </td></tr>
</table>

<p style="margin-left:22%;">Creates a device with the given
name. If table_file or &lt;table&gt; is supplied, the table
is loaded and made live. Otherwise a table is read from
standard input unless <b>&minus;&minus;notable</b> is used.
The optional uuid can be used in place of device_name in
subsequent dmsetup commands. If successful a device will
appear as /dev/mapper/&lt;device-name&gt;. See below for
information on the table format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>deps</b></p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">[<b>&minus;o</b> <i>options</i>]
[<i>device_name</i>]</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">Outputs a list of devices
referenced by the live table for the specified device.
Device names on output can be customised by following
options: devno (major and minor pair, used by default),
blkdevname (block device name), devname (map name for
device-mapper devices, equal to blkdevname otherwise).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>help</b></p></td>
<td width="5%"></td>
<td width="26%">



<p style="margin-top: 1em">[<b>&minus;c</b>|<b>&minus;C</b>|<b>&minus;&minus;columns</b>]</p> </td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:22%;">Outputs a summary of the
commands available, optionally including the list of report
fields.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>info</b></p></td>
<td width="5%"></td>
<td width="20%">


<p style="margin-top: 1em">[<i>device_name</i>]</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:22%;">Outputs some brief information
about the device in the form:</p>

<p style="margin-left:32%;">State: SUSPENDED|ACTIVE,
READ-ONLY <br>
Tables present: LIVE and/or INACTIVE <br>
Open reference count <br>
Last event sequence number (used by <b>wait</b>) <br>
Major and minor device number <br>
Number of targets in the live table <br>
UUID</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>info</b></p></td>
<td width="5%"></td>
<td width="78%">



<p style="margin-top: 1em"><b>&minus;c</b>|<b>&minus;C</b>|<b>&minus;&minus;columns</b>
[<b>&minus;&minus;noheadings</b>]
[<b>&minus;&minus;separator</b> <i>separator</i>]
[<b>&minus;o</b> <i>fields</i>]
[<b>&minus;O</b>|<b>&minus;&minus;sort</b>
<i>sort_fields</i>] [<b>&minus;&minus;interval</b>
<i>seconds</i>] [<b>&minus;&minus;count</b> <i>count</i>]
[<i>device_name</i>]</p> </td></tr>
</table>

<p style="margin-left:22%;">Output you can customise.
Fields are comma-separated and chosen from the following
list: name, major, minor, attr, open, segments, events,
uuid. Attributes are: (L)ive, (I)nactive, (s)uspended,
(r)ead-only, read-(w)rite. Precede the list with
&rsquo;+&rsquo; to append to the default selection of
columns instead of replacing it. Precede any sort_field with
- for a reverse sort on that column.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>ls</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">[<b>&minus;&minus;target</b>
<i>target_type</i>] [<b>&minus;&minus;exec</b>
<i>command</i>] [<b>&minus;&minus;tree</b>] [<b>&minus;o</b>
<i>options</i>]</p> </td></tr>
</table>

<p style="margin-left:22%;">List device names. Optionally
only list devices that have at least one target of the
specified type. Optionally execute a command for each
device. The device name is appended to the supplied command.
Device names on output can be customised by following
options: devno (major and minor pair, used by default),
blkdevname (block device name), devname (map name for
device-mapper devices, equal to blkdevname otherwise).
<b>&minus;&minus;tree</b> displays dependencies between
devices as a tree. It accepts a comma-separate list of
options. Some specify the information displayed against each
node: device/nodevice; blkdevname; active, open, rw, uuid.
Others specify how the tree is displayed: ascii, utf, vt100;
compact, inverted, notrunc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="35%">


<p style="margin-top: 1em"><b>load</b>|<b>reload</b>
<i>device_name</i></p> </td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em">[<b>&minus;&minus;table</b>
&lt;<i>table</i>&gt;|<i>table_file</i>]</p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:22%;">Loads &lt;table&gt; or
table_file into the inactive table slot for device_name. If
neither is supplied, reads a table from standard input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>wipe_table</b></p></td>
<td width="2%"></td>
<td width="17%">


<p style="margin-top: 1em"><i>device_name</i></p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:22%;">Wait for any I/O in-flight
through the device to complete, then replace the table with
a new table that fails any new I/O sent to the device. If
successful, this should release any devices held open by the
device&rsquo;s table(s).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>message</b></p></td>
<td width="1%"></td>
<td width="40%">


<p style="margin-top: 1em"><i>device_name sector
message</i></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:22%;">Send message to target. If
sector not needed use 0.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>mknodes</b></p></td>
<td width="1%"></td>
<td width="20%">


<p style="margin-top: 1em">[<i>device_name</i>]</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:22%;">Ensure that the node in
/dev/mapper for device_name is correct. If no device_name is
supplied, ensure that all nodes in /dev/mapper correspond to
mapped devices currently loaded by the device-mapper kernel
driver, adding, changing or removing nodes as necessary.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>mangle</b></p></td>
<td width="2%"></td>
<td width="20%">


<p style="margin-top: 1em">[<i>device_name</i>]</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:22%;">Ensure existing device-mapper
device name and UUID is in the correct mangled form
containing only whitelisted characters (supported by udev)
and do a rename if necessary. Any character not on the
whitelist will be mangled based on the
<b>&minus;&minus;manglename</b> setting. Automatic rename
works only for device names and not for device UUIDs because
the kernel does not allow changing the UUID of active
devices. Any incorrect UUIDs are reported only and they must
be manually corrected by deactivating the device first and
then reactivating it with proper mangling mode used (see
also <b>&minus;&minus;manglename</b>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>remove</b></p></td>
<td width="2%"></td>
<td width="72%">



<p style="margin-top: 1em">[<b>&minus;f</b>|<b>&minus;&minus;force</b>]
[<b>&minus;&minus;retry</b>] [<b>&minus;&minus;deferred</b>]
<i>device_name</i></p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:22%;">Removes a device. It will no
longer be visible to dmsetup. Open devices cannot be
removed, but adding <b>&minus;&minus;force</b> will replace
the table with one that fails all I/O.
<b>&minus;&minus;deferred</b> will enable deferred removal
of open devices - the device will be removed when the last
user closes it. The deferred removal feature is supported
since version 4.27.0 of the device-mapper driver available
in upstream kernel version 3.13. (Use <b>dmsetup version</b>
to check this.) If an attempt to remove a device fails,
perhaps because a process run from a quick udev rule
temporarily opened the device, the
<b>&minus;&minus;retry</b> option will cause the operation
to be retried for a few seconds before failing. Do NOT
combine <b>&minus;&minus;force</b> and
<b>&minus;&minus;udevcookie</b>, as udev may start to
process udev rules in the middle of error target replacement
and result in nondeterministic result.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>remove_all</b></p></td>
<td width="2%"></td>
<td width="38%">



<p style="margin-top: 1em">[<b>&minus;f</b>|<b>&minus;&minus;force</b>]
[<b>&minus;&minus;deferred</b>]</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:22%;">Attempts to remove all device
definitions i.e. reset the driver. This also runs
<b>mknodes</b> afterwards. Use with care! Open devices
cannot be removed, but adding <b>&minus;&minus;force</b>
will replace the table with one that fails all I/O.
<b>&minus;&minus;deferred</b> will enable deferred removal
of open devices - the device will be removed when the last
user closes it. The deferred removal feature is supported
since version 4.27.0 of the device-mapper driver available
in upstream kernel version 3.13.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>rename</b></p></td>
<td width="2%"></td>
<td width="30%">


<p style="margin-top: 1em"><i>device_name new_name</i></p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:22%;">Renames a device.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>rename</b></p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><i>device_name</i>
<b>&minus;&minus;setuuid</b> <i>uuid</i></p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the uuid of a device that
was created without a uuid. After a uuid has been set it
cannot be changed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>resume</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>device_name</i>
[{<b>&minus;&minus;addnodeoncreate</b>|<b>&minus;&minus;addnodeonresume</b>}]
[<b>&minus;&minus;readahead</b>
[<i>+</i>]&lt;<i>sectors</i>&gt;|<i>auto</i>|<i>none</i>]</p> </td></tr>
</table>

<p style="margin-left:22%;">Un-suspends a device. If an
inactive table has been loaded, it becomes live. Postponed
I/O then gets re-queued for processing.</p>

<p style="margin-left:11%;"><b>setgeometry</b>
<i>device_name cyl head sect start</i></p>

<p style="margin-left:22%;">Sets the device geometry to
C/H/S.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>splitname</b></p></td>
<td width="1%"></td>
<td width="36%">


<p style="margin-top: 1em"><i>device_name</i>
[<i>subsystem</i>]</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">Splits given device name into
subsystem constituents. The default subsystem is LVM. LVM
currently generates device names by concatenating the names
of the Volume Group, Logical Volume and any internal Layer
with a hyphen as separator. Any hyphens within the names are
doubled to escape them. The precise encoding might change
without notice in any future release, so we recommend you
always decode using the current version of this command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>status</b></p></td>
<td width="2%"></td>
<td width="73%">


<p>[<b>&minus;&minus;target</b> <i>target_type</i>]
[<b>&minus;&minus;noflush</b>] [<i>device_name</i>]</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:22%;">Outputs status information for
each of the device&rsquo;s targets. With
<b>&minus;&minus;target</b>, only information relating to
the specified target type any is displayed. With
<b>&minus;&minus;noflush</b>, the thin target (from version
1.3.0) doesn&rsquo;t commit any outstanding changes to disk
before reporting its statistics.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>suspend</b></p></td>
<td width="1%"></td>
<td width="55%">


<p style="margin-top: 1em">[<b>&minus;&minus;nolockfs</b>]
[<b>&minus;&minus;noflush</b>] <i>device_name</i></p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:22%;">Suspends a device. Any I/O that
has already been mapped by the device but has not yet
completed will be flushed. Any further I/O to that device
will be postponed for as long as the device is suspended. If
there&rsquo;s a filesystem on the device which supports the
operation, an attempt will be made to sync it first unless
<b>&minus;&minus;nolockfs</b> is specified. Some targets
such as recent (October 2006) versions of multipath may
support the <b>&minus;&minus;noflush</b> option. This lets
outstanding I/O that has not yet reached the device to
remain unflushed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>table</b></p></td>
<td width="4%"></td>
<td width="75%">


<p style="margin-top: 1em">[<b>&minus;&minus;target</b>
<i>target_type</i>] [<b>&minus;&minus;showkeys</b>]
[<i>device_name</i>]</p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:22%;">Outputs the current table for
the device in a format that can be fed back in using the
create or load commands. With <b>&minus;&minus;target</b>,
only information relating to the specified target type is
displayed. Encryption keys are suppressed in the table
output for the crypt target unless the
<b>&minus;&minus;showkeys</b> parameter is supplied.</p>

<p style="margin-left:11%;"><b>targets</b></p>

<p style="margin-left:22%;">Displays the names and versions
of the currently-loaded targets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>udevcomplete</b></p></td>
<td width="2%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>cookie</i></p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:22%;">Wake any processes that are
waiting for udev to complete processing the specified
cookie.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>udevcomplete_all</b></p></td>
<td width="2%"></td>
<td width="25%">


<p style="margin-top: 1em">[<i>age_in_minutes</i>]</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">Remove all cookies older than
the specified number of minutes. Any process waiting on a
cookie will be resumed immediately.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>udevcookies</b></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:22%;">List all existing cookies.
Cookies are system-wide semaphores with keys prefixed by two
predefined bytes (0x0D4D).</p>

<p style="margin-left:11%;"><b>udevcreatecookie</b></p>

<p style="margin-left:22%;">Creates a new cookie to
synchronize actions with udev processing. The output is a
cookie value. Normally we don&rsquo;t need to create cookies
since dmsetup creates and destroys them for each action
automatically. However, we can generate one explicitly to
group several actions together and use only one cookie
instead. We can define a cookie to use for each relevant
command by using <b>&minus;&minus;udevcookie</b> option.
Alternatively, we can export this value into the environment
of the dmsetup process as <b>DM_UDEV_COOKIE</b> variable and
it will be used automatically with all subsequent commands
until it is unset. Invoking this command will create
system-wide semaphore that needs to be cleaned up explicitly
by calling udevreleasecookie command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>udevflags</b></p></td>
<td width="1%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>cookie</i></p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:22%;">Parses given cookie value and
extracts any udev control flags encoded. The output is in
environment key format that is suitable for use in udev
rules. If the flag has its symbolic name assigned then the
output is DM_UDEV_FLAG_&lt;flag_name&gt;=&rsquo;1&rsquo;,
DM_UDEV_FLAG&lt;flag_position&gt;=&rsquo;1&rsquo; otherwise.
Subsystem udev flags don&rsquo;t have symbolic names
assigned and these ones are always reported as
DM_SUBSYSTEM_UDEV_FLAG&lt;flag_position&gt;=&rsquo;1&rsquo;.
There are 16 udev flags altogether.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="26%">


<p style="margin-top: 1em"><b>udevreleasecookie</b></p></td>
<td width="1%"></td>
<td width="13%">


<p style="margin-top: 1em">[<i>cookie</i>]</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:22%;">Waits for all pending udev
processing bound to given cookie value and clean up the
cookie with underlying semaphore. If the cookie is not given
directly, the command will try to use a value defined by
<b>DM_UDEV_COOKIE</b> environment variable.</p>

<p style="margin-left:11%;"><b>version</b></p>

<p style="margin-left:22%;">Outputs version
information.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>wait</b></p></td>
<td width="5%"></td>
<td width="52%">


<p>[<b>&minus;&minus;noflush</b>] <i>device_name</i>
[<i>event_nr</i>]</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:22%;">Sleeps until the event counter
for device_name exceeds event_nr. Use <b>&minus;v</b> to see
the event number returned. To wait until the next event is
triggered, use <b>info</b> to find the last event number.
With <b>&minus;&minus;noflush</b>, the thin target (from
version 1.3.0) doesn&rsquo;t commit any outstanding changes
to disk before reporting its statistics.</p>

<h2>TABLE FORMAT
<a name="TABLE FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Each line of
the table specifies a single target and is of the form:</p>


<p style="margin-left:11%; margin-top: 1em"><i>logical_start_sector
num_sectors</i> <b>target_type</b>
&lt;<i>target_args</i>&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Simple target
types and &lt;target_args&gt; include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>linear</b></p></td>
<td width="2%"></td>
<td width="47%">


<p style="margin-top: 1em"><i>destination_device
start_sector</i></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:22%;">The traditional linear
mapping.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>striped</b></p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em"><i>num_stripes chunk_size</i>
[<i>destination start_sector</i>]+</p></td></tr>
</table>

<p style="margin-left:22%;">Creates a striped area. <br>
e.g. striped 2 32 /dev/hda1 0 /dev/hdb1 0 will map the first
chunk (16k) as follows:</p>

<p style="margin-left:32%;">LV chunk 1 -&gt; hda1, chunk 1
<br>
LV chunk 2 -&gt; hdb1, chunk 1 <br>
LV chunk 3 -&gt; hda1, chunk 2 <br>
LV chunk 4 -&gt; hdb1, chunk 2 <br>
etc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>error</b></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">Errors any I/O that goes to this
area. Useful for testing or for creating devices with holes
in them.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>zero</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Returns blocks of zeroes on reads. Any data written is
discarded silently. This is a block-device equivalent of the
/dev/zero character-device data sink described in
<b>null</b>(4).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">More complex
targets include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>crypt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Transparent encryption of block
devices using the kernel crypto API.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>delay</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Delays reads and/or writes to different devices. Useful
for testing.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>flakey</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Creates a similar mapping to the linear target but
exhibits unreliable behaviour periodically. Useful for
simulating failing devices when testing.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>mirror</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Mirrors data across two or more devices.</p></td></tr>
</table>

<p style="margin-top: 1em"><b>multipath</b></p></table>

<p style="margin-left:22%;">Mediates access through
multiple paths to the same device.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>raid</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Offers an interface to the
kernel&rsquo;s software raid driver, md.</p></td></tr>
</table>

<p style="margin-top: 1em"><b>snapshot</b></p></table>

<p style="margin-left:22%;">Supports snapshots of
devices.</p>

<p style="margin-left:11%; margin-top: 1em">To find out
more about the various targets and their table formats and
status lines, please read the files in the
Documentation/device-mapper directory in the kernel source
tree. (Your distribution might include a copy of this
information in the documentation directory for the
device-mapper package.)</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"># A table to
join two disks together <br>
0 1028160 linear /dev/hda 0 <br>
1028160 3903762 linear /dev/hdb 0</p>

<p style="margin-left:11%; margin-top: 1em"># A table to
stripe across the two disks, <br>
# and add the spare space from <br>
# hdb to the back of the volume</p>

<p style="margin-left:11%; margin-top: 1em">0 2056320
striped 2 32 /dev/hda 0 /dev/hdb 0 <br>
2056320 2875602 linear /dev/hdb 1028160</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>DM_DEV_DIR</b></p>

<p style="margin-left:22%;">The device directory name.
Defaults to &quot;/dev&quot; and must be an absolute
path.</p>

<p style="margin-left:11%;"><b>DM_UDEV_COOKIE</b></p>

<p style="margin-left:22%;">A cookie to use for all
relevant commands to synchronize with udev processing. It is
an alternative to using <b>&minus;&minus;udevcookie</b>
option.</p>


<p style="margin-left:11%;"><b>DM_DEFAULT_NAME_MANGLING_MODE</b></p>

<p style="margin-left:22%;">A default mangling mode.
Defaults to &quot;<i>auto</i>&quot; and it is an alternative
to using <b>&minus;&minus;manglename</b> option.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Original
version: Joe Thornber (thornber@redhat.com)</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">LVM2 resource
page https://www.sourceware.org/lvm2/ <br>
Device-mapper resource page:
http://sources.redhat.com/dm/</p>
<hr>
</body>
</html>
