<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:25:56 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>open</title>

</head>
<body>

<h1 align="center">open</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#COMMAND PIPELINES">COMMAND PIPELINES</a><br>
<a href="#SERIAL COMMUNICATIONS">SERIAL COMMUNICATIONS</a><br>
<a href="#SERIAL PORT SIGNALS">SERIAL PORT SIGNALS</a><br>
<a href="#ERROR CODES (Windows only)">ERROR CODES (Windows only)</a><br>
<a href="#PORTABILITY ISSUES">PORTABILITY ISSUES</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">open &minus;
Open a file-based or command pipeline channel</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>open</b>
<i>fileName</i> <b><br>
open</b> <i>fileName access</i> <b><br>
open</b> <i>fileName access permissions</i>
_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This command
opens a file, serial port, or command pipeline and returns a
channel identifier that may be used in future invocations of
commands like <b>read</b>, <b>puts</b>, and <b>close</b>. If
the first character of <i>fileName</i> is not <b>|</b> then
the command opens a file: <i>fileName</i> gives the name of
the file to open, and it must conform to the conventions
described in the <b>filename</b> manual entry.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>access</i> argument, if present, indicates the way in
which the file (or command pipeline) is to be accessed. In
the first form <i>access</i> may have any of the following
values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>r</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for reading only; the file must already
exist. This is the default value if <i>access</i> is not
specified.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>r+</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for both reading and writing; the file
must already exist.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>w</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for writing only. Truncate it if it
exists. If it does not exist, create a new file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>w+</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for reading and writing. Truncate it if it
exists. If it does not exist, create a new file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>a</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for writing only. If the file does not
exist, create a new empty file. Set the file pointer to the
end of the file prior to each write.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>a+</b></p></td>
<td width="20%"></td>
<td width="66%">


<p>Open the file for reading and writing. If the file does
not exist, create a new empty file. Set the initial access
position to the end of the file. <big>&#9474;</big></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">All of the
legal <i>access</i> values above may have the character
<b>b</b> added as <big>&#9474;</big> the second or third
character in the value to indicate that the opened
<big>&#9474;</big> channel should be configured with the
<b>&minus;translation binary</b> option, <big>&#9474;</big>
making the channel suitable for reading or writing of binary
data.</p>

<p style="margin-left:11%; margin-top: 1em">In the second
form, <i>access</i> consists of a list of any of the
following flags, all of which have the standard POSIX
meanings. One of the flags must be either <b>RDONLY</b>,
<b>WRONLY</b> or <b>RDWR</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>RDONLY</b></p></td>
<td width="14%"></td>
<td width="66%">


<p style="margin-top: 1em">Open the file for reading
only.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>WRONLY</b></p></td>
<td width="14%"></td>
<td width="66%">


<p>Open the file for writing only.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>RDWR</b></p></td>
<td width="14%"></td>
<td width="66%">


<p>Open the file for both reading and writing.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>APPEND</b></p></td>
<td width="14%"></td>
<td width="66%">


<p>Set the file pointer to the end of the file prior to
each write. <big>&#9474;</big></p></td></tr>
</table>

<p style="margin-left:11%;"><b>BINARY</b>
<big>&#9474;</big></p>

<p style="margin-left:34%;">Configure the opened channel
with the <b>&minus;translation</b> <big>&#9474;</big>
<b>binary</b> option.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>CREAT</b></p></td>
<td width="11%"></td>
<td width="66%">


<p>Create the file if it does not already exist (without
this flag it is an error for the file not to exist).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>EXCL</b></p></td>
<td width="11%"></td>
<td width="66%">


<p>If <b>CREAT</b> is also specified, an error is returned
if the file already exists.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>NOCTTY</b></p></td>
<td width="11%"></td>
<td width="66%">


<p>If the file is a terminal device, this flag prevents the
file from becoming the controlling terminal of the
process.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>NONBLOCK</b></p></td>
<td width="11%"></td>
<td width="66%">


<p>Prevents the process from blocking while opening the
file, and possibly in subsequent I/O operations. The exact
behavior of this flag is system- and device-dependent; its
use is discouraged (it is better to use the
<b>fconfigure</b> command to put a file in nonblocking
mode). For details refer to your system documentation on the
<b>open</b> system call&rsquo;s <b>O_NONBLOCK</b> flag.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>TRUNC</b></p></td>
<td width="11%"></td>
<td width="66%">


<p>If the file exists it is truncated to zero length.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If a new file
is created as part of opening it, <i>permissions</i> (an
integer) is used to set the permissions for the new file in
conjunction with the process&rsquo;s file mode creation
mask. <i>Permissions</i> defaults to 0666.</p>

<h2>COMMAND PIPELINES
<a name="COMMAND PIPELINES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the first
character of <i>fileName</i> is &ldquo;|&rdquo; then the
remaining characters of <i>fileName</i> are treated as a
list of arguments that describe a command pipeline to
invoke, in the same style as the arguments for <b>exec</b>.
In this case, the channel identifier returned by <b>open</b>
may be used to write to the command&rsquo;s input pipe or
read from its output pipe, depending on the value of
<i>access</i>. If write-only access is used (e.g.
<i>access</i> is <b>w</b>), then standard output for the
pipeline is directed to the current standard output unless
overridden by the command. If read-only access is used (e.g.
<i>access</i> is <b>r</b>), standard input for the pipeline
is taken from the current standard input unless overridden
by the command. The id of the spawned process is accessible
through the <b>pid</b> command, using the channel id
returned by <b>open</b> as argument.</p>

<p style="margin-left:11%; margin-top: 1em">If the command
(or one of the commands) executed in the command pipeline
returns an error (according to the definition in
<b>exec</b>), a Tcl error is generated when <b>close</b> is
called on the channel unless the pipeline is in non-blocking
mode then no exit status is returned (a silent <b>close</b>
with -blocking 0).</p>

<p style="margin-left:11%; margin-top: 1em">It is often
useful to use the <b>fileevent</b> command with pipelines so
other processing may happen at the same time as running the
command in the background.</p>

<h2>SERIAL COMMUNICATIONS
<a name="SERIAL COMMUNICATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If
<i>fileName</i> refers to a serial port, then the specified
serial port is opened and initialized in a
platform-dependent manner. Acceptable values for the
<i>fileName</i> to use to open a serial port are described
in the PORTABILITY ISSUES section.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fconfigure</b> command can be used to query and set
additional configuration options specific to serial ports
(where supported): <b><br>
&minus;mode</b>
<i>baud</i><b>,</b><i>parity</i><b>,</b><i>data</i><b>,</b><i>stop</i></p>

<p style="margin-left:22%;">This option is a set of 4
comma-separated values: the baud rate, parity, number of
data bits, and number of stop bits for this serial port. The
<i>baud</i> rate is a simple integer that specifies the
connection speed. <i>Parity</i> is one of the following
letters: <b>n</b>, <b>o</b>, <b>e</b>, <b>m</b>, <b>s</b>;
respectively signifying the parity options of
&ldquo;none&rdquo;, &ldquo;odd&rdquo;, &ldquo;even&rdquo;,
&ldquo;mark&rdquo;, or &ldquo;space&rdquo;. <i>Data</i> is
the number of data bits and should be an integer from 5 to
8, while <i>stop</i> is the number of stop bits and should
be the integer 1 or 2.</p>

<p style="margin-left:11%;"><b>&minus;handshake</b>
<i>type</i></p>

<p style="margin-left:22%;">(Windows and Unix). This option
is used to setup automatic handshake control. Note that not
all handshake types maybe supported by your operating
system. The <i>type</i> parameter is case-independent.</p>

<p style="margin-left:22%; margin-top: 1em">If <i>type</i>
is <b>none</b> then any handshake is switched off.
<b>rtscts</b> activates hardware handshake. Hardware
handshake signals are described below. For software
handshake <b>xonxoff</b> the handshake characters can be
redefined with <b>&minus;xchar</b>. An additional hardware
handshake <b>dtrdsr</b> is available only under Windows.
There is no default handshake configuration, the initial
value depends on your operating system settings. The
<b>&minus;handshake</b> option cannot be queried.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;queue</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>(Windows and Unix). The <b>&minus;queue</b> option can
only be queried. It returns a list of two integers
representing the current number of bytes in the input and
output queue respectively.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;timeout</b>
<i>msec</i></p>

<p style="margin-left:22%;">(Windows and Unix). This option
is used to set the timeout for blocking read operations. It
specifies the maximum interval between the reception of two
bytes in milliseconds. For Unix systems the granularity is
100 milliseconds. The <b>&minus;timeout</b> option does not
affect write operations or nonblocking reads. This option
cannot be queried.</p>

<p style="margin-left:11%;"><b>&minus;ttycontrol</b>
<i>{signal boolean signal boolean ...}</i></p>

<p style="margin-left:22%;">(Windows and Unix). This option
is used to setup the handshake output lines (see below)
permanently or to send a BREAK over the serial line. The
<i>signal</i> names are case-independent. <b>{RTS 1 DTR
0}</b> sets the RTS output to high and the DTR output to
low. The BREAK condition (see below) is enabled and disabled
with <b>{BREAK 1}</b> and <b>{BREAK 0}</b> respectively. It
is not a good idea to change the <b>RTS</b> (or <b>DTR</b>)
signal with active hardware handshake <b>rtscts</b> (or
<b>dtrdsr</b>). The result is unpredictable. The
<b>&minus;ttycontrol</b> option cannot be queried.</p>

<p style="margin-left:11%;"><b>&minus;ttystatus</b></p>

<p style="margin-left:22%;">(Windows and Unix). The
<b>&minus;ttystatus</b> option can only be queried. It
returns the current modem status and handshake input signals
(see below). The result is a list of signal,value pairs with
a fixed order, e.g. <b>{CTS 1 DSR 0 RING 1 DCD 0}</b>. The
<i>signal</i> names are returned upper case.</p>

<p style="margin-left:11%;"><b>&minus;xchar</b> <i>{xonChar
xoffChar}</i></p>

<p style="margin-left:22%;">(Windows and Unix). This option
is used to query or change the software handshake
characters. Normally the operating system default should be
DC1 (0x11) and DC3 (0x13) representing the ASCII standard
XON and XOFF characters.</p>

<p style="margin-left:11%;"><b>&minus;pollinterval</b>
<i>msec</i></p>

<p style="margin-left:22%;">(Windows only). This option is
used to set the maximum time between polling for fileevents.
This affects the time interval between checking for events
throughout the Tcl interpreter (the smallest value always
wins). Use this option only if you want to poll the serial
port more or less often than 10 msec (the default).</p>

<p style="margin-left:11%;"><b>&minus;sysbuffer</b>
<i>inSize</i> <b><br>
&minus;sysbuffer</b> <i>{inSize outSize}</i></p>

<p style="margin-left:22%;">(Windows only). This option is
used to change the size of Windows system buffers for a
serial channel. Especially at higher communication rates the
default input buffer size of 4096 bytes can overrun for
latent systems. The first form specifies the input buffer
size, in the second form both input and output buffers are
defined.</p>

<p style="margin-left:11%;"><b>&minus;lasterror</b></p>

<p style="margin-left:22%;">(Windows only). This option is
query only. In case of a serial communication error,
<b>read</b> or <b>puts</b> returns a general Tcl file I/O
error. <b>fconfigure -lasterror</b> can be called to get a
list of error details. See below for an explanation of the
various error codes.</p>

<h2>SERIAL PORT SIGNALS
<a name="SERIAL PORT SIGNALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">RS-232 is the
most commonly used standard electrical interface for serial
communications. A negative voltage (-3V..-12V) define a mark
(on=1) bit and a positive voltage (+3..+12V) define a space
(off=0) bit (RS-232C). The following signals are specified
for incoming and outgoing data, status lines and
handshaking. Here we are using the terms <i>workstation</i>
for your computer and <i>modem</i> for the external device,
because some signal names (DCD, RI) come from modems. Of
course your external device may use these signal lines for
other purposes. <b><br>
TXD(output)</b></p>

<p style="margin-left:22%;"><b>Transmitted Data:</b>
Outgoing serial data.</p>

<p style="margin-left:11%;"><b>RXD(input)</b></p>

<p style="margin-left:22%;"><b>Received Data:</b>Incoming
serial data.</p>

<p style="margin-left:11%;"><b>RTS(output)</b></p>

<p style="margin-left:22%;"><b>Request To Send:</b> This
hardware handshake line informs the modem that your
workstation is ready to receive data. Your workstation may
automatically reset this signal to indicate that the input
buffer is full.</p>

<p style="margin-left:11%;"><b>CTS(input)</b></p>

<p style="margin-left:22%;"><b>Clear To Send:</b> The
complement to RTS. Indicates that the modem is ready to
receive data.</p>

<p style="margin-left:11%;"><b>DTR(output)</b></p>

<p style="margin-left:22%;"><b>Data Terminal Ready:</b>
This signal tells the modem that the workstation is ready to
establish a link. DTR is often enabled automatically
whenever a serial port is opened.</p>

<p style="margin-left:11%;"><b>DSR(input)</b></p>

<p style="margin-left:22%;"><b>Data Set Ready:</b> The
complement to DTR. Tells the workstation that the modem is
ready to establish a link.</p>

<p style="margin-left:11%;"><b>DCD(input)</b></p>

<p style="margin-left:22%;"><b>Data Carrier Detect:</b>
This line becomes active when a modem detects a
&ldquo;Carrier&rdquo; signal.</p>

<p style="margin-left:11%;"><b>RI(input)</b></p>

<p style="margin-left:22%;"><b>Ring Indicator:</b> Goes
active when the modem detects an incoming call.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>BREAK</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>A BREAK condition is not a hardware signal line, but a
logical zero on the TXD or RXD lines for a long period of
time, usually 250 to 500 milliseconds. Normally a receive or
transmit data signal stays at the mark (on=1) voltage until
the next character is transferred. A BREAK is sometimes used
to reset the communications line or change the operating
mode of communications hardware.</p></td></tr>
</table>

<h2>ERROR CODES (Windows only)
<a name="ERROR CODES (Windows only)"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A lot of
different errors may occur during serial read operations or
during event polling in background. The external device may
have been switched off, the data lines may be noisy, system
buffers may overrun or your mode settings may be wrong. That
is why a reliable software should always <b>catch</b> serial
read operations. In cases of an error Tcl returns a general
file I/O error. Then <b>fconfigure -lasterror</b> may help
to locate the problem. The following error codes may be
returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>RXOVER</b></p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Windows input buffer overrun.
The data comes faster than your scripts reads it or your
system is overloaded. Use <b>fconfigure -sysbuffer</b> to
avoid a temporary bottleneck and/or make your script
faster.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>TXFULL</b></p></td>
<td width="3%"></td>
<td width="74%">


<p>Windows output buffer overrun. Complement to RXOVER.
This error should practically not happen, because Tcl cares
about the output buffer status.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>OVERRUN</b></p></td>
<td width="3%"></td>
<td width="74%">


<p>UART buffer overrun (hardware) with data lost. The data
comes faster than the system driver receives it. Check your
advanced serial port settings to enable the FIFO (16550)
buffer and/or setup a lower(1) interrupt threshold
value.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>RXPARITY</b></p></td>
<td width="3%"></td>
<td width="74%">


<p>A parity error has been detected by your UART. Wrong
parity settings with <b>fconfigure -mode</b> or a noisy data
line (RXD) may cause this error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>FRAME</b></p></td>
<td width="3%"></td>
<td width="74%">


<p>A stop-bit error has been detected by your UART. Wrong
mode settings with <b>fconfigure -mode</b> or a noisy data
line (RXD) may cause this error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>BREAK</b></p></td>
<td width="3%"></td>
<td width="74%">


<p>A BREAK condition has been detected by your UART (see
above).</p> </td></tr>
</table>

<h2>PORTABILITY ISSUES
<a name="PORTABILITY ISSUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Windows</b>
(all versions)</p>

<p style="margin-left:22%;">Valid values for
<i>fileName</i> to open a serial port are of the form
<b>com</b><i>X</i><b>:</b>, where <i>X</i> is a number,
generally from 1 to 4. This notation only works for serial
ports from 1 to 9, if the system happens to have more than
four. An attempt to open a serial port that does not exist
or has a number greater than 9 will fail. An alternate form
of opening serial ports is to use the filename
<b>\\.\comX</b>, where X is any number that corresponds to a
serial port; please note that this method is considerably
slower on Windows 95 and Windows 98.</p>

<p style="margin-left:11%;"><b>Windows NT</b></p>

<p style="margin-left:22%;">When running Tcl interactively,
there may be some strange interactions between the real
console, if one is present, and a command pipeline that uses
standard input or output. If a command pipeline is opened
for reading, some of the lines entered at the console will
be sent to the command pipeline and some will be sent to the
Tcl evaluator. If a command pipeline is opened for writing,
keystrokes entered into the console are not visible until
the pipe is closed. This behavior occurs whether the command
pipeline is executing 16-bit or 32-bit applications. These
problems only occur because both Tcl and the child
application are competing for the console at the same time.
If the command pipeline is started from a script, so that
Tcl is not accessing the console, or if the command pipeline
does not use standard input or output, but is redirected
from or to a file, then the above problems do not occur.</p>

<p style="margin-left:11%;"><b>Windows 95</b></p>

<p style="margin-left:22%;">A command pipeline that
executes a 16-bit DOS application cannot be opened for both
reading and writing, since 16-bit DOS applications that
receive standard input from a pipe and send standard output
to a pipe run synchronously. Command pipelines that do not
execute 16-bit DOS applications run asynchronously and can
be opened for both reading and writing.</p>

<p style="margin-left:22%; margin-top: 1em">When running
Tcl interactively, there may be some strange interactions
between the real console, if one is present, and a command
pipeline that uses standard input or output. If a command
pipeline is opened for reading from a 32-bit application,
some of the keystrokes entered at the console will be sent
to the command pipeline and some will be sent to the Tcl
evaluator. If a command pipeline is opened for writing to a
32-bit application, no output is visible on the console
until the pipe is closed. These problems only occur because
both Tcl and the child application are competing for the
console at the same time. If the command pipeline is started
from a script, so that Tcl is not accessing the console, or
if the command pipeline does not use standard input or
output, but is redirected from or to a file, then the above
problems do not occur.</p>

<p style="margin-left:22%; margin-top: 1em">Whether or not
Tcl is running interactively, if a command pipeline is
opened for reading from a 16-bit DOS application, the call
to <b>open</b> will not return until end-of-file has been
received from the command pipeline&rsquo;s standard output.
If a command pipeline is opened for writing to a 16-bit DOS
application, no data will be sent to the command
pipeline&rsquo;s standard output until the pipe is actually
closed. This problem occurs because 16-bit DOS applications
are run synchronously, as described above.</p>

<p style="margin-left:11%;"><b>Unix</b></p>

<p style="margin-left:22%;">Valid values for
<i>fileName</i> to open a serial port are generally of the
form <b>/dev/tty</b><i>X</i>, where <i>X</i> is <b>a</b> or
<b>b</b>, but the name of any pseudo-file that maps to a
serial port may be used. Advanced configuration options are
only supported for serial ports when Tcl is built to use the
POSIX serial interface.</p>

<p style="margin-left:22%; margin-top: 1em">When running
Tcl interactively, there may be some strange interactions
between the console, if one is present, and a command
pipeline that uses standard input. If a command pipeline is
opened for reading, some of the lines entered at the console
will be sent to the command pipeline and some will be sent
to the Tcl evaluator. This problem only occurs because both
Tcl and the child application are competing for the console
at the same time. If the command pipeline is started from a
script, so that Tcl is not accessing the console, or if the
command pipeline does not use standard input, but is
redirected from a file, then the above problem does not
occur.</p>

<p style="margin-left:11%; margin-top: 1em">See the
<b>PORTABILITY ISSUES</b> section of the <b>exec</b> command
for additional information not specific to command pipelines
about executing applications on the various platforms</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Open a command
pipeline and catch any errors:</p>

<p style="margin-left:22%;">set fl [<b>open</b> &quot;| ls
this_file_does_not_exist&quot;] <br>
set data [read $fl] <br>
if {[catch {close $fl} err]} { <br>
puts &quot;ls command failed: $err&quot; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">file(n),
close(n), filename(n), fconfigure(n), gets(n), read(n),
puts(n), exec(n), pid(n), fopen(3)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">access mode,
append, create, file, non-blocking, open, permissions,
pipeline, process, serial</p>
<hr>
</body>
</html>
