<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:01:31 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FORK</title>

</head>
<body>

<h1 align="center">FORK</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fork &minus;
create a child process</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;unistd.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pid_t
fork(void);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>fork</b>()
creates a new process by duplicating the calling process.
The new process, referred to as the <i>child</i>, is an
exact duplicate of the calling process, referred to as the
<i>parent</i>, except for the following points:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child has its own unique process ID, and this PID
does not match the ID of any existing process group
(<b>setpgid</b>(2)).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child&rsquo;s parent process ID is the same as the
parent&rsquo;s process ID.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child does not inherit its parent&rsquo;s memory
locks (<b>mlock</b>(2), <b>mlockall</b>(2)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Process resource utilizations (<b>getrusage</b>(2)) and
CPU time counters (<b>times</b>(2)) are reset to zero in the
child.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child&rsquo;s set of pending signals is initially
empty (<b>sigpending</b>(2)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child does not inherit semaphore adjustments from
its parent (<b>semop</b>(2)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child does not inherit record locks from its parent
(<b>fcntl</b>(2)).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child does not inherit timers from its parent
(<b>setitimer</b>(2), <b>alarm</b>(2),
<b>timer_create</b>(2)).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child does not inherit outstanding asynchronous I/O
operations from its parent (<b>aio_read</b>(3),
<b>aio_write</b>(3)), nor does it inherit any asynchronous
I/O contexts from its parent (see <b>io_setup</b>(2)).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The process
attributes in the preceding list are all specified in
POSIX.1-2001. The parent and child also differ with respect
to the following Linux-specific process attributes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The child does not inherit
directory change notifications (dnotify) from its parent
(see the description of <b>F_NOTIFY</b> in
<b>fcntl</b>(2)).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The <b>prctl</b>(2) <b>PR_SET_PDEATHSIG</b> setting is
reset so that the child does not receive a signal when its
parent terminates.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The default timer slack value is set to the
parent&rsquo;s current timer slack value. See the
description of <b>PR_SET_TIMERSLACK</b> in
<b>prctl</b>(2).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>Memory mappings that have been marked with the
<b>madvise</b>(2) <b>MADV_DONTFORK</b> flag are not
inherited across a <b>fork</b>().</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The termination signal of the child is always
<b>SIGCHLD</b> (see <b>clone</b>(2)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The port access permission bits set by <b>ioperm</b>(2)
are not inherited by the child; the child must turn on any
bits that it requires using <b>ioperm</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note the
following further points:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The child process is created
with a single thread&mdash;the one that called
<b>fork</b>(). The entire virtual address space of the
parent is replicated in the child, including the states of
mutexes, condition variables, and other pthreads objects;
the use of <b>pthread_atfork</b>(3) may be helpful for
dealing with problems that this can cause.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child inherits copies of the parent&rsquo;s set of
open file descriptors. Each file descriptor in the child
refers to the same open file description (see
<b>open</b>(2)) as the corresponding file descriptor in the
parent. This means that the two descriptors share open file
status flags, current file offset, and signal-driven I/O
attributes (see the description of <b>F_SETOWN</b> and
<b>F_SETSIG</b> in <b>fcntl</b>(2)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child inherits copies of the parent&rsquo;s set of
open message queue descriptors (see <b>mq_overview</b>(7)).
Each descriptor in the child refers to the same open message
queue description as the corresponding descriptor in the
parent. This means that the two descriptors share the same
flags (<i>mq_flags</i>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>The child inherits copies of the parent&rsquo;s set of
open directory streams (see <b>opendir</b>(3)). POSIX.1-2001
says that the corresponding directory streams in the parent
and child <i>may</i> share the directory stream positioning;
on Linux/glibc they do not.</p></td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success, the
PID of the child process is returned in the parent, and 0 is
returned in the child. On failure, &minus;1 is returned in
the parent, no child process is created, and <i>errno</i> is
set appropriately.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><b>fork</b>() cannot allocate
sufficient memory to copy the parent&rsquo;s page tables and
allocate a task structure for the child.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EAGAIN</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>It was not possible to create a new process because the
caller&rsquo;s <b>RLIMIT_NPROC</b> resource limit was
encountered. To exceed this limit, the process must have
either the <b>CAP_SYS_ADMIN</b> or the
<b>CAP_SYS_RESOURCE</b> capability.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOMEM</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>fork</b>() failed to allocate the necessary kernel
structures because memory is tight.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOSYS</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><b>fork</b>() is not supported on this platform (for
example, hardware without a Memory-Management Unit).</p></td></tr>
</table>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SVr4, 4.3BSD,
POSIX.1-2001.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Under Linux,
<b>fork</b>() is implemented using copy-on-write pages, so
the only penalty that it incurs is the time and memory
required to duplicate the parent&rsquo;s page tables, and to
create a unique task structure for the child.</p>

<p style="margin-left:11%; margin-top: 1em">Since version
2.3.3, rather than invoking the kernel&rsquo;s <b>fork</b>()
system call, the glibc <b>fork</b>() wrapper that is
provided as part of the NPTL threading implementation
invokes <b>clone</b>(2) with flags that provide the same
effect as the traditional system call. (A call to
<b>fork</b>() is equivalent to a call to <b>clone</b>(2)
specifying <i>flags</i> as just <b>SIGCHLD</b>.) The glibc
wrapper invokes any fork handlers that have been established
using <b>pthread_atfork</b>(3).</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>pipe</b>(2) and <b>wait</b>(2).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>clone</b>(2),
<b>execve</b>(2), <b>exit</b>(2), <b>setrlimit</b>(2),
<b>unshare</b>(2), <b>vfork</b>(2), <b>wait</b>(2),
<b>daemon</b>(3), <b>capabilities</b>(7),
<b>credentials</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
