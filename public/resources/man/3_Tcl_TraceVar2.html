<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:04:16 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Tcl_TraceVar</title>

</head>
<body>

<h1 align="center">Tcl_TraceVar</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#TWO-PART NAMES">TWO-PART NAMES</a><br>
<a href="#ACCESSING VARIABLES DURING TRACES">ACCESSING VARIABLES DURING TRACES</a><br>
<a href="#CALLBACK TIMING">CALLBACK TIMING</a><br>
<a href="#WHOLE-ARRAY TRACES">WHOLE-ARRAY TRACES</a><br>
<a href="#MULTIPLE TRACES">MULTIPLE TRACES</a><br>
<a href="#ERROR RETURNS">ERROR RETURNS</a><br>
<a href="#RESTRICTIONS">RESTRICTIONS</a><br>
<a href="#UNDEFINED VARIABLES">UNDEFINED VARIABLES</a><br>
<a href="#TCL_TRACE_DESTROYED FLAG">TCL_TRACE_DESTROYED FLAG</a><br>
<a href="#TCL_INTERP_DESTROYED">TCL_INTERP_DESTROYED</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl_TraceVar,
Tcl_TraceVar2, Tcl_UntraceVar, Tcl_UntraceVar2,
Tcl_VarTraceInfo, Tcl_VarTraceInfo2 &minus; monitor accesses
to a variable</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_TraceVar(</b><i>interp, varName, flags, proc,
clientData</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_TraceVar2(</b><i>interp, name1, name2, flags, proc,
clientData</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UntraceVar(</b><i>interp,
varName, flags, proc, clientData</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UntraceVar2(</b><i>interp,
name1, name2, flags, proc, clientData</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_VarTraceInfo(</b><i>interp, varName, flags, proc,
prevClientData</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_VarTraceInfo2(</b><i>interp, name1, name2, flags, proc,
prevClientData</i><b>)</b></p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p style="margin-top: 1em">Tcl_Interp <i>*interp</i>
(in)</p> </td>
<td width="25%"></td>
<td width="18%">


<p style="margin-top: 1em">Interpreter containing
variable.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*varName</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>Name of variable. May refer to a scalar variable, to an
array variable with no index, or to an array variable with a
parenthesized index.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>int <i>flags</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>OR-ed combination of the values <b>TCL_TRACE_READS</b>,
<b>TCL_TRACE_WRITES</b>, <b>TCL_TRACE_UNSETS</b>,
<b>TCL_TRACE_ARRAY</b>, <b>TCL_GLOBAL_ONLY</b>,
<b>TCL_NAMESPACE_ONLY</b>, <b>TCL_TRACE_RESULT_DYNAMIC</b>
and <b>TCL_TRACE_RESULT_OBJECT</b>. Not all flags are used
by all procedures. See below for more information.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>Tcl_VarTraceProc <i>*proc</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>Procedure to invoke whenever one of the traced
operations occurs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>ClientData <i>clientData</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>Arbitrary one-word value to pass to <i>proc</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*name1</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>Name of scalar or array variable (without array
index).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>const char <i>*name2</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>For a trace on an element of an array, gives the index
of the element. For traces on scalar variables or on whole
arrays, is NULL.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p>ClientData <i>prevClientData</i> (in)</p></td>
<td width="25%"></td>
<td width="18%">


<p>If non-NULL, gives last value returned by
<b>Tcl_VarTraceInfo</b> or <b>Tcl_VarTraceInfo2</b>, so this
call will return information about next trace. If NULL, this
call will return information about first trace.</p></td></tr>
</table>


<p style="margin-left:82%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Tcl_TraceVar</b>
allows a C procedure to monitor and control access to a Tcl
variable, so that the C procedure is invoked whenever the
variable is read or written or unset. If the trace is
created successfully then <b>Tcl_TraceVar</b> returns
<b>TCL_OK</b>. If an error occurred (e.g. <i>varName</i>
specifies an element of an array, but the actual variable is
not an array) then <b>TCL_ERROR</b> is returned and an error
message is left in the interpreter&rsquo;s result.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>flags</i> argument to <b>Tcl_TraceVar</b> indicates when
the trace procedure is to be invoked and provides
information for setting up the trace. It consists of an
OR-ed combination of any of the following values: <b><br>
TCL_GLOBAL_ONLY</b></p>

<p style="margin-left:22%;">Normally, the variable will be
looked up at the current level of procedure call; if this
bit is set then the variable will be looked up at global
level, ignoring any active procedures.</p>

<p style="margin-left:11%;"><b>TCL_NAMESPACE_ONLY</b></p>

<p style="margin-left:22%;">Normally, the variable will be
looked up at the current level of procedure call; if this
bit is set then the variable will be looked up in the
current namespace, ignoring any active procedures.</p>

<p style="margin-left:11%;"><b>TCL_TRACE_READS</b></p>

<p style="margin-left:22%;">Invoke <i>proc</i> whenever an
attempt is made to read the variable.</p>

<p style="margin-left:11%;"><b>TCL_TRACE_WRITES</b></p>

<p style="margin-left:22%;">Invoke <i>proc</i> whenever an
attempt is made to modify the variable.</p>

<p style="margin-left:11%;"><b>TCL_TRACE_UNSETS</b></p>

<p style="margin-left:22%;">Invoke <i>proc</i> whenever the
variable is unset. A variable may be unset either explicitly
by an <b>unset</b> command, or implicitly when a procedure
returns (its local variables are automatically unset) or
when the interpreter is deleted (all variables are
automatically unset).</p>

<p style="margin-left:11%;"><b>TCL_TRACE_ARRAY</b></p>

<p style="margin-left:22%;">Invoke <i>proc</i> whenever the
array command is invoked. This gives the trace procedure a
chance to update the array before array names or array get
is called. Note that this is called before an array set, but
that will trigger write traces.</p>


<p style="margin-left:11%;"><b>TCL_TRACE_RESULT_DYNAMIC</b></p>

<p style="margin-left:22%;">The result of invoking the
<i>proc</i> is a dynamically allocated string that will be
released by the Tcl library via a call to <b>ckfree</b>.
Must not be specified at the same time as
<b>TCL_TRACE_RESULT_OBJECT</b>.</p>


<p style="margin-left:11%;"><b>TCL_TRACE_RESULT_OBJECT</b></p>

<p style="margin-left:22%;">The result of invoking the
<i>proc</i> is a Tcl_Obj* (cast to a char*) with a reference
count of at least one. The ownership of that reference will
be transferred to the Tcl core for release (when the core
has finished with it) via a call to <b>Tcl_DecrRefCount</b>.
Must not be specified at the same time as
<b>TCL_TRACE_RESULT_DYNAMIC</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Whenever one of
the specified operations occurs on the variable, <i>proc</i>
will be invoked. It should have arguments and result that
match the type <b>Tcl_VarTraceProc</b>:</p>

<p style="margin-left:22%;">typedef char *Tcl_VarTraceProc(
<br>
ClientData <i>clientData</i>, <br>
Tcl_Interp *<i>interp</i>, <br>
char *<i>name1</i>, <br>
char *<i>name2</i>, <br>
int <i>flags</i>);</p>

<p style="margin-left:11%;">The <i>clientData</i> and
<i>interp</i> parameters will have the same values as those
passed to <b>Tcl_TraceVar</b> when the trace was created.
<i>ClientData</i> typically points to an
application-specific data structure that describes what to
do when <i>proc</i> is invoked. <i>Name1</i> and
<i>name2</i> give the name of the traced variable in the
normal two-part form (see the description of
<b>Tcl_TraceVar2</b> below for details). <i>Flags</i> is an
OR-ed combination of bits providing several pieces of
information. One of the bits <b>TCL_TRACE_READS</b>,
<b>TCL_TRACE_WRITES</b>, <b>TCL_TRACE_ARRAY</b>, or
<b>TCL_TRACE_UNSETS</b> will be set in <i>flags</i> to
indicate which operation is being performed on the variable.
The bit <b>TCL_GLOBAL_ONLY</b> will be set whenever the
variable being accessed is a global one not accessible from
the current level of procedure call: the trace procedure
will need to pass this flag back to variable-related
procedures like <b>Tcl_GetVar</b> if it attempts to access
the variable. The bit <b>TCL_NAMESPACE_ONLY</b> will be set
whenever the variable being accessed is a namespace one not
accessible from the current level of procedure call: the
trace procedure will need to pass this flag back to
variable-related procedures like <b>Tcl_GetVar</b> if it
attempts to access the variable. The bit
<b>TCL_TRACE_DESTROYED</b> will be set in <i>flags</i> if
the trace is about to be destroyed; this information may be
useful to <i>proc</i> so that it can clean up its own
internal data structures (see the section
<b>TCL_TRACE_DESTROYED</b> below for more details). Lastly,
the bit <b>TCL_INTERP_DESTROYED</b> will be set if the
entire interpreter is being destroyed. When this bit is set,
<i>proc</i> must be especially careful in the things it does
(see the section <b>TCL_INTERP_DESTROYED</b> below). The
trace procedure&rsquo;s return value should normally be
NULL; see <b>ERROR RETURNS</b> below for information on
other possibilities.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_UntraceVar</b>
may be used to remove a trace. If the variable specified by
<i>interp</i>, <i>varName</i>, and <i>flags</i> has a trace
set with <i>flags</i>, <i>proc</i>, and <i>clientData</i>,
then the corresponding trace is removed. If no such trace
exists, then the call to <b>Tcl_UntraceVar</b> has no
effect. The same bits are valid for <i>flags</i> as for
calls to <b>Tcl_TraceVar</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_VarTraceInfo</b>
may be used to retrieve information about traces set on a
given variable. The return value from
<b>Tcl_VarTraceInfo</b> is the <i>clientData</i> associated
with a particular trace. The trace must be on the variable
specified by the <i>interp</i>, <i>varName</i>, and
<i>flags</i> arguments (only the <b>TCL_GLOBAL_ONLY</b> and
<b>TCL_NAMESPACE_ONLY</b> bits from <i>flags</i> is used;
other bits are ignored) and its trace procedure must the
same as the <i>proc</i> argument. If the
<i>prevClientData</i> argument is NULL then the return value
corresponds to the first (most recently created) matching
trace, or NULL if there are no matching traces. If the
<i>prevClientData</i> argument is not NULL, then it should
be the return value from a previous call to
<b>Tcl_VarTraceInfo</b>. In this case, the new return value
will correspond to the next matching trace after the one
whose <i>clientData</i> matches <i>prevClientData</i>, or
NULL if no trace matches <i>prevClientData</i> or if there
are no more matching traces after it. This mechanism makes
it possible to step through all of the traces for a given
variable that have the same <i>proc</i>.</p>

<h2>TWO-PART NAMES
<a name="TWO-PART NAMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The procedures
<b>Tcl_TraceVar2</b>, <b>Tcl_UntraceVar2</b>, and
<b>Tcl_VarTraceInfo2</b> are identical to
<b>Tcl_TraceVar</b>, <b>Tcl_UntraceVar</b>, and
<b>Tcl_VarTraceInfo</b>, respectively, except that the name
of the variable consists of two parts. <i>Name1</i> gives
the name of a scalar variable or array, and <i>name2</i>
gives the name of an element within an array. When
<i>name2</i> is NULL, <i>name1</i> may contain both an array
and an element name: if the name contains an open
parenthesis and ends with a close parenthesis, then the
value between the parentheses is treated as an element name
(which can have any string value) and the characters before
the first open parenthesis are treated as the name of an
array variable. If <i>name2</i> is NULL and <i>name1</i>
does not refer to an array element it means that either the
variable is a scalar or the trace is to be set on the entire
array rather than an individual element (see WHOLE-ARRAY
TRACES below for more information).</p>

<h2>ACCESSING VARIABLES DURING TRACES
<a name="ACCESSING VARIABLES DURING TRACES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">During read,
write, and array traces, the trace procedure can read,
write, or unset the traced variable using
<b>Tcl_GetVar2</b>, <b>Tcl_SetVar2</b>, and other
procedures. While <i>proc</i> is executing, traces are
temporarily disabled for the variable, so that calls to
<b>Tcl_GetVar2</b> and <b>Tcl_SetVar2</b> will not cause
<i>proc</i> or other trace procedures to be invoked again.
Disabling only occurs for the variable whose trace procedure
is active; accesses to other variables will still be traced.
However, if a variable is unset during a read or write trace
then unset traces will be invoked.</p>

<p style="margin-left:11%; margin-top: 1em">During unset
traces the variable has already been completely expunged. It
is possible for the trace procedure to read or write the
variable, but this will be a new version of the variable.
Traces are not disabled during unset traces as they are for
read and write traces, but existing traces have been removed
from the variable before any trace procedures are invoked.
If new traces are set by unset trace procedures, these
traces will be invoked on accesses to the variable by the
trace procedures.</p>

<h2>CALLBACK TIMING
<a name="CALLBACK TIMING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When read
tracing has been specified for a variable, the trace
procedure will be invoked whenever the variable&rsquo;s
value is read. This includes <b>set</b> Tcl commands,
<b>$</b>-notation in Tcl commands, and invocations of the
<b>Tcl_GetVar</b> and <b>Tcl_GetVar2</b> procedures.
<i>Proc</i> is invoked just before the variable&rsquo;s
value is returned. It may modify the value of the variable
to affect what is returned by the traced access. If it
unsets the variable then the access will return an error
just as if the variable never existed.</p>

<p style="margin-left:11%; margin-top: 1em">When write
tracing has been specified for a variable, the trace
procedure will be invoked whenever the variable&rsquo;s
value is modified. This includes <b>set</b> commands,
commands that modify variables as side effects (such as
<b>catch</b> and <b>scan</b>), and calls to the
<b>Tcl_SetVar</b> and <b>Tcl_SetVar2</b> procedures).
<i>Proc</i> will be invoked after the variable&rsquo;s value
has been modified, but before the new value of the variable
has been returned. It may modify the value of the variable
to override the change and to determine the value actually
returned by the traced access. If it deletes the variable
then the traced access will return an empty string.</p>

<p style="margin-left:11%; margin-top: 1em">When array
tracing has been specified, the trace procedure will be
invoked at the beginning of the array command
implementation, before any of the operations like get, set,
or names have been invoked. The trace procedure can modify
the array elements with <b>Tcl_SetVar</b> and
<b>Tcl_SetVar2</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When unset
tracing has been specified, the trace procedure will be
invoked whenever the variable is destroyed. The traces will
be called after the variable has been completely unset.</p>

<h2>WHOLE-ARRAY TRACES
<a name="WHOLE-ARRAY TRACES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If a call to
<b>Tcl_TraceVar</b> or <b>Tcl_TraceVar2</b> specifies the
name of an array variable without an index into the array,
then the trace will be set on the array as a whole. This
means that <i>proc</i> will be invoked whenever any element
of the array is accessed in the ways specified by
<i>flags</i>. When an array is unset, a whole-array trace
will be invoked just once, with <i>name1</i> equal to the
name of the array and <i>name2</i> NULL; it will not be
invoked once for each element.</p>

<h2>MULTIPLE TRACES
<a name="MULTIPLE TRACES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It is possible
for multiple traces to exist on the same variable. When this
happens, all of the trace procedures will be invoked on each
access, in order from most-recently-created to
least-recently-created. When there exist whole-array traces
for an array as well as traces on individual elements, the
whole-array traces are invoked before the individual-element
traces. If a read or write trace unsets the variable then
all of the unset traces will be invoked but the remainder of
the read and write traces will be skipped.</p>

<h2>ERROR RETURNS
<a name="ERROR RETURNS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Under normal
conditions trace procedures should return NULL, indicating
successful completion. If <i>proc</i> returns a non-NULL
value it signifies that an error occurred. The return value
must be a pointer to a static character string containing an
error message, unless (<i>exactly</i> one of) the
<b>TCL_TRACE_RESULT_DYNAMIC</b> and
<b>TCL_TRACE_RESULT_OBJECT</b> flags is set, which specify
that the result is either a dynamic string (to be released
with <b>ckfree</b>) or a Tcl_Obj* (cast to char* and to be
released with <b>Tcl_DecrRefCount</b>) containing the error
message. If a trace procedure returns an error, no further
traces are invoked for the access and the traced access
aborts with the given message. Trace procedures can use this
facility to make variables read-only, for example (but note
that the value of the variable will already have been
modified before the trace procedure is called, so the trace
procedure will have to restore the correct value).</p>

<p style="margin-left:11%; margin-top: 1em">The return
value from <i>proc</i> is only used during read and write
tracing. During unset traces, the return value is ignored
and all relevant trace procedures will always be
invoked.</p>

<h2>RESTRICTIONS
<a name="RESTRICTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A trace
procedure can be called at any time, even when there is a
partially formed result in the interpreter&rsquo;s result
area. If the trace procedure does anything that could damage
this result (such as calling <b>Tcl_Eval</b>) then it must
save the original values of the interpreter&rsquo;s
<b>result</b> and <b>freeProc</b> fields and restore them
before it returns.</p>

<h2>UNDEFINED VARIABLES
<a name="UNDEFINED VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It is legal to
set a trace on an undefined variable. The variable will
still appear to be undefined until the first time its value
is set. If an undefined variable is traced and then unset,
the unset will fail with an error (&ldquo;no such
variable&rdquo;), but the trace procedure will still be
invoked.</p>

<h2>TCL_TRACE_DESTROYED FLAG
<a name="TCL_TRACE_DESTROYED FLAG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In an unset
callback to <i>proc</i>, the <b>TCL_TRACE_DESTROYED</b> bit
is set in <i>flags</i> if the trace is being removed as part
of the deletion. Traces on a variable are always removed
whenever the variable is deleted; the only time
<b>TCL_TRACE_DESTROYED</b> is not set is for a whole-array
trace invoked when only a single element of an array is
unset.</p>

<h2>TCL_INTERP_DESTROYED
<a name="TCL_INTERP_DESTROYED"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When an
interpreter is destroyed, unset traces are called for all of
its variables. The <b>TCL_INTERP_DESTROYED</b> bit will be
set in the <i>flags</i> argument passed to the trace
procedures. Trace procedures must be extremely careful in
what they do if the <b>TCL_INTERP_DESTROYED</b> bit is set.
It is not safe for the procedures to invoke any Tcl
procedures on the interpreter, since its state is partially
deleted. All that trace procedures should do under these
circumstances is to clean up and free their own internal
data structures.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tcl does not do
any error checking to prevent trace procedures from misusing
the interpreter during traces with
<b>TCL_INTERP_DESTROYED</b> set.</p>

<p style="margin-left:11%; margin-top: 1em">Array traces
are not yet integrated with the Tcl <b>info exists</b>
command, nor is there Tcl-level access to array traces.</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">clientData,
trace, variable</p>
<hr>
</body>
</html>
