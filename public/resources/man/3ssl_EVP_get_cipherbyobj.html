<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:19:06 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_EncryptInit</title>

</head>
<body>

<h1 align="center">EVP_EncryptInit</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUES">RETURN VALUES</a><br>
<a href="#CIPHER LISTING">CIPHER LISTING</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#HISTORY">HISTORY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">EVP_CIPHER_CTX_init,
EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex,
EVP_DecryptInit_ex, EVP_DecryptUpdate, EVP_DecryptFinal_ex,
EVP_CipherInit_ex, EVP_CipherUpdate, EVP_CipherFinal_ex,
EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl,
EVP_CIPHER_CTX_cleanup, EVP_EncryptInit, EVP_EncryptFinal,
EVP_DecryptInit, EVP_DecryptFinal, EVP_CipherInit,
EVP_CipherFinal, EVP_get_cipherbyname, EVP_get_cipherbynid,
EVP_get_cipherbyobj, EVP_CIPHER_nid, EVP_CIPHER_block_size,
EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type,
EVP_CIPHER_CTX_cipher, EVP_CIPHER_CTX_nid,
EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type,
EVP_CIPHER_CTX_flags, EVP_CIPHER_CTX_mode,
EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding &minus; EVP cipher routines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> #include &lt;openssl/evp.h&gt;
 void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
 int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);
 int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
 int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
 int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);
 int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
 int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);
 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
 const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
 #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
 #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
 #define EVP_CIPHER_nid(e)              ((e)&minus;&gt;nid)
 #define EVP_CIPHER_block_size(e)       ((e)&minus;&gt;block_size)
 #define EVP_CIPHER_key_length(e)       ((e)&minus;&gt;key_len)
 #define EVP_CIPHER_iv_length(e)                ((e)&minus;&gt;iv_len)
 #define EVP_CIPHER_flags(e)            ((e)&minus;&gt;flags)
 #define EVP_CIPHER_mode(e)             ((e)&minus;&gt;flags) &amp; EVP_CIPH_MODE)
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);
 #define EVP_CIPHER_CTX_cipher(e)       ((e)&minus;&gt;cipher)
 #define EVP_CIPHER_CTX_nid(e)          ((e)&minus;&gt;cipher&minus;&gt;nid)
 #define EVP_CIPHER_CTX_block_size(e)   ((e)&minus;&gt;cipher&minus;&gt;block_size)
 #define EVP_CIPHER_CTX_key_length(e)   ((e)&minus;&gt;key_len)
 #define EVP_CIPHER_CTX_iv_length(e)    ((e)&minus;&gt;cipher&minus;&gt;iv_len)
 #define EVP_CIPHER_CTX_get_app_data(e) ((e)&minus;&gt;app_data)
 #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)&minus;&gt;app_data=(char *)(d))
 #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
 #define EVP_CIPHER_CTX_flags(e)                ((e)&minus;&gt;cipher&minus;&gt;flags)
 #define EVP_CIPHER_CTX_mode(e)         ((e)&minus;&gt;cipher&minus;&gt;flags &amp; EVP_CIPH_MODE)
 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 const EVP_CIPHER *EVP_des_ede3(void);
 const EVP_CIPHER *EVP_des_ede3_ecb(void);
 const EVP_CIPHER *EVP_des_ede3_cfb64(void);
 const EVP_CIPHER *EVP_des_ede3_cfb1(void);
 const EVP_CIPHER *EVP_des_ede3_cfb8(void);
 const EVP_CIPHER *EVP_des_ede3_ofb(void);
 const EVP_CIPHER *EVP_des_ede3_cbc(void);
 const EVP_CIPHER *EVP_aes_128_ecb(void);
 const EVP_CIPHER *EVP_aes_128_cbc(void);
 const EVP_CIPHER *EVP_aes_128_cfb1(void);
 const EVP_CIPHER *EVP_aes_128_cfb8(void);
 const EVP_CIPHER *EVP_aes_128_cfb128(void);
 const EVP_CIPHER *EVP_aes_128_ofb(void);
 const EVP_CIPHER *EVP_aes_192_ecb(void);
 const EVP_CIPHER *EVP_aes_192_cbc(void);
 const EVP_CIPHER *EVP_aes_192_cfb1(void);
 const EVP_CIPHER *EVP_aes_192_cfb8(void);
 const EVP_CIPHER *EVP_aes_192_cfb128(void);
 const EVP_CIPHER *EVP_aes_192_ofb(void);
 const EVP_CIPHER *EVP_aes_256_ecb(void);
 const EVP_CIPHER *EVP_aes_256_cbc(void);
 const EVP_CIPHER *EVP_aes_256_cfb1(void);
 const EVP_CIPHER *EVP_aes_256_cfb8(void);
 const EVP_CIPHER *EVP_aes_256_cfb128(void);
 const EVP_CIPHER *EVP_aes_256_ofb(void);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>EVP</small> cipher routines are a high level
interface to certain symmetric ciphers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_init()</i>
initializes cipher contex <b>ctx</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_EncryptInit_ex()</i>
sets up cipher context <b>ctx</b> for encryption with cipher
<b>type</b> from <small>ENGINE</small> <b>impl</b>.
<b>ctx</b> must be initialized before calling this function.
<b>type</b> is normally supplied by a function such as
<i>EVP_des_cbc()</i>. If <b>impl</b> is <small>NULL</small>
then the default implementation is used. <b>key</b> is the
symmetric key to use and <b>iv</b> is the <small>IV</small>
to use (if necessary), the actual number of bytes used for
the key and <small>IV</small> depends on the cipher. It is
possible to set all parameters to <small>NULL</small> except
<b>type</b> in an initial call and supply the remaining
parameters in subsequent calls, all of which have
<b>type</b> set to <small>NULL.</small> This is done when
the default cipher parameters are not appropriate.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_EncryptUpdate()</i>
encrypts <b>inl</b> bytes from the buffer <b>in</b> and
writes the encrypted version to <b>out</b>. This function
can be called multiple times to encrypt successive blocks of
data. The amount of data written depends on the block
alignment of the encrypted data: as a result the amount of
data written may be anything from zero bytes to (inl +
cipher_block_size &minus; 1) so <b>outl</b> should contain
sufficient room. The actual number of bytes written is
placed in <b>outl</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If padding is
enabled (the default) then <i>EVP_EncryptFinal_ex()</i>
encrypts the &quot;final&quot; data, that is any data that
remains in a partial block. It uses standard block padding
(aka <small>PKCS</small> padding). The encrypted final data
is written to <b>out</b> which should have sufficient space
for one cipher block. The number of bytes written is placed
in <b>outl</b>. After this function is called the encryption
operation is finished and no further calls to
<i>EVP_EncryptUpdate()</i> should be made.</p>

<p style="margin-left:11%; margin-top: 1em">If padding is
disabled then <i>EVP_EncryptFinal_ex()</i> will not encrypt
any more data and it will return an error if any data
remains in a partial block: that is if the total data length
is not a multiple of the block size.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_DecryptInit_ex()</i>,
<i>EVP_DecryptUpdate()</i> and <i>EVP_DecryptFinal_ex()</i>
are the corresponding decryption operations.
<i>EVP_DecryptFinal()</i> will return an error code if
padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to
the encryption operations except that if padding is enabled
the decrypted data buffer <b>out</b> passed to
<i>EVP_DecryptUpdate()</i> should have sufficient room for
(<b>inl</b> + cipher_block_size) bytes unless the cipher
block size is 1 in which case <b>inl</b> bytes is
sufficient.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CipherInit_ex()</i>,
<i>EVP_CipherUpdate()</i> and <i>EVP_CipherFinal_ex()</i>
are functions that can be used for decryption or encryption.
The operation performed depends on the value of the
<b>enc</b> parameter. It should be set to 1 for encryption,
0 for decryption and &minus;1 to leave the value unchanged
(the actual value of &rsquo;enc&rsquo; being supplied in a
previous call).</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_cleanup()</i>
clears all information from a cipher context and free up any
allocated memory associate with it. It should be called
after all operations using a cipher are complete so
sensitive information does not remain in memory.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_EncryptInit()</i>,
<i>EVP_DecryptInit()</i> and <i>EVP_CipherInit()</i> behave
in a similar way to <i>EVP_EncryptInit_ex()</i>,
EVP_DecryptInit_ex and <i>EVP_CipherInit_ex()</i> except the
<b>ctx</b> paramter does not need to be initialized and they
always use the default cipher implementation.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_EncryptFinal()</i>,
<i>EVP_DecryptFinal()</i> and <i>EVP_CipherFinal()</i>
behave in a similar way to <i>EVP_EncryptFinal_ex()</i>,
<i>EVP_DecryptFinal_ex()</i> and <i>EVP_CipherFinal_ex()</i>
except <b>ctx</b> is automatically cleaned up after the
call.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_get_cipherbyname()</i>,
<i>EVP_get_cipherbynid()</i> and
<i>EVP_get_cipherbyobj()</i> return an
<small>EVP_CIPHER</small> structure when passed a cipher
name, a <small>NID</small> or an <small>ASN1_OBJECT</small>
structure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_nid()</i>
and <i>EVP_CIPHER_CTX_nid()</i> return the
<small>NID</small> of a cipher when passed an
<b><small>EVP_CIPHER</small></b> or
<b><small>EVP_CIPHER_CTX</small></b> structure. The actual
<small>NID</small> value is an internal value which may not
have a corresponding <small>OBJECT IDENTIFIER.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_set_padding()</i>
enables or disables padding. By default encryption
operations are padded using standard block padding and the
padding is checked and removed when decrypting. If the
<b>pad</b> parameter is zero then no padding is performed,
the total amount of data encrypted or decrypted must then be
a multiple of the block size or an error will occur.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_key_length()</i>
and <i>EVP_CIPHER_CTX_key_length()</i> return the key length
of a cipher when passed an <b><small>EVP_CIPHER</small></b>
or <b><small>EVP_CIPHER_CTX</small></b> structure. The
constant <b><small>EVP_MAX_KEY_LENGTH</small></b> is the
maximum key length for all ciphers. Note: although
<i>EVP_CIPHER_key_length()</i> is fixed for a given cipher,
the value of <i>EVP_CIPHER_CTX_key_length()</i> may be
different for variable key length ciphers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_set_key_length()</i>
sets the key length of the cipher ctx. If the cipher is a
fixed length cipher then attempting to set the key length to
any value other than the fixed value is an error.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_iv_length()</i>
and <i>EVP_CIPHER_CTX_iv_length()</i> return the
<small>IV</small> length of a cipher when passed an
<b><small>EVP_CIPHER</small></b> or
<b><small>EVP_CIPHER_CTX</small></b> . It will return zero
if the cipher does not use an <small>IV.</small> The
constant <b><small>EVP_MAX_IV_LENGTH</small></b> is the
maximum <small>IV</small> length for all ciphers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_block_size()</i>
and <i>EVP_CIPHER_CTX_block_size()</i> return the block size
of a cipher when passed an <b><small>EVP_CIPHER</small></b>
or <b><small>EVP_CIPHER_CTX</small></b> structure. The
constant <b><small>EVP_MAX_IV_LENGTH</small></b> is also the
maximum block length for all ciphers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_type()</i>
and <i>EVP_CIPHER_CTX_type()</i> return the type of the
passed cipher or context. This &quot;type&quot; is the
actual <small>NID</small> of the cipher <small>OBJECT
IDENTIFIER</small> as such it ignores the cipher parameters
and 40 bit <small>RC2</small> and 128 bit <small>RC2</small>
have the same <small>NID.</small> If the cipher does not
have an object identifier or does not have
<small>ASN1</small> support this function will return
<b>NID_undef</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_cipher()</i>
returns the <b><small>EVP_CIPHER</small></b> structure when
passed an <b><small>EVP_CIPHER_CTX</small></b>
structure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_mode()</i>
and <i>EVP_CIPHER_CTX_mode()</i> return the block cipher
mode: <small>EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE,
EVP_CIPH_CFB_MODE</small> or
<small>EVP_CIPH_OFB_MODE.</small> If the cipher is a stream
cipher then <small>EVP_CIPH_STREAM_CIPHER</small> is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_param_to_asn1()</i>
sets the AlgorithmIdentifier &quot;parameter&quot; based on
the passed cipher. This will typically include any
parameters and an <small>IV.</small> The cipher
<small>IV</small> (if any) must be set when this call is
made. This call should be made before the cipher is actually
&quot;used&quot; (before any <i>EVP_EncryptUpdate()</i>,
<i>EVP_DecryptUpdate()</i> calls for example). This function
may fail if the cipher does not have any <small>ASN1</small>
support.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_asn1_to_param()</i>
sets the cipher parameters based on an <small>ASN1</small>
AlgorithmIdentifier &quot;parameter&quot;. The precise
effect depends on the cipher In the case of
<small>RC2,</small> for example, it will set the
<small>IV</small> and effective key length. This function
should be called after the base cipher type is set but
before the key is set. For example <i>EVP_CipherInit()</i>
will be called with the <small>IV</small> and key set to
<small>NULL,</small> <i>EVP_CIPHER_asn1_to_param()</i> will
be called and finally <i>EVP_CipherInit()</i> again with all
parameters except the key set to <small>NULL.</small> It is
possible for this function to fail if the cipher does not
have any <small>ASN1</small> support or the parameters
cannot be set (for example the <small>RC2</small> effective
key length is not supported.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_ctrl()</i>
allows various cipher specific parameters to be determined
and set. Currently only the <small>RC2</small> effective key
length and the number of rounds of <small>RC5</small> can be
set.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>EVP_EncryptInit_ex()</i>,
<i>EVP_EncryptUpdate()</i> and <i>EVP_EncryptFinal_ex()</i>
return 1 for success and 0 for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_DecryptInit_ex()</i>
and <i>EVP_DecryptUpdate()</i> return 1 for success and 0
for failure. <i>EVP_DecryptFinal_ex()</i> returns 0 if the
decrypt failed or 1 for success.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CipherInit_ex()</i>
and <i>EVP_CipherUpdate()</i> return 1 for success and 0 for
failure. <i>EVP_CipherFinal_ex()</i> returns 0 for a
decryption failure or 1 for success.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_cleanup()</i>
returns 1 for success and 0 for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_get_cipherbyname()</i>,
<i>EVP_get_cipherbynid()</i> and
<i>EVP_get_cipherbyobj()</i> return an
<b><small>EVP_CIPHER</small></b> structure or
<small>NULL</small> on error.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_nid()</i>
and <i>EVP_CIPHER_CTX_nid()</i> return a
<small>NID.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_block_size()</i>
and <i>EVP_CIPHER_CTX_block_size()</i> return the block
size.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_key_length()</i>
and <i>EVP_CIPHER_CTX_key_length()</i> return the key
length.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_set_padding()</i>
always returns 1.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_iv_length()</i>
and <i>EVP_CIPHER_CTX_iv_length()</i> return the
<small>IV</small> length or zero if the cipher does not use
an <small>IV.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_type()</i>
and <i>EVP_CIPHER_CTX_type()</i> return the
<small>NID</small> of the cipher&rsquo;s <small>OBJECT
IDENTIFIER</small> or NID_undef if it has no defined
<small>OBJECT IDENTIFIER.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_cipher()</i>
returns an <b><small>EVP_CIPHER</small></b> structure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_param_to_asn1()</i>
and <i>EVP_CIPHER_asn1_to_param()</i> return 1 for success
or zero for failure.</p>

<h2>CIPHER LISTING
<a name="CIPHER LISTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All algorithms
have a fixed key length unless otherwise stated. <i><br>
EVP_enc_null()</i></p>

<p style="margin-left:17%;">Null cipher: does nothing.</p>

<p style="margin-left:11%;">EVP_des_cbc(void),
EVP_des_ecb(void), EVP_des_cfb(void), <br>
EVP_des_ofb(void)</p>

<p style="margin-left:17%;"><small>DES</small> in
<small>CBC, ECB, CFB</small> and <small>OFB</small> modes
respectively.</p>

<p style="margin-left:11%;">EVP_des_ede_cbc(void),
<i>EVP_des_ede()</i>, EVP_des_ede_ofb(void), <br>
EVP_des_ede_cfb(void)</p>

<p style="margin-left:17%;">Two key triple
<small>DES</small> in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_des_ede3_cbc(void),
<i>EVP_des_ede3()</i>, EVP_des_ede3_ofb(void), <br>
EVP_des_ede3_cfb(void)</p>

<p style="margin-left:17%;">Three key triple
<small>DES</small> in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_desx_cbc(void)</p>

<p style="margin-left:17%;"><small>DESX</small> algorithm
in <small>CBC</small> mode.</p>

<p style="margin-left:11%;">EVP_aes_128_cbc(void),
<i>EVP_aes_128_ecb()</i>, EVP_aes_128_ofb(void), <br>
EVP_aes_128_cfb1(void), EVP_aes_128_cfb8(void), <br>
EVP_aes_128_cfb128(void)</p>

<p style="margin-left:17%;"><small>AES</small> with 128 bit
key length in <small>CBC, ECB, OFB</small> and
<small>CFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_aes_192_cbc(void),
<i>EVP_aes_192_ecb()</i>, EVP_aes_192_ofb(void), <br>
EVP_aes_192_cfb1(void), EVP_aes_192_cfb8(void), <br>
EVP_aes_192_cfb128(void)</p>

<p style="margin-left:17%;"><small>AES</small> with 192 bit
key length in <small>CBC, ECB, OFB</small> and
<small>CFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_aes_256_cbc(void),
<i>EVP_aes_256_ecb()</i>, EVP_aes_256_ofb(void), <br>
EVP_aes_256_cfb1(void), EVP_aes_256_cfb8(void), <br>
EVP_aes_256_cfb128(void)</p>

<p style="margin-left:17%;"><small>AES</small> with 256 bit
key length in <small>CBC, ECB, OFB</small> and
<small>CFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_rc4(void)</p>

<p style="margin-left:17%;"><small>RC4</small> stream
cipher. This is a variable key length cipher with default
key length 128 bits.</p>

<p style="margin-left:11%;">EVP_rc4_40(void)</p>

<p style="margin-left:17%;"><small>RC4</small> stream
cipher with 40 bit key length. This is obsolete and new code
should use <i>EVP_rc4()</i> and the
<i>EVP_CIPHER_CTX_set_key_length()</i> function.</p>

<p style="margin-left:11%;"><i>EVP_idea_cbc()</i>
EVP_idea_ecb(void), EVP_idea_cfb(void), <br>
EVP_idea_ofb(void), EVP_idea_cbc(void)</p>

<p style="margin-left:17%;"><small>IDEA</small> encryption
algorithm in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively.</p>

<p style="margin-left:11%;">EVP_rc2_cbc(void),
EVP_rc2_ecb(void), EVP_rc2_cfb(void), <br>
EVP_rc2_ofb(void)</p>

<p style="margin-left:17%;"><small>RC2</small> encryption
algorithm in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively. This is a variable
key length cipher with an additional parameter called
&quot;effective key bits&quot; or &quot;effective key
length&quot;. By default both are set to 128 bits.</p>

<p style="margin-left:11%;">EVP_rc2_40_cbc(void),
EVP_rc2_64_cbc(void)</p>

<p style="margin-left:17%;"><small>RC2</small> algorithm in
<small>CBC</small> mode with a default key length and
effective key length of 40 and 64 bits. These are obsolete
and new code should use <i>EVP_rc2_cbc()</i>,
<i>EVP_CIPHER_CTX_set_key_length()</i> and
<i>EVP_CIPHER_CTX_ctrl()</i> to set the key length and
effective key length.</p>

<p style="margin-left:11%;">EVP_bf_cbc(void),
EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);</p>

<p style="margin-left:17%;">Blowfish encryption algorithm
in <small>CBC, ECB, CFB</small> and <small>OFB</small> modes
respectively. This is a variable key length cipher.</p>

<p style="margin-left:11%;">EVP_cast5_cbc(void),
EVP_cast5_ecb(void), EVP_cast5_cfb(void), <br>
EVP_cast5_ofb(void)</p>

<p style="margin-left:17%;"><small>CAST</small> encryption
algorithm in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively. This is a variable
key length cipher.</p>

<p style="margin-left:11%;">EVP_rc5_32_12_16_cbc(void),
EVP_rc5_32_12_16_ecb(void), <br>
EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)</p>

<p style="margin-left:17%;"><small>RC5</small> encryption
algorithm in <small>CBC, ECB, CFB</small> and
<small>OFB</small> modes respectively. This is a variable
key length cipher with an additional &quot;number of
rounds&quot; parameter. By default the key length is set to
128 bits and 12 rounds.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Where possible
the <b><small>EVP</small></b> interface to symmetric ciphers
should be used in preference to the low level interfaces.
This is because the code then becomes transparent to the
cipher used and much more flexible.</p>


<p style="margin-left:11%; margin-top: 1em"><small>PKCS</small>
padding works by adding <b>n</b> padding bytes of value
<b>n</b> to make the total length of the encrypted data a
multiple of the block size. Padding is always added so if
the data is already a multiple of the block size <b>n</b>
will equal the block size. For example if the block size is
8 and 11 bytes are to be encrypted then 5 padding bytes of
value 5 will be added.</p>

<p style="margin-left:11%; margin-top: 1em">When decrypting
the final block is checked to see if it has the correct
form.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
decryption operation can produce an error if padding is
enabled, it is not a strong test that the input data or key
is correct. A random block has better than 1 in 256 chance
of being of the correct format and problems with the input
data earlier on will not produce a final decrypt error.</p>

<p style="margin-left:11%; margin-top: 1em">If padding is
disabled then the decryption operation will always succeed
if the total amount of data decrypted is a multiple of the
block size.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<i>EVP_EncryptInit()</i>, <i>EVP_EncryptFinal()</i>,
<i>EVP_DecryptInit()</i>, <i>EVP_CipherInit()</i> and
<i>EVP_CipherFinal()</i> are obsolete but are retained for
compatibility with existing code. New code should use
<i>EVP_EncryptInit_ex()</i>, <i>EVP_EncryptFinal_ex()</i>,
<i>EVP_DecryptInit_ex()</i>, <i>EVP_DecryptFinal_ex()</i>,
<i>EVP_CipherInit_ex()</i> and <i>EVP_CipherFinal_ex()</i>
because they can reuse an existing context without
allocating and freeing it up on each call.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For
<small>RC5</small> the number of rounds can currently only
be set to 8, 12 or 16. This is a limitation of the current
<small>RC5</small> code rather than the <small>EVP</small>
interface.</p>


<p style="margin-left:11%; margin-top: 1em"><small>EVP_MAX_KEY_LENGTH</small>
and <small>EVP_MAX_IV_LENGTH</small> only refer to the
internal ciphers with default key lengths. If custom ciphers
exceed these values the results are unpredictable. This is
because it has become standard practice to define a generic
key as a fixed unsigned char array containing
<small>EVP_MAX_KEY_LENGTH</small> bytes.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>ASN1</small> code is incomplete (and sometimes
inaccurate) it has only been tested for certain common
S/MIME ciphers ( <small>RC2, DES,</small> triple
<small>DES</small> ) in <small>CBC</small> mode.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Get the number
of rounds used in <small>RC5:</small></p>

<pre style="margin-left:11%; margin-top: 1em"> int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &amp;nrounds);</pre>


<p style="margin-left:11%; margin-top: 1em">Get the
<small>RC2</small> effective key length:</p>

<pre style="margin-left:11%; margin-top: 1em"> int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &amp;key_bits);</pre>


<p style="margin-left:11%; margin-top: 1em">Set the number
of rounds used in <small>RC5:</small></p>

<pre style="margin-left:11%; margin-top: 1em"> int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);</pre>


<p style="margin-left:11%; margin-top: 1em">Set the
effective key length used in <small>RC2:</small></p>

<pre style="margin-left:11%; margin-top: 1em"> int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);</pre>


<p style="margin-left:11%; margin-top: 1em">Encrypt a
string using blowfish:</p>

<pre style="margin-left:11%; margin-top: 1em"> int do_crypt(char *outfile)
        {
        unsigned char outbuf[1024];
        int outlen, tmplen;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        unsigned char iv[] = {1,2,3,4,5,6,7,8};
        char intext[] = &quot;Some Crypto Text&quot;;
        EVP_CIPHER_CTX ctx;
        FILE *out;
        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_EncryptInit_ex(&amp;ctx, EVP_bf_cbc(), NULL, key, iv);
        if(!EVP_EncryptUpdate(&amp;ctx, outbuf, &amp;outlen, intext, strlen(intext)))
                {
                /* Error */
                return 0;
                }
        /* Buffer passed to EVP_EncryptFinal() must be after data just
         * encrypted to avoid overwriting it.
         */
        if(!EVP_EncryptFinal_ex(&amp;ctx, outbuf + outlen, &amp;tmplen))
                {
                /* Error */
                return 0;
                }
        outlen += tmplen;
        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        /* Need binary mode for fopen because encrypted data is
         * binary data. Also cannot use strlen() on it because
         * it wont be null terminated and may contain embedded
         * nulls.
         */
        out = fopen(outfile, &quot;wb&quot;);
        fwrite(outbuf, 1, outlen, out);
        fclose(out);
        return 1;
        }</pre>


<p style="margin-left:11%; margin-top: 1em">The ciphertext
from the above example can be decrypted using the
<b>openssl</b> utility with the command line:</p>

<pre style="margin-left:11%; margin-top: 1em"> S&lt;openssl bf &minus;in cipher.bin &minus;K 000102030405060708090A0B0C0D0E0F &minus;iv 0102030405060708 &minus;d&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">General
encryption, decryption function example using <small>FILE
I/O</small> and <small>RC2</small> with an 80 bit key:</p>

<pre style="margin-left:11%; margin-top: 1em"> int do_crypt(FILE *in, FILE *out, int do_encrypt)
        {
        /* Allow enough space in output buffer for additional block */
        inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
        int inlen, outlen;
        /* Bogus key and IV: we'd normally set these from
         * another source.
         */
        unsigned char key[] = &quot;0123456789&quot;;
        unsigned char iv[] = &quot;12345678&quot;;
        /* Don't set key or IV because we will modify the parameters */
        EVP_CIPHER_CTX_init(&amp;ctx);
        EVP_CipherInit_ex(&amp;ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
        EVP_CIPHER_CTX_set_key_length(&amp;ctx, 10);
        /* We finished modifying parameters so now we can set key and IV */
        EVP_CipherInit_ex(&amp;ctx, NULL, NULL, key, iv, do_encrypt);
        for(;;)
                {
                inlen = fread(inbuf, 1, 1024, in);
                if(inlen &lt;= 0) break;
                if(!EVP_CipherUpdate(&amp;ctx, outbuf, &amp;outlen, inbuf, inlen))
                        {
                        /* Error */
                        EVP_CIPHER_CTX_cleanup(&amp;ctx);
                        return 0;
                        }
                fwrite(outbuf, 1, outlen, out);
                }
        if(!EVP_CipherFinal_ex(&amp;ctx, outbuf, &amp;outlen))
                {
                /* Error */
                EVP_CIPHER_CTX_cleanup(&amp;ctx);
                return 0;
                }
        fwrite(outbuf, 1, outlen, out);
        EVP_CIPHER_CTX_cleanup(&amp;ctx);
        return 1;
        }</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>evp</i>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>EVP_CIPHER_CTX_init()</i>,
<i>EVP_EncryptInit_ex()</i>, <i>EVP_EncryptFinal_ex()</i>,
<i>EVP_DecryptInit_ex()</i>, <i>EVP_DecryptFinal_ex()</i>,
<i>EVP_CipherInit_ex()</i>, <i>EVP_CipherFinal_ex()</i> and
<i>EVP_CIPHER_CTX_set_padding()</i> appeared in OpenSSL
0.9.7.</p>
<hr>
</body>
</html>
