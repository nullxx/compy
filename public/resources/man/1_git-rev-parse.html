<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 14:58:02 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GIT&minus;REV&minus;PARSE</title>

</head>
<body>

<h1 align="center">GIT&minus;REV&minus;PARSE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#SPECIFYING REVISIONS">SPECIFYING REVISIONS</a><br>
<a href="#SPECIFYING RANGES">SPECIFYING RANGES</a><br>
<a href="#PARSEOPT">PARSEOPT</a><br>
<a href="#SQ-QUOTE">SQ-QUOTE</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#GIT">GIT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">git-rev-parse
&minus; Pick out and massage parameters</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>git
rev&minus;parse</i> [ &minus;&minus;option ]
&lt;args&gt;...</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many Git
porcelainish commands take mixture of flags (i.e. parameters
that begin with a dash <i>&minus;</i>) and parameters meant
for the underlying <i>git rev&minus;list</i> command they
use internally and flags and parameters for the other
commands they use downstream of <i>git rev&minus;list</i>.
This command is used to distinguish between them.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&minus;&minus;parseopt</p>

<p style="margin-left:17%;">Use <i>git rev&minus;parse</i>
in option parsing mode (see PARSEOPT section below).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;keep&minus;dashdash</p>

<p style="margin-left:17%;">Only meaningful in
&minus;&minus;parseopt mode. Tells the option parser to echo
out the first &minus;&minus; met instead of skipping it.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;stop&minus;at&minus;non&minus;option</p>

<p style="margin-left:17%;">Only meaningful in
&minus;&minus;parseopt mode. Lets the option parser stop at
the first non&minus;option argument. This can be used to
parse sub&minus;commands that take options themselves.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;sq&minus;quote</p>

<p style="margin-left:17%;">Use <i>git rev&minus;parse</i>
in shell quoting mode (see SQ&minus;QUOTE section below). In
contrast to the &minus;&minus;sq option below, this mode
does only quoting. Nothing else is done to command
input.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;revs&minus;only</p>

<p style="margin-left:17%;">Do not output flags and
parameters not meant for <i>git rev&minus;list</i>
command.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;revs</p>

<p style="margin-left:17%;">Do not output flags and
parameters meant for <i>git rev&minus;list</i> command.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;flags</p>

<p style="margin-left:17%;">Do not output non&minus;flag
parameters.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;flags</p>

<p style="margin-left:17%;">Do not output flag
parameters.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;default
&lt;arg&gt;</p>

<p style="margin-left:17%;">If there is no parameter given
by the user, use &lt;arg&gt; instead.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;verify</p>

<p style="margin-left:17%;">Verify that exactly one
parameter is provided, and that it can be turned into a raw
20&minus;byte SHA&minus;1 that can be used to access the
object database. If so, emit it to the standard output;
otherwise, error out.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
make sure that the output actually names an object in your
object database and/or can be used as a specific type of
object For example, git rev&minus;parse
&quot;$VAR^{commit}&quot; will make sure $VAR names an
existing object that is a commit&minus;ish (i.e. a commit,
or an annotated tag that points at a commit). To make sure
that $VAR names an existing object of any type, git
rev&minus;parse &quot;$VAR^{object}&quot; can be used.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q,
&minus;&minus;quiet</p>

<p style="margin-left:17%;">Only meaningful in
&minus;&minus;verify mode. Do not output an error message if
the first argument is not a valid object name; instead exit
with non&minus;zero status silently.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;sq</p>

<p style="margin-left:17%;">Usually the output is made one
line per flag and parameter. This option makes output a
single line, properly quoted for consumption by shell.
Useful when you expect your parameter to contain whitespaces
and newlines (e.g. when using pickaxe &minus;S with <i>git
diff&minus;*</i>). In contrast to the
&minus;&minus;sq&minus;quote option, the command input is
still interpreted as usual.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;not</p>

<p style="margin-left:17%;">When showing object names,
prefix them with <i>^</i> and strip <i>^</i> prefix from the
object names that already have one.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;symbolic</p>

<p style="margin-left:17%;">Usually the object names are
output in SHA&minus;1 form (with possible <i>^</i> prefix);
this option makes them output in a form as close to the
original input as possible.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;symbolic&minus;full&minus;name</p>

<p style="margin-left:17%;">This is similar to
&minus;&minus;symbolic, but it omits input that are not refs
(i.e. branch or tag names; or more explicitly disambiguating
&quot;heads/master&quot; form, when you want to name the
&quot;master&quot; branch when there is an unfortunately
named tag &quot;master&quot;), and show them as full
refnames (e.g. &quot;refs/heads/master&quot;).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;abbrev&minus;ref[=(strict|loose)]</p>

<p style="margin-left:17%;">A non&minus;ambiguous short
name of the objects name. The option core.warnAmbiguousRefs
is used to select the strict abbreviation mode.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;disambiguate=&lt;prefix&gt;</p>

<p style="margin-left:17%;">Show every object whose name
begins with the given prefix. The &lt;prefix&gt; must be at
least 4 hexadecimal digits long to avoid listing each and
every object in the repository by mistake.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;all</p>

<p style="margin-left:17%;">Show all refs found in
refs/.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;branches[=pattern],
&minus;&minus;tags[=pattern],
&minus;&minus;remotes[=pattern]</p>

<p style="margin-left:17%;">Show all branches, tags, or
remote&minus;tracking branches, respectively (i.e., refs
found in refs/heads, refs/tags, or refs/remotes,
respectively).</p>

<p style="margin-left:17%; margin-top: 1em">If a pattern is
given, only refs matching the given shell glob are shown. If
the pattern does not contain a globbing character (?, *, or
[), it is turned into a prefix match by appending /*.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;glob=pattern</p>

<p style="margin-left:17%;">Show all refs matching the
shell glob pattern pattern. If the pattern does not start
with refs/, this is automatically prepended. If the pattern
does not contain a globbing character (?, *, or [), it is
turned into a prefix match by appending /*.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;show&minus;toplevel</p>

<p style="margin-left:17%;">Show the absolute path of the
top&minus;level directory.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;show&minus;prefix</p>

<p style="margin-left:17%;">When the command is invoked
from a subdirectory, show the path of the current directory
relative to the top&minus;level directory.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;show&minus;cdup</p>

<p style="margin-left:17%;">When the command is invoked
from a subdirectory, show the path of the top&minus;level
directory relative to the current directory (typically a
sequence of &quot;../&quot;, or an empty string).</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;git&minus;dir</p>

<p style="margin-left:17%;">Show $GIT_DIR if defined.
Otherwise show the path to the .git directory. The path
shown, when relative, is relative to the current working
directory.</p>

<p style="margin-left:17%; margin-top: 1em">If $GIT_DIR is
not defined and the current directory is not detected to lie
in a Git repository or work tree print a message to stderr
and exit with nonzero status.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;is&minus;inside&minus;git&minus;dir</p>

<p style="margin-left:17%;">When the current working
directory is below the repository directory print
&quot;true&quot;, otherwise &quot;false&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;is&minus;inside&minus;work&minus;tree</p>

<p style="margin-left:17%;">When the current working
directory is inside the work tree of the repository print
&quot;true&quot;, otherwise &quot;false&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;is&minus;bare&minus;repository</p>

<p style="margin-left:17%;">When the repository is bare
print &quot;true&quot;, otherwise &quot;false&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;local&minus;env&minus;vars</p>

<p style="margin-left:17%;">List the GIT_* environment
variables that are local to the repository (e.g. GIT_DIR or
GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the
variables are listed, not their value, even if they are
set.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;short,
&minus;&minus;short=number</p>

<p style="margin-left:17%;">Instead of outputting the full
SHA&minus;1 values of object names try to abbreviate them to
a shorter unique name. When no length is specified 7 is
used. The minimum length is 4.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;since=datestring,
&minus;&minus;after=datestring</p>

<p style="margin-left:17%;">Parse the date string, and
output the corresponding &minus;&minus;max&minus;age=
parameter for <i>git rev&minus;list</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;until=datestring,
&minus;&minus;before=datestring</p>

<p style="margin-left:17%;">Parse the date string, and
output the corresponding &minus;&minus;min&minus;age=
parameter for <i>git rev&minus;list</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;args&gt;...</p>

<p style="margin-left:17%;">Flags and parameters to be
parsed.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;resolve&minus;git&minus;dir
&lt;path&gt;</p>

<p style="margin-left:17%;">Check if &lt;path&gt; is a
valid repository or a gitfile that points at a valid
repository, and print the location of the repository. If
&lt;path&gt; is a gitfile then the resolved path to the real
repository is printed.</p>

<h2>SPECIFYING REVISIONS
<a name="SPECIFYING REVISIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A revision
parameter <i>&lt;rev&gt;</i> typically, but not necessarily,
names a commit object. It uses what is called an <i>extended
SHA&minus;1</i> syntax. Here are various ways to spell
object names. The ones listed near the end of this list name
trees and blobs contained in a commit.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;sha1&gt;</i>,
e.g. <i>dae86e1950b1277e545cee180551750029cfe735</i>,
<i>dae86e</i></p>

<p style="margin-left:17%;">The full SHA&minus;1 object
name (40&minus;byte hexadecimal string), or a leading
substring that is unique within the repository. E.g.
dae86e1950b1277e545cee180551750029cfe735 and dae86e both
name the same commit object if there is no other object in
your repository whose object name starts with dae86e.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;describeOutput&gt;</i>,
e.g. <i>v1.7.4.2&minus;679&minus;g3bee7fb</i></p>

<p style="margin-left:17%;">Output from git describe; i.e.
a closest tag, optionally followed by a dash and a number of
commits, followed by a dash, a <i>g</i>, and an abbreviated
object name.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;refname&gt;</i>,
e.g. <i>master</i>, <i>heads/master</i>,
<i>refs/heads/master</i></p>

<p style="margin-left:17%;">A symbolic ref name. E.g.
<i>master</i> typically means the commit object referenced
by <i>refs/heads/master</i>. If you happen to have both
<i>heads/master</i> and <i>tags/master</i>, you can
explicitly say <i>heads/master</i> to tell Git which one you
mean. When ambiguous, a <i>&lt;refname&gt;</i> is
disambiguated by taking the first match in the following
rules:</p>

<p style="margin-left:23%; margin-top: 1em">1. If
<i>$GIT_DIR/&lt;refname&gt;</i> exists, that is what you
mean (this is usually useful only for <i>HEAD</i>,
<i>FETCH_HEAD</i>, <i>ORIG_HEAD</i>, <i>MERGE_HEAD</i> and
<i>CHERRY_PICK_HEAD</i>);</p>

<p style="margin-left:23%; margin-top: 1em">2. otherwise,
<i>refs/&lt;refname&gt;</i> if it exists;</p>

<p style="margin-left:23%; margin-top: 1em">3. otherwise,
<i>refs/tags/&lt;refname&gt;</i> if it exists;</p>

<p style="margin-left:23%; margin-top: 1em">4. otherwise,
<i>refs/heads/&lt;refname&gt;</i> if it exists;</p>

<p style="margin-left:23%; margin-top: 1em">5. otherwise,
<i>refs/remotes/&lt;refname&gt;</i> if it exists;</p>

<p style="margin-left:23%; margin-top: 1em">6. otherwise,
<i>refs/remotes/&lt;refname&gt;/HEAD</i> if it exists.</p>

<p style="margin-left:23%; margin-top: 1em"><i>HEAD</i>
names the commit on which you based the changes in the
working tree. <i>FETCH_HEAD</i> records the branch which you
fetched from a remote repository with your last git fetch
invocation. <i>ORIG_HEAD</i> is created by commands that
move your <i>HEAD</i> in a drastic way, to record the
position of the <i>HEAD</i> before their operation, so that
you can easily change the tip of the branch back to the
state before you ran them. <i>MERGE_HEAD</i> records the
commit(s) which you are merging into your branch when you
run git merge. <i>CHERRY_PICK_HEAD</i> records the commit
which you are cherry&minus;picking when you run git
cherry&minus;pick.</p>

<p style="margin-left:23%; margin-top: 1em">Note that any
of the <i>refs/*</i> cases above may come either from the
<i>$GIT_DIR/refs</i> directory or from the
<i>$GIT_DIR/packed&minus;refs</i> file. While the ref name
encoding is unspecified, UTF&minus;8 is preferred as some
output processing may assume ref names in UTF&minus;8.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;refname&gt;@{&lt;date&gt;}</i>,
e.g. <i>master@{yesterday}</i>, <i>HEAD@{5 minutes
ago}</i></p>

<p style="margin-left:17%;">A ref followed by the suffix
<i>@</i> with a date specification enclosed in a brace pair
(e.g. <i>{yesterday}</i>, <i>{1 month 2 weeks 3 days 1 hour
1 second ago}</i> or <i>{1979&minus;02&minus;26
18:30:00}</i>) specifies the value of the ref at a prior
point in time. This suffix may only be used immediately
following a ref name and the ref must have an existing log
(<i>$GIT_DIR/logs/&lt;ref&gt;</i>). Note that this looks up
the state of your <b>local</b> ref at a given time; e.g.,
what was in your local <i>master</i> branch last week. If
you want to look at commits made during certain times, see
<i>&minus;&minus;since</i> and
<i>&minus;&minus;until</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;refname&gt;@{&lt;n&gt;}</i>,
e.g. <i>master@{1}</i></p>

<p style="margin-left:17%;">A ref followed by the suffix
<i>@</i> with an ordinal specification enclosed in a brace
pair (e.g. <i>{1}</i>, <i>{15}</i>) specifies the n&minus;th
prior value of that ref. For example <i>master@{1}</i> is
the immediate prior value of <i>master</i> while
<i>master@{5}</i> is the 5th prior value of <i>master</i>.
This suffix may only be used immediately following a ref
name and the ref must have an existing log
(<i>$GIT_DIR/logs/&lt;refname&gt;</i>).</p>


<p style="margin-left:11%; margin-top: 1em"><i>@{&lt;n&gt;}</i>,
e.g. <i>@{1}</i></p>

<p style="margin-left:17%;">You can use the <i>@</i>
construct with an empty ref part to get at a reflog entry of
the current branch. For example, if you are on branch
<i>blabla</i> then <i>@{1}</i> means the same as
<i>blabla@{1}</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>@{&minus;&lt;n&gt;}</i>,
e.g. <i>@{&minus;1}</i></p>

<p style="margin-left:17%;">The construct
<i>@{&minus;&lt;n&gt;}</i> means the &lt;n&gt;th branch
checked out before the current one.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;branchname&gt;@{upstream}</i>,
e.g. <i>master@{upstream}</i>, <i>@{u}</i></p>

<p style="margin-left:17%;">The suffix <i>@{upstream}</i>
to a branchname (short form <i>&lt;branchname&gt;@{u}</i>)
refers to the branch that the branch specified by branchname
is set to build on top of. A missing branchname defaults to
the current one.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^</i>,
e.g. <i>HEAD^, v1.5.1^0</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> to a revision
parameter means the first parent of that commit object.
<i>^&lt;n&gt;</i> means the &lt;n&gt;th parent (i.e.
<i>&lt;rev&gt;^</i> is equivalent to <i>&lt;rev&gt;^1</i>).
As a special rule, <i>&lt;rev&gt;^0</i> means the commit
itself and is used when <i>&lt;rev&gt;</i> is the object
name of a tag object that refers to a commit object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;~&lt;n&gt;</i>,
e.g. <i>master~3</i></p>

<p style="margin-left:17%;">A suffix <i>~&lt;n&gt;</i> to a
revision parameter means the commit object that is the
&lt;n&gt;th generation ancestor of the named commit object,
following only the first parents. I.e. <i>&lt;rev&gt;~3</i>
is equivalent to <i>&lt;rev&gt;^^^</i> which is equivalent
to <i>&lt;rev&gt;^1^1^1</i>. See below for an illustration
of the usage of this form.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^{&lt;type&gt;}</i>,
e.g. <i>v0.99.8^{commit}</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> followed by
an object type name enclosed in brace pair means the object
could be a tag, and dereference the tag recursively until an
object of that type is found or the object cannot be
dereferenced anymore (in which case, barf).
<i>&lt;rev&gt;^0</i> is a short&minus;hand for
<i>&lt;rev&gt;^{commit}</i>.</p>


<p style="margin-left:17%; margin-top: 1em"><i>rev^{object}</i>
can be used to make sure <i>rev</i> names an object that
exists, without requiring <i>rev</i> to be a tag, and
without dereferencing <i>rev</i>; because a tag is already
an object, it does not have to be dereferenced even once to
get to an object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^{}</i>,
e.g. <i>v0.99.8^{}</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> followed by
an empty brace pair means the object could be a tag, and
dereference the tag recursively until a non&minus;tag object
is found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^{/&lt;text&gt;}</i>,
e.g. <i>HEAD^{/fix nasty bug}</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> to a revision
parameter, followed by a brace pair that contains a text led
by a slash, is the same as the <i>:/fix nasty bug</i> syntax
below except that it returns the youngest matching commit
which is reachable from the <i>&lt;rev&gt;</i> before
<i>^</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>:/&lt;text&gt;</i>,
e.g. <i>:/fix nasty bug</i></p>

<p style="margin-left:17%;">A colon, followed by a slash,
followed by a text, names a commit whose commit message
matches the specified regular expression. This name returns
the youngest matching commit which is reachable from any
ref. If the commit message starts with a <i>!</i> you have
to repeat that; the special sequence <i>:/!</i>, followed by
something else than <i>!</i>, is reserved for now. The
regular expression can match any part of the commit message.
To match messages starting with a string, one can use e.g.
<i>:/^foo</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;:&lt;path&gt;</i>,
e.g. <i>HEAD:README</i>, <i>:README</i>,
<i>master:./README</i></p>

<p style="margin-left:17%;">A suffix <i>:</i> followed by a
path names the blob or tree at the given path in the
tree&minus;ish object named by the part before the colon.
<i>:path</i> (with an empty part before the colon) is a
special case of the syntax described next: content recorded
in the index at the given path. A path starting with
<i>./</i> or <i>../</i> is relative to the current working
directory. The given path will be converted to be relative
to the working tree&rsquo;s root directory. This is most
useful to address a blob or tree from a commit or tree that
has the same tree structure as the working tree.</p>


<p style="margin-left:11%; margin-top: 1em"><i>:&lt;n&gt;:&lt;path&gt;</i>,
e.g. <i>:0:README</i>, <i>:README</i></p>

<p style="margin-left:17%;">A colon, optionally followed by
a stage number (0 to 3) and a colon, followed by a path,
names a blob object in the index at the given path. A
missing stage number (and the colon that follows it) names a
stage 0 entry. During a merge, stage 1 is the common
ancestor, stage 2 is the target branch&rsquo;s version
(typically the current branch), and stage 3 is the version
from the branch which is being merged.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
illustration, by Jon Loeliger. Both commit nodes B and C are
parents of commit node A. Parent commits are ordered
left&minus;to&minus;right.</p>

<p style="margin-left:17%; margin-top: 1em">G H I J <br>
\ / \ / <br>
D E F <br>
\ | / \ <br>
\ | / | <br>
\|/ | <br>
B C <br>
\ / <br>
\ / <br>
A</p>

<p style="margin-left:17%; margin-top: 1em">A = = A^0 <br>
B = A^ = A^1 = A~1 <br>
C = A^2 = A^2 <br>
D = A^^ = A^1^1 = A~2 <br>
E = B^2 = A^^2 <br>
F = B^3 = A^^3 <br>
G = A^^^ = A^1^1^1 = A~3 <br>
H = D^2 = B^^2 = A^^^2 = A~2^2 <br>
I = F^ = B^3^ = A^^3^ <br>
J = F^2 = B^3^2 = A^^3^2</p>

<h2>SPECIFYING RANGES
<a name="SPECIFYING RANGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">History
traversing commands such as git log operate on a set of
commits, not just a single commit. To these commands,
specifying a single revision with the notation described in
the previous section means the set of commits reachable from
that commit, following the commit ancestry chain.</p>

<p style="margin-left:11%; margin-top: 1em">To exclude
commits reachable from a commit, a prefix <i>^</i> notation
is used. E.g. <i>^r1 r2</i> means commits reachable from
<i>r2</i> but exclude the ones reachable from <i>r1</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This set
operation appears so often that there is a shorthand for it.
When you have two commits <i>r1</i> and <i>r2</i> (named
according to the syntax explained in SPECIFYING REVISIONS
above), you can ask for commits that are reachable from r2
excluding those that are reachable from r1 by <i>^r1 r2</i>
and it can be written as <i>r1..r2</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A similar
notation <i>r1...r2</i> is called symmetric difference of
<i>r1</i> and <i>r2</i> and is defined as <i>r1 r2
&minus;&minus;not $(git merge&minus;base &minus;&minus;all
r1 r2)</i>. It is the set of commits that are reachable from
either one of <i>r1</i> or <i>r2</i> but not from both.</p>

<p style="margin-left:11%; margin-top: 1em">In these two
shorthands, you can omit one end and let it default to HEAD.
For example, <i>origin..</i> is a shorthand for
<i>origin..HEAD</i> and asks &quot;What did I do since I
forked from the origin branch?&quot; Similarly,
<i>..origin</i> is a shorthand for <i>HEAD..origin</i> and
asks &quot;What did the origin do since I forked from
them?&quot; Note that <i>..</i> would mean <i>HEAD..HEAD</i>
which is an empty range that is both reachable and
unreachable from HEAD.</p>

<p style="margin-left:11%; margin-top: 1em">Two other
shorthands for naming a set that is formed by a commit and
its parent commits exist. The <i>r1^@</i> notation means all
parents of <i>r1</i>. <i>r1^!</i> includes commit <i>r1</i>
but excludes all of its parents.</p>

<p style="margin-left:11%; margin-top: 1em">To
summarize:</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;</i></p>

<p style="margin-left:17%;">Include commits that are
reachable from (i.e. ancestors of) &lt;rev&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>^&lt;rev&gt;</i></p>

<p style="margin-left:17%;">Exclude commits that are
reachable from (i.e. ancestors of) &lt;rev&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev1&gt;..&lt;rev2&gt;</i></p>

<p style="margin-left:17%;">Include commits that are
reachable from &lt;rev2&gt; but exclude those that are
reachable from &lt;rev1&gt;. When either &lt;rev1&gt; or
&lt;rev2&gt; is omitted, it defaults to <i>HEAD</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev1&gt;...&lt;rev2&gt;</i></p>

<p style="margin-left:17%;">Include commits that are
reachable from either &lt;rev1&gt; or &lt;rev2&gt; but
exclude those that are reachable from both. When either
&lt;rev1&gt; or &lt;rev2&gt; is omitted, it defaults to
<i>HEAD</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^@</i>,
e.g. <i>HEAD^@</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> followed by
an at sign is the same as listing all parents of
<i>&lt;rev&gt;</i> (meaning, include anything reachable from
its parents, but not the commit itself).</p>


<p style="margin-left:11%; margin-top: 1em"><i>&lt;rev&gt;^!</i>,
e.g. <i>HEAD^!</i></p>

<p style="margin-left:17%;">A suffix <i>^</i> followed by
an exclamation mark is the same as giving commit
<i>&lt;rev&gt;</i> and then all its parents prefixed with
<i>^</i> to exclude them (and their ancestors).</p>

<p style="margin-left:11%; margin-top: 1em">Here are a
handful of examples:</p>

<p style="margin-left:17%; margin-top: 1em">D G H D <br>
D F G H I J D F <br>
^G D H D <br>
^D B E I J F B <br>
B..C C <br>
B...C G H D E B C <br>
^D B C E I J F B C <br>
C I J F C <br>
C^@ I J F <br>
C^! C <br>
F^! D G H D F</p>

<h2>PARSEOPT
<a name="PARSEOPT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In
&minus;&minus;parseopt mode, <i>git rev&minus;parse</i>
helps massaging options to bring to shell scripts the same
facilities C builtins have. It works as an option normalizer
(e.g. splits single switches aggregate values), a bit like
getopt(1) does.</p>

<p style="margin-left:11%; margin-top: 1em">It takes on the
standard input the specification of the options to parse and
understand, and echoes on the standard output a string
suitable for sh(1) eval to replace the arguments with
normalized ones. In case of error, it outputs usage on the
standard error stream, and exits with code 129.</p>

<p style="margin-left:11%; margin-top: 1em">Note: Make sure
you quote the result when passing it to eval. See below for
an example.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Input
Format</b> <i><br>
git rev&minus;parse &minus;&minus;parseopt</i> input format
is fully text based. It has two parts, separated by a line
that contains only &minus;&minus;. The lines before the
separator (should be more than one) are used for the usage.
The lines after the separator describe the options.</p>

<p style="margin-left:11%; margin-top: 1em">Each line of
options has this format:</p>


<p style="margin-left:17%; margin-top: 1em">&lt;opt_spec&gt;&lt;flags&gt;*
SP+ help LF</p>


<p style="margin-left:11%; margin-top: 1em">&lt;opt_spec&gt;</p>

<p style="margin-left:17%;">its format is the short option
character, then the long option name separated by a comma.
Both parts are not required, though at least one is
necessary. h,help, dry&minus;run and f are all three correct
&lt;opt_spec&gt;.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;flags&gt;</p>

<p style="margin-left:17%;">&lt;flags&gt; are of *, =, ? or
!.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Use = if
the option takes an argument.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Use ? to
mean that the option is optional (though its use is
discouraged).</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Use * to
mean that this option should not be listed in the usage
generated for the &minus;h argument. It&rsquo;s shown for
&minus;&minus;help&minus;all as documented in
<b>gitcli</b>(7).</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Use ! to
not make the corresponding negated long option
available.</p>

<p style="margin-left:11%; margin-top: 1em">The remainder
of the line, after stripping the spaces, is used as the help
associated to the option.</p>

<p style="margin-left:11%; margin-top: 1em">Blank lines are
ignored, and lines that don&rsquo;t match this specification
are used as option group headers (start the line with a
space to create such lines on purpose).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<p style="margin-left:17%;">OPTS_SPEC=&quot;\ <br>
some&minus;command [options] &lt;args&gt;...</p>


<p style="margin-left:17%; margin-top: 1em">some&minus;command
does foo and bar! <br>
&minus;&minus; <br>
h,help show the help</p>

<p style="margin-left:17%; margin-top: 1em">foo some nifty
option &minus;&minus;foo <br>
bar= some cool option &minus;&minus;bar with an argument</p>

<p style="margin-left:17%; margin-top: 1em">An option group
Header <br>
C? option C with an optional argument&quot;</p>

<p style="margin-left:17%; margin-top: 1em">eval
&quot;$(echo &quot;$OPTS_SPEC&quot; | git rev&minus;parse
&minus;&minus;parseopt &minus;&minus; &quot;$@&quot; || echo
exit $?)&quot;</p>

<h2>SQ-QUOTE
<a name="SQ-QUOTE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In
&minus;&minus;sq&minus;quote mode, <i>git
rev&minus;parse</i> echoes on the standard output a single
line suitable for sh(1) eval. This line is made by
normalizing the arguments following
&minus;&minus;sq&minus;quote. Nothing other than quoting the
arguments is done.</p>

<p style="margin-left:11%; margin-top: 1em">If you want
command input to still be interpreted as usual by <i>git
rev&minus;parse</i> before the output is shell quoted, see
the &minus;&minus;sq option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<p style="margin-left:17%;">$ cat
&gt;your&minus;git&minus;script.sh &lt;&lt;\EOF <br>
#!/bin/sh <br>
args=$(git rev&minus;parse &minus;&minus;sq&minus;quote
&quot;$@&quot;) # quote user&minus;supplied arguments <br>
command=&quot;git frotz &minus;n24 $args&quot; # and use it
inside a handcrafted <br>
# command line <br>
eval &quot;$command&quot; <br>
EOF</p>

<p style="margin-left:17%; margin-top: 1em">$ sh
your&minus;git&minus;script.sh &quot;a b'c&quot;</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:17%; margin-top: 1em">&bull; Print
the object name of the current commit:</p>

<p style="margin-left:23%; margin-top: 1em">$ git
rev&minus;parse &minus;&minus;verify HEAD</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Print
the commit object name from the revision in the $REV shell
variable:</p>

<p style="margin-left:23%; margin-top: 1em">$ git
rev&minus;parse &minus;&minus;verify $REV^{commit}</p>

<p style="margin-left:17%; margin-top: 1em">This will error
out if $REV is empty or not a valid revision.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Similar
to above:</p>

<p style="margin-left:23%; margin-top: 1em">$ git
rev&minus;parse &minus;&minus;default master
&minus;&minus;verify $REV</p>

<p style="margin-left:17%; margin-top: 1em">but if $REV is
empty, the commit object name from master will be
printed.</p>

<h2>GIT
<a name="GIT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Part of the
<b>git</b>(1) suite</p>
<hr>
</body>
</html>
