<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:17:28 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Math::Complex</title>

</head>
<body>

<h1 align="center">Math::Complex</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPERATIONS">OPERATIONS</a><br>
<a href="#CREATION">CREATION</a><br>
<a href="#DISPLAYING">DISPLAYING</a><br>
<a href="#USAGE">USAGE</a><br>
<a href="#CONSTANTS">CONSTANTS</a><br>
<a href="#ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO">ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO</a><br>
<a href="#ERRORS DUE TO INDIGESTIBLE ARGUMENTS">ERRORS DUE TO INDIGESTIBLE ARGUMENTS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#LICENSE">LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::Complex
&minus; complex numbers and associated mathematical
functions</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">        use Math::Complex;
        $z = Math::Complex&minus;&gt;make(5, 6);
        $t = 4 &minus; 3*i + $z;
        $j = cplxe(1, 2*pi/3);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package
lets you create and manipulate complex numbers. By default,
<i>Perl</i> limits itself to real numbers, but an extra
<tt>&quot;use&quot;</tt> statement brings full complex
support, along with a full set of mathematical functions
typically associated with and/or extended to complex
numbers.</p>

<p style="margin-left:11%; margin-top: 1em">If you wonder
what complex numbers are, they were invented to be able to
solve the following equation:</p>

<pre style="margin-left:11%; margin-top: 1em">        x*x = &minus;1</pre>


<p style="margin-left:11%; margin-top: 1em">and by
definition, the solution is noted <i>i</i> (engineers use
<i>j</i> instead since <i>i</i> usually denotes an
intensity, but the name does not matter). The number
<i>i</i> is a pure <i>imaginary</i> number.</p>

<p style="margin-left:11%; margin-top: 1em">The arithmetics
with pure imaginary numbers works just like you would expect
it with real numbers... you just have to remember that</p>

<pre style="margin-left:11%; margin-top: 1em">        i*i = &minus;1</pre>


<p style="margin-left:11%; margin-top: 1em">so you
have:</p>

<pre style="margin-left:11%; margin-top: 1em">        5i + 7i = i * (5 + 7) = 12i
        4i &minus; 3i = i * (4 &minus; 3) = i
        4i * 2i = &minus;8
        6i / 2i = 3
        1 / i = &minus;i</pre>


<p style="margin-left:11%; margin-top: 1em">Complex numbers
are numbers that have both a real part and an imaginary
part, and are usually noted:</p>

<pre style="margin-left:11%; margin-top: 1em">        a + bi</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;a&quot;</tt> is the <i>real</i> part and
<tt>&quot;b&quot;</tt> is the <i>imaginary</i> part. The
arithmetic with complex numbers is straightforward. You have
to keep track of the real and the imaginary parts, but
otherwise the rules used for real numbers just apply:</p>

<pre style="margin-left:11%; margin-top: 1em">        (4 + 3i) + (5 &minus; 2i) = (4 + 5) + i(3 &minus; 2) = 9 + i
        (2 + i) * (4 &minus; i) = 2*4 + 4i &minus;2i &minus;i*i = 8 + 2i + 1 = 9 + 2i</pre>


<p style="margin-left:11%; margin-top: 1em">A graphical
representation of complex numbers is possible in a plane
(also called the <i>complex plane</i>, but it&rsquo;s really
a 2D plane). The number</p>

<pre style="margin-left:11%; margin-top: 1em">        z = a + bi</pre>


<p style="margin-left:11%; margin-top: 1em">is the point
whose coordinates are (a, b). Actually, it would be the
vector originating from (0, 0) to (a, b). It follows that
the addition of two complex numbers is a vectorial
addition.</p>

<p style="margin-left:11%; margin-top: 1em">Since there is
a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a
complex number can also be uniquely identified with polar
coordinates:</p>

<pre style="margin-left:11%; margin-top: 1em">        [rho, theta]</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;rho&quot;</tt> is the distance to the origin, and
<tt>&quot;theta&quot;</tt> the angle between the vector and
the <i>x</i> axis. There is a notation for this using the
exponential form, which is:</p>

<pre style="margin-left:11%; margin-top: 1em">        rho * exp(i * theta)</pre>


<p style="margin-left:11%; margin-top: 1em">where <i>i</i>
is the famous imaginary number introduced above. Conversion
between this form and the cartesian form <tt>&quot;a +
bi&quot;</tt> is immediate:</p>

<pre style="margin-left:11%; margin-top: 1em">        a = rho * cos(theta)
        b = rho * sin(theta)</pre>


<p style="margin-left:11%; margin-top: 1em">which is also
expressed by this formula:</p>

<pre style="margin-left:11%; margin-top: 1em">        z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)</pre>


<p style="margin-left:11%; margin-top: 1em">In other words,
it&rsquo;s the projection of the vector onto the <i>x</i>
and <i>y</i> axes. Mathematicians call <i>rho</i> the
<i>norm</i> or <i>modulus</i> and <i>theta</i> the
<i>argument</i> of the complex number. The <i>norm</i> of
<tt>&quot;z&quot;</tt> is marked here as
<tt>abs(z)</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The polar
notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions
of complex numbers, whilst the cartesian notation is better
suited for additions and subtractions. Real numbers are on
the <i>x</i> axis, and therefore <i>y</i> or <i>theta</i> is
zero or <i>pi</i>.</p>

<p style="margin-left:11%; margin-top: 1em">All the common
operations that can be performed on a real number have been
defined to work on complex numbers as well, and are merely
<i>extensions</i> of the operations defined on real numbers.
This means they keep their natural meaning when there is no
imaginary part, provided the number is within their
definition set.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
the <tt>&quot;sqrt&quot;</tt> routine which computes the
square root of its argument is only defined for non-negative
real numbers and yields a non-negative real number (it is an
application from <b>R+</b> to <b>R+</b>). If we allow it to
return a complex number, then it can be extended to negative
real numbers to become an application from <b>R</b> to
<b>C</b> (the set of complex numbers):</p>

<pre style="margin-left:11%; margin-top: 1em">        sqrt(x) = x &gt;= 0 ? sqrt(x) : sqrt(&minus;x)*i</pre>


<p style="margin-left:11%; margin-top: 1em">It can also be
extended to be an application from <b>C</b> to <b>C</b>,
whilst its restriction to <b>R</b> behaves as defined above
by using the following definition:</p>

<pre style="margin-left:11%; margin-top: 1em">        sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)</pre>


<p style="margin-left:11%; margin-top: 1em">Indeed, a
negative real number can be noted
<tt>&quot;[x,pi]&quot;</tt> (the modulus <i>x</i> is always
non-negative, so <tt>&quot;[x,pi]&quot;</tt> is really
<tt>&quot;&minus;x&quot;</tt>, a negative number) and the
above definition states that</p>

<pre style="margin-left:11%; margin-top: 1em">        sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i</pre>


<p style="margin-left:11%; margin-top: 1em">which is
exactly what we had defined for negative real numbers above.
The <tt>&quot;sqrt&quot;</tt> returns only one of the
solutions: if you want the both, use the
<tt>&quot;root&quot;</tt> function.</p>

<p style="margin-left:11%; margin-top: 1em">All the common
mathematical functions defined on real numbers that are
extended to complex numbers share that same property of
working <i>as usual</i> when the imaginary part is zero
(otherwise, it would not be called an extension, would
it?).</p>

<p style="margin-left:11%; margin-top: 1em">A <i>new</i>
operation possible on a complex number that is the identity
for real numbers is called the <i>conjugate</i>, and is
noted with a horizontal bar above the number, or
<tt>&quot;~z&quot;</tt> here.</p>

<pre style="margin-left:11%; margin-top: 1em">         z = a + bi
        ~z = a &minus; bi</pre>


<p style="margin-left:11%; margin-top: 1em">Simple... Now
look:</p>

<pre style="margin-left:11%; margin-top: 1em">        z * ~z = (a + bi) * (a &minus; bi) = a*a + b*b</pre>


<p style="margin-left:11%; margin-top: 1em">We saw that the
norm of <tt>&quot;z&quot;</tt> was noted <tt>abs(z)</tt> and
was defined as the distance to the origin, also known
as:</p>

<pre style="margin-left:11%; margin-top: 1em">        rho = abs(z) = sqrt(a*a + b*b)</pre>


<p style="margin-left:11%; margin-top: 1em">so</p>

<pre style="margin-left:11%; margin-top: 1em">        z * ~z = abs(z) ** 2</pre>


<p style="margin-left:11%; margin-top: 1em">If z is a pure
real number (i.e. <tt>&quot;b == 0&quot;</tt>), then the
above yields:</p>

<pre style="margin-left:11%; margin-top: 1em">        a * a = abs(a) ** 2</pre>


<p style="margin-left:11%; margin-top: 1em">which is true
(<tt>&quot;abs&quot;</tt> has the regular meaning for real
number, i.e. stands for the absolute value). This example
explains why the norm of <tt>&quot;z&quot;</tt> is noted
<tt>abs(z)</tt>: it extends the <tt>&quot;abs&quot;</tt>
function to complex numbers, yet is the regular
<tt>&quot;abs&quot;</tt> we know when the complex number
actually has no imaginary part... This justifies <i>a
posteriori</i> our use of the <tt>&quot;abs&quot;</tt>
notation for the norm.</p>

<h2>OPERATIONS
<a name="OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Given the
following notations:</p>

<pre style="margin-left:11%; margin-top: 1em">        z1 = a + bi = r1 * exp(i * t1)
        z2 = c + di = r2 * exp(i * t2)
        z = &lt;any complex or real number&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">the following
(overloaded) operations are supported on complex
numbers:</p>

<pre style="margin-left:11%; margin-top: 1em">        z1 + z2 = (a + c) + i(b + d)
        z1 &minus; z2 = (a &minus; c) + i(b &minus; d)
        z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
        z1 / z2 = (r1 / r2) * exp(i * (t1 &minus; t2))
        z1 ** z2 = exp(z2 * log z1)
        ~z = a &minus; bi
        abs(z) = r1 = sqrt(a*a + b*b)
        sqrt(z) = sqrt(r1) * exp(i * t/2)
        exp(z) = exp(a) * exp(i * b)
        log(z) = log(r1) + i*t
        sin(z) = 1/2i (exp(i * z1) &minus; exp(&minus;i * z))
        cos(z) = 1/2 (exp(i * z1) + exp(&minus;i * z))
        atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.</pre>


<p style="margin-left:11%; margin-top: 1em">The definition
used for complex arguments of <i>atan2()</i> is</p>

<pre style="margin-left:11%; margin-top: 1em">       &minus;i log((x + iy)/sqrt(x*x+y*y))</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
atan2(0, 0) is not well-defined.</p>

<p style="margin-left:11%; margin-top: 1em">The following
extra operations are supported on both real and complex
numbers:</p>

<pre style="margin-left:11%; margin-top: 1em">        Re(z) = a
        Im(z) = b
        arg(z) = t
        abs(z) = r
        cbrt(z) = z ** (1/3)
        log10(z) = log(z) / log(10)
        logn(z, n) = log(z) / log(n)
        tan(z) = sin(z) / cos(z)
        csc(z) = 1 / sin(z)
        sec(z) = 1 / cos(z)
        cot(z) = 1 / tan(z)
        asin(z) = &minus;i * log(i*z + sqrt(1&minus;z*z))
        acos(z) = &minus;i * log(z + i*sqrt(1&minus;z*z))
        atan(z) = i/2 * log((i+z) / (i&minus;z))
        acsc(z) = asin(1 / z)
        asec(z) = acos(1 / z)
        acot(z) = atan(1 / z) = &minus;i/2 * log((i+z) / (z&minus;i))
        sinh(z) = 1/2 (exp(z) &minus; exp(&minus;z))
        cosh(z) = 1/2 (exp(z) + exp(&minus;z))
        tanh(z) = sinh(z) / cosh(z) = (exp(z) &minus; exp(&minus;z)) / (exp(z) + exp(&minus;z))
        csch(z) = 1 / sinh(z)
        sech(z) = 1 / cosh(z)
        coth(z) = 1 / tanh(z)
        asinh(z) = log(z + sqrt(z*z+1))
        acosh(z) = log(z + sqrt(z*z&minus;1))
        atanh(z) = 1/2 * log((1+z) / (1&minus;z))
        acsch(z) = asinh(1 / z)
        asech(z) = acosh(1 / z)
        acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z&minus;1))</pre>


<p style="margin-left:11%; margin-top: 1em"><i>arg</i>,
<i>abs</i>, <i>log</i>, <i>csc</i>, <i>cot</i>, <i>acsc</i>,
<i>acot</i>, <i>csch</i>, <i>coth</i>, <i>acosech</i>,
<i>acotanh</i>, have aliases <i>rho</i>, <i>theta</i>,
<i>ln</i>, <i>cosec</i>, <i>cotan</i>, <i>acosec</i>,
<i>acotan</i>, <i>cosech</i>, <i>cotanh</i>, <i>acosech</i>,
<i>acotanh</i>, respectively. <tt>&quot;Re&quot;</tt>,
<tt>&quot;Im&quot;</tt>, <tt>&quot;arg&quot;</tt>,
<tt>&quot;abs&quot;</tt>, <tt>&quot;rho&quot;</tt>, and
<tt>&quot;theta&quot;</tt> can be used also as mutators. The
<tt>&quot;cbrt&quot;</tt> returns only one of the solutions:
if you want all three, use the <tt>&quot;root&quot;</tt>
function.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>root</i>
function is available to compute all the <i>n</i> roots of
some complex, where <i>n</i> is a strictly positive integer.
There are exactly <i>n</i> such roots, returned as a list.
Getting the number mathematicians call
<tt>&quot;j&quot;</tt> such that:</p>

<pre style="margin-left:11%; margin-top: 1em">        1 + j + j*j = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">is a simple
matter of writing:</p>

<pre style="margin-left:11%; margin-top: 1em">        $j = ((root(1, 3))[1];</pre>


<p style="margin-left:11%; margin-top: 1em">The <i>k</i>th
root for <tt>&quot;z = [r,t]&quot;</tt> is given by:</p>

<pre style="margin-left:11%; margin-top: 1em">        (root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)</pre>


<p style="margin-left:11%; margin-top: 1em">You can return
the <i>k</i>th root directly by <tt>&quot;root(z, n,
k)&quot;</tt>, indexing starting from <i>zero</i> and ending
at <i>n &minus; 1</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>spaceship</i> numeric comparison operator, &lt;=&gt;, is
also defined. In order to ensure its restriction to real
numbers is conform to what you would expect, the comparison
is run on the real part of the complex number first, and
imaginary parts are compared only when the real parts
match.</p>

<h2>CREATION
<a name="CREATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To create a
complex number, use either:</p>

<pre style="margin-left:11%; margin-top: 1em">        $z = Math::Complex&minus;&gt;make(3, 4);
        $z = cplx(3, 4);</pre>


<p style="margin-left:11%; margin-top: 1em">if you know the
cartesian form of the number, or</p>

<pre style="margin-left:11%; margin-top: 1em">        $z = 3 + 4*i;</pre>


<p style="margin-left:11%; margin-top: 1em">if you like. To
create a number using the polar form, use either:</p>

<pre style="margin-left:11%; margin-top: 1em">        $z = Math::Complex&minus;&gt;emake(5, pi/3);
        $x = cplxe(5, pi/3);</pre>


<p style="margin-left:11%; margin-top: 1em">instead. The
first argument is the modulus, the second is the angle (in
radians, the full circle is 2*pi). (Mnemonic:
<tt>&quot;e&quot;</tt> is used as a notation for complex
numbers in the polar form).</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to write:</p>

<pre style="margin-left:11%; margin-top: 1em">        $x = cplxe(&minus;3, pi/4);</pre>


<p style="margin-left:11%; margin-top: 1em">but that will
be silently converted into
<tt>&quot;[3,&minus;3pi/4]&quot;</tt>, since the modulus
must be non-negative (it represents the distance to the
origin in the complex plane).</p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible to have a complex number as either argument of the
<tt>&quot;make&quot;</tt>, <tt>&quot;emake&quot;</tt>,
<tt>&quot;cplx&quot;</tt>, and <tt>&quot;cplxe&quot;</tt>:
the appropriate component of the argument will be used.</p>

<pre style="margin-left:11%; margin-top: 1em">        $z1 = cplx(&minus;2,  1);
        $z2 = cplx($z1, 4);</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;new&quot;</tt>, <tt>&quot;make&quot;</tt>,
<tt>&quot;emake&quot;</tt>, <tt>&quot;cplx&quot;</tt>, and
<tt>&quot;cplxe&quot;</tt> will also understand a single
(string) argument of the forms</p>

<pre style="margin-left:11%; margin-top: 1em">        2&minus;3i
        &minus;3i
        [2,3]
        [2,&minus;3pi/4]
        [2]</pre>


<p style="margin-left:11%; margin-top: 1em">in which case
the appropriate cartesian and exponential components will be
parsed from the string and used to create new complex
numbers. The imaginary component and the theta,
respectively, will default to zero.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;new&quot;</tt>, <tt>&quot;make&quot;</tt>,
<tt>&quot;emake&quot;</tt>, <tt>&quot;cplx&quot;</tt>, and
<tt>&quot;cplxe&quot;</tt> will also understand the case of
no arguments: this means plain zero or (0, 0).</p>

<h2>DISPLAYING
<a name="DISPLAYING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When printed, a
complex number is usually shown under its cartesian style
<i>a+bi</i>, but there are legitimate cases where the polar
style <i>[r,t]</i> is more appropriate. The process of
converting the complex number into a string that can be
displayed is known as <i>stringification</i>.</p>

<p style="margin-left:11%; margin-top: 1em">By calling the
class method
<tt>&quot;Math::Complex::display_format&quot;</tt> and
supplying either <tt>&quot;polar&quot;</tt> or
<tt>&quot;cartesian&quot;</tt> as an argument, you override
the default display style, which is
<tt>&quot;cartesian&quot;</tt>. Not supplying any argument
returns the current settings.</p>

<p style="margin-left:11%; margin-top: 1em">This default
can be overridden on a per-number basis by calling the
<tt>&quot;display_format&quot;</tt> method instead. As
before, not supplying any argument returns the current
display style for this number. Otherwise whatever you
specify will be the new display style for <i>this</i>
particular number.</p>

<p style="margin-left:11%; margin-top: 1em">For
instance:</p>

<pre style="margin-left:11%; margin-top: 1em">        use Math::Complex;
        Math::Complex::display_format('polar');
        $j = (root(1, 3))[1];
        print &quot;j = $j\n&quot;;               # Prints &quot;j = [1,2pi/3]&quot;
        $j&minus;&gt;display_format('cartesian');
        print &quot;j = $j\n&quot;;               # Prints &quot;j = &minus;0.5+0.866025403784439i&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The polar style
attempts to emphasize arguments like <i>k*pi/n</i> (where
<i>n</i> is a positive integer and <i>k</i> an integer
within [&minus;9, +9]), this is called <i>polar
pretty-printing</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For the reverse
of stringifying, see the <tt>&quot;make&quot;</tt> and
<tt>&quot;emake&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CHANGED
IN PERL</small> 5.6</b> <br>
The <tt>&quot;display_format&quot;</tt> class method and the
corresponding <tt>&quot;display_format&quot;</tt> object
method can now be called using a parameter hash instead of
just a one parameter.</p>

<p style="margin-left:11%; margin-top: 1em">The old display
format style, which can have values
<tt>&quot;cartesian&quot;</tt> or
<tt>&quot;polar&quot;</tt>, can be changed using the
<tt>&quot;style&quot;</tt> parameter.</p>

<pre style="margin-left:11%; margin-top: 1em">        $j&minus;&gt;display_format(style =&gt; &quot;polar&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">The one
parameter calling convention also still works.</p>

<pre style="margin-left:11%; margin-top: 1em">        $j&minus;&gt;display_format(&quot;polar&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">There are two
new display parameters.</p>

<p style="margin-left:11%; margin-top: 1em">The first one
is <tt>&quot;format&quot;</tt>, which is a
<i>sprintf()</i>&minus;style format string to be used for
both numeric parts of the complex number(s). The is somewhat
system-dependent but most often it corresponds to
<tt>&quot;%.15g&quot;</tt>. You can revert to the default by
setting the <tt>&quot;format&quot;</tt> to
<tt>&quot;undef&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">        # the $j from the above example
        $j&minus;&gt;display_format('format' =&gt; '%.5f');
        print &quot;j = $j\n&quot;;               # Prints &quot;j = &minus;0.50000+0.86603i&quot;
        $j&minus;&gt;display_format('format' =&gt; undef);
        print &quot;j = $j\n&quot;;               # Prints &quot;j = &minus;0.5+0.86603i&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">Notice that
this affects also the return values of the
<tt>&quot;display_format&quot;</tt> methods: in list context
the whole parameter hash will be returned, as opposed to
only the style parameter value. This is a potential
incompatibility with earlier versions if you have been
calling the <tt>&quot;display_format&quot;</tt> method in
list context.</p>

<p style="margin-left:11%; margin-top: 1em">The second new
display parameter is
<tt>&quot;polar_pretty_print&quot;</tt>, which can be set to
true or false, the default being true. See the previous
section for what this means.</p>

<h2>USAGE
<a name="USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thanks to
overloading, the handling of arithmetics with complex
numbers is simple and almost transparent.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples:</p>

<pre style="margin-left:11%; margin-top: 1em">        use Math::Complex;
        $j = cplxe(1, 2*pi/3);  # $j ** 3 == 1
        print &quot;j = $j, j**3 = &quot;, $j ** 3, &quot;\n&quot;;
        print &quot;1 + j + j**2 = &quot;, 1 + $j + $j**2, &quot;\n&quot;;
        $z = &minus;16 + 0*i;                 # Force it to be a complex
        print &quot;sqrt($z) = &quot;, sqrt($z), &quot;\n&quot;;
        $k = exp(i * 2*pi/3);
        print &quot;$j &minus; $k = &quot;, $j &minus; $k, &quot;\n&quot;;
        $z&minus;&gt;Re(3);                      # Re, Im, arg, abs,
        $j&minus;&gt;arg(2);                     # (the last two aka rho, theta)
                                        # can be used also as mutators.</pre>


<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>PI</small></b>
<br>
The constant <tt>&quot;pi&quot;</tt> and some handy
multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4))
are also available if separately exported:</p>

<pre style="margin-left:11%; margin-top: 1em">    use Math::Complex ':pi';
    $third_of_circle = pi2 / 3;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Inf</b> <br>
The floating point infinity can be exported as a subroutine
<i>Inf()</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print &quot;$AlsoInf is $AnotherInf\n&quot; if $AlsoInf == $AnotherInf;</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
stringified form of infinity varies between platforms: it
can be for example any of</p>

<pre style="margin-left:11%; margin-top: 1em">   inf
   infinity
   INF
   1.#INF</pre>


<p style="margin-left:11%; margin-top: 1em">or it can be
something else.</p>

<p style="margin-left:11%; margin-top: 1em">Also note that
in some platforms trying to use the infinity in arithmetic
operations may result in Perl crashing because using an
infinity causes <small>SIGFPE</small> or its moral
equivalent to be sent. The way to ignore this is</p>

<pre style="margin-left:11%; margin-top: 1em">  local $SIG{FPE} = sub { };</pre>


<h2>ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO

<a name="ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The division
(/) and the following functions</p>

<pre style="margin-left:11%; margin-top: 1em">        log     ln      log10   logn
        tan     sec     csc     cot
        atan    asec    acsc    acot
        tanh    sech    csch    coth
        atanh   asech   acsch   acoth</pre>


<p style="margin-left:11%; margin-top: 1em">cannot be
computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause
fatal runtime errors looking like this</p>

<pre style="margin-left:11%; margin-top: 1em">        cot(0): Division by zero.
        (Because in the definition of cot(0), the divisor sin(0) is 0)
        Died at ...</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:11%; margin-top: 1em">        atanh(&minus;1): Logarithm of zero.
        Died at...</pre>


<p style="margin-left:11%; margin-top: 1em">For the
<tt>&quot;csc&quot;</tt>, <tt>&quot;cot&quot;</tt>,
<tt>&quot;asec&quot;</tt>, <tt>&quot;acsc&quot;</tt>,
<tt>&quot;acot&quot;</tt>, <tt>&quot;csch&quot;</tt>,
<tt>&quot;coth&quot;</tt>, <tt>&quot;asech&quot;</tt>,
<tt>&quot;acsch&quot;</tt>, the argument cannot be
<tt>0</tt> (zero). For the logarithmic functions and the
<tt>&quot;atanh&quot;</tt>, <tt>&quot;acoth&quot;</tt>, the
argument cannot be <tt>1</tt> (one). For the
<tt>&quot;atanh&quot;</tt>, <tt>&quot;acoth&quot;</tt>, the
argument cannot be <tt>&quot;&minus;1&quot;</tt> (minus
one). For the <tt>&quot;atan&quot;</tt>,
<tt>&quot;acot&quot;</tt>, the argument cannot be
<tt>&quot;i&quot;</tt> (the imaginary unit). For the
<tt>&quot;atan&quot;</tt>, <tt>&quot;acoth&quot;</tt>, the
argument cannot be <tt>&quot;&minus;i&quot;</tt> (the
negative imaginary unit). For the <tt>&quot;tan&quot;</tt>,
<tt>&quot;sec&quot;</tt>, <tt>&quot;tanh&quot;</tt>, the
argument cannot be <i>pi/2 + k * pi</i>, where <i>k</i> is
any integer. atan2(0, 0) is undefined, and if the complex
arguments are used for <i>atan2()</i>, a division by zero
will happen if z1**2+z2**2 == 0.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
because we are operating on approximations of real numbers,
these errors can happen when merely &lsquo;too close&rsquo;
to the singularities listed above.</p>

<h2>ERRORS DUE TO INDIGESTIBLE ARGUMENTS
<a name="ERRORS DUE TO INDIGESTIBLE ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;make&quot;</tt> and <tt>&quot;emake&quot;</tt>
accept both real and complex arguments. When they cannot
recognize the arguments they will die with error messages
like the following</p>

<pre style="margin-left:11%; margin-top: 1em">    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...</pre>


<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Saying
<tt>&quot;use Math::Complex;&quot;</tt> exports many
mathematical routines in the caller environment and even
overrides some (<tt>&quot;sqrt&quot;</tt>,
<tt>&quot;log&quot;</tt>, <tt>&quot;atan2&quot;</tt>). This
is construed as a feature by the Authors, actually...
;&minus;)</p>

<p style="margin-left:11%; margin-top: 1em">All routines
expect to be given real or complex numbers. Don&rsquo;t
attempt to use BigFloat, since Perl has currently no rule to
disambiguate a &rsquo;+&rsquo; operation (for instance)
between two overloaded entities.</p>

<p style="margin-left:11%; margin-top: 1em">In Cray
<small>UNICOS</small> there is some strange numerical
instability that results in <i>root()</i>, <i>cos()</i>,
<i>sin()</i>, <i>cosh()</i>, <i>sinh()</i>, losing accuracy
fast. Beware. The bug may be in <small>UNICOS</small> math
libs, in <small>UNICOS</small> C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else
where Perl runs.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::Trig</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Daniel S.
Lewart &lt;<i>lewart!at!uiuc.edu</i>&gt;, Jarkko Hietaniemi
&lt;<i>jhi!at!iki.fi</i>&gt;, Raphael Manfredi
&lt;<i>Raphael_Manfredi!at!pobox.com</i>&gt;, Zefram
&lt;zefram@fysh.org&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
