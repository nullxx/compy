<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:03:32 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Filesystem</title>

</head>
<body>

<h1 align="center">Filesystem</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#THE VIRTUAL FILESYSTEM API">THE VIRTUAL FILESYSTEM API</a><br>
<a href="#FILESYSTEM INFRASTRUCTURE">FILESYSTEM INFRASTRUCTURE</a><br>
<a href="#FILESYSTEM OPERATIONS">FILESYSTEM OPERATIONS</a><br>
<a href="#FILESYSTEM EFFICIENCY">FILESYSTEM EFFICIENCY</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Tcl_FSRegister,
Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged,
Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType,
Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory,
Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile,
Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx,
Tcl_FSLoadFile, Tcl_FSMatchInDirectory, Tcl_FSLink,
Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet,
Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat,
Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd,
Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath,
Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath,
Tcl_FSJoinToPath, Tcl_FSConvertToPathType,
Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath,
Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath,
Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_AllocStatBuf
&minus; procedures to interact with any filesystem</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;tcl.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSRegister</b>(<i>clientData, fsPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSUnregister</b>(<i>fsPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_FSData</b>(<i>fsPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">void <b><br>
Tcl_FSMountsChanged</b>(<i>fsPtr</i>)</p>


<p style="margin-left:11%; margin-top: 1em">Tcl_Filesystem*
<b><br>
Tcl_FSGetFileSystemForPath</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_PathType
<b><br>
Tcl_FSGetPathType</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSCopyFile</b>(<i>srcPathPtr, destPathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSCopyDirectory</b>(<i>srcPathPtr, destPathPtr,
errorPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSCreateDirectory</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSDeleteFile</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSRemoveDirectory</b>(<i>pathPtr, int recursive,
errorPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSRenameFile</b>(<i>srcPathPtr, destPathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSListVolumes</b>(<i>void</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int
<big>&#9474;</big> <b><br>
Tcl_FSEvalFileEx</b>(<i>interp, pathPtr, encodingName</i>)
<big>&#9474;</big></p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSEvalFile</b>(<i>interp, pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSLoadFile</b>(<i>interp, pathPtr, sym1, sym2, proc1Ptr,
proc2Ptr, <br>
handlePtr, unloadProcPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSMatchInDirectory</b>(<i>interp, resultPtr, pathPtr,
pattern, types</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSLink</b>(<i>linkNamePtr, toPtr, linkAction</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSLstat</b>(<i>pathPtr, statPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSUtime</b>(<i>pathPtr, tval</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSFileAttrsGet</b>(<i>interp, int index, pathPtr,
objPtrRef</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSFileAttrsSet</b>(<i>interp, int index, pathPtr,
Tcl_Obj *objPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char**
<b><br>
Tcl_FSFileAttrStrings</b>(<i>pathPtr, objPtrRef</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSStat</b>(<i>pathPtr, statPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSAccess</b>(<i>pathPtr, mode</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Channel
<b><br>
Tcl_FSOpenFileChannel</b>(<i>interp, pathPtr, modeString,
permissions</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSGetCwd</b>(<i>interp</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSChdir</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSPathSeparator</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSJoinPath</b>(<i>listObj, elements</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSSplitPath</b>(<i>pathPtr, lenPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSEqualPaths</b>(<i>firstPtr, secondPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSGetNormalizedPath</b>(<i>interp, pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSJoinToPath</b>(<i>basePtr, objc, objv</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int <b><br>
Tcl_FSConvertToPathType</b>(<i>interp, pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">ClientData
<b><br>
Tcl_FSGetInternalRep</b>(<i>pathPtr, fsPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj *
<b><br>
Tcl_FSGetTranslatedPath</b>(<i>interp, pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_FSGetTranslatedStringPath</b>(<i>interp,
pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSNewNativePath</b>(<i>fsPtr, clientData</i>)</p>

<p style="margin-left:11%; margin-top: 1em">const char *
<b><br>
Tcl_FSGetNativePath</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_Obj*
<b><br>
Tcl_FSFileSystemInfo</b>(<i>pathPtr</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Tcl_StatBuf*
<b><br>
Tcl_AllocStatBuf</b>()</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p style="margin-top: 1em">Tcl_Filesystem <i>*fsPtr</i>
(in)</p> </td>
<td width="14%"></td>
<td width="11%">


<p style="margin-top: 1em">Points to a structure containing
the addresses of procedures that can be called to perform
the various filesystem operations.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*pathPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The path represented by this object is used for the
operation in question. If the object does not already have
an internal <b>path</b> representation, it will be converted
to have one.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*srcPathPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>As for <i>pathPtr</i>, but used for the source file for
a copy or rename operation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*destPathPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>As for <i>pathPtr</i>, but used for the destination
filename for a copy or rename operation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>const char <i>*encodingName</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The encoding of the data stored in the file identified
by <i>pathPtr</i> and to be evaluated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>const char <i>*pattern</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Only files or directories matching this pattern will be
returned.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_GlobTypeData <i>*types</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Only files or directories matching the type descriptions
contained in this structure will be returned. This parameter
may be NULL.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Interp <i>*interp</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Interpreter to use either for results, evaluation, or
reporting error messages.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>ClientData <i>clientData</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The native description of the path object to create.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*firstPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The first of two path objects to compare. The object may
be converted to <b>path</b> type.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*secondPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The second of two path objects to compare. The object
may be converted to <b>path</b> type.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*listObj</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The list of path elements to operate on with a
<b>join</b> operation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>elements</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>If non-negative, the number of elements in the
<i>listObj</i> which should be joined together. If negative,
then all elements are joined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>**errorPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>In the case of an error, filled with an object
containing the name of the file which caused an error in the
various copy/rename operations.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>**objPtrRef</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with an object containing the result of the
operation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*resultPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Pre-allocated object in which to store (using
<b>Tcl_ListObjAppendElement</b>) the list of files or
directories which are successfully matched.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>mode</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Mask consisting of one or more of R_OK, W_OK, X_OK and
F_OK. R_OK, W_OK and X_OK request checking whether the file
exists and has read, write and execute permissions,
respectively. F_OK just requests checking for the existence
of the file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_StatBuf <i>*statPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The structure that contains the result of a stat or
lstat operation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>const char <i>*sym1</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Name of a procedure to look up in the file&rsquo;s
symbol table</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>const char <i>*sym2</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Name of a procedure to look up in the file&rsquo;s
symbol table</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_PackageInitProc <i>**proc1Ptr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with the init function for this code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_PackageInitProc <i>**proc2Ptr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with the safe-init function for this code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>ClientData <i>*clientDataPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with the clientData value to pass to this
code&rsquo;s unload function when it is called.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_LoadHandle <i>*handlePtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with an abstract token representing the loaded
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_FSUnloadFileProc <i>**unloadProcPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Filled with the function to use to unload this piece of
code.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>utimbuf <i>*tval</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The access and modification times in this structure are
read and used to set those values for a given file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>const char <i>*modeString</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>Specifies how the file is to be accessed. May have any
of the values allowed for the <i>mode</i> argument to the
Tcl <b>open</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>permissions</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>POSIX-style permission flags such as 0644. If a new file
is created, these permissions will be set on the created
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>*lenPtr</i> (out)</p></td>
<td width="14%"></td>
<td width="11%">


<p>If non-NULL, filled with the number of elements in the
split path.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*basePtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The base path on to which to join the given elements.
May be NULL.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>objc</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The number of elements in <i>objv</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj *const <i>objv[]</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The elements to join to the given base path.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*linkNamePtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>The name of the link to be created or read.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>Tcl_Obj <i>*toPtr</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>What the link called <i>linkNamePtr</i> should be linked
to, or NULL if the symbolic link specified by
<i>linkNamePtr</i> is to be read.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p>int <i>linkAction</i> (in)</p></td>
<td width="14%"></td>
<td width="11%">


<p>OR-ed combination of flags indicating what kind of link
should be created (will be ignored if <i>toPtr</i> is NULL).
Valid bits to set are <b>TCL_CREATE_SYMBOLIC_LINK</b> and
<b>TCL_CREATE_HARD_LINK</b>. When both flags are set and the
underlying filesystem can do either, symbolic links are
preferred.</p> </td></tr>
</table>


<p style="margin-left:89%;">_________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
several reasons for calling the <b>Tcl_FS</b> API functions
(e.g. <b>Tcl_FSAccess</b> and <b>Tcl_FSStat</b>) rather than
calling system level functions like <b>access</b> and
<b>stat</b> directly. First, they will work cross-platform,
so an extension which calls them should work unmodified on
Unix and Windows. Second, the Windows implementation of some
of these functions fixes some bugs in the system level
calls. Third, these function calls deal with any &ldquo;Utf
to platform-native&rdquo; path conversions which may be
required (and may cache the results of such conversions for
greater efficiency on subsequent calls). Fourth, and perhaps
most importantly, all of these functions are &ldquo;virtual
filesystem aware&rdquo;. Any virtual filesystem (VFS for
short) which has been registered (through
<b>Tcl_FSRegister</b>) may reroute file access to
alternative media or access methods. This means that all of
these functions (and therefore the corresponding
<b>file</b>, <b>glob</b>, <b>pwd</b>, <b>cd</b>,
<b>open</b>, etc. Tcl commands) may be operate on
&ldquo;files&rdquo; which are not native files in the native
filesystem. This also means that any Tcl extension which
accesses the filesystem (FS for short) through this API is
automatically &ldquo;virtual filesystem aware&rdquo;. Of
course, if an extension accesses the native filesystem
directly (through platform-specific APIs, for example), then
Tcl cannot intercept such calls.</p>

<p style="margin-left:11%; margin-top: 1em">If appropriate
VFSes have been registered, the &ldquo;files&rdquo; may, to
give two examples, be remote (e.g. situated on a remote ftp
server) or archived (e.g. lying inside a .zip archive). Such
registered filesystems provide a lookup table of functions
to implement all or some of the functionality listed here.
Finally, the <b>Tcl_FSStat</b> and <b>Tcl_FSLstat</b> calls
abstract away from what the &ldquo;struct stat&rdquo; buffer
is actually declared to be, allowing the same code to be
used both on systems with and systems without support for
files larger than 2GB in size.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_FS</b> API is objectified and may cache internal
representations and other path-related strings (e.g. the
current working directory). One side-effect of this is that
one must not pass in objects with a reference count of zero
to any of these functions. If such calls were handled, they
might result in memory leaks (under some circumstances, the
filesystem code may wish to retain a reference to the passed
in object, and so one must not assume that after any of
these calls return, the object still has a reference count
of zero - it may have been incremented) or in a direct
segmentation fault (or other memory access error) due to the
object being freed part way through the complex object
manipulation required to ensure that the path is fully
normalized and absolute for filesystem determination. The
practical lesson to learn from this is that</p>

<p style="margin-left:22%;">Tcl_Obj *path =
Tcl_NewStringObj(...); <br>
Tcl_FS<i>Whatever</i>(path); <br>
Tcl_DecrRefCount(path);</p>

<p style="margin-left:11%;">is wrong, and may cause memory
errors. The <i>path</i> must have its reference count
incremented before passing it in, or decrementing it. For
this reason, objects with a reference count of zero are
considered not to be valid filesystem paths and calling any
Tcl_FS API function with such an object will result in no
action being taken.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FS API
FUNCTIONS <br>
Tcl_FSCopyFile</b> attempts to copy the file given by
<i>srcPathPtr</i> to the path name given by
<i>destPathPtr</i>. If the two paths given lie in the same
filesystem (according to <b>Tcl_FSGetFileSystemForPath</b>)
then that filesystem&rsquo;s &ldquo;copy file&rdquo;
function is called (if it is non-NULL). Otherwise the
function returns -1 and sets the <b>errno</b> global C
variable to the &ldquo;EXDEV&rdquo; POSIX error code (which
signifies a &ldquo;cross-domain link&rdquo;).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSCopyDirectory</b>
attempts to copy the directory given by <i>srcPathPtr</i> to
the path name given by <i>destPathPtr</i>. If the two paths
given lie in the same filesystem (according to
<b>Tcl_FSGetFileSystemForPath</b>) then that
filesystem&rsquo;s &ldquo;copy file&rdquo; function is
called (if it is non-NULL). Otherwise the function returns
-1 and sets the <b>errno</b> global C variable to the
&ldquo;EXDEV&rdquo; POSIX error code (which signifies a
&ldquo;cross-domain link&rdquo;).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSCreateDirectory</b>
attempts to create the directory given by <i>pathPtr</i> by
calling the owning filesystem&rsquo;s &ldquo;create
directory&rdquo; function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSDeleteFile</b>
attempts to delete the file given by <i>pathPtr</i> by
calling the owning filesystem&rsquo;s &ldquo;delete
file&rdquo; function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSRemoveDirectory</b>
attempts to remove the directory given by <i>pathPtr</i> by
calling the owning filesystem&rsquo;s &ldquo;remove
directory&rdquo; function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSRenameFile</b>
attempts to rename the file or directory given by
<i>srcPathPtr</i> to the path name given by
<i>destPathPtr</i>. If the two paths given lie in the same
filesystem (according to <b>Tcl_FSGetFileSystemForPath</b>)
then that filesystem&rsquo;s &ldquo;rename file&rdquo;
function is called (if it is non-NULL). Otherwise the
function returns -1 and sets the <b>errno</b> global C
variable to the &ldquo;EXDEV&rdquo; POSIX error code (which
signifies a &ldquo;cross-domain link&rdquo;).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSListVolumes</b>
calls each filesystem which has a non-NULL &ldquo;list
volumes&rdquo; function and asks them to return their list
of root volumes. It accumulates the return values in a list
which is returned to the caller (with a reference count of
0).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSEvalFileEx</b>
reads the file given by <i>pathPtr</i> using the encoding
<big>&#9474;</big> identified by <i>encodingName</i> and
evaluates its contents as a Tcl script. <big>&#9474;</big>
It returns the same information as <b>Tcl_EvalObjEx</b>. If
<i>encodingName</i> is <big>&#9474;</big> NULL, the system
encoding is used for reading the file contents. If
<big>&#9474;</big> the file could not be read then a Tcl
error is returned to describe why <big>&#9474;</big> the
file could not be read. The eofchar for files is
&ldquo;\32&rdquo; (^Z) for <big>&#9474;</big> all platforms.
If you require a &ldquo;^Z&rdquo; in code for string
comparison, <big>&#9474;</big> you can use
&ldquo;\032&rdquo; or &ldquo;\u001a&rdquo;, which will be
safely substituted by the <big>&#9474;</big> Tcl interpreter
into &ldquo;^Z&rdquo;. <b>Tcl_FSEvalFile</b> is a simpler
version of <big>&#9474;</big> <b>Tcl_FSEvalFileEx</b> that
always uses the system encoding when reading the
<big>&#9474;</big> file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSLoadFile</b>
dynamically loads a binary code file into memory and returns
the addresses of two procedures within that file, if they
are defined. The appropriate function for the filesystem to
which <i>pathPtr</i> belongs will be called. If that
filesystem does not implement this function (most virtual
filesystems will not, because of OS limitations in
dynamically loading binary code), Tcl will attempt to copy
the file to a temporary directory and load that temporary
file.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
standard Tcl completion code. If an error occurs, an error
message is left in the <i>interp</i>&rsquo;s result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSMatchInDirectory</b>
is used by the globbing code to search a directory for all
files which match a given pattern. The appropriate function
for the filesystem to which <i>pathPtr</i> belongs will be
called.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in globbing. Error messages are placed in interp
(unless interp is NULL, which is allowed), but good results
are placed in the resultPtr given.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
<b>glob</b> code implements recursive patterns internally,
so this function will only ever be passed simple patterns,
which can be matched using the logic of <b>string match</b>.
To handle recursion, Tcl will call this function frequently
asking only for directories to be returned. A special case
of being called with a NULL pattern indicates that the path
needs to be checked only for the correct type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSLink</b>
replaces the library version of <b>readlink</b>, and extends
it to support the creation of links. The appropriate
function for the filesystem to which <i>linkNamePtr</i>
belongs will be called.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>toPtr</i> is NULL, a &ldquo;read link&rdquo; action is
performed. The result is a Tcl_Obj specifying the contents
of the symbolic link given by <i>linkNamePtr</i>, or NULL if
the link could not be read. The result is owned by the
caller, which should call Tcl_DecrRefCount when the result
is no longer needed. If the <i>toPtr</i> is not NULL, Tcl
should create a link of one of the types passed in in the
<i>linkAction</i> flag. This flag is an ORed combination of
<b>TCL_CREATE_SYMBOLIC_LINK</b> and
<b>TCL_CREATE_HARD_LINK</b>. Where a choice exists (i.e.
more than one flag is passed in), the Tcl convention is to
prefer symbolic links. When a link is successfully created,
the return value should be <i>toPtr</i> (which is therefore
already owned by the caller). If unsuccessful, NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSLstat</b>
fills the stat structure <i>statPtr</i> with information
about the specified file. You do not need any access rights
to the file to get this information but you need search
rights to all directories named in the path leading to the
file. The stat structure includes info regarding device,
inode (always 0 on Windows), privilege mode, nlink (always 1
on Windows), user id (always 0 on Windows), group id (always
0 on Windows), rdev (same as device on Windows), size, last
access time, last modification time, and last metadata
change time.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>path</i>
exists, <b>Tcl_FSLstat</b> returns 0 and the stat structure
is filled with data. Otherwise, -1 is returned, and no stat
info is given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSUtime</b>
replaces the library version of utime.</p>

<p style="margin-left:11%; margin-top: 1em">This returns 0
on success and -1 on error (as per the <b>utime</b>
documentation). If successful, the function will update the
&ldquo;atime&rdquo; and &ldquo;mtime&rdquo; values of the
file given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSFileAttrsGet</b>
implements read access for the hookable <b>file
attributes</b> subcommand. The appropriate function for the
filesystem to which <i>pathPtr</i> belongs will be
called.</p>

<p style="margin-left:11%; margin-top: 1em">If the result
is <b>TCL_OK</b>, then an object was placed in
<i>objPtrRef</i>, which will only be temporarily valid
(unless <b>Tcl_IncrRefCount</b> is called).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSFileAttrsSet</b>
implements write access for the hookable <b>file
attributes</b> subcommand. The appropriate function for the
filesystem to which <i>pathPtr</i> belongs will be
called.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSFileAttrStrings</b>
implements part of the hookable <b>file attributes</b>
subcommand. The appropriate function for the filesystem to
which <i>pathPtr</i> belongs will be called.</p>

<p style="margin-left:11%; margin-top: 1em">The called
procedure may either return an array of strings, or may
instead return NULL and place a Tcl list into the given
<i>objPtrRef</i>. Tcl will take that list and first
increment its reference count before using it. On completion
of that use, Tcl will decrement its reference count. Hence
if the list should be disposed of by Tcl when done, it
should have a reference count of zero, and if the list
should not be disposed of, the filesystem should ensure it
retains a reference count to the object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSAccess</b>
checks whether the process would be allowed to read, write
or test for existence of the file (or other filesystem
object) whose name is <i>pathname</i>. If <i>pathname</i> is
a symbolic link on Unix, then permissions of the file
referred by this symbolic link are tested.</p>

<p style="margin-left:11%; margin-top: 1em">On success (all
requested permissions granted), zero is returned. On error
(at least one bit in mode asked for a permission that is
denied, or some other error occurred), -1 is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSStat</b>
fills the stat structure <i>statPtr</i> with information
about the specified file. You do not need any access rights
to the file to get this information but you need search
rights to all directories named in the path leading to the
file. The stat structure includes info regarding device,
inode (always 0 on Windows), privilege mode, nlink (always 1
on Windows), user id (always 0 on Windows), group id (always
0 on Windows), rdev (same as device on Windows), size, last
access time, last modification time, and last metadata
change time.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>path</i>
exists, <b>Tcl_FSStat</b> returns 0 and the stat structure
is filled with data. Otherwise, -1 is returned, and no stat
info is given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSOpenFileChannel</b>
opens a file specified by <i>pathPtr</i> and returns a
channel handle that can be used to perform input and output
on the file. This API is modeled after the <b>fopen</b>
procedure of the Unix standard I/O library. The syntax and
meaning of all arguments is similar to those given in the
Tcl <b>open</b> command when opening a file. If an error
occurs while opening the channel,
<b>Tcl_FSOpenFileChannel</b> returns NULL and records a
POSIX error code that can be retrieved with
<b>Tcl_GetErrno</b>. In addition, if <i>interp</i> is
non-NULL, <b>Tcl_FSOpenFileChannel</b> leaves an error
message in <i>interp</i>&rsquo;s result after any error.</p>

<p style="margin-left:11%; margin-top: 1em">The newly
created channel is not registered in the supplied
interpreter; to register it, use <b>Tcl_RegisterChannel</b>.
If one of the standard channels, <b>stdin, stdout</b> or
<b>stderr</b> was previously closed, the act of creating the
new channel also assigns it as a replacement for the
standard channel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetCwd</b>
replaces the library version of <b>getcwd</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It returns the
Tcl library&rsquo;s current working directory. This may be
different to the native platform&rsquo;s working directory,
which happens when the current working directory is not in
the native filesystem.</p>

<p style="margin-left:11%; margin-top: 1em">The result is a
pointer to a Tcl_Obj specifying the current directory, or
NULL if the current directory could not be determined. If
NULL is returned, an error message is left in the
<i>interp</i>&rsquo;s result.</p>

<p style="margin-left:11%; margin-top: 1em">The result
already has its reference count incremented for the caller.
When it is no longer needed, that reference count should be
decremented. This is needed for thread-safety purposes, to
allow multiple threads to access this and related functions,
while ensuring the results are always valid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSChdir</b>
replaces the library version of <b>chdir</b>. The path is
normalized and then passed to the filesystem which claims
it. If that filesystem does not implement this function, Tcl
will fallback to a combination of <b>stat</b> and
<b>access</b> to check whether the directory exists and has
appropriate permissions.</p>

<p style="margin-left:11%; margin-top: 1em">For results,
see <b>chdir</b> documentation. If successful, we keep a
record of the successful path in <i>cwdPathPtr</i> for
subsequent calls to <b>Tcl_FSGetCwd</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSPathSeparator</b>
returns the separator character to be used for most specific
element of the path specified by <i>pathPtr</i> (i.e. the
last part of the path).</p>

<p style="margin-left:11%; margin-top: 1em">The separator
is returned as a Tcl_Obj containing a string of length 1. If
the path is invalid, NULL is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSJoinPath</b>
takes the given Tcl_Obj, which must be a valid list (which
is allowed to have a reference count of zero), and returns
the path object given by considering the first
<i>elements</i> elements as valid path segments (each path
segment may be a complete path, a partial path or just a
single possible directory or file name). If any path segment
is actually an absolute path, then all prior path segments
are discarded. If <i>elements</i> is less than 0, we use the
entire list.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
that the returned object is actually an element of the given
list, so the caller should be careful to increment the
reference count of the result before freeing the list.</p>

<p style="margin-left:11%; margin-top: 1em">The returned
object, typically with a reference count of zero (but it
could be shared under some conditions), contains the joined
path. The caller must add a reference count to the object
before using it. In particular, the returned object could be
an element of the given list, so freeing the list might free
the object prematurely if no reference count has been taken.
If the number of elements is zero, then the returned object
will be an empty-string Tcl_Obj.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSSplitPath</b>
takes the given Tcl_Obj, which should be a valid path, and
returns a Tcl list object containing each segment of that
path as an element. It returns a list object with a
reference count of zero. If the passed in <i>lenPtr</i> is
non-NULL, the variable it points to will be updated to
contain the number of elements in the returned list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSEqualPaths</b>
tests whether the two paths given represent the same
filesystem object</p>

<p style="margin-left:11%; margin-top: 1em">It returns 1 if
the paths are equal, and 0 if they are different. If either
path is NULL, 0 is always returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetNormalizedPath</b>
this important function attempts to extract from the given
Tcl_Obj a unique normalized path representation, whose
string value can be used as a unique identifier for the
file.</p>

<p style="margin-left:11%; margin-top: 1em">It returns the
normalized path object, owned by Tcl, or NULL if the path
was invalid or could otherwise not be successfully
converted. Extraction of absolute, normalized paths is very
efficient (because the filesystem operates on these
representations internally), although the result when the
filesystem contains numerous symbolic links may not be the
most user-friendly version of a path. The return value is
owned by Tcl and has a lifetime equivalent to that of the
<i>pathPtr</i> passed in (unless that is a relative path, in
which case the normalized path object may be freed any time
the cwd changes) - the caller can of course increment the
refCount if it wishes to maintain a copy for longer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSJoinToPath</b>
takes the given object, which should usually be a valid path
or NULL, and joins onto it the array of paths segments
given.</p>

<p style="margin-left:11%; margin-top: 1em">Returns object,
typically with refCount of zero (but it could be shared
under some conditions), containing the joined path. The
caller must add a refCount to the object before using it. If
any of the objects passed into this function (pathPtr or
path elements) have a refCount of zero, they will be freed
when this function returns.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSConvertToPathType</b>
tries to convert the given Tcl_Obj to a valid Tcl path type,
taking account of the fact that the cwd may have changed
even if this object is already supposedly of the correct
type. The filename may begin with &ldquo;~&rdquo; (to
indicate current user&rsquo;s home directory) or
&ldquo;~&lt;user&gt;&rdquo; (to indicate any user&rsquo;s
home directory).</p>

<p style="margin-left:11%; margin-top: 1em">If the
conversion succeeds (i.e. the object is a valid path in one
of the current filesystems), then <b>TCL_OK</b> is returned.
Otherwise <b>TCL_ERROR</b> is returned, and an error message
may be left in the interpreter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetInternalRep</b>
extracts the internal representation of a given path object,
in the given filesystem. If the path object belongs to a
different filesystem, we return NULL. If the internal
representation is currently NULL, we attempt to generate it,
by calling the filesystem&rsquo;s
<b>Tcl_FSCreateInternalRepProc</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Returns NULL or
a valid internal path representation. This internal
representation is cached, so that repeated calls to this
function will not require additional conversions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetTranslatedPath</b>
attempts to extract the translated path from the given
Tcl_Obj.</p>

<p style="margin-left:11%; margin-top: 1em">If the
translation succeeds (i.e. the object is a valid path), then
it is returned. Otherwise NULL will be returned, and an
error message may be left in the interpreter. A
&ldquo;translated&rdquo; path is one which contains no
&ldquo;~&rdquo; or &ldquo;~user&rdquo; sequences (these have
been expanded to their current representation in the
filesystem). The object returned is owned by the caller,
which must store it or call Tcl_DecrRefCount to ensure
memory is freed. This function is of little practical use,
and <b>Tcl_FSGetNormalizedPath</b> or
<b>Tcl_GetNativePath</b> are usually better functions to use
for most purposes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetTranslatedStringPath</b>
does the same as <b>Tcl_FSGetTranslatedPath</b>, but returns
a character string or NULL. The string returned is
dynamically allocated and owned by the caller, which must
store it or call <b>ckfree</b> to ensure it is freed. Again,
<b>Tcl_FSGetNormalizedPath</b> or <b>Tcl_GetNativePath</b>
are usually better functions to use for most purposes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSNewNativePath</b>
performs something like the reverse of the usual
obj-&gt;path-&gt;nativerep conversions. If some code
retrieves a path in native form (from, e.g. <b>readlink</b>
or a native dialog), and that path is to be used at the Tcl
level, then calling this function is an efficient way of
creating the appropriate path object type.</p>

<p style="margin-left:11%; margin-top: 1em">The resulting
object is a pure &ldquo;path&rdquo; object, which will only
receive a UTF-8 string representation if that is required by
some Tcl code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetNativePath</b>
is for use by the Win/Unix native filesystems, so that they
can easily retrieve the native (char* or TCHAR*)
representation of a path. This function is a convenience
wrapper around <b>Tcl_FSGetInternalRep</b>, and assumes the
native representation is string-based. It may be desirable
in the future to have non-string-based native
representations (for example, on MacOSX, a representation
using a fileSpec of FSRef structure would probably be more
efficient). On Windows a full Unicode representation would
allow for paths of unlimited length. Currently the
representation is simply a character string which may
contain either the relative path or a complete, absolute
normalized path in the native encoding (complex conditions
dictate which of these will be provided, so neither can be
relied upon, unless the path is known to be absolute). If
you need a native path which must be absolute, then you
should ask for the native version of a normalized path. If
for some reason a non-absolute, non-normalized version of
the path is needed, that must be constructed separately
(e.g. using <b>Tcl_FSGetTranslatedPath</b>).</p>

<p style="margin-left:11%; margin-top: 1em">The native
representation is cached so that repeated calls to this
function will not require additional conversions. The return
value is owned by Tcl and has a lifetime equivalent to that
of the <i>pathPtr</i> passed in (unless that is a relative
path, in which case the native representation may be freed
any time the cwd changes).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSFileSystemInfo</b>
returns a list of two elements. The first element is the
name of the filesystem (e.g. &ldquo;native&rdquo;,
&ldquo;vfs&rdquo;, &ldquo;zip&rdquo;, or
&ldquo;prowrap&rdquo;, perhaps), and the second is the
particular type of the given path within that filesystem
(which is filesystem dependent). The second element may be
empty if the filesystem does not provide a further
categorization of files.</p>

<p style="margin-left:11%; margin-top: 1em">A valid list
object is returned, unless the path object is not
recognized, when NULL will be returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetFileSystemForPath</b>
returns the a pointer to the <b>Tcl_Filesystem</b> which
accepts this path as valid.</p>

<p style="margin-left:11%; margin-top: 1em">If no
filesystem will accept the path, NULL is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSGetPathType</b>
determines whether the given path is relative to the current
directory, relative to the current volume, or absolute.</p>

<p style="margin-left:11%; margin-top: 1em">It returns one
of <b>TCL_PATH_ABSOLUTE</b>, <b>TCL_PATH_RELATIVE</b>, or
<b>TCL_PATH_VOLUME_RELATIVE</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_AllocStatBuf</b>
allocates a <i>Tcl_StatBuf</i> on the system heap (which may
be deallocated by being passed to <b>ckfree</b>.) This
allows extensions to invoke <b>Tcl_FSStat</b> and
<b>Tcl_FSLStat</b> without being dependent on the size of
the buffer. That in turn depends on the flags used to build
Tcl.</p>

<h2>THE VIRTUAL FILESYSTEM API
<a name="THE VIRTUAL FILESYSTEM API"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A filesystem
provides a <b>Tcl_Filesystem</b> structure that contains
pointers to functions that implement the various operations
on a filesystem; these operations are invoked as needed by
the generic layer, which generally occurs through the
functions listed above.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_Filesystem</b> structures are manipulated using the
following methods.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSRegister</b>
takes a pointer to a filesystem structure and an optional
piece of data to associated with that filesystem. On calling
this function, Tcl will attach the filesystem to the list of
known filesystems, and it will become fully functional
immediately. Tcl does not check if the same filesystem is
registered multiple times (and in general that is not a good
thing to do). <b>TCL_OK</b> will be returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSUnregister</b>
removes the given filesystem structure from the list of
known filesystems, if it is known, and returns
<b>TCL_OK</b>. If the filesystem is not currently
registered, <b>TCL_ERROR</b> is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSData</b>
will return the ClientData associated with the given
filesystem, if that filesystem is registered. Otherwise it
will return NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl_FSMountsChanged</b>
is used to inform the Tcl&rsquo;s core that the set of mount
points for the given (already registered) filesystem have
changed, and that cached file representations may therefore
no longer be correct.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE
TCL_FILESYSTEM STRUCTURE</b> <br>
The <b>Tcl_Filesystem</b> structure contains the following
fields:</p>

<p style="margin-left:22%;">typedef struct Tcl_Filesystem {
<br>
const char *<i>typeName</i>; <br>
int <i>structureLength</i>; <br>
Tcl_FSVersion <i>version</i>; <br>
Tcl_FSPathInFilesystemProc *<i>pathInFilesystemProc</i>;
<br>
Tcl_FSDupInternalRepProc *<i>dupInternalRepProc</i>; <br>
Tcl_FSFreeInternalRepProc *<i>freeInternalRepProc</i>; <br>
Tcl_FSInternalToNormalizedProc
*<i>internalToNormalizedProc</i>; <br>
Tcl_FSCreateInternalRepProc *<i>createInternalRepProc</i>;
<br>
Tcl_FSNormalizePathProc *<i>normalizePathProc</i>; <br>
Tcl_FSFilesystemPathTypeProc *<i>filesystemPathTypeProc</i>;
<br>
Tcl_FSFilesystemSeparatorProc
*<i>filesystemSeparatorProc</i>; <br>
Tcl_FSStatProc *<i>statProc</i>; <br>
Tcl_FSAccessProc *<i>accessProc</i>; <br>
Tcl_FSOpenFileChannelProc *<i>openFileChannelProc</i>; <br>
Tcl_FSMatchInDirectoryProc *<i>matchInDirectoryProc</i>;
<br>
Tcl_FSUtimeProc *<i>utimeProc</i>; <br>
Tcl_FSLinkProc *<i>linkProc</i>; <br>
Tcl_FSListVolumesProc *<i>listVolumesProc</i>; <br>
Tcl_FSFileAttrStringsProc *<i>fileAttrStringsProc</i>; <br>
Tcl_FSFileAttrsGetProc *<i>fileAttrsGetProc</i>; <br>
Tcl_FSFileAttrsSetProc *<i>fileAttrsSetProc</i>; <br>
Tcl_FSCreateDirectoryProc *<i>createDirectoryProc</i>; <br>
Tcl_FSRemoveDirectoryProc *<i>removeDirectoryProc</i>; <br>
Tcl_FSDeleteFileProc *<i>deleteFileProc</i>; <br>
Tcl_FSCopyFileProc *<i>copyFileProc</i>; <br>
Tcl_FSRenameFileProc *<i>renameFileProc</i>; <br>
Tcl_FSCopyDirectoryProc *<i>copyDirectoryProc</i>; <br>
Tcl_FSLstatProc *<i>lstatProc</i>; <br>
Tcl_FSLoadFileProc *<i>loadFileProc</i>; <br>
Tcl_FSGetCwdProc *<i>getCwdProc</i>; <br>
Tcl_FSChdirProc *<i>chdirProc</i>; <br>
} Tcl_Filesystem;</p>

<p style="margin-left:11%; margin-top: 1em">Except for the
first three fields in this structure which contain simple
data elements, all entries contain addresses of functions
called by the generic filesystem layer to perform the
complete range of filesystem related actions.</p>

<p style="margin-left:11%; margin-top: 1em">The many
functions in this structure are broken down into three
categories: infrastructure functions (almost all of which
must be implemented), operational functions (which must be
implemented if a complete filesystem is provided), and
efficiency functions (which need only be implemented if they
can be done so efficiently, or if they have side-effects
which are required by the filesystem; Tcl has less efficient
emulations it can fall back on). It is important to note
that, in the current version of Tcl, most of these fallbacks
are only used to handle commands initiated in Tcl, not in C.
What this means is, that if a <b>file rename</b> command is
issued in Tcl, and the relevant filesystem(s) do not
implement their <i>Tcl_FSRenameFileProc</i>, Tcl&rsquo;s
core will instead fallback on a combination of other
filesystem functions (it will use <i>Tcl_FSCopyFileProc</i>
followed by <i>Tcl_FSDeleteFileProc</i>, and if
<i>Tcl_FSCopyFileProc</i> is not implemented there is a
further fallback). However, if a <i>Tcl_FSRenameFileProc</i>
command is issued at the C level, no such fallbacks occur.
This is true except for the last four entries in the
filesystem table (<b>lstat</b>, <b>load</b>, <b>getcwd</b>
and <b>chdir</b>) for which fallbacks do in fact occur at
the C level.</p>

<p style="margin-left:11%; margin-top: 1em">Any functions
which take path names in Tcl_Obj form take those names in
UTF&minus;8 form. The filesystem infrastructure API is
designed to support efficient, cached conversion of these
UTF&minus;8 paths to other native representations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>EXAMPLE
FILESYSTEM DEFINITION</b> <br>
Here is the filesystem lookup table used by the
&ldquo;vfs&rdquo; extension which allows filesystem actions
to be implemented in Tcl.</p>

<p style="margin-left:22%;">static Tcl_Filesystem
vfsFilesystem = { <br>
&quot;tclvfs&quot;, <br>
sizeof(Tcl_Filesystem), <br>
TCL_FILESYSTEM_VERSION_1, <br>
&amp;VfsPathInFilesystem, <br>
&amp;VfsDupInternalRep, <br>
&amp;VfsFreeInternalRep, <br>
/* No internal to normalized, since we don&rsquo;t create
<br>
* any pure &rsquo;internal&rsquo; Tcl_Obj path
representations */ <br>
NULL, <br>
/* No create native rep function, since we don&rsquo;t use
<br>
* it and don&rsquo;t choose to support uses of <br>
* Tcl_FSNewNativePath */ <br>
NULL, <br>
/* Normalize path isn&rsquo;t needed - we assume paths only
<br>
* have one representation */ <br>
NULL, <br>
&amp;VfsFilesystemPathType, <br>
&amp;VfsFilesystemSeparator, <br>
&amp;VfsStat, <br>
&amp;VfsAccess, <br>
&amp;VfsOpenFileChannel, <br>
&amp;VfsMatchInDirectory, <br>
&amp;VfsUtime, <br>
/* We choose not to support symbolic links inside our <br>
* VFS&rsquo;s */ <br>
NULL, <br>
&amp;VfsListVolumes, <br>
&amp;VfsFileAttrStrings, <br>
&amp;VfsFileAttrsGet, <br>
&amp;VfsFileAttrsSet, <br>
&amp;VfsCreateDirectory, <br>
&amp;VfsRemoveDirectory, <br>
&amp;VfsDeleteFile, <br>
/* No copy file; use the core fallback mechanism */ <br>
NULL, <br>
/* No rename file; use the core fallback mechanism */ <br>
NULL, <br>
/* No copy directory; use the core fallback mechanism */
<br>
NULL, <br>
/* Core will use stat for lstat */ <br>
NULL, <br>
/* No load; use the core fallback mechanism */ <br>
NULL, <br>
/* We don&rsquo;t need a getcwd or chdir; the core&rsquo;s
own <br>
* internal value is suitable */ <br>
NULL, <br>
NULL <br>
};</p>

<h2>FILESYSTEM INFRASTRUCTURE
<a name="FILESYSTEM INFRASTRUCTURE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These fields
contain basic information about the filesystem structure and
addresses of functions which are used to associate a
particular filesystem with a file path, and deal with the
internal handling of path representations, for example
copying and freeing such representations.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TYPENAME</b>
<br>
The <i>typeName</i> field contains a null-terminated string
that identifies the type of the filesystem implemented, e.g.
&ldquo;native&rdquo;, &ldquo;zip&rdquo; or
&ldquo;vfs&rdquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>STRUCTURE
LENGTH</b> <br>
The <i>structureLength</i> field is generally implemented as
<i>sizeof(Tcl_Filesystem)</i>, and is there to allow easier
binary backwards compatibility if the size of the structure
changes in a future Tcl release.</p>

<p style="margin-left:11%; margin-top: 1em"><b>VERSION</b>
<br>
The <i>version</i> field should be set to
<b>TCL_FILESYSTEM_VERSION_1</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PATHINFILESYSTEMPROC</b>
<br>
The <i>pathInFilesystemProc</i> field contains the address
of a function which is called to determine whether a given
path object belongs to this filesystem or not. Tcl will only
call the rest of the filesystem functions with a path for
which this function has returned <b>TCL_OK</b>. If the path
does not belong, -1 should be returned (the behaviour of Tcl
for any other return value is not defined). If <b>TCL_OK</b>
is returned, then the optional <i>clientDataPtr</i> output
parameter can be used to return an internal (filesystem
specific) representation of the path, which will be cached
inside the path object, and may be retrieved efficiently by
the other filesystem functions. Tcl will simultaneously
cache the fact that this path belongs to this filesystem.
Such caches are invalidated when filesystem structures are
added or removed from Tcl&rsquo;s internal list of known
filesystems.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSPathInFilesystemProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
ClientData *<i>clientDataPtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>DUPINTERNALREPPROC</b>
<br>
This function makes a copy of a path&rsquo;s internal
representation, and is called when Tcl needs to duplicate a
path object. If NULL, Tcl will simply not copy the internal
representation, which may then need to be regenerated
later.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
ClientData Tcl_FSDupInternalRepProc( <br>
ClientData <i>clientData</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>FREEINTERNALREPPROC</b>
<br>
Free the internal representation. This must be implemented
if internal representations need freeing (i.e. if some
memory is allocated when an internal representation is
generated), but may otherwise be NULL.</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_FSFreeInternalRepProc( <br>
ClientData <i>clientData</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>INTERNALTONORMALIZEDPROC</b>
<br>
Function to convert internal representation to a normalized
path. Only required if the filesystem creates pure path
objects with no string/path representation. The return value
is a Tcl object whose string representation is the
normalized path.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSInternalToNormalizedProc( <br>
ClientData <i>clientData</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>CREATEINTERNALREPPROC</b>
<br>
Function to take a path object, and calculate an internal
representation for it, and store that native representation
in the object. May be NULL if paths have no internal
representation, or if the <i>Tcl_FSPathInFilesystemProc</i>
for this filesystem always immediately creates an internal
representation for paths it accepts.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
ClientData Tcl_FSCreateInternalRepProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>NORMALIZEPATHPROC</b>
<br>
Function to normalize a path. Should be implemented for all
filesystems which can have multiple string representations
for the same path object. In Tcl, every &ldquo;path&rdquo;
must have a single unique &ldquo;normalized&rdquo; string
representation. Depending on the filesystem, there may be
more than one unnormalized string representation which
refers to that path (e.g. a relative path, a path with
different character case if the filesystem is case
insensitive, a path contain a reference to a home directory
such as &ldquo;~&rdquo;, a path containing symbolic links,
etc). If the very last component in the path is a symbolic
link, it should not be converted into the object it points
to (but its case or other aspects should be made unique).
All other path components should be converted from symbolic
links. This one exception is required to agree with
Tcl&rsquo;s semantics with <b>file delete</b>, <b>file
rename</b>, <b>file copy</b> operating on symbolic links.
This function may be called with <i>nextCheckpoint</i>
either at the beginning of the path (i.e. zero), at the end
of the path, or at any intermediate file separator in the
path. It will never point to any other arbitrary position in
the path. In the last of the three valid cases, the
implementation can assume that the path up to and including
the file separator is known and normalized.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSNormalizePathProc( <br>
Tcl_Interp *<i>interp</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
int <i>nextCheckpoint</i>);</p>

<h2>FILESYSTEM OPERATIONS
<a name="FILESYSTEM OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fields in
this section of the structure contain addresses of functions
which are called to carry out the basic filesystem
operations. A filesystem which expects to be used with the
complete standard Tcl command set must implement all of
these. If some of them are not implemented, then certain Tcl
commands may fail when operating on paths within that
filesystem. However, in some instances this may be desirable
(for example, a read-only filesystem should not implement
the last four functions, and a filesystem which does not
support symbolic links need not implement the
<b>readlink</b> function, etc. The Tcl core expects
filesystems to behave in this way).</p>


<p style="margin-left:11%; margin-top: 1em"><b>FILESYSTEMPATHTYPEPROC</b>
<br>
Function to determine the type of a path in this filesystem.
May be NULL, in which case no type information will be
available to users of the filesystem. The &ldquo;type&rdquo;
is used only for informational purposes, and should be
returned as the string representation of the Tcl_Obj which
is returned. A typical return value might be
&ldquo;networked&rdquo;, &ldquo;zip&rdquo; or
&ldquo;ftp&rdquo;. The Tcl_Obj result is owned by the
filesystem and so Tcl will increment the refCount of that
object if it wishes to retain a reference to it.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSFilesystemPathTypeProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>FILESYSTEMSEPARATORPROC</b>
<br>
Function to return the separator character(s) for this
filesystem. This need only be implemented if the filesystem
wishes to use a different separator than the standard string
&ldquo;/&rdquo;. Amongst other uses, it is returned by the
<b>file separator</b> command. The return value should be an
object with refCount of zero.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSFilesystemSeparatorProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>STATPROC</b>
<br>
Function to process a <b>Tcl_FSStat</b> call. Must be
implemented for any reasonable filesystem, since many Tcl
level commands depend crucially upon it (e.g. <b>file
atime</b>, <b>file isdirectory</b>, <b>file size</b>,
<b>glob</b>).</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSStatProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_StatBuf *<i>statPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_FSStatProc</b> fills the stat structure
<i>statPtr</i> with information about the specified file.
You do not need any access rights to the file to get this
information but you need search rights to all directories
named in the path leading to the file. The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always
0 on Windows), group id (always 0 on Windows), rdev (same as
device on Windows), size, last access time, last
modification time, and last metadata change time.</p>

<p style="margin-left:11%; margin-top: 1em">If the file
represented by <i>pathPtr</i> exists, the
<b>Tcl_FSStatProc</b> returns 0 and the stat structure is
filled with data. Otherwise, -1 is returned, and no stat
info is given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ACCESSPROC</b>
<br>
Function to process a <b>Tcl_FSAccess</b> call. Must be
implemented for any reasonable filesystem, since many Tcl
level commands depend crucially upon it (e.g. <b>file
exists</b>, <b>file readable</b>).</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSAccessProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
int <i>mode</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_FSAccessProc</b> checks whether the process would be
allowed to read, write or test for existence of the file (or
other filesystem object) whose name is in <i>pathPtr</i>. If
the pathname refers to a symbolic link, then the permissions
of the file referred by this symbolic link should be
tested.</p>

<p style="margin-left:11%; margin-top: 1em">On success (all
requested permissions granted), zero is returned. On error
(at least one bit in mode asked for a permission that is
denied, or some other error occurred), -1 is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OPENFILECHANNELPROC</b>
<br>
Function to process a <b>Tcl_FSOpenFileChannel</b> call.
Must be implemented for any reasonable filesystem, since any
operations which require open or accessing a file&rsquo;s
contents will use it (e.g. <b>open</b>, <b>encoding</b>, and
many Tk commands).</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Channel Tcl_FSOpenFileChannelProc( <br>
Tcl_Interp *<i>interp</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
int <i>mode</i>, <br>
int <i>permissions</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_FSOpenFileChannelProc</b> opens a file specified by
<i>pathPtr</i> and returns a channel handle that can be used
to perform input and output on the file. This API is modeled
after the <b>fopen</b> procedure of the Unix standard I/O
library. The syntax and meaning of all arguments is similar
to those given in the Tcl <b>open</b> command when opening a
file, where the <i>mode</i> argument is a combination of the
POSIX flags O_RDONLY, O_WRONLY, etc. If an error occurs
while opening the channel, the
<b>Tcl_FSOpenFileChannelProc</b> returns NULL and records a
POSIX error code that can be retrieved with
<b>Tcl_GetErrno</b>. In addition, if <i>interp</i> is
non-NULL, the <b>Tcl_FSOpenFileChannelProc</b> leaves an
error message in <i>interp</i>&rsquo;s result after any
error.</p>

<p style="margin-left:11%; margin-top: 1em">The newly
created channel must not registered in the supplied
interpreter; that task is up to the caller of
<b>Tcl_FSOpenFileChannel</b> (if necessary). If one of the
standard channels, <b>stdin, stdout</b> or <b>stderr</b> was
previously closed, the act of creating the new channel also
assigns it as a replacement for the standard channel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MATCHINDIRECTORYPROC</b>
<br>
Function to process a <b>Tcl_FSMatchInDirectory</b> call. If
not implemented, then glob and recursive copy functionality
will be lacking in the filesystem (and this may impact
commands like <b>encoding names</b> which use glob
functionality internally).</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSMatchInDirectoryProc( <br>
Tcl_Interp* <i>interp</i>, <br>
Tcl_Obj *<i>resultPtr</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
const char *<i>pattern</i>, <br>
Tcl_GlobTypeData *<i>types</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The function
should return all files or directories (or other filesystem
objects) which match the given pattern and accord with the
<i>types</i> specification given. There are two ways in
which this function may be called. If <i>pattern</i> is
NULL, then <i>pathPtr</i> is a full path specification of a
single file or directory which should be checked for
existence and correct type. Otherwise, <i>pathPtr</i> is a
directory, the contents of which the function should search
for files or directories which have the correct type. In
either case, <i>pathPtr</i> can be assumed to be both
non-NULL and non-empty. It is not currently documented
whether <i>pathPtr</i> will have a file separator at its end
of not, so code should be flexible to both
possibilities.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the matching process. Error messages are placed
in <i>interp</i>, unless <i>interp</i> in NULL in which case
no error message need be generated; on a <b>TCL_OK</b>
result, results should be added to the <i>resultPtr</i>
object given (which can be assumed to be a valid unshared
Tcl list). The matches added to <i>resultPtr</i> should
include any path prefix given in <i>pathPtr</i> (this
usually means they will be absolute path specifications).
Note that if no matches are found, that simply leads to an
empty result; errors are only signaled for actual file or
filesystem problems which may occur during the matching
process.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_GlobTypeData</b> structure passed in the <i>types</i>
parameter contains the following fields:</p>

<p style="margin-left:22%;">typedef struct Tcl_GlobTypeData
{ <br>
/* Corresponds to bcdpfls as in &rsquo;find -t&rsquo; */
<br>
int <i>type</i>; <br>
/* Corresponds to file permissions */ <br>
int <i>perm</i>; <br>
/* Acceptable mac type */ <br>
Tcl_Obj *<i>macType</i>; <br>
/* Acceptable mac creator */ <br>
Tcl_Obj *<i>macCreator</i>; <br>
} Tcl_GlobTypeData;</p>

<p style="margin-left:11%; margin-top: 1em">There are two
specific cases which it is important to handle correctly,
both when <i>types</i> is non-NULL. The two cases are when
<i>types-&gt;types &amp; TCL_GLOB_TYPE_DIR</i> or
<i>types-&gt;types &amp; TCL_GLOB_TYPE_MOUNT</i> are true
(and in particular when the other flags are false). In the
first of these cases, the function must list the contained
directories. Tcl uses this to implement recursive globbing,
so it is critical that filesystems implement directory
matching correctly. In the second of these cases, with
<b>TCL_GLOB_TYPE_MOUNT</b>, the filesystem must list the
mount points which lie within the given <i>pathPtr</i> (and
in this case, <i>pathPtr</i> need not lie within the same
filesystem - different to all other cases in which this
function is called). Support for this is critical if Tcl is
to have seamless transitions between from one filesystem to
another.</p>


<p style="margin-left:11%; margin-top: 1em"><b>UTIMEPROC</b>
<br>
Function to process a <b>Tcl_FSUtime</b> call. Required to
allow setting (not reading) of times with <b>file mtime</b>,
<b>file atime</b> and the open-r/open-w/fcopy implementation
of <b>file copy</b>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSUtimeProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
struct utimbuf *<i>tval</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The access and
modification times of the file specified by <i>pathPtr</i>
should be changed to the values given in the <i>tval</i>
structure.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value should be 0 on success and -1 on an error, as with the
system <b>utime</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>LINKPROC</b>
<br>
Function to process a <b>Tcl_FSLink</b> call. Should be
implemented only if the filesystem supports links, and may
otherwise be NULL.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSLinkProc( <br>
Tcl_Obj *<i>linkNamePtr</i>, <br>
Tcl_Obj *<i>toPtr</i>, <br>
int <i>linkAction</i>);</p>

<p style="margin-left:11%; margin-top: 1em">If <i>toPtr</i>
is NULL, the function is being asked to read the contents of
a link. The result is a Tcl_Obj specifying the contents of
the link given by <i>linkNamePtr</i>, or NULL if the link
could not be read. The result is owned by the caller (and
should therefore have its ref count incremented before being
returned). Any callers should call Tcl_DecrRefCount on this
result when it is no longer needed. If <i>toPtr</i> is not
NULL, the function should attempt to create a link. The
result in this case should be <i>toPtr</i> if the link was
successful and NULL otherwise. In this case the result is
not owned by the caller (i.e. no ref count manipulation on
either end is needed). See the documentation for
<b>Tcl_FSLink</b> for the correct interpretation of the
<i>linkAction</i> flags.</p>


<p style="margin-left:11%; margin-top: 1em"><b>LISTVOLUMESPROC</b>
<br>
Function to list any filesystem volumes added by this
filesystem. Should be implemented only if the filesystem
adds volumes at the head of the filesystem, so that they can
be returned by <b>file volumes</b>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSListVolumesProc(void);</p>

<p style="margin-left:11%; margin-top: 1em">The result
should be a list of volumes added by this filesystem, or
NULL (or an empty list) if no volumes are provided. The
result object is considered to be owned by the filesystem
(not by Tcl&rsquo;s core), but should be given a refCount
for Tcl. Tcl will use the contents of the list and then
decrement that refCount. This allows filesystems to choose
whether they actually want to retain a &ldquo;master
list&rdquo; of volumes or not (if not, they generate the
list on the fly and pass it to Tcl with a refCount of 1 and
then forget about the list, if yes, then they simply
increment the refCount of their master list and pass it to
Tcl which will copy the contents and then decrement the
count back to where it was).</p>

<p style="margin-left:11%; margin-top: 1em">Therefore, Tcl
considers return values from this proc to be read-only.</p>


<p style="margin-left:11%; margin-top: 1em"><b>FILEATTRSTRINGSPROC</b>
<br>
Function to list all attribute strings which are valid for
this filesystem. If not implemented the filesystem will not
support the <b>file attributes</b> command. This allows
arbitrary additional information to be attached to files in
the filesystem. If it is not implemented, there is no need
to implement the <b>get</b> and <b>set</b> methods.</p>

<p style="margin-left:22%; margin-top: 1em">typedef const
char** Tcl_FSFileAttrStringsProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_Obj** <i>objPtrRef</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The called
function may either return an array of strings, or may
instead return NULL and place a Tcl list into the given
<i>objPtrRef</i>. Tcl will take that list and first
increment its reference count before using it. On completion
of that use, Tcl will decrement its reference count. Hence
if the list should be disposed of by Tcl when done, it
should have a reference count of zero, and if the list
should not be disposed of, the filesystem should ensure it
returns an object with a reference count of at least
one.</p>


<p style="margin-left:11%; margin-top: 1em"><b>FILEATTRSGETPROC</b>
<br>
Function to process a <b>Tcl_FSFileAttrsGet</b> call, used
by <b>file attributes</b>.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSFileAttrsGetProc( <br>
Tcl_Interp *<i>interp</i>, <br>
int <i>index</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_Obj **<i>objPtrRef</i>);</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
standard Tcl return code. The attribute value retrieved,
which corresponds to the <i>index</i>&rsquo;th element in
the list returned by the <b>Tcl_FSFileAttrStringsProc</b>,
is a Tcl_Obj placed in <i>objPtrRef</i> (if <b>TCL_OK</b>
was returned) and is likely to have a reference count of
zero. Either way we must either store it somewhere (e.g. the
Tcl result), or Incr/Decr its reference count to ensure it
is properly freed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>FILEATTRSSETPROC</b>
<br>
Function to process a <b>Tcl_FSFileAttrsSet</b> call, used
by <b>file attributes</b>. If the filesystem is read-only,
there is no need to implement this.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSFileAttrsSetProc( <br>
Tcl_Interp *<i>interp</i>, <br>
int <i>index</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_Obj *<i>objPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The attribute
value of the <i>index</i>&rsquo;th element in the list
returned by the Tcl_FSFileAttrStringsProc should be set to
the <i>objPtr</i> given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CREATEDIRECTORYPROC</b>
<br>
Function to process a <b>Tcl_FSCreateDirectory</b> call.
Should be implemented unless the FS is read-only.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSCreateDirectoryProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the process. If successful, a new directory
should have been added to the filesystem in the location
specified by <i>pathPtr</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>REMOVEDIRECTORYPROC</b>
<br>
Function to process a <b>Tcl_FSRemoveDirectory</b> call.
Should be implemented unless the FS is read-only.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSRemoveDirectoryProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
int <i>recursive</i>, <br>
Tcl_Obj **<i>errorPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the process. If successful, the directory
specified by <i>pathPtr</i> should have been removed from
the filesystem. If the <i>recursive</i> flag is given, then
a non-empty directory should be deleted without error. If
this flag is not given, then and the directory is non-empty
a POSIX &ldquo;EEXIST&rdquo; error should be signaled. If an
error does occur, the name of the file or directory which
caused the error should be placed in <i>errorPtr</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DELETEFILEPROC</b>
<br>
Function to process a <b>Tcl_FSDeleteFile</b> call. Should
be implemented unless the FS is read-only.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSDeleteFileProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the process. If successful, the file specified
by <i>pathPtr</i> should have been removed from the
filesystem. Note that, if the filesystem supports symbolic
links, Tcl will always call this function and not
Tcl_FSRemoveDirectoryProc when needed to delete them (even
if they are symbolic links to directories).</p>

<h2>FILESYSTEM EFFICIENCY
<a name="FILESYSTEM EFFICIENCY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
need not be implemented for a particular filesystem because
the core has a fallback implementation available. See each
individual description for the consequences of leaving the
field NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>LSTATPROC</b>
<br>
Function to process a <b>Tcl_FSLstat</b> call. If not
implemented, Tcl will attempt to use the <i>statProc</i>
defined above instead. Therefore it need only be implemented
if a filesystem can differentiate between <b>stat</b> and
<b>lstat</b> calls.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSLstatProc( <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_StatBuf *<i>statPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The behavior of
this function is very similar to that of the
<b>Tcl_FSStatProc</b> defined above, except that if it is
applied to a symbolic link, it returns information about the
link, not about the target file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>COPYFILEPROC</b>
<br>
Function to process a <b>Tcl_FSCopyFile</b> call. If not
implemented Tcl will fall back on <b>open</b>-r,
<b>open</b>-w and <b>fcopy</b> as a copying mechanism.
Therefore it need only be implemented if the filesystem can
perform that action more efficiently.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSCopyFileProc( <br>
Tcl_Obj *<i>srcPathPtr</i>, <br>
Tcl_Obj *<i>destPathPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the copying process. Note that,
<i>destPathPtr</i> is the name of the file which should
become the copy of <i>srcPathPtr</i>. It is never the name
of a directory into which <i>srcPathPtr</i> could be copied
(i.e. the function is much simpler than the Tcl level
<b>file copy</b> subcommand). Note that, if the filesystem
supports symbolic links, Tcl will always call this function
and not <i>copyDirectoryProc</i> when needed to copy them
(even if they are symbolic links to directories). Finally,
if the filesystem determines it cannot support the <b>file
copy</b> action, calling <b>Tcl_SetErrno(EXDEV)</b> and
returning a non-<b>TCL_OK</b> result will tell Tcl to use
its standard fallback mechanisms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>RENAMEFILEPROC</b>
<br>
Function to process a <b>Tcl_FSRenameFile</b> call. If not
implemented, Tcl will fall back on a copy and delete
mechanism. Therefore it need only be implemented if the
filesystem can perform that action more efficiently.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSRenameFileProc( <br>
Tcl_Obj *<i>srcPathPtr</i>, <br>
Tcl_Obj *<i>destPathPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the renaming process. If the filesystem
determines it cannot support the <b>file rename</b> action,
calling <b>Tcl_SetErrno(EXDEV)</b> and returning a
non-<b>TCL_OK</b> result will tell Tcl to use its standard
fallback mechanisms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>COPYDIRECTORYPROC</b>
<br>
Function to process a <b>Tcl_FSCopyDirectory</b> call. If
not implemented, Tcl will fall back on a recursive <b>file
mkdir</b>, <b>file copy</b> mechanism. Therefore it need
only be implemented if the filesystem can perform that
action more efficiently.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSCopyDirectoryProc( <br>
Tcl_Obj *<i>srcPathPtr</i>, <br>
Tcl_Obj *<i>destPathPtr</i>, <br>
Tcl_Obj **<i>errorPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a standard Tcl result indicating whether an error
occurred in the copying process. If an error does occur, the
name of the file or directory which caused the error should
be placed in <i>errorPtr</i>. Note that, <i>destPathPtr</i>
is the name of the directory-name which should become the
mirror-image of <i>srcPathPtr</i>. It is not the name of a
directory into which <i>srcPathPtr</i> should be copied
(i.e. the function is much simpler than the Tcl level
<b>file copy</b> subcommand). Finally, if the filesystem
determines it cannot support the directory copy action,
calling <b>Tcl_SetErrno(EXDEV)</b> and returning a
non-<b>TCL_OK</b> result will tell Tcl to use its standard
fallback mechanisms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>LOADFILEPROC</b>
<br>
Function to process a <b>Tcl_FSLoadFile</b> call. If not
implemented, Tcl will fall back on a copy to native-temp
followed by a <b>Tcl_FSLoadFile</b> on that temporary copy.
Therefore it need only be implemented if the filesystem can
load code directly, or it can be implemented simply to
return <b>TCL_ERROR</b> to disable load functionality in
this filesystem entirely.</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSLoadFileProc( <br>
Tcl_Interp *<i>interp</i>, <br>
Tcl_Obj *<i>pathPtr</i>, <br>
Tcl_LoadHandle *<i>handlePtr</i>, <br>
Tcl_FSUnloadFileProc *<i>unloadProcPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
standard Tcl completion code. If an error occurs, an error
message is left in the <i>interp</i>&rsquo;s result. The
function dynamically loads a binary code file into memory.
On a successful load, the <i>handlePtr</i> should be filled
with a token for the dynamically loaded file, and the
<i>unloadProcPtr</i> should be filled in with the address of
a procedure. The unload procedure will be called with the
given <b>Tcl_LoadHandle</b> as its only parameter when Tcl
needs to unload the file. For example, for the native
filesystem, the <b>Tcl_LoadHandle</b> returned is currently
a token which can be used in the private
<b>TclpFindSymbol</b> to access functions in the new code.
Each filesystem is free to define the <b>Tcl_LoadHandle</b>
as it requires. Finally, if the filesystem determines it
cannot support the file load action, calling
<b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b>
result will tell Tcl to use its standard fallback
mechanisms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>UNLOADFILEPROC</b>
<br>
Function to unload a previously successfully loaded file. If
load was implemented, then this should also be implemented,
if there is any cleanup action required.</p>

<p style="margin-left:22%; margin-top: 1em">typedef void
Tcl_FSUnloadFileProc( <br>
Tcl_LoadHandle <i>loadHandle</i>);</p>


<p style="margin-left:11%; margin-top: 1em"><b>GETCWDPROC</b>
<br>
Function to process a <b>Tcl_FSGetCwd</b> call. Most
filesystems need not implement this. It will usually only be
called once, if <b>getcwd</b> is called before <b>chdir</b>.
May be NULL.</p>

<p style="margin-left:22%; margin-top: 1em">typedef
Tcl_Obj* Tcl_FSGetCwdProc( <br>
Tcl_Interp *<i>interp</i>);</p>

<p style="margin-left:11%; margin-top: 1em">If the
filesystem supports a native notion of a current working
directory (which might perhaps change independent of Tcl),
this function should return that cwd as the result, or NULL
if the current directory could not be determined (e.g. the
user does not have appropriate permissions on the cwd
directory). If NULL is returned, an error message is left in
the <i>interp</i>&rsquo;s result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CHDIRPROC</b>
<br>
Function to process a <b>Tcl_FSChdir</b> call. If
filesystems do not implement this, it will be emulated by a
series of directory access checks. Otherwise, virtual
filesystems which do implement it need only respond with a
positive return result if the <i>pathPtr</i> is a valid,
accessible directory in their filesystem. They need not
remember the result, since that will be automatically
remembered for use by <b>Tcl_FSGetCwd</b>. Real filesystems
should carry out the correct action (i.e. call the correct
system <b>chdir</b> API).</p>

<p style="margin-left:22%; margin-top: 1em">typedef int
Tcl_FSChdirProc( <br>
Tcl_Obj *<i>pathPtr</i>);</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Tcl_FSChdirProc</b> changes the applications current
working directory to the value specified in <i>pathPtr</i>.
The function returns -1 on error or 0 on success.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">cd(n), file(n),
load(n), open(n), pwd(n), unload(n)</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stat, access,
filesystem, vfs, virtual</p>
<hr>
</body>
</html>
