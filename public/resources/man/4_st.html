<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Aug 18 15:22:52 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ST</title>

</head>
<body>

<h1 align="center">ST</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#FILES">FILES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">st &minus; SCSI
tape device</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/mtio.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ioctl(int</b> <i>fd</i><b>, int</b> <i>request</i> <b>[,
(void *)</b><i>arg3</i><b>]); <br>
int ioctl(int</b> <i>fd</i><b>, MTIOCTOP, (struct mtop
*)</b><i>mt_cmd</i><b>); <br>
int ioctl(int</b> <i>fd</i><b>, MTIOCGET, (struct mtget
*)</b><i>mt_status</i><b>); <br>
int ioctl(int</b> <i>fd</i><b>, MTIOCPOS, (struct mtpos
*)</b><i>mt_pos</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <b>st</b>
driver provides the interface to a variety of SCSI tape
devices. Currently, the driver takes control of all detected
devices of type &ldquo;sequential-access&rdquo;. The
<b>st</b> driver uses major device number 9.</p>

<p style="margin-left:11%; margin-top: 1em">Each device
uses eight minor device numbers. The lowermost five bits in
the minor numbers are assigned sequentially in the order of
detection. In the 2.6 kernel, the bits above the eight
lowermost bits are concatenated to the five lowermost bits
to form the tape number. The minor numbers can be grouped
into two sets of four numbers: the principal (auto-rewind)
minor device numbers, <i>n</i>, and the
&ldquo;no-rewind&rdquo; device numbers, (<i>n</i> + 128).
Devices opened using the principal device number will be
sent a <b>REWIND</b> command when they are closed. Devices
opened using the &ldquo;no-rewind&rdquo; device number will
not. (Note that using an auto-rewind device for positioning
the tape with, for instance, mt does not lead to the desired
result: the tape is rewound after the mt command and the
next command starts from the beginning of the tape).</p>

<p style="margin-left:11%; margin-top: 1em">Within each
group, four minor numbers are available to define devices
with different characteristics (block size, compression,
density, etc.) When the system starts up, only the first
device is available. The other three are activated when the
default characteristics are defined (see below). (By
changing compile-time constants, it is possible to change
the balance between the maximum number of tape drives and
the number of minor numbers for each drive. The default
allocation allows control of 32 tape drives. For instance,
it is possible to control up to 64 tape drives with two
minor numbers for different options.)</p>

<p style="margin-left:11%; margin-top: 1em">Devices are
typically created by:</p>

<p style="margin-left:17%; margin-top: 1em">mknod &minus;m
666 /dev/st0 c 9 0 <br>
mknod &minus;m 666 /dev/st0l c 9 32 <br>
mknod &minus;m 666 /dev/st0m c 9 64 <br>
mknod &minus;m 666 /dev/st0a c 9 96 <br>
mknod &minus;m 666 /dev/nst0 c 9 128 <br>
mknod &minus;m 666 /dev/nst0l c 9 160 <br>
mknod &minus;m 666 /dev/nst0m c 9 192 <br>
mknod &minus;m 666 /dev/nst0a c 9 224</p>

<p style="margin-left:11%; margin-top: 1em">There is no
corresponding block device.</p>

<p style="margin-left:11%; margin-top: 1em">The driver uses
an internal buffer that has to be large enough to hold at
least one tape block. In kernels before 2.1.121, the buffer
is allocated as one contiguous block. This limits the block
size to the largest contiguous block of memory the kernel
allocator can provide. The limit is currently 128 kB for
32-bit architectures and 256 kB for 64-bit architectures. In
newer kernels the driver allocates the buffer in several
parts if necessary. By default, the maximum number of parts
is 16. This means that the maximum block size is very large
(2 MB if allocation of 16 blocks of 128 kB succeeds).</p>

<p style="margin-left:11%; margin-top: 1em">The
driver&rsquo;s internal buffer size is determined by a
compile-time constant which can be overridden with a kernel
startup option. In addition to this, the driver tries to
allocate a larger temporary buffer at run time if necessary.
However, run-time allocation of large contiguous blocks of
memory may fail and it is advisable not to rely too much on
dynamic buffer allocation with kernels older than 2.1.121
(this applies also to demand-loading the driver with kerneld
or kmod).</p>

<p style="margin-left:11%; margin-top: 1em">The driver does
not specifically support any tape drive brand or model.
After system start-up the tape device options are defined by
the drive firmware. For example, if the drive firmware
selects fixed-block mode, the tape device uses fixed-block
mode. The options can be changed with explicit
<b>ioctl</b>(2) calls and remain in effect when the device
is closed and reopened. Setting the options affects both the
auto-rewind and the nonrewind device.</p>

<p style="margin-left:11%; margin-top: 1em">Different
options can be specified for the different devices within
the subgroup of four. The options take effect when the
device is opened. For example, the system administrator can
define one device that writes in fixed-block mode with a
certain block size, and one which writes in variable-block
mode (if the drive supports both modes).</p>

<p style="margin-left:11%; margin-top: 1em">The driver
supports <b>tape partitions</b> if they are supported by the
drive. (Note that the tape partitions have nothing to do
with disk partitions. A partitioned tape can be seen as
several logical tapes within one medium.) Partition support
has to be enabled with an <b>ioctl</b>(2). The tape location
is preserved within each partition across partition changes.
The partition used for subsequent tape operations is
selected with an <b>ioctl</b>(2). The partition switch is
executed together with the next tape operation in order to
avoid unnecessary tape movement. The maximum number of
partitions on a tape is defined by a compile-time constant
(originally four). The driver contains an <b>ioctl</b>(2)
that can format a tape with either one or two
partitions.</p>

<p style="margin-left:11%; margin-top: 1em">Device
<i>/dev/tape</i> is usually created as a hard or soft link
to the default tape device on the system.</p>

<p style="margin-left:11%; margin-top: 1em">Starting from
kernel 2.6.2, the driver exports in the sysfs directory
<i>/sys/class/scsi_tape</i> the attached devices and some
parameters assigned to the devices.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Data
transfer</b> <br>
The driver supports operation in both fixed-block mode and
variable-block mode (if supported by the drive). In
fixed-block mode the drive writes blocks of the specified
size and the block size is not dependent on the byte counts
of the write system calls. In variable-block mode one tape
block is written for each write call and the byte count
determines the size of the corresponding tape block. Note
that the blocks on the tape don&rsquo;t contain any
information about the writing mode: when reading, the only
important thing is to use commands that accept the block
sizes on the tape.</p>

<p style="margin-left:11%; margin-top: 1em">In
variable-block mode the read byte count does not have to
match the tape block size exactly. If the byte count is
larger than the next block on tape, the driver returns the
data and the function returns the actual block size. If the
block size is larger than the byte count, the requested
amount of data from the start of the block is returned and
the rest of the block is discarded.</p>

<p style="margin-left:11%; margin-top: 1em">In fixed-block
mode the read byte counts can be arbitrary if buffering is
enabled, or a multiple of the tape block size if buffering
is disabled. Kernels before 2.1.121 allow writes with
arbitrary byte count if buffering is enabled. In all other
cases (kernel before 2.1.121 with buffering disabled or
newer kernel) the write byte count must be a multiple of the
tape block size.</p>

<p style="margin-left:11%; margin-top: 1em">In the 2.6
kernel, the driver tries to use direct transfers between the
user buffer and the device. If this is not possible, the
driver&rsquo;s internal buffer is used. The reasons for not
using direct transfers include improper alignment of the
user buffer (default is 512 bytes but this can be changed by
the HBA driver), one of more pages of the user buffer not
reachable by the SCSI adapter, etc.</p>

<p style="margin-left:11%; margin-top: 1em">A filemark is
automatically written to tape if the last tape operation
before close was a write.</p>

<p style="margin-left:11%; margin-top: 1em">When a filemark
is encountered while reading, the following happens. If
there are data remaining in the buffer when the filemark is
found, the buffered data is returned. The next read returns
zero bytes. The following read returns data from the next
file. The end of recorded data is signaled by returning zero
bytes for two consecutive read calls. The third read returns
an error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Ioctls</b>
<br>
The driver supports three <b>ioctl</b>(2) requests. Requests
not recognized by the <b>st</b> driver are passed to the
<b>SCSI</b> driver. The definitions below are from
<i>/usr/include/linux/mtio.h</i>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>MTIOCTOP
&mdash; perform a tape operation</b> <br>
This request takes an argument of type <i>(struct
mtop&nbsp;*)</i>. Not all drives support all operations. The
driver returns an <b>EIO</b> error if the drive rejects an
operation.</p>

<p style="margin-left:17%; margin-top: 1em">/* Structure
for MTIOCTOP &minus; mag tape op command: */ <br>
struct mtop { <br>
short mt_op; /* operations defined below */ <br>
int mt_count; /* how many of them */ <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Magnetic Tape
operations for normal tape use:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTBSF</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Backward space over <i>mt_count</i> filemarks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTBSFM</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Backward space over <i>mt_count</i> filemarks.
Reposition the tape to the EOT side of the last
filemark.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTBSR</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Backward space over <i>mt_count</i> records (tape
blocks).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTBSS</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Backward space over <i>mt_count</i> setmarks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTCOMPRESSION</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Enable compression of tape data within the drive if
<i>mt_count</i> is nonzero and disable compression if
<i>mt_count</i> is zero. This command uses the MODE page 15
supported by most DATs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTEOM</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Go to the end of the recorded media (for appending
files).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTERASE</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Erase tape. With 2.6 kernel, short erase (mark tape
empty) is performed if the argument is zero. Otherwise long
erase (erase all) is done.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTFSF</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Forward space over <i>mt_count</i> filemarks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTFSFM</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Forward space over <i>mt_count</i> filemarks. Reposition
the tape to the BOT side of the last filemark.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTFSR</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Forward space over <i>mt_count</i> records (tape
blocks).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTFSS</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Forward space over <i>mt_count</i> setmarks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTLOAD</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Execute the SCSI load command. A special case is
available for some HP autoloaders. If <i>mt_count</i> is the
constant <b>MT_ST_HPLOADER_OFFSET</b> plus a number, the
number is sent to the drive to control the autoloader.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTLOCK</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Lock the tape drive door.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTMKPART</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Format the tape into one or two partitions. If
<i>mt_count</i> is nonzero, it gives the size of the first
partition and the second partition contains the rest of the
tape. If <i>mt_count</i> is zero, the tape is formatted into
one partition. This command is not allowed for a drive
unless the partition support is enabled for the drive (see
<b>MT_ST_CAN_PARTITIONS</b> below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTNOP</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>No op&mdash;flushes the driver&rsquo;s buffer as a side
effect. Should be used before reading status with
<b>MTIOCGET</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTOFFL</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Rewind and put the drive off line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTRESET</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Reset drive.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTRETEN</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Re-tension tape.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTREW</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Rewind.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTSEEK</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Seek to the tape block number specified in
<i>mt_count</i>. This operation requires either a SCSI-2
drive that supports the <b>LOCATE</b> command
(device-specific address) or a Tandberg-compatible SCSI-1
drive (Tandberg, Archive Viper, Wangtek, ...). The block
number should be one that was previously returned by
<b>MTIOCPOS</b> if device-specific addresses are used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTSETBLK</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Set the drive&rsquo;s block length to the value
specified in <i>mt_count</i>. A block length of zero sets
the drive to variable block size mode.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTSETDENSITY</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Set the tape density to the code in <i>mt_count</i>. The
density codes supported by a drive can be found from the
drive documentation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTSETPART</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>The active partition is switched to <i>mt_count</i>. The
partitions are numbered from zero. This command is not
allowed for a drive unless the partition support is enabled
for the drive (see <b>MT_ST_CAN_PARTITIONS</b> below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTUNLOAD</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Execute the SCSI unload command (does not eject the
tape).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTUNLOCK</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Unlock the tape drive door.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTWEOF</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Write <i>mt_count</i> filemarks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p><b>MTWSM</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Write <i>mt_count</i> setmarks.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Magnetic Tape
operations for setting of device options (by the superuser):
<b><br>
MTSETDRVBUFFER</b></p>

<p style="margin-left:23%;">Set various drive and driver
options according to bits encoded in <i>mt_count</i>. These
consist of the drive&rsquo;s buffering mode, a set of
Boolean driver options, the buffer write threshold, defaults
for the block size and density, and timeouts (only in
kernels 2.1 and later). A single operation can affect only
one item in the list above (the Booleans counted as one
item.)</p>

<p style="margin-left:23%; margin-top: 1em">A value having
zeros in the high-order 4 bits will be used to set the
drive&rsquo;s buffering mode. The buffering modes are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="29%"></td>
<td width="2%">


<p>0</p></td>
<td width="4%"></td>
<td width="65%">


<p>The drive will not report <b>GOOD</b> status on write
commands until the data blocks are actually written to the
medium.</p> </td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="2%">


<p>1</p></td>
<td width="4%"></td>
<td width="65%">


<p>The drive may report <b>GOOD</b> status on write
commands as soon as all the data has been transferred to the
drive&rsquo;s internal buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="2%">


<p>2</p></td>
<td width="4%"></td>
<td width="65%">


<p>The drive may report <b>GOOD</b> status on write
commands as soon as (a) all the data has been transferred to
the drive&rsquo;s internal buffer, and (b) all buffered data
from different initiators has been successfully written to
the medium.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">To control the
write threshold the value in <i>mt_count</i> must include
the constant <b>MT_ST_WRITE_THRESHOLD</b> bitwise ORed with
a block count in the low 28 bits. The block count refers to
1024-byte blocks, not the physical block size on the tape.
The threshold cannot exceed the driver&rsquo;s internal
buffer size (see DESCRIPTION, above).</p>

<p style="margin-left:23%; margin-top: 1em">To set and
clear the Boolean options the value in <i>mt_count</i> must
include one of the constants <b>MT_ST_BOOLEANS</b>,
<b>MT_ST_SETBOOLEANS</b>, <b>MT_ST_CLEARBOOLEANS</b>, or
<b>MT_ST_DEFBOOLEANS</b> bitwise ORed with whatever
combination of the following options is desired. Using
<b>MT_ST_BOOLEANS</b> the options can be set to the values
defined in the corresponding bits. With
<b>MT_ST_SETBOOLEANS</b> the options can be selectively set
and with <b>MT_ST_DEFBOOLEANS</b> selectively cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p style="margin-top: 1em">The default options for a tape
device are set with <b>MT_ST_DEFBOOLEANS</b>. A nonactive
tape device (e.g., device with minor 32 or 160) is activated
when the default options for it are defined the first time.
An activated device inherits from the device activated at
start-up the options not set explicitly.</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p>The Boolean options are:</p></td></tr>
</table>

<p style="margin-left:23%;"><b>MT_ST_BUFFER_WRITES</b>
(Default: true)</p>

<p style="margin-left:34%;">Buffer all write operations in
fixed-block mode. If this option is false and the drive uses
a fixed block size, then all write operations must be for a
multiple of the block size. This option must be set false to
write reliable multivolume archives.</p>

<p style="margin-left:23%;"><b>MT_ST_ASYNC_WRITES</b>
(Default: true)</p>

<p style="margin-left:34%;">When this option is true, write
operations return immediately without waiting for the data
to be transferred to the drive if the data fits into the
driver&rsquo;s buffer. The write threshold determines how
full the buffer must be before a new SCSI write command is
issued. Any errors reported by the drive will be held until
the next operation. This option must be set false to write
reliable multivolume archives.</p>

<p style="margin-left:23%;"><b>MT_ST_READ_AHEAD</b>
(Default: true)</p>

<p style="margin-left:34%;">This option causes the driver
to provide read buffering and read-ahead in fixed-block
mode. If this option is false and the drive uses a fixed
block size, then all read operations must be for a multiple
of the block size.</p>

<p style="margin-left:23%;"><b>MT_ST_TWO_FM</b> (Default:
false)</p>

<p style="margin-left:34%;">This option modifies the driver
behavior when a file is closed. The normal action is to
write a single filemark. If the option is true the driver
will write two filemarks and backspace over the second
one.</p>

<p style="margin-left:34%; margin-top: 1em">Note: This
option should not be set true for QIC tape drives since they
are unable to overwrite a filemark. These drives detect the
end of recorded data by testing for blank tape rather than
two consecutive filemarks. Most other current drives also
detect the end of recorded data and using two filemarks is
usually necessary only when interchanging tapes with some
other systems.</p>

<p style="margin-left:23%;"><b>MT_ST_DEBUGGING</b>
(Default: false)</p>

<p style="margin-left:34%;">This option turns on various
debugging messages from the driver (effective only if the
driver was compiled with <b>DEBUG</b> defined nonzero).</p>

<p style="margin-left:23%;"><b>MT_ST_FAST_EOM</b> (Default:
false)</p>

<p style="margin-left:34%;">This option causes the
<b>MTEOM</b> operation to be sent directly to the drive,
potentially speeding up the operation but causing the driver
to lose track of the current file number normally returned
by the <b>MTIOCGET</b> request. If <b>MT_ST_FAST_EOM</b> is
false the driver will respond to an <b>MTEOM</b> request by
forward spacing over files.</p>

<p style="margin-left:23%;"><b>MT_ST_AUTO_LOCK</b>
(Default: false)</p>

<p style="margin-left:34%;">When this option is true, the
drive door is locked when the device is opened and unlocked
when it is closed.</p>

<p style="margin-left:23%;"><b>MT_ST_DEF_WRITES</b>
(Default: false)</p>

<p style="margin-left:34%;">The tape options (block size,
mode, compression, etc.) may change when changing from one
device linked to a drive to another device linked to the
same drive depending on how the devices are defined. This
option defines when the changes are enforced by the driver
using SCSI-commands and when the drives auto-detection
capabilities are relied upon. If this option is false, the
driver sends the SCSI-commands immediately when the device
is changed. If the option is true, the SCSI-commands are not
sent until a write is requested. In this case the drive
firmware is allowed to detect the tape structure when
reading and the SCSI-commands are used only to make sure
that a tape is written according to the correct
specification.</p>

<p style="margin-left:23%;"><b>MT_ST_CAN_BSR</b> (Default:
false)</p>

<p style="margin-left:34%;">When read-ahead is used, the
tape must sometimes be spaced backward to the correct
position when the device is closed and the SCSI command to
space backward over records is used for this purpose. Some
older drives can&rsquo;t process this command reliably and
this option can be used to instruct the driver not to use
the command. The end result is that, with read-ahead and
fixed-block mode, the tape may not be correctly positioned
within a file when the device is closed. With 2.6 kernel,
the default is true for drives supporting SCSI-3.</p>

<p style="margin-left:23%;"><b>MT_ST_NO_BLKLIMS</b>
(Default: false)</p>

<p style="margin-left:34%;">Some drives don&rsquo;t accept
the <b>READ BLOCK LIMITS</b> SCSI command. If this is used,
the driver does not use the command. The drawback is that
the driver can&rsquo;t check before sending commands if the
selected block size is acceptable to the drive.</p>

<p style="margin-left:23%;"><b>MT_ST_CAN_PARTITIONS</b>
(Default: false)</p>

<p style="margin-left:34%;">This option enables support for
several partitions within a tape. The option applies to all
devices linked to a drive.</p>

<p style="margin-left:23%;"><b>MT_ST_SCSI2LOGICAL</b>
(Default: false)</p>

<p style="margin-left:34%;">This option instructs the
driver to use the logical block addresses defined in the
SCSI-2 standard when performing the seek and tell operations
(both with <b>MTSEEK</b> and <b>MTIOCPOS</b> commands and
when changing tape partition). Otherwise the device-specific
addresses are used. It is highly advisable to set this
option if the drive supports the logical addresses because
they count also filemarks. There are some drives that
support only the logical block addresses.</p>

<p style="margin-left:23%;"><b>MT_ST_SYSV</b> (Default:
false)</p>

<p style="margin-left:34%;">When this option is enabled,
the tape devices use the SystemV semantics. Otherwise the
BSD semantics are used. The most important difference
between the semantics is what happens when a device used for
reading is closed: in System V semantics the tape is spaced
forward past the next filemark if this has not happened
while using the device. In BSD semantics the tape position
is not changed.</p>

<p style="margin-left:23%;"><b>MT_NO_WAIT</b> (Default:
false)</p>

<p style="margin-left:34%;">Enables immediate mode (i.e.,
don&rsquo;t wait for the command to finish) for some
commands (e.g., rewind).</p>

<p style="margin-left:23%; margin-top: 1em">An example:</p>

<p style="margin-left:29%; margin-top: 1em">struct mtop
mt_cmd; <br>
mt_cmd.mt_op = MTSETDRVBUFFER; <br>
mt_cmd.mt_count = MT_ST_BOOLEANS | <br>
MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES; <br>
ioctl(fd, MTIOCTOP, mt_cmd);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p>The default block size for a device can be set with
<b>MT_ST_DEF_BLKSIZE</b> and the default density code can be
set with <b>MT_ST_DEFDENSITY</b>. The values for the
parameters are or&rsquo;ed with the operation code.</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p>With kernels 2.1.x and later, the timeout values can be
set with the subcommand <b>MT_ST_SET_TIMEOUT</b> ORed with
the timeout in seconds. The long timeout (used for rewinds
and other commands that may take a long time) can be set
with <b>MT_ST_SET_LONG_TIMEOUT</b>. The kernel defaults are
very long to make sure that a successful command is not
timed out with any drive. Because of this the driver may
seem stuck even if it is only waiting for the timeout. These
commands can be used to set more practical values for a
specific drive. The timeouts set for one device apply for
all devices linked to the same drive.</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p>Starting from kernels 2.4.19 and 2.5.43, the driver
supports a status bit which indicates whether the drive
requests cleaning. The method used by the drive to return
cleaning information is set using the <b>MT_ST_SEL_CLN</b>
subcommand. If the value is zero, the cleaning bit is always
zero. If the value is one, the TapeAlert data defined in the
SCSI-3 standard is used (not yet implemented). Values 2-17
are reserved. If the lowest eight bits are &gt;= 18, bits
from the extended sense data are used. The bits 9-16 specify
a mask to select the bits to look at and the bits 17-23
specify the bit pattern to look for. If the bit pattern is
zero, one or more bits under the mask indicate the cleaning
request. If the pattern is nonzero, the pattern must match
the masked sense data byte.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>MTIOCGET
&mdash; get status</b> <br>
This request takes an argument of type <i>(struct
mtget&nbsp;*)</i>.</p>

<p style="margin-left:17%; margin-top: 1em">/* structure
for MTIOCGET &minus; mag tape get status command */ <br>
struct mtget { <br>
long mt_type; <br>
long mt_resid; <br>
/* the following registers are device dependent */ <br>
long mt_dsreg; <br>
long mt_gstat; <br>
long mt_erreg; <br>
/* The next two fields are not always used */ <br>
daddr_t mt_fileno; <br>
daddr_t mt_blkno; <br>
};</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><i>mt_type</i></p></td>
<td width="5%"></td>
<td width="72%">


<p style="margin-top: 1em">The header file defines many
values for <i>mt_type</i>, but the current driver reports
only the generic types <b>MT_ISSCSI1</b> (Generic SCSI-1
tape) and <b>MT_ISSCSI2</b> (Generic SCSI-2 tape).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><i>mt_resid</i></p></td>
<td width="5%"></td>
<td width="72%">


<p>contains the current tape partition number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><i>mt_dsreg</i></p></td>
<td width="5%"></td>
<td width="72%">


<p>reports the drive&rsquo;s current settings for block
size (in the low 24 bits) and density (in the high 8 bits).
These fields are defined by <b>MT_ST_BLKSIZE_SHIFT</b>,
<b>MT_ST_BLKSIZE_MASK</b>, <b>MT_ST_DENSITY_SHIFT</b>, and
<b>MT_ST_DENSITY_MASK</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><i>mt_gstat</i></p></td>
<td width="5%"></td>
<td width="72%">


<p>reports generic (device independent) status information.
The header file defines macros for testing these status
bits:</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="38%">


<p style="margin-top: 1em"><b>GMT_EOF</b>(<i>x</i>): The
tape is positioned just after a filemark (always false after
an <b>MTSEEK</b></p></td>
<td width="14%"></td>
<td width="17%">


<p style="margin-top: 1em">operation).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="67%">


<p style="margin-top: 1em"><b>GMT_BOT</b>(<i>x</i>): The
tape is</p></td>
<td width="2%"></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:28%;">positioned at the beginning of
the first file (always false after an <b>MTSEEK</b>
operation).</p>


<p style="margin-left:28%; margin-top: 1em"><b>GMT_EOT</b>(<i>x</i>):
A tape operation has reached the</p>

<p style="margin-left:28%;">physical End Of Tape.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="28%"></td>
<td width="72%">


<p style="margin-top: 1em"><b>GMT_SM</b>(<i>x</i>): The
tape is currently positioned at a setmark (always false
after an <b>MTSEEK</b></p></td></tr>
</table>

<p style="margin-left:28%;">operation).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_EOD</b>(<i>x</i>): The
tape is positioned at the end of recorded data.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_WR_PROT</b>(<i>x</i>):
The drive is write-protected. For some drives this can also
mean that the drive does not support writing on the current
medium type.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_ONLINE</b>(<i>x</i>): The
last <b>open</b>(2) found the drive with a tape in place and
ready for operation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_D_6250</b>(<i>x</i>),
<b>GMT_D_1600</b>(<i>x</i>), <b>GMT_D_800</b>(<i>x</i>):
This &ldquo;generic&rdquo; status information reports the
current density setting for 9-track &frac12;&quot; tape
drives only.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_DR_OPEN</b>(<i>x</i>):
The drive does not have a tape in place.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_IM_REP_EN</b>(<i>x</i>):
Immediate report mode. This bit is set if there are no
guarantees that the data has been physically written to the
tape when the write call returns. It is set zero only when
the driver does not buffer data and the drive is set not to
buffer data.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>GMT_CLN</b>(<i>x</i>): The
drive has requested cleaning. Implemented in kernels since
2.4.19 and 2.5.43.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><i>mt_erreg</i></p></td></tr>
</table>

<p style="margin-left:28%; margin-top: 1em">The only field
defined in <i>mt_erreg</i> is the recovered error count in
the low 16 bits (as defined by <b>MT_ST_SOFTERR_SHIFT</b>
and <b>MT_ST_SOFTERR_MASK</b>. Due to inconsistencies in the
way drives report recovered errors, this count is often not
maintained (most drives do not by default report soft errors
but this can be changed with a SCSI MODE SELECT
command).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>mt_fileno</i></p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">reports the current file number
(zero-based). This value is set to &minus;1 when the file
number is unknown (e.g., after <b>MTBSS</b> or
<b>MTSEEK</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><i>mt_blkno</i></p></td>
<td width="3%"></td>
<td width="72%">


<p>reports the block number (zero-based) within the current
file. This value is set to &minus;1 when the block number is
unknown (e.g., after <b>MTBSF</b>, <b>MTBSS</b>, or
<b>MTSEEK</b>).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>MTIOCPOS
&mdash; get tape position</b> <br>
This request takes an argument of type <i>(struct
mtpos&nbsp;*)</i> and reports the drive&rsquo;s notion of
the current tape block number, which is not the same as
<i>mt_blkno</i> returned by <b>MTIOCGET</b>. This drive must
be a SCSI-2 drive that supports the <b>READ POSITION</b>
command (device-specific address) or a Tandberg-compatible
SCSI-1 drive (Tandberg, Archive Viper, Wangtek, ... ).</p>

<p style="margin-left:17%; margin-top: 1em">/* structure
for MTIOCPOS &minus; mag tape get position command */ <br>
struct mtpos { <br>
long mt_blkno; /* current block number */ <br>
};</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="7%"></td>
<td width="68%">


<p style="margin-top: 1em">An attempt was made to write or
erase a write-protected tape. (This error is not detected
during <b>open</b>(2).)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EBUSY</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>The device is already in use or the driver was unable to
allocate a buffer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EFAULT</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>The command parameters point to memory not belonging to
the calling process.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EINVAL</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>An <b>ioctl</b>(2) had an invalid argument, or a
requested block size was invalid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EIO</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>The requested operation could not be completed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>ENOMEM</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>The byte count in <b>read</b>(2) is smaller than the
next physical block on the tape. (Before 2.2.18 and
2.4.0-test6 the extra bytes have been silently ignored.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>ENOSPC</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>A write operation could not be completed because the
tape reached end-of-medium.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>ENOSYS</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Unknown <b>ioctl</b>(2).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>ENXIO</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>During opening, the tape device does not exist.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EOVERFLOW</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>An attempt was made to read or write a variable-length
block that is larger than the driver&rsquo;s internal
buffer.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>EROFS</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Open is attempted with <b>O_WRONLY</b> or <b>O_RDWR</b>
when the tape in the drive is write-protected.</p></td></tr>
</table>

<h2>FILES
<a name="FILES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>/dev/st*</i></p></td>
<td width="4%"></td>
<td width="51%">


<p style="margin-top: 1em">the auto-rewind SCSI tape
devices</p> </td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><i>/dev/nst*</i></p></td>
<td width="4%"></td>
<td width="51%">


<p>the nonrewind SCSI tape devices</p></td>
<td width="20%">
</td></tr>
</table>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">When exchanging data between
systems, both systems have to agree on the physical tape
block size. The parameters of a drive after startup are
often not the ones most operating systems use with these
devices. Most systems use drives in variable-block mode if
the drive supports that mode. This applies to most modern
drives, including DATs, 8mm helical scan drives, DLTs, etc.
It may be advisable to use these drives in variable-block
mode also in Linux (i.e., use <b>MTSETBLK</b> or
<b>MTSETDEFBLK</b> at system startup to set the mode), at
least when exchanging data with a foreign system. The
drawback of this is that a fairly large tape block size has
to be used to get acceptable data transfer rates on the SCSI
bus.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Many programs (e.g., <b>tar</b>(1)) allow the user to
specify the blocking factor on the command line. Note that
this determines the physical block size on tape only in
variable-block mode.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>In order to use SCSI tape drives, the basic SCSI driver,
a SCSI-adapter driver and the SCSI tape driver must be
either configured into the kernel or loaded as modules. If
the SCSI-tape driver is not present, the drive is recognized
but the tape support described in this page is not
available.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The driver writes error messages to the console/log. The
SENSE codes written into some messages are automatically
translated to text if verbose SCSI messages are enabled in
kernel configuration.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The driver&rsquo;s internal buffering allows good
throughput in fixed-block mode also with small
<b>read</b>(2) and <b>write</b>(2) byte counts. With direct
transfers this is not possible and may cause a surprise when
moving to the 2.6 kernel. The solution is to tell the
software to use larger transfers (often telling it to use
larger blocks). If this is not possible, direct transfers
can be disabled.</p></td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>mt</b>(1)</p>

<p style="margin-left:11%; margin-top: 1em">The file
<i>drivers/scsi/README.st</i> or
<i>Documentation/scsi/st.txt</i> (kernel &gt;= 2.6) in the
Linux kernel source tree contains the most recent
information about the driver and its configuration
possibilities</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.53 of the Linux <i>man-pages</i> project.
A description of the project, and information about
reporting bugs, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
